{"spec": "text \\<open>\n\n  The Separation Kernel maintains separation between processes by limiting the capabilities that are\n  present in the system. We call these the \"restricted capabilities\" in the documentation that\n  follows.\n\n  The specification described here, the Separation Kernel Abstract Specification (abbreviated\n  \\texttt{sep-abstract} from here on in), is identical to the Abstract Specification\n  (aka. \\texttt{abstract}), except that the following system calls have been overridden to\n  provide reduced (fully static) functionality only.\n\n  \\begin{itemize}\n  \\item{handle_fault}\n  \\item{invoke_irq_handler}\n  \\item{decode_invocation}\n  \\item{perform_invocation}\n  \\item{handle_invocation}\n  \\item{handle_reply}\n  \\item{handle_event}\n  \\item{call_kernel}\n  \\end{itemize}\n\n  The resulting kernel API is simplified significantly compared to full seL4.\n  The changes to the original abstract specification are minimal, except that it contains\n  much fewer system calls.\n\n  We achieve this by modifying the cases distinctions that determine which API call is\n  to by executed. The new case distinctions\n  on capabilities only provide code for the restricted capabilities in our reduced setup,\n  otherwise they fail (i.e. throw an exception).\n\n  We then prove that \\texttt{sep-abstract} and \\texttt{abstract} have the same behaviour under the\n  restricted capabilities of the separation kernel via bi-simulation. This simply requires that we\n  prove refinement in both directions. This proof implies that the missing (failing) code branches\n  in the reduced specification can never be executed.\n\n  It is clear that the behaviour will be the same for the \"mostly identical\" overridden\n  definitions. In a few cases, which are documented below, the definitions have bigger differencess.\n  We provide ab informal explanation at the site of the overriden definition in each of these\n  cases. (The bi-simulation proof provides the formal demonstration.)\n\n\\<close>", "property": "Separation Kernel Abstract Specification: The specification restricts the system calls to a reduced, fully static set of functionalities, ensuring that only specific, restricted capabilities are allowed. This simplification maintains the same behavior as the full abstract specification under the restricted capabilities, as proven by bi-simulation.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Generic system call structure\\label{s:spec_syscall}", "comment": ""}
{"spec": "fun\n  perform_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"perform_invocation block call (InvokeNotification ep badge) =\n    doE\n      without_preemption $ send_signal ep badge;\n      returnOk []\n    odE\"\n| \"perform_invocation _ _ _ = fail\"\n\ndefinition\n  handle_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_invocation calling blocking \\<equiv> doE\n    thread \\<leftarrow> liftE $ gets cur_thread;\n    info \\<leftarrow> without_preemption $ get_message_info thread;\n    ptr \\<leftarrow> without_preemption $ liftM data_to_cptr $\n          as_user thread $ getRegister cap_register;\n    syscall\n      (doE\n         (cap, slot) \\<leftarrow> cap_fault_on_failure (of_bl ptr) False $ lookup_cap_and_slot thread ptr;\n         buffer \\<leftarrow> liftE $ lookup_ipc_buffer False thread;\n         extracaps \\<leftarrow> lookup_extra_caps thread buffer info;\n         returnOk (slot, cap, extracaps, buffer)\n       odE)\n      (\\<lambda>fault. when blocking $ handle_fault thread fault)\n      (\\<lambda>(slot,cap,extracaps,buffer). doE\n            args \\<leftarrow> liftE $ get_mrs thread buffer info;\n            decode_invocation (mi_label info) args ptr slot cap extracaps\n       odE)\n      (\\<lambda>err. when calling $\n            reply_from_kernel thread $ msg_from_syscall_error err)\n      (\\<lambda>oper. doE\n            without_preemption $ set_thread_state thread Restart;\n            reply \\<leftarrow> perform_invocation blocking calling oper;\n            without_preemption $ do\n                state \\<leftarrow> get_thread_state thread;\n                case state of\n                      Restart \\<Rightarrow> do\n                          when calling $\n                              reply_from_kernel thread (0, reply);\n                          set_thread_state thread Running\n                      od\n                    | _ \\<Rightarrow>  return ()\n            od\n       odE)\n  odE\"\n\ndefinition\n  handle_yield :: \"(unit,'z::state_ext) s_monad\" where\n  \"handle_yield \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) thread);\n     do_extended_op (tcb_sched_action (tcb_sched_append) thread);\n     do_extended_op reschedule_required\n   od\"\n\ndefinition\n  handle_send :: \"bool \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"handle_send bl \\<equiv> handle_invocation False bl\"\n\ndefinition\n  handle_call :: \"(unit,'z::state_ext) p_monad\" where\n \"handle_call \\<equiv> handle_invocation True True\"", "property": "System Call Handling: Manages the execution of system calls by handling invocations, including sending signals to notifications, and managing thread states and scheduling. It ensures that system calls are processed correctly, with appropriate fault handling, state transitions, and rescheduling as needed.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": ""}
{"spec": "definition\n  handle_recv :: \"bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"handle_recv is_blocking \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n\n     ep_cptr \\<leftarrow> liftM data_to_cptr $ as_user thread $\n                 getRegister cap_register;\n\n     (cap_fault_on_failure (of_bl ep_cptr) True $ doE\n        ep_cap \\<leftarrow> lookup_cap thread ep_cptr;\n\n        let flt = (throwError $ MissingCapability 0)\n        in\n        case ep_cap\n          of\n            NotificationCap ref badge rights \\<Rightarrow>\n             (if AllowRecv \\<in> rights\n              then doE\n                ntfn \\<leftarrow> liftE $ get_notification ref;\n                boundTCB \\<leftarrow> returnOk $ ntfn_bound_tcb ntfn;\n                if boundTCB = Some thread \\<or> boundTCB = None\n                then liftE $ receive_signal thread ep_cap is_blocking\n                else flt\n               odE\n              else flt)\n           | _ \\<Rightarrow> flt\n      odE)\n      <catch> handle_fault thread\n   od\"", "property": "Handle Receive System Call: Processes a receive system call by checking the current thread's capability and performing the receive operation if the capability is a notification with the appropriate rights. If the capability is valid and allows receiving, it checks the notification's bound TCB and either receives the signal or throws a fault.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": "\n\n  This definition of \\texttt{handle_recv} is almost identical to the abstract specification's definition\n  for the restricted capabilities. Also, a call to \\texttt{delete_caller_cap} has been removed. They have\n  the same behaviour under the restricted capabilities since there are no caller capabilities in\n  \\texttt{sep-abstract}.\n\n"}
{"spec": "definition\n  handle_reply :: \"(unit,'z::state_ext) s_monad\" where\n \"handle_reply \\<equiv> return ()\"", "property": "Handle Reply: The system call entry point for handling replies is defined to perform no action, effectively returning immediately.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": "\n\n  The definition here has been specialised to \\texttt{return ()}. The behaviour\n  is identical with the abstract specification under restricted capabilities because there\n  are no \\texttt{Reply} capabilities in \\texttt{sep-abstract}.\n\n"}
{"spec": "text \\<open>\n\n  The definition here is almost identical to that of the abstract specification (for the restricted\n  capablities), except that a call to \\texttt{handle_reply} has been removed. Since there\n  are no \\texttt{Reply}s in the restricted capabilities the behaviour is the same.\n\n\\<close>\n\n\nfun\n  handle_event :: \"event \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_event (SyscallEvent call) =\n   (case call of\n          SysSend \\<Rightarrow> handle_send True\n        | SysNBSend \\<Rightarrow> handle_send False\n        | SysCall \\<Rightarrow> handle_call\n        | SysRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysYield \\<Rightarrow> without_preemption handle_yield\n        | SysReply \\<Rightarrow> without_preemption handle_reply\n        | SysReplyRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysNBRecv \\<Rightarrow> without_preemption $ handle_recv False)\"\n\n| \"handle_event (UnknownSyscall n) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UnknownSyscallException $ of_nat n;\n    return ()\n  od)\"\n\n| \"handle_event (UserLevelFault w1 w2) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UserException w1 (w2 && mask 28);\n    return ()\n  od)\"\n\n| \"handle_event Interrupt = (without_preemption $ do\n    active \\<leftarrow> do_machine_op (getActiveIRQ False);\n    case active of\n       Some irq \\<Rightarrow> handle_interrupt irq\n     | None \\<Rightarrow> return ()\n  od)\"\n\n| \"handle_event (VMFaultEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_vm_fault thread fault_type <catch> handle_fault thread;\n    return ()\n  od)\"\n\n| \"handle_event (HypervisorEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_hypervisor_fault thread fault_type;\n    return ()\n  od)\"", "property": "Event Handling: Processes various types of events, including system calls, unknown syscalls, user-level faults, interrupts, VM faults, and hypervisor events. Each event is handled in a non-preemptive context to ensure atomicity and consistency.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Top-level event handling", "comment": ""}
{"spec": "text \\<open>\n  This function is the main kernel entry point. The main event loop of the\n  kernel handles events, handles a potential preemption interrupt, schedules\n  and switches back to the active thread.\n\\<close>\n\ndefinition\n  call_kernel :: \"event \\<Rightarrow> (unit,'z::state_ext_sched) s_monad\" where\n  \"call_kernel ev \\<equiv> do\n       handle_event ev <handle>\n           (\\<lambda>_. without_preemption $ do\n                  irq \\<leftarrow> do_machine_op (getActiveIRQ True);\n                  when (irq \\<noteq> None) $ handle_interrupt (the irq)\n                od);\n       schedule;\n       activate_thread\n   od\"\n\nend", "property": "Kernel Entry Point: Processes events, handles potential preemption interrupts, schedules threads, and activates the next thread. This ensures that the kernel efficiently manages events and thread execution while maintaining system responsiveness and integrity.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Kernel entry point", "comment": ""}
{"spec": "text \\<open>This definition is the toplevel decoding definition; it dispatches\nto the above definitions, after checking, in some cases, whether the\ninvocation is allowed.\n\\<close>\n\ndefinition\n  decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_invocation label args cap_index slot cap excaps \\<equiv>\n  case cap of\n    NotificationCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeNotification ptr badge\n      else throwError $ InvalidCapability 0\n  | _ \\<Rightarrow>\n      throwError $ InvalidCapability 0\"\n\nend", "property": "Decode Invocation: Decodes the system call based on the provided capability. If the capability is a NotificationCap and includes the AllowSend right, it returns an InvokeNotification invocation; otherwise, it throws an InvalidCapability error.", "title": "./spec/sep-abstract/Decode_SA.thy", "chapter": "Decoding System Calls", "section": "Toplevel invocation decode.", "comment": ""}
{"spec": "text \\<open>\n\n  \\texttt{handle_fault} in \\texttt{sep-abstract} always sets the thread state to\n  \\texttt{Inactive}. This is the same behaviour as \\texttt{handle_double_fault} in the abstract\n  specification.\n\n  The two \\texttt{handle_fault}s have the same behaviour under restricted capabilities because in\n  the abstract specification \\texttt{handle_fault} will call \\texttt{handle_double_fault} in all\n  cases except when the thread has an \\texttt{EndpointCap}. Since \\texttt{EndpointCap} is not part\n  of the restricted capabilities their behaviour is the same. This means, the system assumes\n  fully static virtual memory and no dynamic paging of any kind.\n  Faulting threads will be disabled by the kernel.\n\\<close>\n\ndefinition\n  handle_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault tptr ex \\<equiv> set_thread_state tptr Inactive\"\n\nend", "property": "Fault Handling: Sets the thread state to Inactive upon handling a fault, effectively disabling the faulting thread. This behavior is consistent under restricted capabilities, assuming fully static virtual memory and no dynamic paging.", "title": "./spec/sep-abstract/Ipc_SA.thy", "chapter": "IPC", "section": "", "comment": ""}
{"spec": "text \\<open>\n\n  The Separation Kernel maintains separation between processes by limiting the capabilities that are\n  present in the system. We call these the \"restricted capabilities\" in the documentation that\n  follows.\n\n  The specification described here, the Separation Kernel Abstract Specification (abbreviated\n  \\texttt{sep-abstract} from here on in), is identical to the Abstract Specification\n  (aka. \\texttt{abstract}), except that the following system calls have been overridden to\n  provide reduced (fully static) functionality only.\n\n  \\begin{itemize}\n  \\item{handle_fault}\n  \\item{invoke_irq_handler}\n  \\item{decode_invocation}\n  \\item{perform_invocation}\n  \\item{handle_invocation}\n  \\item{handle_reply}\n  \\item{handle_event}\n  \\item{call_kernel}\n  \\end{itemize}\n\n  The resulting kernel API is simplified significantly compared to full seL4.\n  The changes to the original abstract specification are minimal, except that it contains\n  much fewer system calls.\n\n  We achieve this by modifying the cases distinctions that determine which API call is\n  to by executed. The new case distinctions\n  on capabilities only provide code for the restricted capabilities in our reduced setup,\n  otherwise they fail (i.e. throw an exception).\n\n  We then prove that \\texttt{sep-abstract} and \\texttt{abstract} have the same behaviour under the\n  restricted capabilities of the separation kernel via bi-simulation. This simply requires that we\n  prove refinement in both directions. This proof implies that the missing (failing) code branches\n  in the reduced specification can never be executed.\n\n  It is clear that the behaviour will be the same for the \"mostly identical\" overridden\n  definitions. In a few cases, which are documented below, the definitions have bigger differencess.\n  We provide ab informal explanation at the site of the overriden definition in each of these\n  cases. (The bi-simulation proof provides the formal demonstration.)\n\n\\<close>", "property": "Separation Kernel Abstract Specification: Provides a reduced set of system calls with fully static functionality, limiting capabilities to maintain separation between processes, while ensuring the same behavior as the original abstract specification under restricted capabilities.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Generic system call structure\\label{s:spec_syscall}", "comment": ""}
{"spec": "fun\n  perform_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"perform_invocation block call (InvokeNotification ep badge) =\n    doE\n      without_preemption $ send_signal ep badge;\n      returnOk []\n    odE\"\n| \"perform_invocation _ _ _ = fail\"\n\ndefinition\n  handle_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_invocation calling blocking \\<equiv> doE\n    thread \\<leftarrow> liftE $ gets cur_thread;\n    info \\<leftarrow> without_preemption $ get_message_info thread;\n    ptr \\<leftarrow> without_preemption $ liftM data_to_cptr $\n          as_user thread $ getRegister cap_register;\n    syscall\n      (doE\n         (cap, slot) \\<leftarrow> cap_fault_on_failure (of_bl ptr) False $ lookup_cap_and_slot thread ptr;\n         buffer \\<leftarrow> liftE $ lookup_ipc_buffer False thread;\n         extracaps \\<leftarrow> lookup_extra_caps thread buffer info;\n         returnOk (slot, cap, extracaps, buffer)\n       odE)\n      (\\<lambda>fault. when blocking $ handle_fault thread fault)\n      (\\<lambda>(slot,cap,extracaps,buffer). doE\n            args \\<leftarrow> liftE $ get_mrs thread buffer info;\n            decode_invocation (mi_label info) args ptr slot cap extracaps\n       odE)\n      (\\<lambda>err. when calling $\n            reply_from_kernel thread $ msg_from_syscall_error err)\n      (\\<lambda>oper. doE\n            without_preemption $ set_thread_state thread Restart;\n            reply \\<leftarrow> perform_invocation blocking calling oper;\n            without_preemption $ do\n                state \\<leftarrow> get_thread_state thread;\n                case state of\n                      Restart \\<Rightarrow> do\n                          when calling $\n                              reply_from_kernel thread (0, reply);\n                          set_thread_state thread Running\n                      od\n                    | _ \\<Rightarrow>  return ()\n            od\n       odE)\n  odE\"\n\ndefinition\n  handle_yield :: \"(unit,'z::state_ext) s_monad\" where\n  \"handle_yield \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) thread);\n     do_extended_op (tcb_sched_action (tcb_sched_append) thread);\n     do_extended_op reschedule_required\n   od\"\n\ndefinition\n  handle_send :: \"bool \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"handle_send bl \\<equiv> handle_invocation False bl\"\n\ndefinition\n  handle_call :: \"(unit,'z::state_ext) p_monad\" where\n \"handle_call \\<equiv> handle_invocation True True\"", "property": "System Call Entry Point: Handle system call invocations, including sending signals, handling faults, decoding invocations, and performing the requested operation. Ensure proper thread state management, including restarting and running threads as necessary.\n\nSubproperties:\n\n* Handle Invocation: Manage the invocation process, including retrieving message information, looking up capabilities, and performing the requested operation.\n* Handle Yield: Dequeue and re-append the current thread to the scheduler, then reschedule as required.\n* Handle Send: Handle invocations without blocking, used for sending signals.\n* Handle Call: Handle invocations with blocking, used for system calls.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": ""}
{"spec": "definition\n  handle_recv :: \"bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"handle_recv is_blocking \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n\n     ep_cptr \\<leftarrow> liftM data_to_cptr $ as_user thread $\n                 getRegister cap_register;\n\n     (cap_fault_on_failure (of_bl ep_cptr) True $ doE\n        ep_cap \\<leftarrow> lookup_cap thread ep_cptr;\n\n        let flt = (throwError $ MissingCapability 0)\n        in\n        case ep_cap\n          of\n            NotificationCap ref badge rights \\<Rightarrow>\n             (if AllowRecv \\<in> rights\n              then doE\n                ntfn \\<leftarrow> liftE $ get_notification ref;\n                boundTCB \\<leftarrow> returnOk $ ntfn_bound_tcb ntfn;\n                if boundTCB = Some thread \\<or> boundTCB = None\n                then liftE $ receive_signal thread ep_cap is_blocking\n                else flt\n               odE\n              else flt)\n           | _ \\<Rightarrow> flt\n      odE)\n      <catch> handle_fault thread\n   od\"", "property": "Handle Receive: Ensure that the current thread can receive a signal from a notification capability, checking for the required AllowRecv right and handling faults if necessary. \n\nSubproperties:\n- Retrieve the current thread and its endpoint capability pointer.\n- Check the endpoint capability for the AllowRecv right.\n- If the right is present, retrieve the notification and check if the thread is bound to it or if it is unbound.\n- If the thread is bound or the notification is unbound, receive the signal; otherwise, throw a MissingCapability error.\n- Handle any faults that occur during the process.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": "\n\n  This definition of \\texttt{handle_recv} is almost identical to the abstract specification's definition\n  for the restricted capabilities. Also, a call to \\texttt{delete_caller_cap} has been removed. They have\n  the same behaviour under the restricted capabilities since there are no caller capabilities in\n  \\texttt{sep-abstract}.\n\n"}
{"spec": "definition\n  handle_reply :: \"(unit,'z::state_ext) s_monad\" where\n \"handle_reply \\<equiv> return ()\"", "property": "System Call Entry Point: Handle Reply Action: Always returns without performing any action, ensuring that the system call entry point does not modify the system state.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": "\n\n  The definition here has been specialised to \\texttt{return ()}. The behaviour\n  is identical with the abstract specification under restricted capabilities because there\n  are no \\texttt{Reply} capabilities in \\texttt{sep-abstract}.\n\n"}
{"spec": "text \\<open>\n\n  The definition here is almost identical to that of the abstract specification (for the restricted\n  capablities), except that a call to \\texttt{handle_reply} has been removed. Since there\n  are no \\texttt{Reply}s in the restricted capabilities the behaviour is the same.\n\n\\<close>\n\n\nfun\n  handle_event :: \"event \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_event (SyscallEvent call) =\n   (case call of\n          SysSend \\<Rightarrow> handle_send True\n        | SysNBSend \\<Rightarrow> handle_send False\n        | SysCall \\<Rightarrow> handle_call\n        | SysRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysYield \\<Rightarrow> without_preemption handle_yield\n        | SysReply \\<Rightarrow> without_preemption handle_reply\n        | SysReplyRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysNBRecv \\<Rightarrow> without_preemption $ handle_recv False)\"\n\n| \"handle_event (UnknownSyscall n) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UnknownSyscallException $ of_nat n;\n    return ()\n  od)\"\n\n| \"handle_event (UserLevelFault w1 w2) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UserException w1 (w2 && mask 28);\n    return ()\n  od)\"\n\n| \"handle_event Interrupt = (without_preemption $ do\n    active \\<leftarrow> do_machine_op (getActiveIRQ False);\n    case active of\n       Some irq \\<Rightarrow> handle_interrupt irq\n     | None \\<Rightarrow> return ()\n  od)\"\n\n| \"handle_event (VMFaultEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_vm_fault thread fault_type <catch> handle_fault thread;\n    return ()\n  od)\"\n\n| \"handle_event (HypervisorEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_hypervisor_fault thread fault_type;\n    return ()\n  od)\"", "property": "Top-level Event Handling: Handle system events, including system calls, unknown system calls, user-level faults, interrupts, VM faults, and hypervisor events, ensuring that each event is processed correctly and securely, with necessary fault handling and potential preemption.\n\nSubproperties:\n- System Call Handling: Handle various system calls, such as send, receive, yield, and reply, with specific handling for each type.\n- Unknown System Call Handling: Handle unknown system calls by reporting a fault to the current thread.\n- User-Level Fault Handling: Handle user-level faults by reporting an exception to the current thread.\n- Interrupt Handling: Handle interrupts by determining the active IRQ and handling it if present.\n- VM Fault Handling: Handle VM faults by reporting the fault to the current thread and handling potential errors.\n- Hypervisor Event Handling: Handle hypervisor events by reporting the fault to the current thread.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Top-level event handling", "comment": ""}
{"spec": "text \\<open>\n  This function is the main kernel entry point. The main event loop of the\n  kernel handles events, handles a potential preemption interrupt, schedules\n  and switches back to the active thread.\n\\<close>\n\ndefinition\n  call_kernel :: \"event \\<Rightarrow> (unit,'z::state_ext_sched) s_monad\" where\n  \"call_kernel ev \\<equiv> do\n       handle_event ev <handle>\n           (\\<lambda>_. without_preemption $ do\n                  irq \\<leftarrow> do_machine_op (getActiveIRQ True);\n                  when (irq \\<noteq> None) $ handle_interrupt (the irq)\n                od);\n       schedule;\n       activate_thread\n   od\"\n\nend", "property": "Kernel Entry Point: The kernel's main entry point handles events, checks for preemption interrupts, schedules, and switches to the active thread, ensuring the kernel's core functionality and thread management. \n\nHandle Event and Interrupt: Handle an event, and then check for and handle any pending interrupts without preemption, ensuring that interrupts are processed efficiently and safely. \n\nScheduling and Thread Activation: Schedule and activate the next thread, maintaining the kernel's scheduling and thread management functionality.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Kernel entry point", "comment": ""}
{"spec": "text \\<open>This definition is the toplevel decoding definition; it dispatches\nto the above definitions, after checking, in some cases, whether the\ninvocation is allowed.\n\\<close>\n\ndefinition\n  decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_invocation label args cap_index slot cap excaps \\<equiv>\n  case cap of\n    NotificationCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeNotification ptr badge\n      else throwError $ InvalidCapability 0\n  | _ \\<Rightarrow>\n      throwError $ InvalidCapability 0\"\n\nend", "property": "Toplevel Invocation Decode: Decodes system calls by dispatching to specific decoding definitions after checking invocation permissions. \n\nInvocation Permission Check: Verifies if the invocation is allowed based on the capability rights, specifically checking for the AllowSend right in NotificationCap capabilities.", "title": "./spec/sep-abstract/Decode_SA.thy", "chapter": "Decoding System Calls", "section": "Toplevel invocation decode.", "comment": ""}
{"spec": "text \\<open>\n\n  \\texttt{handle_fault} in \\texttt{sep-abstract} always sets the thread state to\n  \\texttt{Inactive}. This is the same behaviour as \\texttt{handle_double_fault} in the abstract\n  specification.\n\n  The two \\texttt{handle_fault}s have the same behaviour under restricted capabilities because in\n  the abstract specification \\texttt{handle_fault} will call \\texttt{handle_double_fault} in all\n  cases except when the thread has an \\texttt{EndpointCap}. Since \\texttt{EndpointCap} is not part\n  of the restricted capabilities their behaviour is the same. This means, the system assumes\n  fully static virtual memory and no dynamic paging of any kind.\n  Faulting threads will be disabled by the kernel.\n\\<close>\n\ndefinition\n  handle_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault tptr ex \\<equiv> set_thread_state tptr Inactive\"\n\nend", "property": "Fault Handling: When a fault occurs, the thread is immediately set to an inactive state, effectively disabling it. This ensures that faulting threads do not compromise the stability and security of the system, assuming a fully static virtual memory with no dynamic paging.", "title": "./spec/sep-abstract/Ipc_SA.thy", "chapter": "IPC", "section": "", "comment": ""}

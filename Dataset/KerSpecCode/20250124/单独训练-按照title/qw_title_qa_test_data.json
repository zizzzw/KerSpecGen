[
  {
    "instruction": "Separation Kernel Abstract Specification: The specification restricts the system calls to a reduced, fully static set of functionalities, ensuring that only specific, restricted capabilities are allowed. This simplification maintains the same behavior as the full abstract specification under the restricted capabilities, as proven by bi-simulation.",
    "input": "",
    "output": "text \\<open>\n\n  The Separation Kernel maintains separation between processes by limiting the capabilities that are\n  present in the system. We call these the \"restricted capabilities\" in the documentation that\n  follows.\n\n  The specification described here, the Separation Kernel Abstract Specification (abbreviated\n  \\texttt{sep-abstract} from here on in), is identical to the Abstract Specification\n  (aka. \\texttt{abstract}), except that the following system calls have been overridden to\n  provide reduced (fully static) functionality only.\n\n  \\begin{itemize}\n  \\item{handle_fault}\n  \\item{invoke_irq_handler}\n  \\item{decode_invocation}\n  \\item{perform_invocation}\n  \\item{handle_invocation}\n  \\item{handle_reply}\n  \\item{handle_event}\n  \\item{call_kernel}\n  \\end{itemize}\n\n  The resulting kernel API is simplified significantly compared to full seL4.\n  The changes to the original abstract specification are minimal, except that it contains\n  much fewer system calls.\n\n  We achieve this by modifying the cases distinctions that determine which API call is\n  to by executed. The new case distinctions\n  on capabilities only provide code for the restricted capabilities in our reduced setup,\n  otherwise they fail (i.e. throw an exception).\n\n  We then prove that \\texttt{sep-abstract} and \\texttt{abstract} have the same behaviour under the\n  restricted capabilities of the separation kernel via bi-simulation. This simply requires that we\n  prove refinement in both directions. This proof implies that the missing (failing) code branches\n  in the reduced specification can never be executed.\n\n  It is clear that the behaviour will be the same for the \"mostly identical\" overridden\n  definitions. In a few cases, which are documented below, the definitions have bigger differencess.\n  We provide ab informal explanation at the site of the overriden definition in each of these\n  cases. (The bi-simulation proof provides the formal demonstration.)\n\n\\<close>",
    "system": "",
    "history": []
  },
  {
    "instruction": "System Call Handling: Manages the execution of system calls by handling invocations, including sending signals to notifications, and managing thread states and scheduling. It ensures that system calls are processed correctly, with appropriate fault handling, state transitions, and rescheduling as needed.",
    "input": "",
    "output": "fun\n  perform_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"perform_invocation block call (InvokeNotification ep badge) =\n    doE\n      without_preemption $ send_signal ep badge;\n      returnOk []\n    odE\"\n| \"perform_invocation _ _ _ = fail\"\n\ndefinition\n  handle_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_invocation calling blocking \\<equiv> doE\n    thread \\<leftarrow> liftE $ gets cur_thread;\n    info \\<leftarrow> without_preemption $ get_message_info thread;\n    ptr \\<leftarrow> without_preemption $ liftM data_to_cptr $\n          as_user thread $ getRegister cap_register;\n    syscall\n      (doE\n         (cap, slot) \\<leftarrow> cap_fault_on_failure (of_bl ptr) False $ lookup_cap_and_slot thread ptr;\n         buffer \\<leftarrow> liftE $ lookup_ipc_buffer False thread;\n         extracaps \\<leftarrow> lookup_extra_caps thread buffer info;\n         returnOk (slot, cap, extracaps, buffer)\n       odE)\n      (\\<lambda>fault. when blocking $ handle_fault thread fault)\n      (\\<lambda>(slot,cap,extracaps,buffer). doE\n            args \\<leftarrow> liftE $ get_mrs thread buffer info;\n            decode_invocation (mi_label info) args ptr slot cap extracaps\n       odE)\n      (\\<lambda>err. when calling $\n            reply_from_kernel thread $ msg_from_syscall_error err)\n      (\\<lambda>oper. doE\n            without_preemption $ set_thread_state thread Restart;\n            reply \\<leftarrow> perform_invocation blocking calling oper;\n            without_preemption $ do\n                state \\<leftarrow> get_thread_state thread;\n                case state of\n                      Restart \\<Rightarrow> do\n                          when calling $\n                              reply_from_kernel thread (0, reply);\n                          set_thread_state thread Running\n                      od\n                    | _ \\<Rightarrow>  return ()\n            od\n       odE)\n  odE\"\n\ndefinition\n  handle_yield :: \"(unit,'z::state_ext) s_monad\" where\n  \"handle_yield \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) thread);\n     do_extended_op (tcb_sched_action (tcb_sched_append) thread);\n     do_extended_op reschedule_required\n   od\"\n\ndefinition\n  handle_send :: \"bool \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"handle_send bl \\<equiv> handle_invocation False bl\"\n\ndefinition\n  handle_call :: \"(unit,'z::state_ext) p_monad\" where\n \"handle_call \\<equiv> handle_invocation True True\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Handle Receive System Call: Processes a receive system call by checking the current thread's capability and performing the receive operation if the capability is a notification with the appropriate rights. If the capability is valid and allows receiving, it checks the notification's bound TCB and either receives the signal or throws a fault.",
    "input": "",
    "output": "definition\n  handle_recv :: \"bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"handle_recv is_blocking \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n\n     ep_cptr \\<leftarrow> liftM data_to_cptr $ as_user thread $\n                 getRegister cap_register;\n\n     (cap_fault_on_failure (of_bl ep_cptr) True $ doE\n        ep_cap \\<leftarrow> lookup_cap thread ep_cptr;\n\n        let flt = (throwError $ MissingCapability 0)\n        in\n        case ep_cap\n          of\n            NotificationCap ref badge rights \\<Rightarrow>\n             (if AllowRecv \\<in> rights\n              then doE\n                ntfn \\<leftarrow> liftE $ get_notification ref;\n                boundTCB \\<leftarrow> returnOk $ ntfn_bound_tcb ntfn;\n                if boundTCB = Some thread \\<or> boundTCB = None\n                then liftE $ receive_signal thread ep_cap is_blocking\n                else flt\n               odE\n              else flt)\n           | _ \\<Rightarrow> flt\n      odE)\n      <catch> handle_fault thread\n   od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Handle Reply: The system call entry point for handling replies is defined to perform no action, effectively returning immediately.",
    "input": "",
    "output": "definition\n  handle_reply :: \"(unit,'z::state_ext) s_monad\" where\n \"handle_reply \\<equiv> return ()\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Event Handling: Processes various types of events, including system calls, unknown syscalls, user-level faults, interrupts, VM faults, and hypervisor events. Each event is handled in a non-preemptive context to ensure atomicity and consistency.",
    "input": "",
    "output": "text \\<open>\n\n  The definition here is almost identical to that of the abstract specification (for the restricted\n  capablities), except that a call to \\texttt{handle_reply} has been removed. Since there\n  are no \\texttt{Reply}s in the restricted capabilities the behaviour is the same.\n\n\\<close>\n\n\nfun\n  handle_event :: \"event \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_event (SyscallEvent call) =\n   (case call of\n          SysSend \\<Rightarrow> handle_send True\n        | SysNBSend \\<Rightarrow> handle_send False\n        | SysCall \\<Rightarrow> handle_call\n        | SysRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysYield \\<Rightarrow> without_preemption handle_yield\n        | SysReply \\<Rightarrow> without_preemption handle_reply\n        | SysReplyRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysNBRecv \\<Rightarrow> without_preemption $ handle_recv False)\"\n\n| \"handle_event (UnknownSyscall n) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UnknownSyscallException $ of_nat n;\n    return ()\n  od)\"\n\n| \"handle_event (UserLevelFault w1 w2) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UserException w1 (w2 && mask 28);\n    return ()\n  od)\"\n\n| \"handle_event Interrupt = (without_preemption $ do\n    active \\<leftarrow> do_machine_op (getActiveIRQ False);\n    case active of\n       Some irq \\<Rightarrow> handle_interrupt irq\n     | None \\<Rightarrow> return ()\n  od)\"\n\n| \"handle_event (VMFaultEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_vm_fault thread fault_type <catch> handle_fault thread;\n    return ()\n  od)\"\n\n| \"handle_event (HypervisorEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_hypervisor_fault thread fault_type;\n    return ()\n  od)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Entry Point: Processes events, handles potential preemption interrupts, schedules threads, and activates the next thread. This ensures that the kernel efficiently manages events and thread execution while maintaining system responsiveness and integrity.",
    "input": "",
    "output": "text \\<open>\n  This function is the main kernel entry point. The main event loop of the\n  kernel handles events, handles a potential preemption interrupt, schedules\n  and switches back to the active thread.\n\\<close>\n\ndefinition\n  call_kernel :: \"event \\<Rightarrow> (unit,'z::state_ext_sched) s_monad\" where\n  \"call_kernel ev \\<equiv> do\n       handle_event ev <handle>\n           (\\<lambda>_. without_preemption $ do\n                  irq \\<leftarrow> do_machine_op (getActiveIRQ True);\n                  when (irq \\<noteq> None) $ handle_interrupt (the irq)\n                od);\n       schedule;\n       activate_thread\n   od\"\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Decode Invocation: Decodes the system call based on the provided capability. If the capability is a NotificationCap and includes the AllowSend right, it returns an InvokeNotification invocation; otherwise, it throws an InvalidCapability error.",
    "input": "",
    "output": "text \\<open>This definition is the toplevel decoding definition; it dispatches\nto the above definitions, after checking, in some cases, whether the\ninvocation is allowed.\n\\<close>\n\ndefinition\n  decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_invocation label args cap_index slot cap excaps \\<equiv>\n  case cap of\n    NotificationCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeNotification ptr badge\n      else throwError $ InvalidCapability 0\n  | _ \\<Rightarrow>\n      throwError $ InvalidCapability 0\"\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Fault Handling: Sets the thread state to Inactive upon handling a fault, effectively disabling the faulting thread. This behavior is consistent under restricted capabilities, assuming fully static virtual memory and no dynamic paging.",
    "input": "",
    "output": "text \\<open>\n\n  \\texttt{handle_fault} in \\texttt{sep-abstract} always sets the thread state to\n  \\texttt{Inactive}. This is the same behaviour as \\texttt{handle_double_fault} in the abstract\n  specification.\n\n  The two \\texttt{handle_fault}s have the same behaviour under restricted capabilities because in\n  the abstract specification \\texttt{handle_fault} will call \\texttt{handle_double_fault} in all\n  cases except when the thread has an \\texttt{EndpointCap}. Since \\texttt{EndpointCap} is not part\n  of the restricted capabilities their behaviour is the same. This means, the system assumes\n  fully static virtual memory and no dynamic paging of any kind.\n  Faulting threads will be disabled by the kernel.\n\\<close>\n\ndefinition\n  handle_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault tptr ex \\<equiv> set_thread_state tptr Inactive\"\n\nend",
    "system": "",
    "history": []
  }
]
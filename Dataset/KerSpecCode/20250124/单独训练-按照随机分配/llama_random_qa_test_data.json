[
  {
    "instruction": "Create Appropriately Qualified Aliases: Define aliases for page sizes (small, large, huge) with the correct qualifications to ensure accurate and consistent references to these page sizes within the system.",
    "input": "",
    "output": "context begin interpretation Arch . global_naming vmpage_size\nrequalify_consts ARMSmallPage ARMLargePage ARMHugePage\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Machine Operations: Provide low-level operations for managing hardware components, including initializing and resetting timers, invalidating the translation lookaside buffer (TLB), and printing debug messages. These operations ensure that the machine's hardware is properly initialized and managed, supporting the kernel's execution and interaction with the hardware. \n\nTimer Management: Initialize and reset the system timer to manage timekeeping and scheduling. \n\nTLB Management: Invalidate the TLB to ensure cache coherence and proper memory management. \n\nDebugging: Print debug messages to facilitate kernel development and debugging.",
    "input": "",
    "output": "consts'\n  memory_regions :: \"(paddr \\<times> paddr) list\" \n  initTimer_impl :: \"unit machine_rest_monad\"\ndefinition\n  initTimer :: \"unit machine_monad\"\nwhere \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts'\n  resetTimer_impl :: \"unit machine_rest_monad\"\n\ndefinition\n  resetTimer :: \"unit machine_monad\"\nwhere \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"\n\nconsts'\n  invalidateTLB_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidateTLB :: \"unit machine_monad\"\nwhere \"invalidateTLB \\<equiv> machine_op_lift invalidateTLB_impl\"\n\nlemmas cache_machine_op_defs = invalidateTLB_def\n\ndefinition\n  debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\"\nwhere\n  debugPrint_def[simp]:\n \"debugPrint \\<equiv> \\<lambda>message. return ()\"\n\n\n\\<comment> \\<open>Interrupt controller operations\\<close>",
    "system": "",
    "history": []
  },
  {
    "instruction": "Debug Print Operation: Ignore any debug print messages and do nothing.",
    "input": "",
    "output": "definition debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\" where\n  debugPrint_def[simp]:\n  \"debugPrint \\<equiv> \\<lambda>message. return ()\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Monad Laws: Ensure that the state monad satisfies the traditional monad laws, specifically the left identity, right identity, and associativity laws, providing a sound foundation for monadic computations.",
    "input": "",
    "output": "text \\<open>This section defines traditional Haskell-like do-syntax\n  for the state monad in Isabelle.\\<close>",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Virtual Address Space: The kernel reserves a portion of the virtual address space, starting from a fixed base address (pptr_base) and extending upwards, in every virtual address space. \n\nUser Virtual Address Space: A portion of the virtual address space is available for use by users, up to a fixed top address (user_vtop).",
    "input": "",
    "output": "definition pptr_base :: \"machine_word\"\n  where\n  \"pptr_base = Platform.RISCV64.pptrBase\"\n\ntext \"Virtual address space available to users.\"\ndefinition user_vtop :: \"machine_word\"\n  where\n  \"user_vtop = Platform.RISCV64.pptrUserTop\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "VCPU Object Creation: Creates a new VCPU object with default settings, including a VGIC interface, registers, and a virtual timer, ensuring a consistent initial state for VCPUs.\n\nArchitectural Object Type Identification: Identifies the type of an architectural kernel object, categorizing it as a page table entry, VCPU, or ASID pool, allowing for proper management and handling of different object types.",
    "input": "",
    "output": "defs makeVCPUObject_def:\n\"makeVCPUObject \\<equiv>\n    VCPUObj_ \\<lparr>\n          vcpuTCBPtr= Nothing\n        , vcpuVGIC= VGICInterface_ \\<lparr>\n                          vgicHCR= vgicHCREN\n                        , vgicVMCR= 0\n                        , vgicAPR= 0\n                        , vgicLR= (\\<lambda>_. 0)\n                        \\<rparr>\n        , vcpuRegs= funArray (const 0)  aLU  [(VCPURegSCTLR, sctlrEL1VM)]\n        , vcpuVPPIMasked= (\\<lambda>_. False)\n        , vcpuVTimer= VirtTimer 0\n        \\<rparr>\"\n\ndatatype arch_kernel_object_type =\n    PTET\n  | VCPUT\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOVCPU e) = VCPUT\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Initialise Architecture-Specific Objects: Initialise architecture-specific objects, including page tables, page directories, and various types of page objects, ensuring correct configuration and cache management for these objects. \n\nSubproperties:\n- Page Directory Initialisation: When initialising a page directory, copy global mappings to the referenced objects.\n- Page Object Initialisation: Clean the cache range for non-device page objects, such as small, large, section, and super section page objects.\n- Page Table and Directory Cache Management: Clean the cache range for page tables and directories to ensure correct operation.\n- Architecture-Specific TCB Initialisation: Initialise the architecture-specific components of a TCB (Thread Control Block) with an empty context.",
    "input": "",
    "output": "definition vs_apiobj_size where\n  \"vs_apiobj_size ty \\<equiv>\n     case ty of\n       ArchObject SmallPageObj \\<Rightarrow> pageBitsForSize ARMSmallPage\n     | ArchObject LargePageObj \\<Rightarrow> pageBitsForSize ARMLargePage\n     | ArchObject SectionObj \\<Rightarrow> pageBitsForSize ARMSection\n     | ArchObject SuperSectionObj \\<Rightarrow> pageBitsForSize ARMSuperSection\n     | ArchObject PageTableObj \\<Rightarrow> pt_bits\n     | ArchObject PageDirectoryObj \\<Rightarrow> pd_bits\"\n\ndefinition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv> do\n     when (new_type = ArchObject PageDirectoryObj) $ mapM_x copy_global_mappings refs;\n     if \\<not>is_device \\<and>\n        new_type \\<in> {ArchObject SmallPageObj, ArchObject LargePageObj,\n                    ArchObject SectionObj, ArchObject SuperSectionObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_RAM ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else if new_type \\<in> {ArchObject PageTableObj, ArchObject PageDirectoryObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_PoU ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else\n       return ()\n   od\"\n\ndefinition\n  empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context \\<rparr>\"\n\n\nend\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Arch Capability Equivalence: Two architecture-specific capabilities are considered equivalent if they refer to the same object, which is determined by matching device, reference, and page size attributes for page capabilities, or by using architecture-specific region comparison for other capability types.",
    "input": "",
    "output": "definition\n  same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n \"same_aobject_as cp cp' \\<equiv>\n   (case (cp, cp') of\n      (PageCap dev ref _ pgsz _,PageCap dev' ref' _ pgsz' _)\n          \\<Rightarrow> (dev, ref, pgsz) = (dev', ref', pgsz')\n              \\<and> ref \\<le> ref + 2 ^ pageBitsForSize pgsz - 1\n    | _ \\<Rightarrow> arch_same_region_as cp cp')\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel State Structure: The kernel state is a record that contains various components, including the process space, user pages, CNodes, untyped zero ranges, maximum object size, domain schedule, current domain, domain time, ready queues, current thread, idle thread, scheduler action, interrupt state, work units completed, architecture-specific state, and machine state. This structure encapsulates the essential data for managing the kernel's operation and interactions with the machine.\n\nKernel Monad: The kernel monad is a type synonym for a nondeterministic monad that operates on the kernel state, providing a way to express kernel functions that interact with and modify the kernel state.",
    "input": "",
    "output": "record kernel_state =\n  ksPSpace             :: pspace\n  gsUserPages          :: \"machine_word \\<Rightarrow> vmpage_size option\"\n  gsCNodes             :: \"machine_word \\<Rightarrow> nat option\"\n  gsUntypedZeroRanges  :: \"(machine_word \\<times> machine_word) set\"\n  gsMaxObjectSize      :: nat\n  ksDomScheduleIdx     :: nat\n  ksDomSchedule        :: \"(domain \\<times> machine_word) list\"\n  ksCurDomain          :: domain\n  ksDomainTime         :: machine_word\n  ksReadyQueues        :: \"domain \\<times> priority \\<Rightarrow> ready_queue\"\n  ksReadyQueuesL1Bitmap :: \"domain \\<Rightarrow> machine_word\"\n  ksReadyQueuesL2Bitmap :: \"domain \\<times> nat \\<Rightarrow> machine_word\"\n  ksCurThread          :: machine_word\n  ksIdleThread         :: machine_word\n  ksSchedulerAction    :: scheduler_action\n  ksInterruptState     :: interrupt_state\n  ksWorkUnitsCompleted :: machine_word\n  ksArchState          :: Arch.kernel_state\n  ksMachineState       :: machine_state\n\ncontext Arch begin\ncontext begin global_naming global\nrequalify_types KernelStateData_H.kernel_state\nend\nend\n\ntype_synonym 'a kernel = \"(kernel_state, 'a) nondet_monad\"\n\ntranslations\n  (type) \"'c kernel\" <= (type) \"(kernel_state, 'c) nondet_monad\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "First Capability Slot of Kernel Objects: Returns the first capability slot of a given kernel object, which can be a thread, CNode, or zombie. \n\nSubproperties:\n- For threads, it returns the slot at index 0 of the thread's CNode.\n- For CNodes, it returns the slot at the start of the CNode's capability array.\n- For zombies, it returns the slot at the start of the zombie's capability array, taking into account the zombie's CTE bits.",
    "input": "",
    "output": "primrec (nonexhaustive)\n  first_cslot_of :: \"cap \\<Rightarrow> cslot_ptr\"\nwhere\n  \"first_cslot_of (ThreadCap oref) = (oref, tcb_cnode_index 0)\"\n| \"first_cslot_of (CNodeCap oref bits g) = (oref, replicate bits False)\"\n| \"first_cslot_of (Zombie oref bits n) = (oref, replicate (zombie_cte_bits bits) False)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Untyped Objects Management: Provide definitions and constants for managing untyped objects, including minimum and maximum size bits, and functions for checking overlap with CNodes and asserting canonical addresses.",
    "input": "",
    "output": "chapter \"Untyped Objects\"\n\ntheory Untyped_H\nimports\n  RetypeDecls_H\n  CSpaceDecls_H\n  CNode_H\n  Invocations_H\n  InvocationLabels_H\n  Config_H\nbegin\n\narch_requalify_consts (H)\n  minUntypedSizeBits\n  maxUntypedSizeBits\n\nconsts\n  cNodeOverlap :: \"(machine_word \\<Rightarrow> nat option) \\<Rightarrow> (machine_word \\<Rightarrow> bool) \\<Rightarrow> bool\"\n\n#INCLUDE_HASKELL SEL4/Object/Untyped.lhs decls_only ONLY archOverlap\n\n#INCLUDE_HASKELL SEL4/Object/Untyped.lhs NOT cNodeOverlap canonicalAddressAssert archOverlap\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Thread Reply Capability Setup: Ensure that an active thread has a master Reply capability to itself in its reply slot, creating a new one if it does not exist, to facilitate immediate generation of derived Reply capabilities.",
    "input": "",
    "output": "text \\<open>Threads that are active always have a master Reply capability to\nthemselves stored in their reply slot. This is so that a derived Reply\ncapability can be generated immediately if they wish to issue one. This function\nsets up a new master Reply capability if one does not exist.\\<close>\ndefinition\n  \"setup_reply_master thread \\<equiv> do\n     old_cap <- get_cap (thread, tcb_cnode_index 2);\n     when (old_cap = NullCap) $ do\n         set_original (thread, tcb_cnode_index 2) True;\n         set_cap (ReplyCap thread True {AllowGrant, AllowWrite}) (thread, tcb_cnode_index 2)\n     od\n  od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Architecture-specific Invocation Decoding: Provides a function to calculate the base address of a page in a virtual address space, given a virtual address and a page size. \n\nPage Base Calculation: Calculates the base address of a page by performing a bitwise AND operation between the virtual address and the negation of the mask for the given page size.",
    "input": "",
    "output": "text \\<open>This definition decodes architecture-specific invocations.\n\\<close>\n\ndefinition\n  page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\nwhere\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Lookup PT Slot: Calculate the address of a page table slot for a given virtual address and page table.",
    "input": "",
    "output": "definition\n  lookup_pt_slot_no_fail :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\"\nwhere\n  \"lookup_pt_slot_no_fail pt vptr \\<equiv>\n     let pt_index = ((vptr >> pageBits) && mask (pt_bits - pte_bits))\n     in pt + (pt_index << pte_bits)\"\n\nend\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Page Table Invocation: Authorize page table mapping and unmapping operations, ensuring the correct configuration of page tables and the maintenance of valid memory mappings.\n\nSubproperties:\n- Map Page Table: Set a page table capability, store a page directory entry, and invalidate the page structure cache for the specified address space identifier.\n- Unmap Page Table: Unmap a page table, clear the mapped page table entries, and update the capability with the unmapped data.",
    "input": "",
    "output": "definition\nperform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_page_table_invocation iv \\<equiv>\ncase iv of PageTableMap cap ct_slot pde pd_slot vspace \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pde pd_slot pde;\n    asid <- case cap of ArchObjectCap (PageTableCap  _ (Some (as, _))) \\<Rightarrow> return as\n            | _ \\<Rightarrow> fail;\n    invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n  od\n  | PageTableUnmap (ArchObjectCap (PageTableCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_page_table asid vaddr p;\n      pte_bits \\<leftarrow> return word_size_bits;\n      slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + (1 <<  pt_bits) - 1];\n      mapM_x (swp store_pte InvalidPTE) slots\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "VM Fault Handling: Formats a VM fault message to be passed to a thread's supervisor after encountering a page fault, providing the fault address and relevant fault information. \n\nSubproperties:\n- Data Abort Handling: Handles ARM data aborts by retrieving the fault address, translating it, and constructing a VM fault message with the translated address and fault status.\n- Prefetch Abort Handling: Handles ARM prefetch aborts by retrieving the faulting instruction address, translating it, and constructing a VM fault message with the translated address and fault status.",
    "input": "",
    "output": "fun\nhandle_vm_fault :: \"word32 \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n\"handle_vm_fault thread ARMDataAbort = doE\n    addr \\<leftarrow> liftE $ do_machine_op getHDFAR;\n    uaddr \\<leftarrow> liftE $ do_machine_op (addressTranslateS1 addr);\n    fault \\<leftarrow> liftE $ do_machine_op getHSR;\n    let faddr = (uaddr && complement (mask pageBits)) || (addr && mask pageBits)\n    in\n    throwError $ ArchFault $ VMFault faddr [0, fault && 0x3ffffff]\nodE\"\n|\n\"handle_vm_fault thread ARMPrefetchAbort = doE\n    pc \\<leftarrow> liftE $ as_user thread $ getRestartPC;\n    upc \\<leftarrow> liftE $ do_machine_op (addressTranslateS1 pc);\n    fault \\<leftarrow> liftE $ do_machine_op getHSR;\n    let faddr = (upc && complement (mask pageBits)) || (pc && mask pageBits)\n    in\n    throwError $ ArchFault $ VMFault faddr [1, fault && 0x3ffffff]\nodE\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Architecture-specific Object Type Decoding: Map numeric values to architecture-specific object types, including HugePageObj, SmallPageObj, LargePageObj, and PageTableObj, while rejecting invalid values.",
    "input": "",
    "output": "definition arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\"\n  where\n  \"arch_data_to_obj_type n \\<equiv>\n     if      n = 0 then Some HugePageObj\n     else if n = 1 then Some SmallPageObj\n     else if n = 2 then Some LargePageObj\n     else if n = 3 then Some PageTableObj\n     else None\"\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Select From State: Select an element from a state set S, throwing an exception ex if the set is empty. \n\nThrow Exception When Empty: Throws an exception when the state set S is empty.",
    "input": "",
    "output": "definition\n  \"throw_select S ex \\<equiv> doE\n     whenE (S = {}) (throwError ex);\n     liftE (select S)\n   odE\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Decode MMU Invocations: Decodes architecture-specific system calls related to Memory Management Unit (MMU) invocations, handling various operations such as page directory flushes, page table maps and unmaps, page maps and unmaps, ASID control, and ASID pool assignments.\n\nSubproperties:\n- Page Directory Flush: Flushes a range of addresses in a page directory, ensuring that the start address is less than the end address and that the range does not exceed the kernel base.\n- Page Table Map: Maps a page table to a virtual address, checking that the mapped address is not already in use and that the page directory and ASID match.\n- Page Table Unmap: Unmaps a page table from a virtual address, checking that the final capability is being used.\n- Page Map: Maps a page to a virtual address, checking that the page is not already mapped and that the ASID and page directory match.\n- Page Unmap: Unmaps a page from a virtual address.\n- Page Flush: Flushes a range of addresses in a page, ensuring that the start address is less than the end address and that the range does not exceed the page size.\n- ASID Control: Creates a new ASID pool or assigns an ASID to a page directory, checking that the ASID is not already in use and that the page directory and ASID match.\n- ASID Pool Assignment: Assigns an ASID to a page directory, checking that the ASID is not already in use and that the page directory and ASID match.",
    "input": "",
    "output": "definition\n  isIOSpaceFrame :: \"arch_cap \\<Rightarrow> bool\"\n  where \"isIOSpaceFrame c \\<equiv> False\"\n\ndefinition\n  decode_mmu_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_mmu_invocation label args x_slot cte cap extra_caps \\<equiv>\ncase cap of\n\n  PageDirectoryCap _ _ \\<Rightarrow>\n    if isPDFlushLabel (invocation_type label) then\n    if length args > 1\n    then let start = args ! 0;\n             end = args ! 1\n    in doE\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            whenE (start \\<ge> kernel_base \\<or> end > kernel_base) $ throwError IllegalOperation;\n            (pd,asid) \\<leftarrow> (case cap of\n                    PageDirectoryCap pd (Some asid) \\<Rightarrow> returnOk (pd,asid)\n                  | _ \\<Rightarrow> throwError $ InvalidCapability 0);\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 0;\n            frame_info \\<leftarrow> liftE $ resolve_vaddr pd start;\n            case frame_info of\n                None \\<Rightarrow> returnOk $ InvokePageDirectory PageDirectoryNothing\n              | Some (frame_size, frame_base) \\<Rightarrow>\n                    let base_start = page_base start frame_size;\n                        base_end = page_base (end - 1) frame_size;\n                        offset = start && mask (pageBitsForSize frame_size);\n                        pstart = frame_base + offset\n                    in doE\n                        whenE (base_start \\<noteq> base_end) $ throwError $\n                            RangeError start (base_start + mask (pageBitsForSize frame_size));\n                        returnOk $ InvokePageDirectory $\n                            PageDirectoryFlush (label_to_flush_type (invocation_type label))\n                            start (end - 1) pstart pd asid\n                    odE\n    odE\n    else throwError TruncatedMessage\n    else throwError IllegalOperation\n\n| PageTableCap p mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageTableMap then\n    if length args > 1 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             pd_cap = fst (extra_caps ! 0)\n    in doE\n            whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            whenE (vaddr \\<ge> kernel_base) $ throwError $ InvalidArgument 0;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            pd_index \\<leftarrow> returnOk (shiftr vaddr (pageBits + pt_bits - pte_bits));\n            vaddr' \\<leftarrow> returnOk (vaddr && ~~ mask (pageBits + pt_bits - pte_bits));\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << pde_bits));\n            oldpde \\<leftarrow> liftE $ get_master_pde pd_slot;\n            unlessE (oldpde = InvalidPDE) $ throwError DeleteFirst;\n            pde \\<leftarrow> returnOk (PageTablePDE (addrFromPPtr p));\n            returnOk $ InvokePageTable $\n                PageTableMap\n                (ArchObjectCap $ PageTableCap p (Some (asid, vaddr')))\n                cte pde pd_slot\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageTableUnmap\n    then doE\n            final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n            unlessE final $ throwError RevokeFirst;\n            returnOk $ InvokePageTable $ PageTableUnmap (ArchObjectCap cap) cte\n    odE\n    else throwError IllegalOperation\n\n| PageCap dev p R pgsz mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageMap then\n    if length args > 2 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             rights_mask = args ! 1;\n             attr = args ! 2;\n             pd_cap = fst (extra_caps ! 0)\n        in doE\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            case mapped_address of\n              Some (asid', vaddr') \\<Rightarrow> doE\n                whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n                whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0)\n              odE\n            | None \\<Rightarrow> doE\n                vtop \\<leftarrow> returnOk (vaddr + (1 << (pageBitsForSize pgsz)) - 1);\n                whenE (vtop \\<ge> kernel_base) $ throwError $ InvalidArgument 0\n              odE;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            vm_rights \\<leftarrow> returnOk (mask_vm_rights R (data_to_rights rights_mask));\n            check_vp_alignment pgsz vaddr;\n            entries \\<leftarrow> create_mapping_entries (addrFromPPtr p)\n                                              vaddr pgsz vm_rights\n                                              (attribs_from_word attr) pd;\n            ensure_safe_mapping entries;\n            returnOk $ InvokePage $ PageMap asid\n                (ArchObjectCap $ PageCap dev p R pgsz (Some (asid, vaddr)))\n                cte entries\n        odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageUnmap\n    then  returnOk $ InvokePage $ PageUnmap cap cte\n    else if isPageFlushLabel (invocation_type label) then\n        if length args > 1\n        then let start = args ! 0;\n                 end = args ! 1;\n                 pstart = start + addrFromPPtr p\n        in doE\n            (asid, _) \\<leftarrow> (case mapped_address of\n                Some a \\<Rightarrow> returnOk a\n              | _ \\<Rightarrow> throwError IllegalOperation);\n            pd \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            page_size \\<leftarrow> returnOk $ 1 << pageBitsForSize pgsz;\n            whenE (start \\<ge> page_size \\<or> end > page_size) $ throwError $ InvalidArgument 0;\n            whenE (pstart < physBase \\<or> ((end - start) + pstart) > paddrTop) $ throwError IllegalOperation;\n            returnOk $ InvokePage $ PageFlush\n                (label_to_flush_type (invocation_type label)) (start + p) \\<comment> \\<open>check\\<close>\n                (end + p - 1) pstart pd asid\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageGetAddress\n    then returnOk $ InvokePage $ PageGetAddr p\n  else  throwError IllegalOperation\n\n| ASIDControlCap \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMASIDControlMakePool then\n    if length args > 1 \\<and> length extra_caps > 1\n    then let index = args ! 0;\n             depth = args ! 1;\n             (untyped, parent_slot) = extra_caps ! 0;\n             root = fst (extra_caps ! 1)\n         in doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            free_set \\<leftarrow> returnOk (- dom asid_table \\<inter> {x. x \\<le> (1 << asid_high_bits) - 1});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n            base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n            (p,n) \\<leftarrow> (case untyped of UntypedCap False p n f \\<Rightarrow> returnOk (p,n)\n                                    | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            frame \\<leftarrow> (if n = pageBits\n                      then doE\n                        ensure_no_children parent_slot;\n                        returnOk p\n                      odE\n                      else  throwError $ InvalidCapability 1);\n            dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n            ensure_empty dest_slot;\n            returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n        odE\n    else  throwError TruncatedMessage\n    else  throwError IllegalOperation\n\n| ASIDPoolCap p base \\<Rightarrow>\n  if invocation_type label = ArchInvocationLabel ARMASIDPoolAssign then\n  if length extra_caps > 0\n  then\n    let (pd_cap, pd_cap_slot) = extra_caps ! 0\n     in case pd_cap of\n          ArchObjectCap (PageDirectoryCap _ None) \\<Rightarrow> doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n            whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n            whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n            pool \\<leftarrow> liftE $ get_asid_pool p;\n            free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n            returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pd_cap_slot\n          odE\n        | _ \\<Rightarrow>  throwError $ InvalidCapability 1\n  else  throwError TruncatedMessage\n  else  throwError IllegalOperation\n| VCPUCap p \\<Rightarrow> fail \\<comment> \\<open>not an MMU invocation\\<close>\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Atomic Capability Swap: Swap two capabilities atomically, ensuring that the swap is executed as a single, uninterruptible operation. \n\nSwap Operation: The swap operation involves setting the first capability to the second slot and the second capability to the first slot, and then updating the parent-child relationships between the slots.",
    "input": "",
    "output": "definition\n  swap_cap :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"swap_cap cap1 slot1 cap2 slot2 \\<equiv> do\n     set_cap slot1 cap2;\n     set_cap slot2 cap1;\n     swap_parents slot1 slot2\n  od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Find Page Directory for ASID: Locate the page directory associated with a given ASID, ensuring the process succeeds and returns a valid page directory pointer. \n\nSubproperties: \n- The search for the page directory must be successful.\n- The returned pointer must correspond to a real page directory.",
    "input": "",
    "output": "definition\nfind_vspace_for_asid_assert :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) s_monad\" where\n\"find_vspace_for_asid_assert asid \\<equiv> do\n   pml4 \\<leftarrow> find_vspace_for_asid asid <catch> K fail;\n   get_pml4 pml4;\n   return pml4\n od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Fault Reply Handling: React to a fault reply message based on the original fault type, potentially reconfiguring the thread and saving an additional system call, and return a boolean indicating whether the thread should be restarted.\n\nSubproperties:\n- CapFault Handling: Always return True for capability faults.\n- Unknown Syscall and User Exception Handling: Sanitize and set registers based on the fault message and return whether the label is 0.\n- ArchFault Handling: Handle architecture-specific faults using a separate function.",
    "input": "",
    "output": "fun\n  handle_fault_reply :: \"fault \\<Rightarrow> obj_ref \\<Rightarrow>\n                         data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault_reply (CapFault cptr rp lf) thread x y = return True\"\n| \"handle_fault_reply (UnknownSyscallException n) thread label msg = do\n     t \\<leftarrow> arch_get_sanitise_register_info thread;\n     as_user thread $ zipWithM_x\n         (\\<lambda>r v. setRegister r $ sanitise_register t r v)\n         syscallMessage msg;\n     return (label = 0)\n   od\"\n| \"handle_fault_reply (UserException exception code) thread label msg = do\n     t \\<leftarrow> arch_get_sanitise_register_info thread;\n     as_user thread $ zipWithM_x\n         (\\<lambda>r v. setRegister r $ sanitise_register t r v)\n         exceptionMessage msg;\n     return (label = 0)\n   od\"\n| \" handle_fault_reply (ArchFault af) thread label msg =\n    handle_arch_fault_reply af thread label msg\" (* arch_fault *)",
    "system": "",
    "history": []
  },
  {
    "instruction": "Architecture-Specific Object Properties: Define the properties and sizes of various architecture-specific objects, including ASID pools, page tables, frames, VCPUs, and capabilities. These properties ensure that the objects are correctly sized and configured for the AARCH64 architecture.\n\nObject Size Definitions: Define the sizes of various objects, including ASID pools, page tables, frames, VCPUs, TCBs, endpoints, notifications, and untyped objects. These definitions ensure that the objects are correctly sized and aligned for the architecture.\n\nCapability Properties: Define the properties of architecture-specific capabilities, including the rights update function for frame capabilities. These properties ensure that capabilities are correctly managed and updated for the architecture.",
    "input": "",
    "output": "lemma ppn_len:\n  \"LENGTH(ppn_len) = ipa_size - pt_bits NormalPT_T\"\n  by (simp add: pt_bits_def table_size_def ptTranslationBits_def pte_bits_def word_size_bits_def\n                ipa_size_def Kernel_Config.config_ARM_PA_SIZE_BITS_40_def)\n\nprimrec arch_obj_size :: \"arch_cap \\<Rightarrow> nat\" where\n  \"arch_obj_size (ASIDPoolCap _ _) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (FrameCap _ _ sz _ _) = pageBitsForSize sz\"\n| \"arch_obj_size (PageTableCap _ pt_t _ ) = table_size pt_t\"\n| \"arch_obj_size (VCPUCap _) = vcpuBits\"\n\nfun arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_cap_is_device (FrameCap _ _ _ is_dev _) = is_dev\"\n| \"arch_cap_is_device _ = False\"\n\ndefinition cte_level_bits :: nat where\n  \"cte_level_bits \\<equiv> 5\"\n\ndefinition tcb_bits :: nat where\n  \"tcb_bits \\<equiv> 11\"\n\ndefinition endpoint_bits :: nat where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat where\n  \"ntfn_bits \\<equiv> 5\"\n\ndefinition untyped_min_bits :: nat where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat where\n  \"untyped_max_bits \\<equiv> 47\"\n\nprimrec arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\" where\n  \"arch_kobj_size (ASIDPool _) = pageBits\"\n| \"arch_kobj_size (PageTable pt) = table_size (pt_type pt)\"\n| \"arch_kobj_size (DataPage _ sz) = pageBitsForSize sz\"\n| \"arch_kobj_size (VCPU _) = vcpuBits\"\n\nfun aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\" where\n  \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref c = Some (acap_obj c)\"\n\ndefinition acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\" where\n  \"acap_rights_update R acap \\<equiv>\n    case acap of\n      FrameCap ref cR sz dev as \\<Rightarrow> FrameCap ref (validate_vm_rights R) sz dev as\n    | _ \\<Rightarrow> acap\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Initialization: \nUse the largest possible frame size (1M or 4K) for memory allocation based on alignment, and initialize the kernel by creating frames, providing capabilities, and updating boot information.\n\n Untyped Object Creation: \nCreate an untyped object in the kernel, which involves getting the current slot position, and preparing for the creation of the object.",
    "input": "",
    "output": "frame_size \\<leftarrow>\n         returnOk $ if (is_aligned start (pageBitsForSize ARMSection)\n                        \\<and> is_aligned end (pageBitsForSize ARMSection))\n                    then ARMSection\n                    else ARMSmallPage;\n\n       slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n       (swp mapME) [start,(start + 2^(pageBitsForSize frame_size))\n                       .e. (end - 1)]\n         (\\<lambda>f. doE\n                frame_cap \\<leftarrow> create_it_frame_cap f 0 None\n                                                (frame_size = ARMSection);\n                provide_cap root_cnode_cap frame_cap\n              odE);\n\n       slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n       bi_dev_reg \\<leftarrow> returnOk (addrFromPPtr start,\n                              of_nat (pageBitsForSize frame_size),\n                              (slot_pos_before, slot_pos_after));\n\n       liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n         bi_f_dev_reg_list := (bi_f_dev_reg_list $\n                                 ki_bootinfo s) @ [bi_dev_reg]\n         \\<rparr>\\<rparr>);\n\n       bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n       sync_bootinfo_frame bi_frame\n\n     odE);\n\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_num_dev_regs := of_nat $ length (bi_f_dev_reg_list $\n                                               ki_bootinfo s)\n       \\<rparr>\\<rparr>);\n\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame\n   odE\"\n\nfun (* for (ptr,bits)-style regions which don't straddle the end of memory *)\n  no_region_overlap :: \"(paddr \\<times> nat) \\<Rightarrow> (paddr \\<times> nat) \\<Rightarrow> bool\" where\n  \"no_region_overlap (ptr1,bits1) (ptr2,bits2) =\n     ({ptr1 .. ptr1 + 2 ^ bits1 - 1} \\<inter> {ptr2 .. ptr2 + 2 ^ bits2 - 1} = {})\"\n\ndefinition\n  freemem_regions :: \"obj_ref set \\<Rightarrow> ((paddr \\<times> nat) list,'z::state_ext) s_monad\" where\n  \"freemem_regions free \\<equiv> do\n     regs \\<leftarrow> select {lst. (\\<forall>(ptr,bits) \\<in> set lst. is_aligned ptr bits \\<and>\n                                           {ptr .. ptr + 2 ^ bits - 1} \\<subseteq> free)\n                         \\<and> distinct_prop no_region_overlap lst};\n     return regs\n   od\"\n\ndefinition\n  create_untyped_obj :: \"cap \\<Rightarrow> (paddr \\<times> paddr) \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"create_untyped_obj root_cnode_cap boot_mem_reuse_reg \\<equiv> doE\n\n     slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;",
    "system": "",
    "history": []
  },
  {
    "instruction": "Page Unmapping: Allows a page to be unmapped from a target address space, ensuring that the page is no longer accessible through that mapping.",
    "input": "",
    "output": "|  PageUnmapIntent",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Object Getters and Setters: Provide functions to access and modify the slots of various kernel objects, including page directories, page tables, ASID pools, CNodes, TCBs, and IRQ nodes. Additionally, functions are provided to check if an object has slots, retrieve the free IDs of an untyped capability, remove free IDs from an untyped capability, and get the IRQ of an IRQ handler capability. \n\nSubproperties:\n- Object Slots: Retrieve the capability map of an object based on its type.\n- Update Slots: Update the capability map of an object.\n- Has Slots: Check if an object has slots.\n- Capability Free IDs: Get the free IDs of an untyped capability.\n- Remove Free IDs: Remove free IDs from an untyped capability.\n- Capability IRQ: Get the IRQ of an IRQ handler capability.",
    "input": "",
    "output": "definition\n  object_slots :: \"cdl_object \\<Rightarrow> cdl_cap_map\"\nwhere\n  \"object_slots obj \\<equiv> case obj of\n    PageDirectory x \\<Rightarrow> cdl_page_directory_caps x\n  | PageTable x \\<Rightarrow> cdl_page_table_caps x\n  | AsidPool x \\<Rightarrow> cdl_asid_pool_caps x\n  | CNode x \\<Rightarrow> cdl_cnode_caps x\n  | Tcb x \\<Rightarrow> cdl_tcb_caps x\n  | IRQNode x \\<Rightarrow> cdl_irq_node_caps x\n  | _ \\<Rightarrow> Map.empty\"\n\ndefinition\n  update_slots :: \"cdl_cap_map \\<Rightarrow> cdl_object \\<Rightarrow> cdl_object\"\nwhere\n  \"update_slots new_val obj \\<equiv> case obj of\n    PageDirectory x \\<Rightarrow> PageDirectory (x\\<lparr>cdl_page_directory_caps := new_val\\<rparr>)\n  | PageTable x \\<Rightarrow> PageTable (x\\<lparr>cdl_page_table_caps := new_val\\<rparr>)\n  | AsidPool x \\<Rightarrow> AsidPool (x\\<lparr>cdl_asid_pool_caps := new_val\\<rparr>)\n  | CNode x \\<Rightarrow> CNode (x\\<lparr>cdl_cnode_caps := new_val\\<rparr>)\n  | Tcb x \\<Rightarrow> Tcb (x\\<lparr>cdl_tcb_caps := new_val\\<rparr>)\n  | IRQNode x \\<Rightarrow> IRQNode (x\\<lparr>cdl_irq_node_caps := new_val\\<rparr>)\n  | _ \\<Rightarrow> obj\"\n\ndefinition\n  has_slots :: \"cdl_object \\<Rightarrow> bool\"\nwhere\n  \"has_slots obj \\<equiv> case obj of\n    PageDirectory _ \\<Rightarrow> True\n  | PageTable _ \\<Rightarrow> True\n  | AsidPool _ \\<Rightarrow> True\n  | CNode _ \\<Rightarrow> True\n  | Tcb _ \\<Rightarrow> True\n  | IRQNode _ \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"\n\n\ndefinition\n  cap_free_ids :: \"cdl_cap \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"cap_free_ids cap \\<equiv> (case cap of\n     UntypedCap _ _ free_ids \\<Rightarrow> free_ids\n   | _ \\<Rightarrow> {})\"\n\ndefinition\n  remove_free_ids :: \"cdl_cap \\<Rightarrow> cdl_object_id set \\<Rightarrow> cdl_cap\"\nwhere\n  \"remove_free_ids cap obj_ids \\<equiv> case cap of\n     UntypedCap dev c a \\<Rightarrow> UntypedCap dev c (a - obj_ids)\n   | _ \\<Rightarrow> cap\"\n\ndefinition cap_irq :: \"cdl_cap \\<Rightarrow> cdl_irq\"\nwhere\n  \"cap_irq cap \\<equiv> case cap of\n      IrqHandlerCap x \\<Rightarrow> x\n    | _ \\<Rightarrow> undefined\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Capability Derivation Tree Descendants: Retrieves the set of descendant slots in the capability derivation tree for a given slot.",
    "input": "",
    "output": "definition\n  descendants_of :: \"cslot_ptr \\<Rightarrow> cdt \\<Rightarrow> cslot_ptr set\" where\n  \"descendants_of p t \\<equiv> {q. (p,q) \\<in> (cdt_parent_rel t)\\<^sup>+}\"\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Architecture-specific System Call Decoding: Decodes invocations specific to the architecture, handling various page-related operations (map, unmap, get address), ASID control (make pool, assign), and IO port control.\n\nSubproperties:\n- Page-related Operations: Handles page mapping, unmapping, and getting page addresses, ensuring correct page table and directory updates.\n- ASID Control Operations: Manages ASID pool creation and assignment, ensuring correct ASID table updates and pool management.\n- IO Port Control Operations: Decodes IO port control invocations, handling IO port capability management.\n- Error Handling: Throws errors for invalid operations, truncated messages, and other exceptional conditions.",
    "input": "",
    "output": "text \\<open>This definition decodes architecture-specific invocations.\n\\<close>\n\ndefinition\n  page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\nwhere\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"\n\n\n\n*)\n\ndefinition\ndecode_page_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap\n                            \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_page_invocation label args cte cap extra_caps \\<equiv> (case cap of\n  PageCap dev p R map_type pgsz mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel X64PageMap then\n    if length args > 2 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             rights_mask = args ! 1;\n             attr = args ! 2;\n             vspace_cap = fst (extra_caps ! 0)\n         in doE\n             (vspace, asid) \\<leftarrow> (case vspace_cap of\n                                   ArchObjectCap (PML4Cap pm (Some asid)) \\<Rightarrow>\n                                         returnOk (pm, asid)\n                                 | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n             case mapped_address of\n               Some (asid', vaddr') \\<Rightarrow> doE\n                 whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n                 whenE (map_type \\<noteq> VMVSpaceMap) $ throwError IllegalOperation;\n                 whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0)\n               odE\n             | None \\<Rightarrow> doE\n                 vtop \\<leftarrow> returnOk $ vaddr + bit (pageBitsForSize pgsz);\n                 whenE (vaddr > user_vtop \\<or> vtop > user_vtop) $ throwError $ InvalidArgument 0\n               odE;\n             vspace' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n             whenE (vspace' \\<noteq> vspace) $ throwError $ InvalidCapability 1;\n             vm_rights \\<leftarrow> returnOk $ mask_vm_rights R $ data_to_rights rights_mask;\n             check_vp_alignment pgsz vaddr;\n             entries \\<leftarrow> create_mapping_entries (addrFromPPtr p) vaddr pgsz vm_rights\n                                               (attribs_from_word attr) vspace;\n             ensure_safe_mapping entries;\n             returnOk $ InvokePage $ PageMap\n               (ArchObjectCap $ PageCap dev p R VMVSpaceMap pgsz (Some (asid,vaddr))) cte entries vspace\n          odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel X64PageUnmap then\n             \\<^cancel>\\<open>case map_type of\n                 VMIOSpaceMap \\<Rightarrow> decode_io_unmap_invocation label args cte cap extra_caps\n               | _ \\<Rightarrow>\\<close> returnOk $ InvokePage $ PageUnmap cap cte\n    \\<^cancel>\\<open>FIXME x64-vtd:\n    else if invocation_type label = ArchInvocationLabel X64PageMapIO\n    then decode_io_map_invocation label args cte cap extra_caps \\<close>\n    else if invocation_type label = ArchInvocationLabel X64PageGetAddress\n    then returnOk $ InvokePage $ PageGetAddr p\n  else throwError IllegalOperation\n | _ \\<Rightarrow> fail)\"\n\ndefinition filter_frame_attrs :: \"frame_attrs \\<Rightarrow> table_attrs\"\nwhere\n  \"filter_frame_attrs attrs \\<equiv> {s. \\<exists>s' \\<in> attrs. s' = PTAttr s}\"\n\ndefinition\n  decode_page_table_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow>\n                                  (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_page_table_invocation label args cte cap extra_caps \\<equiv> (case cap of\n    PageTableCap p mapped_address \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64PageTableMap then\n      if length args > 1 \\<and> length extra_caps > 0\n      then let vaddr = args ! 0;\n               attr = args ! 1;\n               pml4_cap = fst (extra_caps ! 0)\n      in doE\n               whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n               vaddr' \\<leftarrow> returnOk $ vaddr && ~~ mask pd_shift_bits;\n               (pml4, asid) \\<leftarrow> (case pml4_cap of\n                   ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> returnOk (pml4, asid)\n                   | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               whenE (user_vtop < vaddr') $ throwError $ InvalidArgument 0;\n               pml4' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n               whenE (pml4' \\<noteq> pml4) $ throwError $ InvalidCapability 1;\n               pd_slot \\<leftarrow> lookup_error_on_failure False $ lookup_pd_slot pml4 vaddr';\n               old_pde \\<leftarrow> liftE $ get_pde pd_slot;\n               unlessE (old_pde = InvalidPDE) $ throwError DeleteFirst;\n               pde \\<leftarrow> returnOk (PageTablePDE (addrFromPPtr p)\n                                  (filter_frame_attrs $ attribs_from_word attr) vm_read_write);\n               cap' <- returnOk $ ArchObjectCap $ PageTableCap p $ Some (asid, vaddr');\n               returnOk $ InvokePageTable $ PageTableMap cap' cte pde pd_slot pml4\n            odE\n      else throwError TruncatedMessage\n      else if invocation_type label = ArchInvocationLabel X64PageTableUnmap then doE\n               final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n               unlessE final $ throwError RevokeFirst;\n               returnOk $ InvokePageTable $ PageTableUnmap (ArchObjectCap cap) cte\n        odE\n      else throwError IllegalOperation\n  | _ \\<Rightarrow> fail)\"\n\ndefinition\n  decode_page_directory_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow>\n                                      (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_page_directory_invocation label args cte cap extra_caps \\<equiv> (case cap of\n    PageDirectoryCap p mapped_address \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64PageDirectoryMap then\n      if length args > 1 \\<and> length extra_caps > 0\n      then let vaddr = args ! 0;\n               attr = args ! 1;\n               pml4_cap = fst (extra_caps ! 0)\n      in doE\n               whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n               vaddr' \\<leftarrow> returnOk $ vaddr && ~~ mask pdpt_shift_bits;\n               (pml4, asid) \\<leftarrow> (case pml4_cap of\n                       ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> returnOk (pml4, asid)\n                       | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               whenE (user_vtop < vaddr') $ throwError $ InvalidArgument 0;\n               pml4' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n               whenE (pml4' \\<noteq> pml4) $ throwError $ InvalidCapability 1;\n               pdpt_slot \\<leftarrow> lookup_error_on_failure False $ lookup_pdpt_slot pml4 vaddr';\n               old_pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n               unlessE (old_pdpte = InvalidPDPTE) $ throwError DeleteFirst;\n               pdpte \\<leftarrow> returnOk (PageDirectoryPDPTE (addrFromPPtr p)\n                          (filter_frame_attrs $ attribs_from_word attr) vm_read_write);\n               cap' <- returnOk $ ArchObjectCap $ PageDirectoryCap p $ Some (asid, vaddr');\n               returnOk $ InvokePageDirectory $ PageDirectoryMap cap' cte pdpte pdpt_slot pml4\n        odE\n      else throwError TruncatedMessage\n      else if invocation_type label = ArchInvocationLabel X64PageDirectoryUnmap then doE\n               final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n               unlessE final $ throwError RevokeFirst;\n               returnOk $ InvokePageDirectory $ PageDirectoryUnmap (ArchObjectCap cap) cte\n            odE\n      else throwError IllegalOperation\n  | _ \\<Rightarrow> fail)\"\n\ndefinition\n  decode_pdpt_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow>\n                                      (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_pdpt_invocation label args cte cap extra_caps \\<equiv> (case cap of\n    PDPointerTableCap p mapped_address \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64PDPTMap then\n      if length args > 1 \\<and> length extra_caps > 0\n      then let vaddr = args ! 0;\n               attr = args ! 1;\n               pml4_cap = fst (extra_caps ! 0)\n      in doE\n               whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n               vaddr' \\<leftarrow> returnOk $ vaddr && ~~ mask pml4_shift_bits;\n               (pml4 ,asid) \\<leftarrow> (case pml4_cap of\n                       ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> returnOk (pml4, asid)\n                       | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               whenE (user_vtop < vaddr') $ throwError $ InvalidArgument 0;\n               pml4' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid (asid);\n               whenE (pml4' \\<noteq> pml4) $ throwError $ InvalidCapability 1;\n               pml_slot \\<leftarrow> returnOk $ lookup_pml4_slot pml4 vaddr';\n               old_pml4e \\<leftarrow> liftE $ get_pml4e pml_slot;\n               unlessE (old_pml4e = InvalidPML4E) $ throwError DeleteFirst;\n               pml4e \\<leftarrow> returnOk (PDPointerTablePML4E (addrFromPPtr p)\n                          (filter_frame_attrs $ attribs_from_word attr) vm_read_write);\n               cap' <- returnOk $ ArchObjectCap $ PDPointerTableCap p $ Some (asid, vaddr');\n               returnOk $ InvokePDPT $ PDPTMap cap' cte pml4e pml_slot pml4\n            odE\n      else throwError TruncatedMessage\n      else if invocation_type label = ArchInvocationLabel X64PDPTUnmap then doE\n               final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n               unlessE final $ throwError RevokeFirst;\n               returnOk $ InvokePDPT $ PDPTUnmap (ArchObjectCap cap) cte\n         odE\n      else throwError IllegalOperation\n  | _ \\<Rightarrow> fail)\"\n\ndefinition\n  arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n    PDPointerTableCap _ _ \\<Rightarrow> decode_pdpt_invocation label args cte cap extra_caps\n  | PageDirectoryCap _ _ \\<Rightarrow> decode_page_directory_invocation label args cte cap extra_caps\n  | PageTableCap _ _ \\<Rightarrow> decode_page_table_invocation label args cte cap extra_caps\n  | PageCap _ _ _ _ _ _ \\<Rightarrow> decode_page_invocation label args cte cap extra_caps\n  | ASIDControlCap \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64ASIDControlMakePool then\n      if length args > 1 \\<and> length extra_caps > 1\n      then let index = args ! 0;\n               depth = args ! 1;\n               (untyped, parent_slot) = extra_caps ! 0;\n               root = fst (extra_caps ! 1)\n      in doE\n               asid_table \\<leftarrow> liftE $ gets (x64_asid_table \\<circ> arch_state);\n               free_set \\<leftarrow> returnOk (- dom asid_table);\n               whenE (free_set = {}) $ throwError DeleteFirst;\n               free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n               base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n               (p,n) \\<leftarrow> (case untyped of UntypedCap False p n f \\<Rightarrow> returnOk (p,n)\n                                        | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               frame \\<leftarrow> (if n = pageBits\n                        then doE\n                            ensure_no_children parent_slot;\n                            returnOk p\n                          odE\n                        else  throwError $ InvalidCapability 1);\n               dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n               ensure_empty dest_slot;\n               returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n           odE\n   else throwError TruncatedMessage\n   else throwError IllegalOperation\n\n  | ASIDPoolCap p base \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64ASIDPoolAssign then\n      if length extra_caps > 0\n      then let (pd_cap, pd_cap_slot) = extra_caps ! 0 in\n            case pd_cap of\n               ArchObjectCap (PML4Cap _ None) \\<Rightarrow> doE\n                  asid_table \\<leftarrow> liftE $ gets (x64_asid_table \\<circ> arch_state);\n                  pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n                  whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n                  whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n                  pool \\<leftarrow> liftE $ get_asid_pool p;\n                  free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n                  whenE (free_set = {}) $ throwError DeleteFirst;\n                  offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n                  returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pd_cap_slot\n              odE\n            | _ \\<Rightarrow> throwError $ InvalidCapability 1\n      else throwError TruncatedMessage\n      else throwError IllegalOperation\n\n  | IOPortCap f l \\<Rightarrow> decode_port_invocation label args (IOPortCap f l)\n  | IOPortControlCap \\<Rightarrow> decode_ioport_control_invocation label args cte cap (map fst extra_caps)\n  | PML4Cap a b \\<Rightarrow> throwError IllegalOperation\"\n\ndefinition\n  arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\" where\n \"arch_data_to_obj_type n \\<equiv>\n  if      n = 0 then Some PDPTObj\n  else if n = 1 then Some PML4Obj\n  else if n = 2 then Some HugePageObj\n  else if n = 3 then Some SmallPageObj\n  else if n = 4 then Some LargePageObj\n  else if n = 5 then Some PageTableObj\n  else if n = 6 then Some PageDirectoryObj\n  else None\"\n\ndefinition\n  arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"arch_check_irq irq \\<equiv> throwError IllegalOperation\"\n\nend (* context Arch *)\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "VCPU Acknowledge VPPI: Allows the VCPU to acknowledge a VPPI (Virtual Processor Pending Interrupt) event, updating the VCPU's VPPI mask to reflect the acknowledgement. \n\nSubproperty: Validate the VPPI event index, ensuring it is a valid interrupt request before proceeding with the acknowledgement.",
    "input": "",
    "output": "definition decode_vcpu_ack_vppi ::\n  \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_ack_vppi mrs cap \\<equiv>\n     case (mrs, cap)\n       of (mr0 # _, VCPUCap vcpu_ptr) \\<Rightarrow> doE\n           arch_check_irq mr0;\n           (case irq_vppi_event_index (ucast mr0)\n            of None \\<Rightarrow> throwError $ InvalidArgument 0\n             | Some vppi \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUAckVPPI vcpu_ptr vppi)\n         odE\n       | _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_ack_vppi :: \"obj_ref \\<Rightarrow> vppievent_irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"invoke_vcpu_ack_vppi vcpu_ptr vppi =\n     vcpu_update vcpu_ptr\n                 (\\<lambda>vcpu. vcpu\\<lparr> vcpu_vppi_masked := (vcpu_vppi_masked vcpu)(vppi := False) \\<rparr>)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "VCPU IRQ Injection: Inject a virtual IRQ into a VCPU, handling the injection process based on whether the VCPU is currently active. If the VCPU is active, directly set the GIC VCPU control register; otherwise, update the VCPU's LR register.\n\nSubproperties:\n- VCPU IRQ Construction: Construct a virtual IRQ value from group, priority, and IRQ number inputs, incorporating pending and enable flags.\n- VCPU IRQ Injection Validation: Validate the inputs for VCPU IRQ injection, ensuring that the index, priority, and group values are within valid ranges and that the target VCPU list register is not currently active.",
    "input": "",
    "output": "definition make_virq :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> virq\" where\n  \"make_virq grp prio irq \\<equiv>\n  let\n    groupShift = 30;\n    prioShift = 23;\n    irqPending = 1 << 28;\n    eoiirqen = 1 << 19\n  in ((grp && 1) << groupShift) || ((prio && 0x1F) << prioShift) || (irq && 0x3FF) || irqPending || eoiirqen\"\n\n\ndefinition decode_vcpu_inject_irq :: \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_vcpu_inject_irq ptrs cap \\<equiv> case (ptrs, cap) of\n  (mr0 # mr1 # _, VCPUCap p) \\<Rightarrow> doE\n     vid \\<leftarrow> returnOk (mr0 && 0xFFFF);\n     priority \\<leftarrow> returnOk ((mr0 >> 16) && 0xFF);\n     group \\<leftarrow> returnOk ((mr0 >> 24) && 0xFF);\n     index \\<leftarrow> returnOk (mr1 && 0xFF);\n     range_check vid 0 ((1 << 10) - 1);\n     range_check priority 0 31;\n     range_check group 0 1;\n     num_list_regs \\<leftarrow> liftE $ gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     whenE (index \\<ge> of_nat num_list_regs) $\n        (throwError $ RangeError 0 (of_nat num_list_regs - 1));\n\n     vcpu \\<leftarrow> liftE $ get_vcpu p;\n     vcpuLR \\<leftarrow> returnOk (vgic_lr $ vcpu_vgic $ vcpu);\n\n     whenE (vcpuLR (unat index) && vgic_irq_mask = vgic_irq_active) $ throwError DeleteFirst;\n\n     virq \\<leftarrow> returnOk (make_virq group priority vid);\n     returnOk $ InvokeVCPU $ VCPUInjectIRQ p (unat index) virq\n  odE\n| _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition\n  invoke_vcpu_inject_irq :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> virq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"invoke_vcpu_inject_irq vr index virq \\<equiv> do\n    cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n    if (cur_v \\<noteq> None \\<and> fst (the cur_v) = vr)\n    then do_machine_op $ set_gic_vcpu_ctrl_lr (of_nat index) virq\n    else vgic_update_lr vr index virq\n   od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel State Management: The kernel state is managed through a non-deterministic monad, allowing for handling of exceptions, preemptions, and faults in a controlled manner. \n\nSubproperties:\n- Exception Handling: The kernel state monad allows for the handling of exceptions through the ExceptError type.\n- Preemption Handling: The kernel state monad allows for the handling of preemptions through the PreemptError type.\n- Fault Handling: The kernel state monad allows for the handling of faults through the FaultError type.",
    "input": "",
    "output": "type_synonym 'a k_monad = \"(cdl_state, 'a) nondet_monad\"\n\ndatatype cdl_except_error = ExceptError\ndatatype cdl_preempt_error = PreemptError\ndatatype cdl_fault_error = FaultError",
    "system": "",
    "history": []
  },
  {
    "instruction": "Retype Objects: Allow the kernel to retype objects, modifying their type and structure to accommodate different uses and requirements, while maintaining the integrity and consistency of the system's object model.",
    "input": "",
    "output": "chapter \"Retyping Objects\"\n\ntheory ArchVSpaceDecls_H\nimports ArchRetypeDecls_H InvocationLabels_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT X64_H\n#INCLUDE_HASKELL_PREPARSE SEL4/API/InvocationLabels/X64.lhs CONTEXT X64\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/X64.lhs CONTEXT X64_H decls_only ArchInv=\n#INCLUDE_HASKELL SEL4/Object/IOPort/X64.lhs CONTEXT X64_H decls_only ArchInv=\n\nend (* context X64 *)\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Page Table Invocation: Allows invoking a page table with specific parameters, currently supporting flush and no-operation actions. \n\nFlush Action: Does nothing when invoked with a flush parameter.\nNo-Operation Action: Does nothing when invoked with no parameters.",
    "input": "",
    "output": "definition\n  invoke_page_directory :: \"cdl_page_directory_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_page_directory params \\<equiv> case params of\n      PageDirectoryFlush flush  => return ()\n    | PageDirectoryNothing => return ()\n  \"\n\ndefinition \"option_exec f \\<equiv> \\<lambda>x. case x of Some a \\<Rightarrow> f a | None \\<Rightarrow> return ()\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create New Capability Objects: Supports the creation of various capability objects (e.g., page, table, VCPU) with specified attributes (e.g., device, size, access rights) in a given memory region, ensuring proper initialization and caching. \n\nSubproperties:\n- Create Page Objects: Creates new page capability objects with specified properties (device, size, access rights) in a given memory region, handling caching and initialization.\n- Create Table Objects: Creates new table capability objects (e.g., page tables, page directories) with specified properties (size, mappings) in a given memory region, handling caching and initialization.\n- Create VCPU Objects: Creates new VCPU capability objects in a given memory region, ensuring proper initialization.",
    "input": "",
    "output": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewPageCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        when (\\<not>dev) $\n          mapM_x (\\<lambda>addr. doMachineOp $\n                            cleanCacheRange_RAM addr\n                                                (addr + mask (pageBitsForSize pSize))\n                                                (addrFromPPtr addr)) addrs;\n        return $ map (\\<lambda>n. PageCap dev (PPtr (fromPPtr n)) VMReadWrite pSize Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects tableBits objectProto cap initialiseMappings \\<equiv> (do\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      initialiseMappings pts;\n      mapM_x (\\<lambda>addr. doMachineOp $\n                       cleanCacheRange_PoU addr (addr + mask tableBits) (addrFromPPtr addr)) addrs;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 0 ARMSmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 4 ARMLargePage\n        | SectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 9 ARMSection\n        | SuperSectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 13 ARMSuperSection\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects ptBits (makeObject::pte) PageTableCap\n              (\\<lambda>pts. return ())\n        | PageDirectoryObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pdBits (makeObject::pde) PageDirectoryCap\n              (\\<lambda>pds. do objSize \\<leftarrow> return (((1::nat) `~shiftL~` pdBits));\n                        mapM_x copyGlobalMappings pds\n                     od)\n        | VCPUObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject :: vcpu)) 0;\n            return $ map (\\<lambda>addr. VCPUCap addr) addrs\n            od)\n        )\"\n\nend\nend\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Set IPC Buffer: Set the IPC buffer for a target thread, specifying the buffer address and optionally a buffer frame.",
    "input": "",
    "output": "|  TcbSetIPCBufferIntent word32",
    "system": "",
    "history": []
  },
  {
    "instruction": "Dummy Initial State: Defines the initial state of the kernel with dummy values, ensuring consistency of invariants and refinement relations. \n\nInitialization Constants: Specifies the initial pointers for the thread control block (TCB) and interrupt request (IRQ) node.",
    "input": "",
    "output": "definition\n  init_tcb_ptr :: word32 where\n  \"init_tcb_ptr = kernel_base + 0x2000\"\n\ndefinition\n  init_irq_node_ptr :: word32 where\n  \"init_irq_node_ptr = kernel_base + 0x8000\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "TCB Register Management: Provide functions to get and set the register set of a thread, specifically for the ARM architecture.",
    "input": "",
    "output": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/ARM.lhs RegisterSet= CONTEXT ARM_HYP_H\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Platform Integer Representation: The platform represents C integer literals as 32-bit signed words.",
    "input": "",
    "output": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Distinguish Physical Capabilities: Identify whether an architecture-specific capability is physical or not, with ASIDControlCap being treated as non-physical and all others as physical.",
    "input": "",
    "output": "definition arch_is_physical :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_is_physical cap \\<equiv> case cap of ASIDControlCap \\<Rightarrow> False | _ \\<Rightarrow> True\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Non-Kernel Interrupts: Define the set of interrupts that cannot occur while the kernel is running but can occur from user mode.",
    "input": "",
    "output": "definition\n  \"non_kernel_IRQs = {irqVGICMaintenance, irqVTimerEvent}\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Memory Region Reservation: Reserve a memory region with the specified pointer, byte length, and kernel flag, currently a no-op placeholder for potential future extension to explicitly tag kernel data regions in memory.",
    "input": "",
    "output": "definition\n  reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Default Capability Construction: Construct a default capability for a new object based on its type, ID set, size, and device status, ensuring that the capability is correctly initialized with the required attributes and permissions.",
    "input": "",
    "output": "definition\n  default_cap :: \"cdl_object_type \\<Rightarrow> cdl_object_id set \\<Rightarrow> cdl_size_bits \\<Rightarrow> bool \\<Rightarrow> cdl_cap\"\nwhere\n  \"default_cap t id_set sz dev \\<equiv>\n    case t of\n        EndpointType \\<Rightarrow> EndpointCap (pick id_set) 0 UNIV\n      | NotificationType \\<Rightarrow> NotificationCap (THE i. i \\<in> id_set) 0 {Read,Write}\n      | TcbType \\<Rightarrow> TcbCap (pick id_set)\n      | CNodeType \\<Rightarrow> CNodeCap (pick id_set) 0 0 sz\n      | IRQNodeType \\<Rightarrow> IrqHandlerCap undefined\n      | UntypedType \\<Rightarrow> UntypedCap dev id_set id_set\n      | AsidPoolType \\<Rightarrow> AsidPoolCap (pick id_set) 0\n      | PageTableType \\<Rightarrow> PageTableCap (pick id_set) Real None\n      | PageDirectoryType \\<Rightarrow> PageDirectoryCap (pick id_set) Real None\n      | FrameType frame_size \\<Rightarrow> FrameCap dev (pick id_set) {Read, Write} frame_size Real None\"\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Badge Bits Limitation: The number of bits available for a badge is limited to 28.",
    "input": "",
    "output": "definition\n  badge_bits :: nat\nwhere\n  \"badge_bits \\<equiv> 28\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Virtual Address Translation: Calculate the page table index for a given virtual address and VM level, using bit shifts and masks to extract the relevant bits. \n\nPage Table Index Calculation: Extract the page table index from a virtual address by shifting and masking the address according to the VM level.",
    "input": "",
    "output": "definition pt_bits_left :: \"vm_level \\<Rightarrow> nat\"\n  where\n  \"pt_bits_left level = ptTranslationBits * size level + pageBits\"\n\ndefinition pt_index :: \"vm_level \\<Rightarrow> vspace_ref \\<Rightarrow> machine_word\"\n  where\n  \"pt_index level vptr \\<equiv> (vptr >> pt_bits_left level) && mask ptTranslationBits\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "System Call Error Messages: Create a message from a system-call failure to be returned to the thread attempting the operation that failed, providing specific error codes and relevant information for different types of failures. \n\nError Message Format: The message format includes an error code and additional data specific to the error type, such as invalid argument or capability numbers, range error bounds, or lookup failure details.",
    "input": "",
    "output": "primrec\n  msg_from_lookup_failure :: \"lookup_failure \\<Rightarrow> data list\"\nwhere\n  \"msg_from_lookup_failure InvalidRoot           = [1]\"\n| \"msg_from_lookup_failure (MissingCapability n) = [2, of_nat n]\"\n| \"msg_from_lookup_failure (DepthMismatch n m)   = [3, of_nat n, of_nat m]\"\n| \"msg_from_lookup_failure (GuardMismatch n g)   = [4, of_nat n, of_bl g, of_nat (size g)]\"\n\nprimrec\n  msg_from_syscall_error :: \"syscall_error \\<Rightarrow> (data \\<times> data list)\"\nwhere\n  \"msg_from_syscall_error (InvalidArgument n)    = (1, [of_nat n])\"\n| \"msg_from_syscall_error (InvalidCapability n)  = (2, [of_nat n])\"\n| \"msg_from_syscall_error IllegalOperation       = (3, [])\"\n| \"msg_from_syscall_error (RangeError minv maxv) = (4, [minv, maxv])\"\n| \"msg_from_syscall_error AlignmentError         = (5, [])\"\n| \"msg_from_syscall_error (FailedLookup s lf)    = (6, [if s then 1 else 0]@(msg_from_lookup_failure lf))\"\n| \"msg_from_syscall_error TruncatedMessage       = (7, [])\"\n| \"msg_from_syscall_error DeleteFirst            = (8, [])\"\n| \"msg_from_syscall_error RevokeFirst            = (9, [])\"\n| \"msg_from_syscall_error (NotEnoughMemory n)    = (10, [n])\"\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Retype Objects: Allow the kernel to retype objects, modifying their structure and properties to adapt to changing system requirements.",
    "input": "",
    "output": "chapter \"Retyping Objects\"\n\ntheory ArchVSpaceDecls_H\nimports ArchRetypeDecls_H InvocationLabels_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT RISCV64_H\n#INCLUDE_HASKELL_PREPARSE SEL4/API/InvocationLabels/RISCV64.hs CONTEXT RISCV64\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/RISCV64.hs CONTEXT RISCV64_H decls_only ArchInv= NOT lookupPTSlotFromLevel lookupPTFromLevel\n\nend (* context RISCV64 *)\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Capability Swap for Delete: Swap the capabilities in two slots without modifying the capabilities themselves, ensuring the existing capabilities are preserved during the swap operation.",
    "input": "",
    "output": "definition\n  cap_swap_for_delete :: \"cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cap_swap_for_delete slot1 slot2 \\<equiv>\n  when (slot1 \\<noteq> slot2) $ do\n    cap1 \\<leftarrow> get_cap slot1;\n    cap2 \\<leftarrow> get_cap slot2;\n    cap_swap cap1 slot1 cap2 slot2\n  od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Get Hardware ASID: Retrieve the hardware ASID associated with a virtual ASID, assigning a new one if none is already assigned.\nContext Switch: Perform a context switch by setting the current page directory and hardware ASID for a given virtual ASID.",
    "input": "",
    "output": "definition\nget_hw_asid :: \"asid \\<Rightarrow> (hardware_asid,'z::state_ext) s_monad\" where\n\"get_hw_asid asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  (case maybe_hw_asid of\n    Some hw_asid \\<Rightarrow> return hw_asid\n  | None \\<Rightarrow>  do\n      new_hw_asid \\<leftarrow> find_free_hw_asid;\n      store_hw_asid asid new_hw_asid;\n      return new_hw_asid\n  od)\nod\"\n\n\nabbreviation\n  \"arm_context_switch_hwasid pd hwasid \\<equiv> do\n              set_current_pd $ addrFromPPtr pd;\n              setHardwareASID hwasid\n          od\"\n\ndefinition\n  arm_context_switch :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arm_context_switch pd asid \\<equiv> do\n      hwasid \\<leftarrow> get_hw_asid asid;\n      do_machine_op $ arm_context_switch_hwasid pd hwasid\n    od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Function Declarations for Endpoints: Declare functions for endpoint operations, providing a foundation for implementing endpoint-related functionality in the kernel.",
    "input": "",
    "output": "chapter \"Function Declarations for Endpoints\"\n\ntheory EndpointDecls_H\nimports FaultMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Endpoint.lhs decls_only\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Architecture-Specific Object Initialization: Initialize architecture-specific objects, including PML4 objects, by copying global mappings for the provided references. \n\nSubproperties:\n- PML4 Object Initialization: Copy global mappings for the provided references when initializing a PML4 object.\n- Empty Context Initialization: Initialize an empty user context with all registers set to 0.\n- Architecture-Specific TCB Initialization: Initialize an architecture-specific TCB with an empty context.",
    "input": "",
    "output": "definition\n  init_arch_objects :: \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list\n   \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs\n    \\<equiv> when (new_type = ArchObject PML4Obj) (mapM_x copy_global_mappings refs)\"\n\ndefinition\n  empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0) (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context \\<rparr>\"\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Page Table Size Property: The size of the page table is defined by the vs_index_bits, which is guaranteed to be greater than 0.",
    "input": "",
    "output": "declare AARCH64.vs_index_bits_def[code]\n\ncontext Arch begin global_naming AARCH64\n\nlemma vs_index_bits_ge0[simp, intro!]: \"0 < vs_index_bits\"\n  by (simp add: vs_index_bits_def)",
    "system": "",
    "history": []
  },
  {
    "instruction": "Architecture-specific Fault Handling: Provides functions for constructing architecture-specific fault messages and handling replies to these faults, ensuring proper error handling and communication between threads in the system.\n\nSubproperties:\n- Construct Architecture-specific Fault Messages: Creates a fault message for a given architecture-specific fault, including the fault address and relevant data.\n- Handle Architecture-specific Fault Replies: Processes the reply to an architecture-specific fault, determining the course of action based on the fault type and reply data.",
    "input": "",
    "output": "chapter \\<open>Architecture-specific Fault-handling Functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\n  where\n  \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData)\n   od\"\n\ndefinition handle_arch_fault_reply ::\n  \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\n  where\n  \"handle_arch_fault_reply vmf thread x y \\<equiv> return True\"\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Fast Finalise Capability: Immediately finalise a capability if it is of a kind that can be finalised, specifically NullCap, ReplyCap, EndpointCap, or NotificationCap, and perform necessary cleanup actions such as cancelling IPC or signals, and unbinding notifications.\n\nSubproperties:\n- NullCap and ReplyCap finalisation are no-ops.\n- EndpointCap finalisation cancels all IPC when final flag is set.\n- NotificationCap finalisation unbinds notifications and cancels signals when final flag is set.\n- Other capability types (CNodeCap, ThreadCap, DomainCap, Zombie, IRQControlCap, IRQHandlerCap, UntypedCap, ArchObjectCap) cannot be fast finalised.",
    "input": "",
    "output": "fun\n  fast_finalise :: \"cap \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"fast_finalise NullCap                  final = return ()\"\n| \"fast_finalise (ReplyCap r m R)         final = return ()\"\n| \"fast_finalise (EndpointCap r b R)      final =\n      (when final $ cancel_all_ipc r)\"\n| \"fast_finalise (NotificationCap r b R) final =\n      (when final $ do\n          unbind_maybe_notification r;\n          cancel_all_signals r\n       od)\"\n| \"fast_finalise (CNodeCap r bits g)      final = fail\"\n| \"fast_finalise (ThreadCap r)            final = fail\"\n| \"fast_finalise DomainCap                final = fail\"\n| \"fast_finalise (Zombie r b n)           final = fail\"\n| \"fast_finalise IRQControlCap            final = fail\"\n| \"fast_finalise (IRQHandlerCap irq)      final = fail\"\n| \"fast_finalise (UntypedCap dev r n f)       final = fail\"\n| \"fast_finalise (ArchObjectCap a)        final = fail\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Heap Access for Endpoints and Notifications: Provides functions to access and modify endpoints and notifications in the kernel heap, including retrieving and setting endpoint and notification objects, as well as updating notification bindings and objects.\n\nSubproperties:\n- Get and Set Endpoints: Access and modify endpoint objects in the kernel heap.\n- Get and Set Notifications: Access and modify notification objects in the kernel heap.\n- Update Notification Bindings and Objects: Modify notification bindings and objects within the kernel heap.",
    "input": "",
    "output": "abbreviation\n  get_endpoint :: \"obj_ref \\<Rightarrow> (endpoint,'z::state_ext) s_monad\" where\n  \"get_endpoint \\<equiv> get_simple_ko Endpoint\"\n\nabbreviation\n  set_endpoint :: \"obj_ref \\<Rightarrow> endpoint \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_endpoint \\<equiv> set_simple_ko Endpoint\"\n\nabbreviation\n  get_notification :: \"obj_ref \\<Rightarrow> (notification,'z::state_ext) s_monad\" where\n  \"get_notification \\<equiv> get_simple_ko Notification\"\n\nabbreviation\n  set_notification :: \"obj_ref \\<Rightarrow> notification \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_notification \\<equiv> set_simple_ko Notification\"\n\nabbreviation\n  ntfn_set_bound_tcb :: \"notification \\<Rightarrow> obj_ref option \\<Rightarrow> notification\" where\n  \"ntfn_set_bound_tcb ntfn t \\<equiv> ntfn \\<lparr> ntfn_bound_tcb := t \\<rparr>\"\n\nabbreviation\n  ntfn_set_obj :: \"notification \\<Rightarrow> ntfn \\<Rightarrow> notification\" where\n  \"ntfn_set_obj ntfn a \\<equiv> ntfn \\<lparr> ntfn_obj := a \\<rparr>\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "ARM Architecture State: Maintains the architecture-specific state for the ARM model, including the ASID table, hardware ASID to seL4 ASID mapping, next hardware ASID, inverse mapping from seL4 ASIDs to hardware ASIDs, and the shared address space mappings.\n\nSubproperties:\n- ASID Management: Manages the mapping between hardware ASIDs and seL4 ASIDs, ensuring that hardware ASIDs are only associated with active page directories.\n- Page Table Management: Maintains the page directory and page table addresses for the shared address space.",
    "input": "",
    "output": "text \\<open>The architecture-specific state for the ARM model\nconsists of the first level of the ASID table (@{text \"arm_asid_table\"}), a\nmap from hardware ASIDs to seL4 ASIDs (@{text \"arm_hwasid_table\"}),\nthe next hardware ASID to preempt (@{text \"arm_next_asid\"}), the\ninverse map from seL4 ASIDs to hardware ASIDs (first component of\n@{text \"arm_asid_map\"}), and the address of the page directory and\npage tables mapping the shared address space, along with a description\nof this space (@{text \"arm_global_pd\"}, @{text \"arm_global_pts\"}, and\n@{text \"arm_kernel_vspace\"} respectively).\n\nHardware ASIDs are only ever associated with seL4 ASIDs that have a\ncurrently active page directory. The second component of\n@{text \"arm_asid_map\"} values is the address of that page directory.\n\\<close>\n\nend\n\nqualify ARM_A (in Arch)\n\nrecord arch_state =\n  arm_asid_table    :: \"7 word \\<rightharpoonup> obj_ref\"\n  arm_hwasid_table  :: \"ARM_A.hw_asid \\<rightharpoonup> ARM_A.asid\"\n  arm_next_asid     :: ARM_A.hw_asid\n  arm_asid_map      :: \"ARM_A.asid \\<rightharpoonup> (ARM_A.hw_asid \\<times> obj_ref)\"\n  arm_global_pd     :: obj_ref\n  arm_global_pts    :: \"obj_ref list\"\n  arm_kernel_vspace :: ARM_A.arm_vspace_region_uses\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  pd_bits :: \"nat\" where\n  \"pd_bits \\<equiv> pageBits + 2\"\n\ndefinition\n  pt_bits :: \"nat\" where\n  \"pt_bits \\<equiv> pageBits - 2\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Load Word Offsets: Load a machine word from a memory location specified by an object reference and an offset, either as a natural number or a data type, ensuring that the word is retrieved correctly from the memory address calculated by adding the offset to the base address.",
    "input": "",
    "output": "definition\n  load_word_offs :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n \"load_word_offs ptr offs \\<equiv>\n    do_machine_op $ loadWord (ptr + of_nat (offs * word_size))\"\ndefinition\n  load_word_offs_word :: \"obj_ref \\<Rightarrow> data \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n \"load_word_offs_word ptr offs \\<equiv>\n    do_machine_op $ loadWord (ptr + (offs * word_size))\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Ghost State Management: \nManage the ghost state, which tracks the allocation and deallocation of memory regions, including the creation of new frames and CNodes, and the clearing of regions. It ensures that the ghost state accurately reflects the current state of the system's memory. \n\nSubproperties:\n- Clear Region: Clear a region of memory in the ghost state, ensuring that the region is marked as unallocated.\n- New Frames: Create new frames in the ghost state, tracking the allocation of memory for a given page size and address range.\n- New CNodes: Create new CNodes in the ghost state, tracking the allocation of memory for a given CNode size and address range.\n- Get/Set Assertion: Get and set the values of ghost assertions, which are used to track additional information about the system's state.",
    "input": "",
    "output": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> word32\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> word32 \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Store Connectedness: The store connected relation is defined as the union of the identity relation and the specific connection between elements 1 and 2. This relation is both reflexive and transitive, ensuring that any element connected to 1 is also connected to 2, and any element connected to itself remains unchanged.",
    "input": "",
    "output": "lemma into_rtrancl [rule_format]:\n  \"(a,b) \\<in> r^* \\<Longrightarrow> (\\<forall>x. (x,b) \\<in> r \\<longrightarrow> x = b) \\<longrightarrow> a = b\"\n  apply (erule converse_rtrancl_induct)\n   apply simp\n  apply clarsimp\n  done\n\nlemma into_rtrancl2 [rule_format]:\n  \" \\<And> B. \\<lbrakk>(a,b) \\<in> r^*; b \\<in> B\\<rbrakk> \\<Longrightarrow> (\\<forall>x.(x,b) \\<in> r \\<longrightarrow> x \\<in> B) \\<longrightarrow> a \\<in> B\"\n  thm rtrancl_induct converse_rtrancl_induct\n  apply (erule converse_rtrancl_induct)\n   apply clarsimp\n  apply clarsimp\n  oops\n\nlemma store_connected_id:\n \"{(0::word32, 0), (1, 1), (1, 2)}\\<^sup>* = {(1, 2)}\\<^sup>* \"\n  apply rule\n   apply clarsimp\n   apply (erule rtranclE)\n    apply simp\n   apply (fastforce dest: into_rtrancl)\n  apply clarsimp\n  apply (erule rtranclE)\n   apply simp\n  apply (fastforce dest: into_rtrancl)\n  done\n\nlemma store_connected_s: \"store_connected s = {(1,2)} \\<union> Id\"\n  apply simp\n  apply (rule equalityI)\n  apply (insert store_connected_direct_s)\n   apply (simp add: store_connected_def)\n   apply clarsimp\n   apply (erule converse_rtranclE)\n    apply simp\n   apply clarsimp\n   apply (erule rtranclE)\n    apply fastforce\n   apply (simp add: store_connected_id)\n   apply (drule rtranclD)\n   apply (safe, simp_all, (erule tranclE, simp, fastforce)+)\n  apply (fastforce simp: store_connected_def)\n  done",
    "system": "",
    "history": []
  },
  {
    "instruction": "Global Page Table Pointer Alignment: The global page table pointer is sufficiently aligned for a single page.",
    "input": "",
    "output": "definition arm_global_pt_ptr :: obj_ref where\n  \"arm_global_pt_ptr = pptr_base + 0x2000\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Copy Registers: Copy the register values from a source thread to a target thread, with options to suspend the source thread, resume the target thread, transfer frame and integer registers, and consider architecture-specific flags.",
    "input": "",
    "output": "|  TcbCopyRegistersIntent bool bool bool bool word8",
    "system": "",
    "history": []
  },
  {
    "instruction": "Save Caller Intent: Save the caller's intent for a specific target, including its index and depth.",
    "input": "",
    "output": "|  CNodeSaveCallerIntent word32 word32",
    "system": "",
    "history": []
  },
  {
    "instruction": "Global Page Table Mapping: The kernel maps all physical memory using huge page mappings in the global PDPT, except for the upper-most entry, which maps to the global page directory.",
    "input": "",
    "output": "definition [simp]:\n  \"global_pdpt \\<equiv> (\\<lambda> i :: 9 word. HugePagePDPTE (ucast i << 30) {} {})\n                    (0x1FF := PageDirectoryPDPTE (addrFromPPtr init_global_pd) {} {})\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Heap Access for Simple Objects: Provides functions to get and set simple kernel objects (endpoints and notifications) from the kernel heap, ensuring the object type is valid and the operation is type-safe. \n\nGet Simple Kernel Object: Retrieves a simple kernel object from the kernel heap, asserting the object type is valid and returning the object if successful.\n\nSet Simple Kernel Object: Sets a simple kernel object in the kernel heap, asserting the object type is valid and the new object is compatible with the existing object.",
    "input": "",
    "output": "(* to be used for abstraction unifying kernel objects other than TCB and CNode *)\n\ndefinition\n  partial_inv :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('b \\<Rightarrow> 'a option)\"\nwhere\n  \"partial_inv f x = (if \\<exists>!y. f y = x then Some (THE y. f y = x) else None)\"\n\nlemma proj_inj: \"inj f \\<Longrightarrow> (partial_inv f ko = Some v) = (f v = ko)\"\n  by (auto simp: partial_inv_def the_equality injD)\n\nlemma inj_Endpoint: \"inj Endpoint\" by (auto intro: injI)\nlemma inj_Notification: \"inj Notification\"  by (auto intro: injI)\n\nlemmas proj_inj_ep[simp] = proj_inj[OF inj_Endpoint]\nlemma proj_ko_type_ep[simp]: \"(\\<exists>v. partial_inv Endpoint  ko = Some (v::endpoint)) = (a_type ko = AEndpoint)\"\n  by (cases ko; auto simp: partial_inv_def a_type_def)\n\nlemmas proj_inj_ntfn[simp] = proj_inj[OF inj_Notification]\nlemma proj_ko_type_ntfn[simp]:\n  \"(\\<exists>v. partial_inv Notification  ko = Some (v::notification)) = (a_type ko = ANTFN)\"\n  by (cases ko; auto simp: partial_inv_def a_type_def)\n\n\nabbreviation\n  \"is_simple_type \\<equiv> (\\<lambda>ob. a_type ob \\<in> {AEndpoint, ANTFN})\"\n\n\ndefinition\n  get_simple_ko :: \"('a \\<Rightarrow> kernel_object) \\<Rightarrow> obj_ref \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"get_simple_ko f ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     assert (is_simple_type kobj);\n     (case partial_inv f kobj of Some e \\<Rightarrow> return e | _ \\<Rightarrow> fail)\n   od\"\n\n\ndefinition\n  set_simple_ko :: \"('a \\<Rightarrow> kernel_object) \\<Rightarrow> obj_ref \\<Rightarrow> 'a \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_simple_ko f ptr ep \\<equiv> do\n     obj \\<leftarrow> get_object ptr;\n     assert (is_simple_type obj);\n     assert (partial_inv f obj \\<noteq> None);\n     set_object ptr (f ep)\n   od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Top-level Event Handling: Handle system events, including system calls, unknown system calls, user-level faults, interrupts, VM faults, and hypervisor events, ensuring that each event is processed correctly and securely, with necessary fault handling and potential preemption.\n\nSubproperties:\n- System Call Handling: Handle various system calls, such as send, receive, yield, and reply, with specific handling for each type.\n- Unknown System Call Handling: Handle unknown system calls by reporting a fault to the current thread.\n- User-Level Fault Handling: Handle user-level faults by reporting an exception to the current thread.\n- Interrupt Handling: Handle interrupts by determining the active IRQ and handling it if present.\n- VM Fault Handling: Handle VM faults by reporting the fault to the current thread and handling potential errors.\n- Hypervisor Event Handling: Handle hypervisor events by reporting the fault to the current thread.",
    "input": "",
    "output": "text \\<open>\n\n  The definition here is almost identical to that of the abstract specification (for the restricted\n  capablities), except that a call to \\texttt{handle_reply} has been removed. Since there\n  are no \\texttt{Reply}s in the restricted capabilities the behaviour is the same.\n\n\\<close>\n\n\nfun\n  handle_event :: \"event \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_event (SyscallEvent call) =\n   (case call of\n          SysSend \\<Rightarrow> handle_send True\n        | SysNBSend \\<Rightarrow> handle_send False\n        | SysCall \\<Rightarrow> handle_call\n        | SysRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysYield \\<Rightarrow> without_preemption handle_yield\n        | SysReply \\<Rightarrow> without_preemption handle_reply\n        | SysReplyRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysNBRecv \\<Rightarrow> without_preemption $ handle_recv False)\"\n\n| \"handle_event (UnknownSyscall n) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UnknownSyscallException $ of_nat n;\n    return ()\n  od)\"\n\n| \"handle_event (UserLevelFault w1 w2) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UserException w1 (w2 && mask 28);\n    return ()\n  od)\"\n\n| \"handle_event Interrupt = (without_preemption $ do\n    active \\<leftarrow> do_machine_op (getActiveIRQ False);\n    case active of\n       Some irq \\<Rightarrow> handle_interrupt irq\n     | None \\<Rightarrow> return ()\n  od)\"\n\n| \"handle_event (VMFaultEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_vm_fault thread fault_type <catch> handle_fault thread;\n    return ()\n  od)\"\n\n| \"handle_event (HypervisorEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_hypervisor_fault thread fault_type;\n    return ()\n  od)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Machine Operations: Perform low-level operations on the machine state, specifically on the underspecified part of the machine state, without failing and always returning a non-empty set of follow-on states.",
    "input": "",
    "output": "text \\<open>\n  Most of the machine operations below work on the underspecified part of the machine state @{typ\n  machine_state_rest} and cannot fail. We could express the latter by type (leaving out the failure\n  flag), but if we later wanted to implement them, we'd have to set up a new Hoare logic framework\n  for that type. So instead, we provide a wrapper for these operations that explicitly ignores the\n  fail flag and sets it to False. Similarly, these operations never return an empty set of follow-on\n  states, which would require the operation to fail. So we explicitly make this (non-existing) case\n  a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming RISCV64",
    "system": "",
    "history": []
  },
  {
    "instruction": "Machine State Properties: Define the hardware-specific machine state for ARM_HYP, including hardware ASID, VM fault types, and VM page sizes, ensuring correct hardware configuration and virtualization support. \n\nHardware Configuration: Specify the hardware control register (HCR) settings, including common, TWE, TWI, VCPU, and native configurations, as well as the system control register (SCTLR) and auxiliary control register (ACTLR) defaults, to ensure proper hardware setup and virtualization functionality.",
    "input": "",
    "output": "#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP ONLY HardwareASID VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize hcrCommon hcrTWE hcrTWI hcrVCPU hcrNative vgicHCREN sctlrDefault actlrDefault gicVCPUMaxNumLR\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP instanceproofs ONLY HardwareASID VMFaultType HypFaultType VMPageSize\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "RISCV64 Architecture State: Maintains architecture-specific state information, including the ASID table, global page tables, and kernel virtual space mappings. \n\nSubproperties:\n- ASID Table Management: Stores the mapping of ASID high indices to object references.\n- Global Page Table Management: Tracks the set of object references for each virtual machine level.\n- Kernel Virtual Space Mappings: Records the usage of RISCV64 virtual space regions for each object reference.",
    "input": "",
    "output": "record arch_state =\n  riscv_asid_table :: \"asid_high_index \\<rightharpoonup> obj_ref\"\n  riscv_global_pts :: \"RISCV64_A.vm_level \\<Rightarrow> obj_ref set\"\n  riscv_kernel_vspace :: \"obj_ref \\<Rightarrow> RISCV64_H.riscvvspace_region_use\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Capability Management: Provides functions for managing capabilities, including retrieving, setting, and inserting capabilities, while maintaining the integrity of the capability derivation tree (CDT) and ensuring that capabilities are correctly updated and tracked.\n\nSubproperties:\n- Get Capability: Retrieves a capability from a specified slot, handling different object types (CNode, TCB, etc.).\n- Set Capability: Sets a capability in a specified slot, ensuring that the object type and slot index are valid.\n- Insert Capability: Inserts a new capability into a destination slot, updating the CDT and performing necessary checks for untyped capabilities, endpoint badges, and notification badges.\n- Setup Reply Master: Sets up a reply master capability for a thread, ensuring that the reply capability is correctly set and marked as original.",
    "input": "",
    "output": "text \\<open>\n  These shadow the normal functions, but do not force a well-formedness\n  check for the cnodes, as wellformed\\_cnode\\_sz is non-local with respect\n  to individual caps, and so get\\_cap and set\\_cap are also.\\<close>\n\ndefinition\n  get_cap_local :: \"cslot_ptr \\<Rightarrow> (cap,'z::state_ext) s_monad\"\nwhere\n  \"get_cap_local \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     caps \\<leftarrow> case obj of\n             CNode sz cnode \\<Rightarrow> return cnode\n           | TCB tcb     \\<Rightarrow> return (tcb_cnode_map tcb)\n           | _ \\<Rightarrow> fail;\n     assert_opt (caps cref)\n   od\"\n\ndefinition\n  set_cap_local :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_cap_local cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     obj' \\<leftarrow> case obj of\n               CNode sz cn \\<Rightarrow> if cref \\<in> dom cn\n                                then return $ CNode sz $ cn (cref \\<mapsto> cap)\n                                else fail\n             | TCB tcb \\<Rightarrow>\n                   if cref = tcb_cnode_index 0 then\n                       return $ TCB $ tcb \\<lparr> tcb_ctable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 1 then\n                       return $ TCB $ tcb \\<lparr> tcb_vtable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 2 then\n                       return $ TCB $ tcb \\<lparr> tcb_reply := cap \\<rparr>\n                   else if cref = tcb_cnode_index 3 then\n                       return $ TCB $ tcb \\<lparr> tcb_caller := cap \\<rparr>\n                   else if cref = tcb_cnode_index 4 then\n                       return $ TCB $ tcb \\<lparr> tcb_ipcframe := cap \\<rparr>\n                   else\n                       fail\n             | _ \\<Rightarrow> fail;\n     set_object oref obj'\n  od\"\n\ndefinition\n  set_untyped_cap_as_full_local :: \"cap \\<Rightarrow> cap \\<Rightarrow> word32 \\<times> bool list\\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_untyped_cap_as_full_local src_cap new_cap src_slot \\<equiv>\n   if (is_untyped_cap src_cap \\<and> is_untyped_cap new_cap\n       \\<and> obj_ref_of src_cap = obj_ref_of new_cap \\<and> cap_bits_untyped src_cap = cap_bits_untyped new_cap)\n       then set_cap_local (max_free_index_update src_cap) src_slot else return ()\"\n\ndefinition\n  cap_insert_local :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"cap_insert_local new_cap src_slot dest_slot \\<equiv> do\n    src_cap \\<leftarrow> get_cap_local src_slot;\n\n    dest_original \\<leftarrow> return (if is_ep_cap new_cap then\n                                cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n                             else if is_ntfn_cap new_cap then\n                                cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n                             else if \\<exists>irq. new_cap = IRQHandlerCap irq then\n                                src_cap = IRQControlCap\n                             else is_untyped_cap new_cap);\n    old_cap \\<leftarrow> get_cap_local dest_slot;\n    assert (old_cap = NullCap);\n    set_untyped_cap_as_full_local src_cap new_cap src_slot;\n    set_cap_local new_cap dest_slot;\n\n    is_original \\<leftarrow> gets is_original_cap;\n    src_parent \\<leftarrow> return $\n       should_be_parent_of src_cap (is_original src_slot) new_cap dest_original;\n    src_p \\<leftarrow> gets (\\<lambda>s. cdt s src_slot);\n    dest_p \\<leftarrow> gets (\\<lambda>s. cdt s dest_slot);\n    update_cdt (\\<lambda>cdt. cdt (dest_slot := if src_parent\n                                        then Some src_slot\n                                        else cdt src_slot));\n    do_extended_op (cap_insert_ext src_parent src_slot dest_slot src_p dest_p);\n    set_original dest_slot dest_original\n  od\"\n\ndefinition\n  \"setup_reply_master_local thread \\<equiv> do\n     old_cap <- get_cap_local (thread, tcb_cnode_index 2);\n     when (old_cap = NullCap) $ do\n         set_original (thread, tcb_cnode_index 2) True;\n         set_cap_local (ReplyCap thread True) (thread, tcb_cnode_index 2)\n     od\n  od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Uniform Capability Access: Retrieve and update capabilities in a uniform fashion, regardless of whether they reside in a CNode or inside a TCB.\n\nGet Capability: Retrieve a capability from a CNode or TCB, ensuring that the CNode is well-formed and the capability exists at the specified location.\n\nSet Capability: Update a capability in a CNode or TCB, ensuring that the CNode is well-formed and the capability is valid for the specified location.",
    "input": "",
    "output": "text \\<open>\n Recall that a capability may reside in either a CNode, or inside a TCB;\nthe following definitions allow the kernel model to retrieve and update\ncapabilities in a uniform fashion.\\<close>\ndefinition\n  get_cap :: \"cslot_ptr \\<Rightarrow> (cap,'z::state_ext) s_monad\"\nwhere\n  \"get_cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     caps \\<leftarrow> case obj of\n             CNode sz cnode \\<Rightarrow> do\n                                assert (well_formed_cnode_n sz cnode);\n                                return cnode\n                              od\n           | TCB tcb     \\<Rightarrow> return (tcb_cnode_map tcb)\n           | _ \\<Rightarrow> fail;\n     assert_opt (caps cref)\n   od\"\n\ndefinition\n  set_cap :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_cap cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     obj' \\<leftarrow> case obj of\n               CNode sz cn \\<Rightarrow> if cref \\<in> dom cn \\<and> well_formed_cnode_n sz cn\n                                then return $ CNode sz $ cn (cref \\<mapsto> cap)\n                                else fail\n             | TCB tcb \\<Rightarrow>\n                   if cref = tcb_cnode_index 0 then\n                       return $ TCB $ tcb \\<lparr> tcb_ctable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 1 then\n                       return $ TCB $ tcb \\<lparr> tcb_vtable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 2 then\n                       return $ TCB $ tcb \\<lparr> tcb_reply := cap \\<rparr>\n                   else if cref = tcb_cnode_index 3 then\n                       return $ TCB $ tcb \\<lparr> tcb_caller := cap \\<rparr>\n                   else if cref = tcb_cnode_index 4 then\n                       return $ TCB $ tcb \\<lparr> tcb_ipcframe := cap \\<rparr>\n                   else\n                       fail\n             | _ \\<Rightarrow> fail;\n     set_object oref obj'\n  od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Hardware Abstraction: Provide a hardware abstraction layer for the RISCV64 architecture, encapsulating low-level operations and hardware-specific details, such as memory management, interrupt handling, and timer configuration, to facilitate platform-agnostic kernel development.\n\nSubproperties:\n- Memory Management: Manage memory regions, kernel devices, and hardware ASIDs, ensuring efficient memory allocation and deallocation.\n- Interrupt Handling: Handle interrupts, including getting active IRQs, acknowledging and masking interrupts, and configuring timers.\n- Low-Level Operations: Perform low-level operations, such as loading and storing words, setting the next PC, and clearing memory.\n- Virtual Memory: Manage virtual memory, including page table translations, VM fault types, and VM page sizes.\n- Hardware-Specific Details: Encapsulate hardware-specific details, such as physical base addresses, page bits, and VM rights.",
    "input": "",
    "output": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs Platform=Platform.RISCV64 CONTEXT RISCV64_H NOT plic_complete_claim getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory setHardwareASID wordFromPDE wordFromPTE VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize toPAddr addrFromPPtr ptrFromPAddr sfence physBase paddrBase pptrBase pptrBaseOffset pptrTop pptrUserTop kernelELFBase kernelELFBaseOffset kernelELFPAddrBase addrFromKPPtr ptTranslationBits vmFaultTypeFSR read_stval setVSpaceRoot hwASIDFlush setIRQTrigger\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64_H instanceproofs NOT plic_complete_claim HardwareASID VMFaultType VMPageSize VMPageEntry HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64_H ONLY wordFromPTE",
    "system": "",
    "history": []
  },
  {
    "instruction": "Pending Sync Send Capability: Tracks the state of a pending synchronous send capability, including the target object ID, badge, and flags indicating whether it's a call, can grant capabilities, can grant reply capabilities, and whether it's a fault IPC.",
    "input": "",
    "output": "| PendingSyncSendCap cdl_object_id cdl_badge bool bool bool bool",
    "system": "",
    "history": []
  },
  {
    "instruction": "Synchronous Message Transfer: Transfer a non-fault message between threads, involving the transfer of message registers, capability pointers, and updating the message info of the receiving thread. \n\nMessage Register Transfer: Copy message registers from the sender's buffer to the receiver's buffer.\n\nCapability Transfer: Transfer capability pointers from the sender to the receiver, updating the message info accordingly.",
    "input": "",
    "output": "text \\<open>Transfer a non-fault message.\\<close>\ndefinition\n  do_normal_transfer :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> obj_ref option\n                                    \\<Rightarrow> data \\<Rightarrow> bool \\<Rightarrow> obj_ref\n                                    \\<Rightarrow> obj_ref option\n                                    \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"do_normal_transfer sender sbuf endpoint badge grant\n                     receiver rbuf  \\<equiv>\n  do\n    mi \\<leftarrow> get_message_info sender;\n    caps \\<leftarrow> if grant then lookup_extra_caps sender sbuf mi <catch> K (return [])\n      else return [];\n    mrs_transferred \\<leftarrow> copy_mrs sender sbuf receiver rbuf (mi_length mi);\n    mi' \\<leftarrow> transfer_caps mi caps endpoint receiver rbuf;\n    set_message_info receiver $ MI mrs_transferred (mi_extra_caps mi')\n                                   (mi_caps_unwrapped mi') (mi_label mi);\n    as_user receiver $ setRegister badge_register badge\n  od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Arch-Specific Ghost Update Functions: Provide functions for updating the ghost state of physical memory, specific to the RISCV64 architecture.",
    "input": "",
    "output": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/RISCV64.hs\n\nend (* context Arch *)\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Initial Architecture State: The initial architecture state is defined with an empty ASID table, a kernel vspace mapping function, an empty VMID table, a next VMID of 0, a global vspace pointer, no current VCPU, and undefined GIC VCPU number list registers. \n\nKernel Vspace Mapping: Maps kernel-level page tables in hyp mode, distinguishing between the kernel window and invalid regions.",
    "input": "",
    "output": "definition init_vspace_uses :: \"vspace_ref \\<Rightarrow> arm_vspace_region_use\" where\n  \"init_vspace_uses p \\<equiv>\n     if p \\<in> {pptr_base ..< pptr_base + (1 << 30)} then ArmVSpaceKernelWindow\n     else ArmVSpaceInvalidRegion\"\n\n\ndefinition init_arch_state :: arch_state where\n  \"init_arch_state \\<equiv> \\<lparr>\n     arm_asid_table = Map.empty,\n     arm_kernel_vspace = init_vspace_uses,\n     arm_vmid_table = Map.empty,\n     arm_next_vmid = 0,\n     arm_us_global_vspace = arm_global_pt_ptr,\n     arm_current_vcpu = None,\n     arm_gicvcpu_numlistregs = undefined\n   \\<rparr>\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Associativity of Bind with Exceptions: The bind operation with exceptions is associative, ensuring that the order in which exceptions are handled does not affect the outcome.",
    "input": "",
    "output": "lemma bindE_assoc:\n  \"(m >>=E f) >>=E g = m >>=E (\\<lambda>x. f x >>=E g)\"\n  unfolding bindE_def\n  by (fastforce simp: bind_assoc lift_def throwError_def\n                split: sum.splits\n                intro: arg_cong[where f=\"\\<lambda>x. m >>= x\"])",
    "system": "",
    "history": []
  },
  {
    "instruction": "Clear Memory Operation: Clears a specified range of memory, defined by a pointer and a number of bits, with no actual effect in the Haskell simulator interface stub.",
    "input": "",
    "output": "definition clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\" where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "ARM-Specific System Call Arguments: Define the various data types for encoding arguments to ARM-specific system calls, including flush types, page directory, page table, ASID control, ASID pool, page, and VCPU invocations. These data types provide a structured way to represent the different parameters and options for each system call, ensuring that the correct information is passed to the kernel for processing.\n\nSubproperties:\n- Flush Type: Specifies the type of flush operation to perform (Clean, Invalidate, CleanInvalidate, or Unify).\n- Page Directory and Page Table Invocations: Define the structure for page directory and page table operations, including mapping, unmapping, and flushing.\n- ASID Control and Pool Invocations: Represent the creation and assignment of ASID pools.\n- Page Invocations: Encode page-related operations, such as mapping, unmapping, flushing, and getting addresses.\n- VCPU Invocations: Define the structure for VCPU-related operations, including setting TCBs, injecting IRQs, reading and writing registers, and acknowledging VPP events.",
    "input": "",
    "output": "datatype flush_type = Clean | Invalidate | CleanInvalidate | Unify\n\ndatatype page_directory_invocation =\n    PageDirectoryFlush (pd_flush_type: flush_type) (pd_flush_start: vspace_ref)\n                       (pd_flush_end: vspace_ref) (pd_flush_pstart: word32)\n                       (pd_flush_pd: obj_ref) (pd_flush_asid: asid)\n  | PageDirectoryNothing\n\ndatatype page_table_invocation =\n    PageTableMap cap cslot_ptr pde obj_ref\n  | PageTableUnmap cap cslot_ptr\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation\n     = PageMap\n         (page_map_asid: asid)\n         (page_map_cap: cap)\n         (page_map_ct_slot: cslot_ptr)\n         (page_map_entries: \"pte \\<times> (obj_ref list) + pde \\<times> (obj_ref list)\")\n     | PageUnmap\n         (page_unmap_cap: arch_cap)\n         (page_unmap_cap_slot: cslot_ptr)\n     | PageFlush\n         (page_flush_type: flush_type)\n         (page_flush_start: vspace_ref)\n         (page_flush_end: vspace_ref)\n         (page_flush_pstart: word32)\n         (page_flush_pd: obj_ref)\n         (page_flush_asid: asid)\n     | PageGetAddr\n         (page_get_paddr: obj_ref)\n\ndatatype vcpu_invocation =\n       VCPUSetTCB obj_ref (*vcpu*) obj_ref (*tcb*)\n     | VCPUInjectIRQ obj_ref nat virq\n     | VCPUReadRegister obj_ref vcpureg\n     | VCPUWriteRegister obj_ref vcpureg machine_word\n     | VCPUAckVPPI obj_ref (* vcpu *) vppievent_irq\n\ndatatype arch_invocation\n     = InvokePageTable page_table_invocation\n     | InvokePageDirectory page_directory_invocation\n     | InvokePage page_invocation\n     | InvokeASIDControl asid_control_invocation\n     | InvokeASIDPool asid_pool_invocation\n     | InvokeVCPU vcpu_invocation",
    "system": "",
    "history": []
  },
  {
    "instruction": "Exception Handling: Raise an exception if a specified property does not hold, ensuring that the system maintains its integrity and reports errors when necessary.",
    "input": "",
    "output": "definition\nthrow_on_false :: \"'e \\<Rightarrow> (bool,'z::state_ext) s_monad \\<Rightarrow> ('e + unit,'z::state_ext) s_monad\" where\n\"throw_on_false ex f \\<equiv> doE v \\<leftarrow> liftE f; unlessE v $ throwError ex odE\"\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Retrieve Extra Capabilities: Retrieve additional capability pointers from a thread's IPC buffer, handling cases where the buffer is present or absent. \n\n Load Capability Pointer: Load a capability pointer from a specific offset in the IPC buffer.",
    "input": "",
    "output": "definition\n  buffer_cptr_index :: nat\nwhere\n \"buffer_cptr_index \\<equiv> (msg_max_length + 2)\"\n\nprimrec\n  get_extra_cptrs :: \"obj_ref option \\<Rightarrow> message_info \\<Rightarrow> (cap_ref list,'z::state_ext) s_monad\"\nwhere\n  \"get_extra_cptrs (Some buf) mi =\n    (liftM (map data_to_cptr) $ mapM (load_word_offs buf)\n        [buffer_cptr_index ..< buffer_cptr_index + (unat (mi_extra_caps mi))])\"\n| \"get_extra_cptrs None mi = return []\"\n\ndefinition\n  get_extra_cptr :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> (cap_ref,'z::state_ext) s_monad\"\nwhere\n  \"get_extra_cptr buffer n \\<equiv> liftM data_to_cptr\n      (load_word_offs buffer (n + buffer_cptr_index))\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "ARM-Specific Object Types: Defines the types and structures for architecture-specific objects, including page directory entries (PDEs), page table entries (PTEs), ASID pools, page tables, page directories, and data pages, which are used to model user memory and facilitate memory management.",
    "input": "",
    "output": "text \\<open>This section gives the types and auxiliary definitions for the\narchitecture-specific objects: a page directory entry (@{text \"pde\"})\ncontains either an invalid entry, a page table reference, a section\nreference, or a super-section reference; a page table entry contains\neither an invalid entry, a large page, or a small page mapping;\nfinally, an architecture-specific object is either an ASID pool, a\npage table, a page directory, or a data page used to model user\nmemory.\n\\<close>",
    "system": "",
    "history": []
  },
  {
    "instruction": "Set Cap Derivation: Establish a parent-child relationship between two capability references in the capability derivation tree (CDT), ensuring the child reference has no existing parent.",
    "input": "",
    "output": "definition\n  set_parent :: \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\" where\n  \"set_parent child parent \\<equiv> do\n    cdt \\<leftarrow> gets cdl_cdt;\n    assert (cdt child = None);\n    modify (\\<lambda>s. s \\<lparr> cdl_cdt := (cdl_cdt s) (child \\<mapsto> parent) \\<rparr> )\n   od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Initialization of Kernel State: The kernel's initial state is defined, including the global page table, kernel heap, capability derivation tree, and I/O controller. The global page table is constructed with specific page table entries for the kernel window and ELF index. The kernel heap is initialized with the idle thread, global page table, and interrupt nodes. The capability derivation tree is empty, and the I/O controller is defined based on the kernel heap and capability derivation. The initial state also includes the current thread, idle thread, machine state, interrupt IRQ node, interrupt states, architecture state, and extended state. \n\nSubproperties:\n- Global Page Table: Maps specific indices to page table entries for the kernel window and ELF index, with all other indices mapped to invalid page table entries.\n- Kernel Heap: Initializes the kernel heap with the idle thread, global page table, and interrupt nodes.\n- Capability Derivation Tree: The capability derivation tree is initially empty.\n- I/O Controller: Defines the I/O controller based on the kernel heap and capability derivation.",
    "input": "",
    "output": "definition global_pte :: \"pt_index \\<Rightarrow> pte\"\n  where\n  \"global_pte idx \\<equiv>\n     if idx = 0x100\n     then PagePTE ((ucast (idx && mask (ptTranslationBits - 1)) << ptTranslationBits * size max_pt_level))\n                  {} vm_kernel_only\n     else if idx = elf_index\n     then PagePTE (ucast ((kernelELFPAddrBase && ~~mask toplevel_bits) >> pageBits)) {} vm_kernel_only\n     else InvalidPTE\"\n\ndefinition init_global_pt :: kernel_object\n  where\n  \"init_global_pt \\<equiv> ArchObj $ PageTable (\\<lambda>idx. if idx \\<in> kernel_mapping_slots\n                                                then global_pte idx\n                                                else InvalidPTE)\"\n\ndefinition init_kheap :: kheap\n  where\n  \"init_kheap \\<equiv>\n    (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n           then Some (CNode 0 (empty_cnode 0))\n           else None)\n    (idle_thread_ptr \\<mapsto>\n       TCB \\<lparr>\n         tcb_ctable = NullCap,\n         tcb_vtable = NullCap,\n         tcb_reply = NullCap,\n         tcb_caller = NullCap,\n         tcb_ipcframe = NullCap,\n         tcb_state = IdleThreadState,\n         tcb_fault_handler = replicate word_bits False,\n         tcb_ipc_buffer = 0,\n         tcb_fault = None,\n         tcb_bound_notification = None,\n         tcb_mcpriority = minBound,\n         tcb_arch = init_arch_tcb\n         \\<rparr>,\n      riscv_global_pt_ptr \\<mapsto> init_global_pt\n    )\"\n\ndefinition init_cdt :: cdt\n  where\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition init_ioc :: \"cslot_ptr \\<Rightarrow> bool\"\n  where\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition init_A_st :: \"'z::state_ext state\"\n  where\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Machine Operations: Perform low-level operations on the machine state, working on the underspecified part of the machine state and never failing, with any potential failure flag explicitly ignored and set to False, ensuring a non-empty set of follow-on states.",
    "input": "",
    "output": "text \\<open>\n  Most of the machine operations below work on the underspecified\n  part of the machine state @{typ machine_state_rest} and cannot fail.\n  We could express the latter by type (leaving out the failure flag),\n  but if we later wanted to implement them,\n  we'd have to set up a new hoare-logic\n  framework for that type. So instead, we provide a wrapper for these\n  operations that explicitly ignores the fail flag and sets it to\n  False. Similarly, these operations never return an empty set of\n  follow-on states, which would require the operation to fail.\n  So we explicitly make this (non-existing) case a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming X64",
    "system": "",
    "history": []
  },
  {
    "instruction": "Basic Kernel Monad: Provides a fundamental execution environment without faults, interrupts, or errors, allowing for nondeterministic operations on the kernel state.",
    "input": "",
    "output": "type_synonym ('a,'z) s_monad = \"('z state, 'a) nondet_monad\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "IRQ Decoding: Decodes system calls for interrupt controller and interrupt handlers, ensuring that the invocation type matches the expected format and that the provided arguments and capabilities are valid.\n\nSubproperties:\n- IRQ Issue IRQ Handler: Validates the IRQ word, checks if the IRQ is active, and ensures the destination slot is empty before issuing the IRQ handler.\n- IRQ Handler Invocation: Decodes the invocation type and validates the provided capabilities and arguments for ACK IRQ, Set IRQ Handler, and Clear IRQ Handler operations.",
    "input": "",
    "output": "text \\<open>The following two definitions decode system calls for the\ninterrupt controller and interrupt handlers\\<close>\n\ndefinition\n  decode_irq_control_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list\n                                     \\<Rightarrow> (irq_control_invocation,'z::state_ext) se_monad\" where\n \"decode_irq_control_invocation label args src_slot cps \\<equiv>\n  (if gen_invocation_type label = IRQIssueIRQHandler\n    then if length args \\<ge> 3 \\<and> length cps \\<ge> 1\n      then let irq_word = args ! 0;\n               index = args ! 1;\n               depth = args ! 2;\n               cnode = cps ! 0;\n               irq = ucast irq_word\n      in doE\n        arch_check_irq irq_word;\n        irq_active \\<leftarrow> liftE $ is_irq_active irq;\n        whenE irq_active $ throwError RevokeFirst;\n\n        dest_slot \\<leftarrow> lookup_target_slot\n               cnode (data_to_cptr index) (unat depth);\n        ensure_empty dest_slot;\n\n        returnOk $ IRQControl irq dest_slot src_slot\n      odE\n    else throwError TruncatedMessage\n  else liftME ArchIRQControl $ arch_decode_irq_control_invocation label args src_slot cps)\"\n\ndefinition\n  decode_irq_handler_invocation :: \"data \\<Rightarrow> irq \\<Rightarrow> (cap \\<times> cslot_ptr) list\n                                     \\<Rightarrow> (irq_handler_invocation,'z::state_ext) se_monad\" where\n \"decode_irq_handler_invocation label irq cps \\<equiv>\n  if gen_invocation_type label = IRQAckIRQ\n    then returnOk $ ACKIrq irq\n  else if gen_invocation_type label = IRQSetIRQHandler\n    then if cps \\<noteq> []\n      then let (cap, slot) = hd cps in\n      if is_ntfn_cap cap \\<and> AllowSend \\<in> cap_rights cap\n      then returnOk $ SetIRQHandler irq cap slot\n      else throwError $ InvalidCapability 0\n    else throwError TruncatedMessage\n  else if gen_invocation_type label = IRQClearIRQHandler\n    then returnOk $ ClearIRQHandler irq\n  else throwError IllegalOperation\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Architectural Capability Finalisation: Ensure that ARM-specific capabilities are properly finalised by deleting or unmapping associated resources, such as ASID pools, page directories, page tables, and pages, when they are no longer needed.\n\nThread Deletion Preparation: No additional steps are required to prepare an ARM thread for deletion.",
    "input": "",
    "output": "definition\n  arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n    (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n    delete_asid_pool b ptr;\n    return (NullCap, NullCap)\n    od\n  | (PageDirectoryCap ptr (Some a), True) \\<Rightarrow> do\n    delete_asid a ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageTableCap ptr (Some (a, v)), True) \\<Rightarrow> do\n    unmap_page_table a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageCap _ ptr _ s (Some (a, v)), _) \\<Rightarrow> do\n     unmap_page s a v ptr;\n     return (NullCap, NullCap)\n  od\n  | _ \\<Rightarrow> return (NullCap, NullCap)\"\n\n\ndefinition (* prepares a thread for deletion; nothing to do for ARM *)\n  prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"prepare_thread_delete p \\<equiv> return ()\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Lookup Page Table Slot: Compute the pointer to the Page Table Entry (PTE) in kernel memory for a given virtual address and page-directory reference, failing if the virtual address is mapped on a section or super section. \n\nSubproperties:\n- Retrieve the page directory slot for the given virtual address.\n- Get the Page Directory Entry (PDE) from the page directory slot.\n- If the PDE is a Page Table PDE, calculate the page table index and slot.\n- Return the page table slot if successful, or throw an error if the PDE is not a Page Table PDE.",
    "input": "",
    "output": "definition\nlookup_pt_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"lookup_pt_slot vspace vptr \\<equiv> doE\n    pd_slot \\<leftarrow> lookup_pd_slot vspace vptr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    (case pde of\n          PageTablePDE ptab _ _ \\<Rightarrow>   (doE\n            pt \\<leftarrow> returnOk (ptrFromPAddr ptab);\n            pt_index \\<leftarrow> returnOk (get_pt_index vptr);\n            pt_slot \\<leftarrow> returnOk (pt + (pt_index << word_size_bits));\n            returnOk pt_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability pd_shift_bits)\n   odE\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "UCast MaxIRQ Equality: The unsigned cast of maxIRQ from type 'a to type 'b is equal to maxIRQ, given that the length of irq_len is less than or equal to the lengths of both 'a and 'b.",
    "input": "",
    "output": "lemma ucast_maxIRQ[simp]:\n  \"\\<lbrakk> LENGTH(irq_len) \\<le> LENGTH('a::len); LENGTH(irq_len) \\<le> LENGTH('b::len) \\<rbrakk> \\<Longrightarrow>\n   UCAST ('a \\<rightarrow> 'b) maxIRQ = maxIRQ\"\n  by (metis of_nat_maxIRQ ucast_nat_def unat_maxIRQ)",
    "system": "",
    "history": []
  },
  {
    "instruction": "State Transition Properties: The trans_state function preserves various system components, including the kernel heap, capability derivation tree, original capability status, current thread, idle thread, machine state, interrupt IRQ node, interrupt states, and architecture state, while updating the exst (extra state) component according to the provided transformation function.\n\nUpdate Properties: The trans_state function commutes with update functions for various system components, ensuring that the order of updates does not affect the resulting system state.\n\nComposition Property: The trans_state function can be composed with other transformation functions to create a new transformation function that applies the transformations sequentially.",
    "input": "",
    "output": "lemma trans_state[simp]: \"kheap (trans_state t s) = kheap s\"\n                            \"cdt (trans_state t s) = cdt s\"\n                            \"is_original_cap (trans_state t s) = is_original_cap s\"\n                            \"cur_thread (trans_state t s) = cur_thread s\"\n                            \"idle_thread (trans_state t s) = idle_thread s\"\n                            \"machine_state (trans_state t s) = machine_state s\"\n                            \"interrupt_irq_node (trans_state t s) = interrupt_irq_node s\"\n                           \"interrupt_states (trans_state t s) = interrupt_states s\"\n                            \"arch_state (trans_state t s) = arch_state s\"\n                            \"exst (trans_state t s) = (t (exst s))\"\n                            \"exst (trans_state (\\<lambda>_. e) s) = e\"\n  apply (simp add: trans_state_def)+\n  done\n\nlemma trans_state_update[simp]:\n \"trans_state t (kheap_update f s) = kheap_update f (trans_state t s)\"\n \"trans_state t (cdt_update g s) = cdt_update g (trans_state t s)\"\n \"trans_state t (is_original_cap_update h s) = is_original_cap_update h (trans_state t s)\"\n \"trans_state t (cur_thread_update i s) = cur_thread_update i (trans_state t s)\"\n \"trans_state t (idle_thread_update j s) = idle_thread_update j (trans_state t s)\"\n \"trans_state t (machine_state_update k s) = machine_state_update k (trans_state t s)\"\n \"trans_state t (interrupt_irq_node_update l s) = interrupt_irq_node_update l (trans_state t s)\"\n \"trans_state t (arch_state_update m s) = arch_state_update m (trans_state t s)\"\n \"trans_state t (interrupt_states_update p s) = interrupt_states_update p (trans_state t s)\"\n  apply (simp add: trans_state_def)+\n  done\n\n\nlemma trans_state_update':\n  \"trans_state f = exst_update f\"\n  apply (rule ext)\n  apply simp\n  done\n\nlemma trans_state_update''[simp]:\n  \"trans_state t' (trans_state t s) = trans_state (\\<lambda>e. t' (t e)) s\"\n  apply simp\n  done",
    "system": "",
    "history": []
  },
  {
    "instruction": "VCPU Restore: Restore the VCPU-related state and registers, including the GIC VCPU control state and banked VCPU registers, and enable the VCPU.",
    "input": "",
    "output": "definition vcpu_restore :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_restore vr \\<equiv> do\n     do_machine_op $ set_gic_vcpu_ctrl_hcr 0;  \\<comment> \\<open>turn off VGIC\\<close>\n     do_machine_op $ isb;\n     vcpu \\<leftarrow> get_vcpu vr;  \\<comment> \\<open>restore GIC VCPU control state\\<close>\n     vgic \\<leftarrow> return (vcpu_vgic vcpu);\n     num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     gicIndices \\<leftarrow> return [0..<num_list_regs];\n     do_machine_op $ do\n         set_gic_vcpu_ctrl_vmcr (vgic_vmcr vgic);\n         set_gic_vcpu_ctrl_apr (vgic_apr vgic);\n         mapM (\\<lambda>p. set_gic_vcpu_ctrl_lr (of_nat (fst p)) (snd p))\n              (map (\\<lambda>i. (i, (vgic_lr vgic) i)) gicIndices)\n     od;\n    \\<comment> \\<open>restore banked VCPU registers except SCTLR (that's in VCPUEnable)\\<close>\n     vcpu_restore_reg_range vr VCPURegTTBR0 VCPURegSPSR_EL1;\n     vcpu_enable vr\n  od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Virtual ASID Management: Extract the high bits of a virtual ASID.",
    "input": "",
    "output": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition\n  asid_high_bits_of :: \"asid \\<Rightarrow> 7 word\" where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"\n\nlocale_abbrev\n  \"asid_table \\<equiv> \\<lambda>s. arm_asid_table (arch_state s)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Arch-Specific Ghost Update Functions: Provide functions for updating the ghost state of physical memory, specific to the X64 architecture.",
    "input": "",
    "output": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/X64.hs\n\nend (* context Arch *)\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Find Page Directory for ASID: Locate the page directory associated with a given virtual ASID, ensuring the ASID is valid and retrieving the corresponding page directory pointer from the ASID table and pool. \n\nSubproperties:\n- ASID Validation: Verify that the given ASID is greater than 0.\n- ASID Table Lookup: Retrieve the ASID table from the arch state and extract the pool pointer for the given ASID.\n- Pool Lookup: Retrieve the page directory pointer from the pool, handling cases where the pool or page directory is invalid.",
    "input": "",
    "output": "definition\nfind_pd_for_asid :: \"asid \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"find_pd_for_asid asid \\<equiv> doE\n    assertE (asid > 0);\n    asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n    pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of asid));\n    pool \\<leftarrow> (case pool_ptr of\n               Some ptr \\<Rightarrow> liftE $ get_asid_pool ptr\n             | None \\<Rightarrow> throwError InvalidRoot);\n    pd \\<leftarrow> returnOk (pool (ucast asid));\n    (case pd of\n          Some ptr \\<Rightarrow> returnOk ptr\n        | None \\<Rightarrow> throwError InvalidRoot)\nodE\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Initialization: Initialize the page table by re-typing a region of memory as a page table object with a specified size.",
    "input": "",
    "output": "retype_region global_pt 1 PT_SIZE_BITS\n                   (ArchObject PageTableObj);",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Object Capability Set: The set of all capabilities contained in a kernel object is defined as the range of the capability mapping function for that object.",
    "input": "",
    "output": "definition\n  caps_of :: \"kernel_object \\<Rightarrow> cap set\" where\n  \"caps_of kobj \\<equiv> ran (cap_of kobj)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "IO Port Representation: Represents a single IA32 IO port using a natural number.",
    "input": "",
    "output": "type_synonym cdl_io_port = nat",
    "system": "",
    "history": []
  },
  {
    "instruction": "System Operation Execution: Only execute a system operation if it is legal in the current state, ensuring that the system remains in a valid state after the operation. \n\nState Preservation: If the operation is not legal, preserve the current state.",
    "input": "",
    "output": "definition\n  step :: \"sysOPs \\<Rightarrow> modify_state_n\" where\n  \"step cmd s \\<equiv> if legal cmd s then (step' cmd s) \\<union> {s} else {s}\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Device Mapping Region: The virtual address for the start of the kernel device mapping region is located in the highest 1GiB of memory.",
    "input": "",
    "output": "definition kdev_base :: \"machine_word\" where\n  \"kdev_base = Platform.AARCH64.kdevBase\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Capability Object References: Determine the set of object references associated with a given capability, identifying the specific objects that the capability can access or manipulate.",
    "input": "",
    "output": "primrec\n  obj_refs :: \"cap \\<Rightarrow> obj_ref set\"\nwhere\n  \"obj_refs NullCap = {}\"\n| \"obj_refs (ReplyCap r m cr) = {}\"\n| \"obj_refs IRQControlCap = {}\"\n| \"obj_refs (IRQHandlerCap irq) = {}\"\n| \"obj_refs (UntypedCap dev r s f) = {}\"\n| \"obj_refs (CNodeCap r bits guard) = {r}\"\n| \"obj_refs (EndpointCap r b cr) = {r}\"\n| \"obj_refs (NotificationCap r b cr) = {r}\"\n| \"obj_refs (ThreadCap r) = {r}\"\n| \"obj_refs DomainCap = {}\"\n| \"obj_refs (Zombie ptr b n) = {ptr}\"\n| \"obj_refs (ArchObjectCap x) = set_option (aobj_ref x)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Access Hypervisor Banked Registers: Provide access to the hypervisor banked registers, including getting and setting the CNTV_CVAL_64 and CNTV_OFF_64 registers, and reading the CNTPCT register.",
    "input": "",
    "output": "consts'\n  cntv_cval_64_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition\n  get_cntv_cval_64 :: \"64 word machine_monad\"\nwhere\n  \"get_cntv_cval_64 \\<equiv> gets cntv_cval_64_val\"\n\nconsts'\n  set_cntv_cval_64_impl :: \"64 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_cntv_cval_64 :: \"64 word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_cntv_cval_64 w \\<equiv> machine_op_lift (set_cntv_cval_64_impl w)\"\n\nconsts'\n  cntv_off_64_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition\n  get_cntv_off_64 :: \"64 word machine_monad\"\nwhere\n  \"get_cntv_off_64 \\<equiv> gets cntv_off_64_val\"\n\nconsts'\n  set_cntv_off_64_impl :: \"64 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_cntv_off_64 :: \"64 word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_cntv_off_64 w \\<equiv> machine_op_lift (set_cntv_off_64_impl w)\"\n\nconsts'\n  read_cntpct_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition\n  read_cntpct :: \"64 word machine_monad\"\nwhere\n  \"read_cntpct \\<equiv> gets read_cntpct_val\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Initialization: \nMap kernel frames and devices, initialize the kernel window, and set up the bootinfo frame, ensuring that the kernel's memory layout and boot information are correctly established. \n\nSubproperties:\n- Map kernel frames to specific physical addresses with the correct virtual memory rights and attributes.\n- Map kernel devices (EPIT, AVIC, L2CC) to their respective physical addresses with kernel-only access and specific attributes.\n- Initialize the kernel window by retrieving the global page directory.",
    "input": "",
    "output": "freemem \\<leftarrow> liftE $ gets ki_free_mem;\n     freeregs \\<leftarrow> do_kernel_op $ freemem_regions freemem;\n\n     (swp mapME) (take MAX_NUM_FREEMEM_REG freeregs)\n       (\\<lambda>(start,bits). provide_untyped_cap root_cnode_cap start bits\n                                           slot_pos_before);\n\n     slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_ut_obj_caps := (slot_pos_before, slot_pos_after) \\<rparr>\\<rparr>);\n\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame\n   odE\"\n\ndefinition\n  map_kernel_frame :: \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vm_rights \\<Rightarrow> vm_attributes\n                       \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"map_kernel_frame paddr vaddr vm_rights attributes \\<equiv> do\n\n     idx \\<leftarrow> return $ (vaddr && mask (pageBitsForSize ARMSection))\n                    >> pageBitsForSize ARMSmallPage;\n\n     global_pt \\<leftarrow> get_arm_global_pt;\n\n     pte \\<leftarrow> return $ SmallPagePTE paddr attributes vm_rights;\n\n     store_pte (global_pt + (idx << PTE_SIZE_BITS)) pte\n   od\"\n\n\ndefinition (* from plat/imx31/machine/hardware.c *)\n  map_kernel_devices :: \"(unit,'z::state_ext) s_monad\" where\n  \"map_kernel_devices \\<equiv> do\n     map_kernel_frame EPIT_PADDR EPIT_PPTR vm_kernel_only\n                      {ParityEnabled,PageCacheable};\n     map_kernel_frame AVIC_PADDR AVIC_PPTR vm_kernel_only\n                      {ParityEnabled,PageCacheable};\n     map_kernel_frame L2CC_PADDR L2CC_PPTR vm_kernel_only\n                      {ParityEnabled,PageCacheable}\n   od\"\n\ndefinition\n  map_kernel_window :: \"(unit,'z::state_ext) s_monad\" where\n  \"map_kernel_window \\<equiv> do\n\n     global_pd \\<leftarrow> gets (arm_global_pd \\<circ> arch_state);",
    "system": "",
    "history": []
  },
  {
    "instruction": "Initialization of Global Page Directory Pointer Table (PDPT): The global PDPT is initialized at a fixed address, 0x5000 offset from the kernel base, with a size of 4KiB.",
    "input": "",
    "output": "definition\n  init_global_pdpt :: obj_ref where\n  \"init_global_pdpt = kernel_base + 0x5000\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Page Table Invocation Actions: Allow mapping and unmapping of page tables, conferring authority to manage page table capabilities. \n\nMap Page Table: Map a page table into a capability table slot.\nUnmap Page Table: Unmap a page table from a capability table slot.",
    "input": "",
    "output": "definition perform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_page_table_invocation iv \\<equiv> case iv of\n     PageTableMap cap ct_slot pte slot level \\<Rightarrow> perform_pt_inv_map cap ct_slot pte slot level\n   | PageTableUnmap cap ct_slot \\<Rightarrow> perform_pt_inv_unmap cap ct_slot\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Arch-Specific TCB Accessors: Provide access to the user register part of the architecture-specific TCB (Thread Control Block), allowing for getting and setting the registers within the TCB's user context.",
    "input": "",
    "output": "definition arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\n  where\n  \"arch_tcb_set_registers regs a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := UserContext regs \\<rparr>\"\n\ndefinition arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\"\n  where\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Object Creation Defaults: Newly created objects are initialized with default values specific to their type, ensuring a consistent and predictable state for further operations. \n\nSubproperties:\n- CapTableObject: Initialized as a CNode with an empty cnode of a specified size.\n- TCBObject: Initialized as a TCB with default_tcb values.\n- EndpointObject: Initialized as an Endpoint with default_ep values.\n- NotificationObject: Initialized as a Notification with default_notification values.\n- ArchObject: Initialized as an ArchObj with default_arch_object values specific to the architecture, device, and size.",
    "input": "",
    "output": "definition\n  default_object :: \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> kernel_object\" where\n  \"default_object api dev n \\<equiv> case api of\n           Untyped \\<Rightarrow> undefined\n         | CapTableObject \\<Rightarrow> CNode n (empty_cnode n)\n         | TCBObject \\<Rightarrow> TCB default_tcb\n         | EndpointObject \\<Rightarrow> Endpoint default_ep\n         | NotificationObject \\<Rightarrow> Notification default_notification\n         | ArchObject aobj \\<Rightarrow> ArchObj (default_arch_object aobj dev n)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Maximum IRQ Value: The maximum IRQ value is defined as a constant, which is architecture-dependent, ensuring that the kernel is configured to handle the correct range of interrupt requests for the specific architecture.",
    "input": "",
    "output": "arch_requalify_consts\n  maxIRQ\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "List Index Retrieval: Retrieve an element at a specified index from a list, returning None if the index is out of bounds. \n\nList Bounds Checking: Check if the given index is within the bounds of the list.",
    "input": "",
    "output": "definition\n  get_index :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a option\"\nwhere\n  \"get_index a b \\<equiv>\n     if b < length a then\n       Some (a ! b)\n     else\n       None\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Entity Rights: Entities in seL4 have specific rights to kernel objects, determining how they can interact with those objects.",
    "input": "",
    "output": "type_synonym cdl_right = rights",
    "system": "",
    "history": []
  },
  {
    "instruction": "Architecture-Specific Data Types: Define data types specific to a particular architecture, such as ARM, to be shared by specification and abstraction.",
    "input": "",
    "output": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Main Setup_Locale\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/ARM.lhs CONTEXT ARM_H ONLY ArmVSpaceRegionUse\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "API Module Collection: Collects and integrates all API modules, ensuring a unified interface for kernel interactions.",
    "input": "",
    "output": "#INCLUDE_HASKELL SEL4.lhs decls_only NOT callKernel\n\n#INCLUDE_HASKELL SEL4.lhs NOT kernelExitAssertions fastpathKernelAssertions\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "No property can be extracted from this code snippet as it appears to be a header or import declaration and does not contain any specific functionality or behavior that can be summarized as a property.",
    "input": "",
    "output": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs CONTEXT Arch decls_only ArchInv=\n\nend\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "IRQ Masks Initialization: All IRQs are masked after kernel initialization.",
    "input": "",
    "output": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "VCPU Invocation Management: Perform and decode VCPU-related functions, including setting the TCB for a VCPU, reading and writing VCPU registers, injecting IRQs, and acknowledging VPPIs. This ensures that VCPUs can be managed and interacted with correctly, maintaining the integrity and performance of the system.\n\nSubproperties:\n- Set TCB for VCPU: Associate a TCB with a VCPU.\n- Read/Write VCPU Registers: Read and write registers of a VCPU.\n- Inject IRQs: Inject interrupts into a VCPU.\n- Acknowledge VPPIs: Acknowledge VPPIs for a VCPU.",
    "input": "",
    "output": "definition\n  perform_vcpu_invocation :: \"vcpu_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"perform_vcpu_invocation iv \\<equiv> case iv of\n     VCPUSetTCB vcpu tcb \\<Rightarrow> do associate_vcpu_tcb vcpu tcb; return [] od\n   | VCPUReadRegister vcpu reg \\<Rightarrow> invoke_vcpu_read_register vcpu reg\n   | VCPUWriteRegister vcpu reg val \\<Rightarrow> do invoke_vcpu_write_register vcpu reg val; return [] od\n   | VCPUInjectIRQ vcpu index vir \\<Rightarrow> do invoke_vcpu_inject_irq vcpu index vir; return [] od\n   | VCPUAckVPPI vcpu vppi \\<Rightarrow> do invoke_vcpu_ack_vppi vcpu vppi; return [] od\"\n\ndefinition decode_vcpu_invocation ::\n  \"machine_word \\<Rightarrow> machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_invocation label args cap extras \\<equiv> case cap of\n  VCPUCap _ \\<Rightarrow> (case invocation_type label of\n      ArchInvocationLabel ARMVCPUSetTCB \\<Rightarrow> decode_vcpu_set_tcb cap extras\n    | ArchInvocationLabel ARMVCPUReadReg \\<Rightarrow> decode_vcpu_read_register args cap\n    | ArchInvocationLabel ARMVCPUWriteReg \\<Rightarrow> decode_vcpu_write_register args cap\n    | ArchInvocationLabel ARMVCPUInjectIRQ \\<Rightarrow> decode_vcpu_inject_irq args cap\n    | ArchInvocationLabel ARMVCPUAckVPPI \\<Rightarrow> decode_vcpu_ack_vppi args cap\n    |  _ \\<Rightarrow> throwError IllegalOperation)\n  | _ \\<Rightarrow> throwError IllegalOperation\"\n\nend\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Architectural Object Classification: Classify architectural kernel objects into distinct types, including Page Directory Entries (PDET), Page Table Entries (PTET), Page Directory Pointer Table Entries (PDPTET), Page Map Level 4 Entries (PML4ET), and ASID Pool Entries (ASIDPoolT).",
    "input": "",
    "output": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/X64.lhs CONTEXT X64_H decls_only\n#INCLUDE_HASKELL SEL4/Object/Structures/X64.lhs CONTEXT X64_H instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/X64.lhs CONTEXT X64_H bodies_only\n\ndatatype arch_kernel_object_type =\n    PDET\n  | PTET\n  | PDPTET\n  | PML4ET\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPDE e) = PDET\"\n| \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOPDPTE e) = PDPTET\"\n| \"archTypeOf (KOPML4E e) = PML4ET\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Memory and Pointer Management: Define the basic operations and types for managing memory and pointers in the system, including the definition of word bits, pointer types (PPtr), and conversion functions (fromPPtr), as well as the representation of a null pointer.",
    "input": "",
    "output": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=X64 CONTEXT X64_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Dissociate VCPU from TCB: Remove the connection between a VCPU and a TCB, ensuring that the VCPU is invalidated if it is currently active, and update the TCB and VCPU states accordingly. \n\nSubproperties:\n- Validate the association between the VCPU and TCB before dissociation.\n- Invalidate the VCPU if it is currently active.\n- Update the TCB state to remove the VCPU reference.\n- Update the VCPU state to remove the TCB reference.\n- Sanitise the SPSR_EL1 register for the TCB.",
    "input": "",
    "output": "definition dissociate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"dissociate_vcpu_tcb vr t \\<equiv> do\n     t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n     v \\<leftarrow> get_vcpu vr;\n     assert (t_vcpu = Some vr \\<and> vcpu_tcb v = Some t); \\<comment> \\<open>make sure they were associated\\<close>\n     cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     when (\\<exists>a. cur_v = Some (vr,a)) vcpu_invalidate_active;\n     arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := None \\<rparr>) t;\n     set_vcpu vr (v\\<lparr> vcpu_tcb := None \\<rparr>);\n     as_user t $ do\n       sr \\<leftarrow> getRegister SPSR_EL1;\n       setRegister SPSR_EL1 $ sanitise_register False SPSR_EL1 sr\n     od\n   od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "IRQ Value Properties: Ensure that IRQ values are correctly represented and converted between different types, such as machine words and IRQ types, while maintaining their original value and respecting the maximum IRQ limit.\n\nSubproperties:\n- IRQ values are less than 2 to the power of irq_len when less than or equal to maxIRQ.\n- IRQ values are preserved when cast between machine word and IRQ types.\n- The maximum IRQ value is correctly represented and converted between signed and unsigned types.\n- Enumerations of IRQ values less than or equal to maxIRQ are correctly converted to their original values.",
    "input": "",
    "output": "lemma le_maxIRQ_machine_less_irqBits_val[simplified]:\n  \"w \\<le> maxIRQ \\<Longrightarrow> unat w < 2^LENGTH(irq_len)\" for w::machine_word\n  using maxIRQ_less_2p_irq_len\n  by (simp add: word_le_nat_alt)\n\nlemma irq_machine_le_maxIRQ_irq:\n  \"irq \\<le> Kernel_Config.maxIRQ \\<Longrightarrow> (ucast irq::irq) \\<le> maxIRQ\" for irq::machine_word\n  by (simp add: Kernel_Config.maxIRQ_def word_le_nat_alt unat_ucast)\n\nlemma maxIRQ_eq_ucast_irq_32_signed_uint:\n  \"(maxIRQ = (ucast b :: 32 signed word)) = (uint b = maxIRQ)\" for b::irq\n  unfolding Kernel_Config.maxIRQ_def\n  apply uint_arith\n  apply (simp add: uint_up_ucast is_up)\n  done\n\nlemma sint_maxIRQ_32[simp]:\n  \"sint (maxIRQ :: 32 signed word) = maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_machine[simp]:\n  \"scast (maxIRQ::32 signed word) = (maxIRQ::machine_word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_irq[simp]:\n  \"scast (maxIRQ :: 32 signed word) = (maxIRQ::irq)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_machine:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = x\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_irq:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = (ucast x :: irq)\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_1_plus_eq_Suc_machine[simp]:\n  \"unat (1 + Kernel_Config.maxIRQ :: machine_word) = Suc Kernel_Config.maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)",
    "system": "",
    "history": []
  },
  {
    "instruction": "Valid Mapping Size: Ensure that the mapping size is valid by checking if the page size corresponding to the given size is less than or equal to the maximum object size in the current state.",
    "input": "",
    "output": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  Untyped_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/X64.lhs CONTEXT X64_H bodies_only ArchInv=ArchRetypeDecls_H NOT checkPML4At checkPDPTAt checkPDAt checkPTAt checkValidMappingSize\n#INCLUDE_HASKELL SEL4/Object/IOPort/X64.lhs CONTEXT X64_H bodies_only ArchInv=ArchRetypeDecls_H\n\ndefs checkValidMappingSize_def:\n  \"checkValidMappingSize sz \\<equiv> stateAssert\n    (\\<lambda>s. 2 ^ pageBitsForSize sz <= gsMaxObjectSize s) []\"\n\nend\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Capability Deletion Actions: Ensure that when a capability is deleted, necessary actions are taken to maintain system integrity, such as canceling IPC, unbinding notifications, and updating kernel data structures. If deletion requires a long-running operation, a Zombie capability is returned, and a possible IRQ is cleared.\n\nSubproperties:\n- Cancel IPC and unbind notifications for Endpoint and Notification capabilities.\n- Update kernel data structures for CNode and Tcb capabilities.\n- Clear possible IRQ for IrqHandler capabilities.\n- Delete AsidPool, PageDirectory, PageTable, and Frame capabilities when finalising.\n- Return Zombie capability if deletion requires a long-running operation.",
    "input": "",
    "output": "fun\n  finalise_cap :: \"cdl_cap \\<Rightarrow> bool \\<Rightarrow> (cdl_cap \\<times> cdl_cap) k_monad\"\nwhere\n  \"finalise_cap NullCap                  final = return (NullCap, NullCap)\"\n| \"finalise_cap RestartCap               final = return (NullCap, NullCap)\"\n| \"finalise_cap (UntypedCap dev r a)           final = return (NullCap, NullCap)\"\n| \"finalise_cap (EndpointCap r b R)      final =\n      (liftM (K (NullCap, NullCap)) $ when  final $ cancel_all_ipc r)\"\n| \"finalise_cap (NotificationCap r b R) final =\n      (liftM (K (NullCap, NullCap)) $ when  final $\n       do\n         unbind_maybe_notification r;\n         cancel_all_ipc r\n       od)\"\n| \"finalise_cap (ReplyCap r R)           final = return (NullCap, NullCap)\"\n| \"finalise_cap (MasterReplyCap r)       final = return (NullCap, NullCap)\"\n| \"finalise_cap (CNodeCap r bits g sz)   final =\n      (return (if final then ZombieCap r else NullCap, NullCap))\"\n| \"finalise_cap (TcbCap r)               final =\n      (do\n         when final $ (do unbind_notification r;\n         cancel_ipc r;\n         KHeap_D.set_cap (r, tcb_pending_op_slot) cdl_cap.NullCap;\n         prepare_thread_delete r od);\n         return (if final then (ZombieCap r) else NullCap, NullCap)\n       od)\"\n| \"finalise_cap (PendingSyncSendCap r _ _ _ _ _) final = return (NullCap, NullCap)\"\n| \"finalise_cap (PendingSyncRecvCap r _ _) final = return (NullCap, NullCap)\"\n| \"finalise_cap (PendingNtfnRecvCap r)  final = return (NullCap, NullCap)\"\n| \"finalise_cap IrqControlCap            final = return (NullCap, NullCap)\"\n| \"finalise_cap (IrqHandlerCap irq)      final = (\n       if final then do\n         deleting_irq_handler irq;\n         return (NullCap, (IrqHandlerCap irq))\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (ZombieCap r)            final =\n      (do assert final; return (ZombieCap r, NullCap) od)\"\n| \"finalise_cap (AsidPoolCap ptr asid)        final = (\n       if final then do\n         delete_asid_pool asid ptr;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap AsidControlCap           final = return (NullCap,NullCap)\"\n| \"finalise_cap (PageDirectoryCap ptr x (Some asid))   final = (\n       if final \\<and> x = Real then do\n         delete_asid asid ptr;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (PageTableCap ptr x (Some asid))     final = (\n       if (final \\<and> x = Real) then do\n         unmap_page_table asid ptr;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (FrameCap dev ptr _ s x (Some asid))       final = (\n       if x = Real then do\n         unmap_page asid ptr s;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap _ final = return (NullCap, NullCap)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Flush Table Mappings: Flush the mappings associated with a page table by iterating over each page table entry and invalidating the translation for the corresponding virtual address and ASID if the entry is valid.",
    "input": "",
    "output": "definition\nflush_table :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_table pml4_ref vptr pt_ref asid \\<equiv> do\n    assert (vptr && mask (ptTranslationBits + pageBits) = 0);\n           pt \\<leftarrow> get_pt pt_ref;\n           forM_x [0 .e. (-1::9 word)] (\\<lambda>index. do\n             pte \\<leftarrow> return $ pt index;\n             case pte of\n               InvalidPTE \\<Rightarrow> return ()\n             | _ \\<Rightarrow> do_machine_op $ invalidateTranslationSingleASID (vptr + (ucast index << pageBits)) (ucast asid)\n           od)\nod\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Thread State Definitions: Provide a comprehensive set of definitions for thread states, encapsulating various states a thread can be in.",
    "input": "",
    "output": "lemmas ThreadState_defs = StrictC'_thread_state_defs",
    "system": "",
    "history": []
  },
  {
    "instruction": "TCB Context: Represent the user context of a thread as a list of 32-bit words for operations such as writing to a thread's registers.",
    "input": "",
    "output": "type_synonym cdl_raw_usercontext = \"word32 list\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Machine Operations: Provides low-level operations for managing user context, registers, and FPU state, as well as hardware-specific operations for ASID invalidation, interrupt handling, and I/O operations.\n\nUser Context Management: Allows getting and setting register values, FPU state, and next PC values, ensuring proper management of user context.\n\nHardware Operations: Supports hardware-specific operations, including ASID invalidation, getting fault addresses, and I/O operations (in8, in16, in32, out8, out16, out32), enabling interaction with the underlying hardware.",
    "input": "",
    "output": "text \\<open> There are 576 bytes of FPU state. Since there are no operations on this state apart from bulk\nsave/restore, we abstract from names and just say how many bytes there are. \\<close>\ntype_synonym fpu_bytes = 576\ntype_synonym fpu_state = \"fpu_bytes \\<Rightarrow> 8 word\"\n\ntype_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (fpu_state : fpu_state) (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition\n  getRegister :: \"register \\<Rightarrow> machine_word user_monad\"\nwhere\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition\n  \"modify_registers f uc \\<equiv> UserContext (fpu_state uc) (f (user_regs uc))\"\n\ndefinition\n  setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\"\nwhere\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext (fpu_state s) ((user_regs s) (r := v)))\"\n\ndefinition\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition\n  \"setNextPC \\<equiv> setRegister NextIP\"\n\n\ndefinition\n  getFPUState :: \"fpu_state user_monad\"\nwhere\n  \"getFPUState \\<equiv> gets fpu_state\"\n\ndefinition\n  setFPUState :: \"fpu_state \\<Rightarrow> unit user_monad\"\nwhere\n  \"setFPUState fc \\<equiv> modify (\\<lambda>s. UserContext fc (user_regs s))\"\n\n\n\ndefinition\n  hwASIDInvalidate :: \"word64 \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"hwASIDInvalidate \\<equiv> invalidateASID\"\n\nconsts'\n  getFaultAddress_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\ngetFaultAddress :: \"word64 machine_monad\"\nwhere\n\"getFaultAddress \\<equiv> gets getFaultAddress_val\"\n\nconsts'\n  irqIntOffset_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\nirqIntOffset :: \"machine_word\"\nwhere\n\"irqIntOffset \\<equiv> 0x20\"\n\ndefinition\nmaxPCIBus :: \"machine_word\"\nwhere\n\"maxPCIBus \\<equiv> 0xFF\"\n\ndefinition\nmaxPCIDev :: \"machine_word\"\nwhere\n\"maxPCIDev \\<equiv> 31\"\n\ndefinition\nmaxPCIFunc :: \"machine_word\"\nwhere\n\"maxPCIFunc \\<equiv> 7\"\n\ndefinition\nioapicIRQLines :: \"machine_word\"\nwhere\n\"ioapicIRQLines \\<equiv> 24\"\n\nconsts'\n  ioapicMapPinToVector_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow>\n    machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  ioapicMapPinToVector :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow>\n    machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"ioapicMapPinToVector ioapic pin level polarity vector \\<equiv>\n    machine_op_lift (ioapicMapPinToVector_impl ioapic pin level polarity vector)\"\n\ndefinition IRQ :: \"word8 \\<Rightarrow> irq\"\nwhere\n  \"IRQ \\<equiv> id\"\n\nconsts'\n  in8_impl :: \"word16 \\<Rightarrow> unit machine_rest_monad\"\n  in8_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  in8 :: \"word16 \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"in8 port \\<equiv> do machine_op_lift $ in8_impl port; gets in8_val od\"\n\nconsts'\n  in16_impl :: \"word16 \\<Rightarrow> unit machine_rest_monad\"\n  in16_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  in16 :: \"word16 \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"in16 port \\<equiv> do machine_op_lift $ in16_impl port; gets in16_val od\"\n\nconsts'\n  in32_impl :: \"word16 \\<Rightarrow> unit machine_rest_monad\"\n  in32_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  in32 :: \"word16 \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"in32 port \\<equiv> do machine_op_lift $ in32_impl port; gets in32_val od\"\n\nconsts'\n  out8_impl :: \"word16 \\<Rightarrow> word8 \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  out8 :: \"word16 \\<Rightarrow> word8 \\<Rightarrow> unit machine_monad\"\nwhere\n  \"out8 port dat \\<equiv> machine_op_lift $ out8_impl port dat\"\n\nconsts'\n  out16_impl :: \"word16 \\<Rightarrow> word16 \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  out16 :: \"word16 \\<Rightarrow> word16 \\<Rightarrow> unit machine_monad\"\nwhere\n  \"out16 port dat \\<equiv> machine_op_lift $ out16_impl port dat\"\n\nconsts'\n  out32_impl :: \"word16 \\<Rightarrow> word32 \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  out32 :: \"word16 \\<Rightarrow> word32 \\<Rightarrow> unit machine_monad\"\nwhere\n  \"out32 port dat \\<equiv> machine_op_lift $ out32_impl port dat\"\n\nend\n\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Entity State Transitions: Define the initial states and transitions of entities in the system, including the creation, granting, taking, copying, revoking, removing, and destroying of capabilities. These transitions govern how entities interact and manage their capabilities, ensuring the integrity and security of the system.\n\nSubproperties:\n- Capability Creation: Define the creation of new capabilities for entities, including the initial capabilities of e0.\n- Capability Grants: Specify the rules for granting capabilities between entities, including the rights and targets involved.\n- Capability Management: Define the operations for taking, copying, revoking, removing, and destroying capabilities, ensuring the correct management of entity capabilities.",
    "input": "",
    "output": "definition\n  e0_caps :: \"cap set\"\nwhere\n  \"e0_caps \\<equiv> range create_cap \\<union> {full_cap 0}\"\n\ndefinition\n  s0  :: \"state\"\nwhere\n  \"s0  \\<equiv> [0 \\<mapsto> Entity e0_caps]\"\n\ndefinition\n  s1  :: \"state\"\nwhere\n  \"s1  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> null_entity]\"\n\ndefinition\n  s2  :: \"state\" where\n  \"s2  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2}]\"\n\ndefinition\n  s3  :: \"state\" where\n  \"s3  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>}]\"\n\ndefinition\n  s4  :: \"state\" where\n  \"s4  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  s5  :: \"state\" where\n  \"s5  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1, write_cap 2}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  s6  :: \"state\" where\n  \"s6  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1, write_cap 2}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2, read_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  s7  :: \"state\" where \"s7  \\<equiv> s4\"\n\ndefinition\n  s8  :: \"state\" where\n  \"s8  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1, full_cap 3}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity,\n          3 \\<mapsto> null_entity]\"\n\ndefinition\n  s9  :: \"state\" where\n  \"s9  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity,\n          3 \\<mapsto> null_entity]\"\n\ndefinition\n  s10 :: \"state\" where \"s10 \\<equiv> s4\"\n\ndefinition\n  s   :: \"state\" where\n  \"s   \\<equiv> [0 \\<mapsto> Entity (e0_caps - {create_cap 1, create_cap 2}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  op0  :: \"sysOPs\" where\n  \"op0  \\<equiv> SysCreate  0 (full_cap 0) (create_cap 1)\"\ndefinition\n  op1  :: \"sysOPs\" where\n  \"op1  \\<equiv> SysGrant   0 (full_cap 1) (create_cap 2) UNIV\"\ndefinition\n  op2  :: \"sysOPs\" where\n  \"op2  \\<equiv> SysGrant   0 (full_cap 1) (full_cap   1) {Write, Store}\"\ndefinition\n  op3  :: \"sysOPs\" where\n  \"op3  \\<equiv> SysCreate  1 \\<lparr>target = 1, rights = {Write, Store}\\<rparr> (create_cap 2)\"\ndefinition\n  op4  :: \"sysOPs\" where\n  \"op4  \\<equiv> SysTake    0 (full_cap 1) (full_cap   2) {Write}\"\ndefinition\n  op5  :: \"sysOPs\" where\n  \"op5  \\<equiv> SysCopy    1 \\<lparr>target = 1, rights = {Write, Store}\\<rparr> (full_cap   2) {Read}\"\ndefinition\n  op6  :: \"sysOPs\" where\n  \"op6  \\<equiv> SysRevoke  0 (write_cap 2)\"\ndefinition\n  op7  :: \"sysOPs\" where\n  \"op7  \\<equiv> SysCreate  0 (full_cap 0) (create_cap 3)\"\ndefinition\n  op8  :: \"sysOPs\" where\n  \"op8  \\<equiv> SysRemove  0 (full_cap 0) (full_cap 3)\"\ndefinition\n  op9  :: \"sysOPs\" where\n  \"op9  \\<equiv> SysDestroy  0 (create_cap 3)\"\ndefinition\n  op10 :: \"sysOPs\" where\n  \"op10 \\<equiv> SysRemoveSet 0 (full_cap 0) {full_cap 1, create_cap 1, create_cap 2}\"\n\ndefinition ops :: \"sysOPs list\" where",
    "system": "",
    "history": []
  },
  {
    "instruction": "SysCreate Operation: The SysCreate operation (op7) creates a new capability with all rights, starting from a null capability, and results in a new state (s8) in addition to the original state (s7). The operation is both safe and live, meaning it only transitions to the specified states and always enables the transition to the new state.",
    "input": "",
    "output": "lemma op7_legal:\n  \"legal op7 s7\"\n  by  (clarsimp simp: s7_def op7_def all_rights_def)\n\nlemma execute_op7_safe:\n  \"step op7 s7 \\<subseteq> ({s7, s8})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s7_def s8_def s4_def op7_def step_def createOperation_def\n             split: if_split_asm)\n  done\n\nlemma execute_op7_live:\n  \"step op7 s7 \\<supseteq> ({s7, s8})\"\n  apply clarsimp\n  apply (simp add: step_def op7_legal)\n  apply (rule disjI2)\n  apply (simp add: op7_def)\n  apply (rule ext)\n  apply (fastforce simp: s7_def s8_def s4_def createOperation_def)\n  done\n\nlemma execute_op7:\n  \"step op7 s7 = ({s7, s8})\"\n  apply rule\n   apply (rule execute_op7_safe)\n  apply (rule execute_op7_live)\n  done",
    "system": "",
    "history": []
  },
  {
    "instruction": "Unmap Page: Unmap a frame from the page table, removing its mappings and deleting associated capabilities. \n\nSubproperties:\n- Find the page directory for the given address space identifier.\n- Get the page mapping entries for the specified page size.\n- Remove the page mappings and delete associated capabilities.",
    "input": "",
    "output": "definition\n \"might_throw \\<equiv> (returnOk ()) \\<sqinter> throw\"\n\ndefinition\n  unmap_page :: \"cdl_mapped_addr  \\<Rightarrow> cdl_object_id \\<Rightarrow> nat \\<Rightarrow> unit k_monad\"\nwhere\n  \"unmap_page maddr frame_id pgsz \\<equiv>\n    doE\n      pd \\<leftarrow> cdl_find_pd_for_asid maddr;\n      pslots \\<leftarrow> cdl_page_mapping_entries (snd maddr) pgsz pd;\n      might_throw;\n      liftE $ mapM_x delete_cap_simple pslots;\n      returnOk ()\n    odE <catch> (K $ return ())\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Requalify Constants: Ensure compatibility with Haskell by requalifying constants cteRightsBits and cteGuardBits under the Arch module.",
    "input": "",
    "output": "requalify_consts\n  cteRightsBits cteGuardBits",
    "system": "",
    "history": []
  },
  {
    "instruction": "Ghost State Management: \nManage the ghost state, which tracks the allocation and deallocation of memory regions, including the creation of new frames and CNodes, and the clearing of regions. It ensures that the ghost state accurately reflects the current state of the system's memory. \n\nSubproperties:\n- Clear Region: Clear a region of memory in the ghost state, ensuring that the region is marked as unallocated.\n- New Frames: Create new frames in the ghost state, tracking the allocation of memory for a given page size and address range.\n- New CNodes: Create new CNodes in the ghost state, tracking the allocation of memory for a given CNode size and address range.\n- Get and Set Assertions: Retrieve and update the values of ghost assertions, which are used to track additional information about the system's state.",
    "input": "",
    "output": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> word32\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> word32 \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Machine State Management: Manage the state of the AARCH64 machine, including accessing and modifying register sets, creating new user contexts, and handling FPU state. \n\n Register Set Management: Access and modify the AARCH64 register set, including getting and setting register values.\n\n User Context Management: Create new user contexts for the AARCH64 machine.\n\n FPU State Management: Create new FPU states for the AARCH64 machine.",
    "input": "",
    "output": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/AARCH64.hs CONTEXT AARCH64 decls_only NOT UserContext UserMonad Word getRegister setRegister newContext FPUState newFPUState\n\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64 ONLY VPPIEventIRQ VirtTimer",
    "system": "",
    "history": []
  },
  {
    "instruction": "Nondeterministic Selection: Select a value from a bounding set, either by using the extended state when a switch is enabled or by choosing nondeterministically from the set when the switch is disabled, ensuring the selected value is within the set.",
    "input": "",
    "output": "definition select_ext :: \"(det_ext state \\<Rightarrow> 'd) \\<Rightarrow> ('d set) \\<Rightarrow> ('a::state_ext state,'d) nondet_monad\" where\n  \"select_ext a S \\<equiv> do\n                      s \\<leftarrow> get;\n                      x \\<leftarrow> if (select_switch (exst s)) then (return (a (unwrap_ext s)))\n                          else (select S);\n                      assert (x \\<in> S);\n                      return x\n                    od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "SysTake Operation: The SysTake operation, denoted as op4, is a system call that takes a capability with all rights, except for the Write right, from one capability (full_cap 1) and transfers it to another capability (full_cap 2). \n\nOperation Safety and Liveness: The execution of op4 is both safe and live, meaning that it only transitions between two specific states (s4 and s5) and that it can reach these states.",
    "input": "",
    "output": "lemma op4_legal:\n  \"legal op4 s4\"\n  by  (clarsimp simp: op4_def all_rights_def)\n\nlemma execute_op4_safe:\n  \"step op4 s4 \\<subseteq> ({s4, s5})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s4_def s5_def op4_def step_def takeOperation_def\n                    diminish_def all_rights_def write_cap_def\n             split: if_split_asm)\n  done\n\nlemma execute_op4_live:\n  \"step op4 s4 \\<supseteq> ({s4, s5})\"\n  apply clarsimp\n  apply (simp add: op4_legal step_def)\n  apply (rule disjI2)\n  apply (simp add: op4_def)\n  apply (rule ext)\n  apply (fastforce simp: s4_def s5_def takeOperation_def diminish_def all_rights_def write_cap_def)\n  done\n\nlemma execute_op4:\n  \"step op4 s4 = ({s4, s5})\"\n  apply rule\n   apply (rule execute_op4_safe)\n  apply (rule execute_op4_live)\n  done",
    "system": "",
    "history": []
  },
  {
    "instruction": "IRQ Handler Invocation: Configure interrupt delivery and acknowledge delivered interrupts by loading or clearing Notification capabilities in per-IRQ slots.\n\nSubproperties:\n- Acknowledge delivered interrupts.\n- Set Notification capabilities to configure interrupt delivery.\n- Clear Notification capabilities to disable interrupt delivery.",
    "input": "",
    "output": "fun\n  invoke_irq_handler :: \"irq_handler_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"invoke_irq_handler (ACKIrq irq) = arch_invoke_irq_handler (ACKIrq irq)\"\n| \"invoke_irq_handler (SetIRQHandler irq cap slot) = (do\n     irq_slot \\<leftarrow> get_irq_slot irq;\n     cap_delete_one irq_slot;\n     cap_insert cap slot irq_slot\n   od)\"\n| \"invoke_irq_handler (ClearIRQHandler irq) = (do\n     irq_slot \\<leftarrow> get_irq_slot irq;\n     cap_delete_one irq_slot\n   od)\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "User Register Management: Provides operations to access and modify user registers, including getting the value of a specific register, modifying multiple registers, setting the value of a register, and getting and setting the restart and next program counter values.",
    "input": "",
    "output": "type_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\" where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\" where\n  \"modify_registers f uc \\<equiv> UserContext (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\" where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext ((user_regs s) (r := v)))\"\n\ndefinition\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition\n  \"setNextPC \\<equiv> setRegister NextIP\"\n\nend\n\ntranslations\n  (type) \"'a ARM_HYP.user_monad\" <= (type) \"(ARM_HYP.register \\<Rightarrow> machine_word, 'a) nondet_monad\"\n\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Clear IRQ Handler Intent: Clear the intent to handle an IRQ for a target.",
    "input": "",
    "output": "|  IrqHandlerClearIntent\n\ndatatype cdl_arch_irq_control_intent =",
    "system": "",
    "history": []
  },
  {
    "instruction": "Update Capability Derivation Tree: Modify the capability derivation tree by applying a given transformation function to the current tree, ensuring that the updated tree is correctly stored in the system state.",
    "input": "",
    "output": "definition\n  update_cdt :: \"(cdt \\<Rightarrow> cdt) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"update_cdt f \\<equiv> do\n     t \\<leftarrow> gets cdt;\n     set_cdt (f t)\n  od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Acknowledge Interrupt: Allow a thread to acknowledge an interrupt, indicating that it has begun processing the interrupt request.",
    "input": "",
    "output": "IrqHandlerAckIntent",
    "system": "",
    "history": []
  },
  {
    "instruction": "No property can be summarized as there is no code provided.",
    "input": "",
    "output": "end",
    "system": "",
    "history": []
  },
  {
    "instruction": "Thread State Definitions Collection: Provide an alias for a collection of thread state definitions for easier reference and usage.",
    "input": "",
    "output": "lemmas ThreadState_defs = StrictC'_thread_state_defs",
    "system": "",
    "history": []
  },
  {
    "instruction": "ARM-Specific Capability Types: The ARM kernel supports various capability types, including ASID pools, ASID controllers, page directories, page tables, page mappings, and VCPU capabilities, each with its own specific structure and properties. \n\nCapability Type Identification: Identify whether a given capability is a page capability or not.",
    "input": "",
    "output": "text \\<open>The ARM kernel supports capabilities for ASID pools and an ASID controller capability,\nalong with capabilities for page directories, page tables, and page mappings.\\<close>\n\ndatatype arch_cap =\n   ASIDPoolCap obj_ref asid\n | ASIDControlCap\n | PageCap bool obj_ref cap_rights vmpage_size \"(asid * vspace_ref) option\"\n | PageTableCap obj_ref \"(asid * vspace_ref) option\"\n | PageDirectoryCap obj_ref \"asid option\"\n | VCPUCap obj_ref\n\nlemmas arch_cap_cases =\n  arch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P, simplified, rule_format]\n\nlemmas arch_cap_cases_asm =\narch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n  simplified, rule_format, rotated -1]\n\ndefinition\n  is_page_cap :: \"arch_cap \\<Rightarrow> bool\" where\n  \"is_page_cap c \\<equiv> \\<exists>x0 x1 x2 x3 x4. c = PageCap x0 x1 x2 x3 x4\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "VCPU Enable: Turn on VCPU mode at the hardware level by restoring specific registers, setting hardware control registers, and restoring the virtual timer.",
    "input": "",
    "output": "definition vcpu_enable :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_enable vr \\<equiv> do\n     vcpu_restore_reg vr VCPURegSCTLR;\n     vcpu \\<leftarrow> get_vcpu vr;\n     do_machine_op $ do\n        setHCR hcrVCPU;\n        isb;\n        set_gic_vcpu_ctrl_hcr (vgic_hcr $ vcpu_vgic vcpu)\n     od;\n     vcpu_restore_reg vr VCPURegCPACR; \\<comment> \\<open>FPU\\<close>\n     restore_virt_timer vr\n   od\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Initialization of Kernel State: The kernel's initial state is defined, including the memory layout, page directory, and page tables. The kernel's base address, global page directory, and global page tables are set up. The initial kernel heap, capability derivation tree, and I/O controller are also defined.\n\nSubproperties:\n\n* Memory Layout: The kernel's memory layout is defined, including the base address, global page directory, and global page tables.\n* Kernel Heap Initialization: The initial kernel heap is defined, including the idle thread, global frame, and global page directory.\n* Capability Derivation Tree Initialization: The initial capability derivation tree is defined as an empty map.\n* I/O Controller Initialization: The initial I/O controller is defined, which checks if an object exists in the kernel heap and has a non-null capability.",
    "input": "",
    "output": "definition\n  init_globals_frame :: word32 where\n  \"init_globals_frame = kernel_base + 0x5000\"\n\ndefinition\n  init_global_pd :: word32 where\n  \"init_global_pd = kernel_base + 0x60000\"\n\ndefinition\n  \"init_arch_state \\<equiv> \\<lparr>\n    arm_asid_table = Map.empty,\n    arm_hwasid_table = Map.empty,\n    arm_next_asid = 0,\n    arm_asid_map = Map.empty,\n    arm_global_pd = init_global_pd,\n    arm_global_pts = [],\n    arm_kernel_vspace = \\<lambda>ref.\n      if ref \\<in> {kernel_base .. kernel_base + mask 20}\n      then ArmVSpaceKernelWindow\n      else ArmVSpaceInvalidRegion\n  \\<rparr>\"\n\ndefinition\n  [simp]:\n  \"global_pd \\<equiv> (\\<lambda>_. InvalidPDE)( ucast (kernel_base >> 20) := SectionPDE (addrFromPPtr kernel_base) {} 0 {})\"\n\ndefinition\n  \"init_kheap \\<equiv>\n  (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n       then Some (CNode 0 (empty_cnode 0)) else None)\n  (idle_thread_ptr \\<mapsto> TCB \\<lparr>\n    tcb_ctable = NullCap,\n    tcb_vtable = NullCap,\n    tcb_reply = NullCap,\n    tcb_caller = NullCap,\n    tcb_ipcframe = NullCap,\n    tcb_state = IdleThreadState,\n    tcb_fault_handler = replicate word_bits False,\n    tcb_ipc_buffer = 0,\n    tcb_fault = None,\n    tcb_bound_notification = None,\n    tcb_mcpriority = minBound,\n    tcb_arch = init_arch_tcb\n  \\<rparr>,\n  init_globals_frame \\<mapsto> ArchObj (DataPage False ARMSmallPage), \\<comment> \\<open>same reason as why we kept the definition of @{term init_globals_frame}\\<close>\n  init_global_pd \\<mapsto> ArchObj (PageDirectory global_pd)\n  )\"\n\ndefinition\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. Structures_A.IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\n\n\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "Interrupt Object Operations: Provide operations for managing interrupt objects, including handling and manipulating interrupt requests (IRQs).",
    "input": "",
    "output": "(*\n * Operations on interrupt objects.\n *)\n\ntheory Interrupt_D\nimports Endpoint_D \"ExecSpec.Platform\"\nbegin\n\ncontext begin interpretation Arch .\nrequalify_types\n  irq\nend",
    "system": "",
    "history": []
  },
  {
    "instruction": "VCPU Invocation Decoding: Validate and decode the VCPU set TCB invocation, ensuring that the provided capability and extra arguments match the expected format for setting a TCB for a VCPU.",
    "input": "",
    "output": "definition decode_vcpu_set_tcb :: \"arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere \"decode_vcpu_set_tcb cap extras \\<equiv> case (cap, extras) of\n  (VCPUCap v, fs#_) \\<Rightarrow> (case fs of\n        (ThreadCap t, _) \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUSetTCB v t\n      | _ \\<Rightarrow> throwError IllegalOperation)\n |(VCPUCap v, _) \\<Rightarrow> throwError TruncatedMessage\n | _ \\<Rightarrow> throwError IllegalOperation\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "ARM Architecture State: Maintains architecture-specific state, including the ASID table, hardware ASID to seL4 ASID mapping, next hardware ASID, inverse mapping from seL4 ASIDs to hardware ASIDs, and shared address space mappings.",
    "input": "",
    "output": "text \\<open>The architecture-specific state for the ARM model\nconsists of the first level of the ASID table (@{text \"arm_asid_table\"}), a\nmap from hardware ASIDs to seL4 ASIDs (@{text \"arm_hwasid_table\"}),\nthe next hardware ASID to preempt (@{text \"arm_next_asid\"}), the\ninverse map from seL4 ASIDs to hardware ASIDs (first component of\n@{text \"arm_asid_map\"}), and the address of the page directory and\npage tables mapping the shared address space, along with a description\nof this space (@{text \"arm_global_pd\"}, @{text \"arm_global_pts\"}, and\n@{text \"arm_kernel_vspace\"} respectively).\n\nHardware ASIDs are only ever associated with seL4 ASIDs that have a\ncurrently active page directory. The second component of\n@{text \"arm_asid_map\"} values is the address of that page directory.\n\\<close>\n\nend\n\nqualify ARM_HYP_A (in Arch)",
    "system": "",
    "history": []
  },
  {
    "instruction": "Set Interrupt Mode: Does nothing, leaving interrupt settings unchanged.",
    "input": "",
    "output": "definition\n  setInterruptMode :: \"irq \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setInterruptMode \\<equiv> \\<lambda>irq levelTrigger polarityLow. return ()\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Capability Mapping: Maps capability identifiers to their corresponding capabilities, allowing for efficient lookup and management of capabilities within the system.",
    "input": "",
    "output": "type_synonym cdl_cap_map = \"cdl_cnode_index \\<Rightarrow> cdl_cap option\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Kernel Device Mapping Region: The virtual address for the start of the kernel device mapping region is located in the highest 1GiB of memory.",
    "input": "",
    "output": "definition kdev_base :: \"machine_word\"\n  where\n  \"kdev_base = Platform.RISCV64.kdevBase\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Machine State Initialization: The machine state is initialized with default values for IRQ masks, IRQ state, underlying memory, device state, and exclusive state, while leaving the rest of the machine state underspecified. \n\nSubproperties:\n- IRQ Masks Initialization: IRQ masks are initialized to their default values.\n- IRQ State Initialization: The IRQ state is initialized to 0.\n- Underlying Memory Initialization: The underlying memory is initialized to its default state.\n- Device State Initialization: The device state is initialized as an empty map.\n- Exclusive State Initialization: The exclusive state is initialized to its default value.",
    "input": "",
    "output": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         exclusive_state = default_exclusive_state,\n                         machine_state_rest = undefined \\<rparr>\"",
    "system": "",
    "history": []
  },
  {
    "instruction": "Runnable Threads Collection: Collect the set of runnable threads in the system, including threads with RunningCap or RestartCap in their pending operation slot. \nRunnable Threads in Domain: Collect the set of runnable threads within a specific domain, including threads with RunningCap or RestartCap in their pending operation slot and matching the specified domain.",
    "input": "",
    "output": "definition\n  all_active_tcbs :: \"cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"all_active_tcbs state \\<equiv> {x \\<in> dom (cdl_objects state).\n      \\<exists> a. (cdl_objects state) x = Some (Tcb a)\n          \\<and> ( ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RunningCap) \\<or> ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RestartCap))}\"\n\ndefinition\n  active_tcbs_in_domain :: \"word8 \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"active_tcbs_in_domain domain state  = {x \\<in> dom (cdl_objects state).\n      \\<exists> a. (cdl_objects state) x = Some (Tcb a)\n          \\<and> ( ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RunningCap) \\<or> ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RestartCap))\n          \\<and> cdl_tcb_domain a = domain }\"",
    "system": "",
    "history": []
  }
]
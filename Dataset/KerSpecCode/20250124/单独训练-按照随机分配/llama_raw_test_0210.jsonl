{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM bodies_only NOT getRegister setRegister newContext", "property": "ARM Machine State Management: Manage the state of the ARM machine, including the register set, to ensure correct execution and interaction with the kernel.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "definition\n  remove_rights :: \"cap_rights \\<Rightarrow> cap \\<Rightarrow> cap\"\nwhere\n \"remove_rights rights cap \\<equiv> cap_rights_update (cap_rights cap - rights) cap\"", "property": "Capability Rights Removal: Remove specified rights from a capability, ensuring that the resulting capability has reduced privileges.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": ""}
{"spec": "Signal cdl_badge cdl_object_id\n\ndatatype cdl_reply_invocation =\n    ReplyMessage cdl_object_id cdl_cap_ref bool (* can grant *)\n\ndatatype cdl_page_table_invocation =", "property": "Signal Notification: Send a signal to a notification object with a specific badge. \n\nNo subproperties are necessary for this simple property.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": " badge (notification word) and notification object "}
{"spec": "hide_const\n  vmpage_size.X64SmallPage\n  vmpage_size.X64LargePage\n  vmpage_size.X64HugePage", "property": "Hide Virtual Memory Page Sizes: Conceal the definitions of virtual memory page sizes (X64SmallPage, X64LargePage, X64HugePage) to prevent direct access.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "definition\n  nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\" where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len)\n                           (to_bl (of_nat n :: machine_word))\"\n\ndefinition\n \"msg_info_register \\<equiv> msgInfoRegister\"\ndefinition\n \"msg_registers \\<equiv> msgRegisters\"\ndefinition\n \"cap_register \\<equiv> capRegister\"\ndefinition\n \"badge_register \\<equiv> badgeRegister\"\ndefinition\n \"frame_registers \\<equiv> frameRegisters\"\ndefinition\n \"gp_registers \\<equiv> gpRegisters\"\ndefinition\n \"exception_message \\<equiv> exceptionMessage\"\ndefinition\n \"syscall_message \\<equiv> syscallMessage\"\n\n\ndatatype arch_fault =\n    VMFault vspace_ref \"machine_word list\"\n  | VGICMaintenance \"data option\" (* idx *)\n  | VCPUFault data (* hsr *)\n  | VPPIEvent irq (* vppi IRQ *)\n\n\nend\n\nend", "property": "Constant Definitions: Define various constants used in modelling machine operations, including register names, message types, and fault types for architecture-specific errors. \n\nSubproperties:\n- Register Names: Specify the names of registers used in message handling, capability management, and other operations.\n- Message Types: Define the types of messages used in the system, including exception and syscall messages.\n- Fault Types: Enumerate the types of faults that can occur in the architecture, including virtual memory faults, VGIC maintenance, VCPU faults, and VPPI events.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "Miscellaneous definitions of constants used in modelling machine\noperations."}
{"spec": "lemma ucast_maxIRQ[simp]:\n  \"\\<lbrakk> LENGTH(irq_len) \\<le> LENGTH('a::len); LENGTH(irq_len) \\<le> LENGTH('b::len) \\<rbrakk> \\<Longrightarrow>\n   UCAST ('a \\<rightarrow> 'b) maxIRQ = maxIRQ\"\n  by (metis of_nat_maxIRQ ucast_nat_def unat_maxIRQ)", "property": "UCast MaxIRQ Equality: The unsigned cast of maxIRQ from type 'a to type 'b is equal to maxIRQ, given that the length of irq_len is less than or equal to the lengths of both 'a and 'b.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "class state_ext =\n fixes unwrap_ext :: \"'a state \\<Rightarrow> det_ext state\"\n fixes wrap_ext :: \"(det_ext \\<Rightarrow> det_ext) \\<Rightarrow> ('a \\<Rightarrow> 'a)\"\n fixes wrap_ext_op :: \"unit det_ext_monad \\<Rightarrow> ('a state,unit) nondet_monad\"\n fixes wrap_ext_bool :: \"bool det_ext_monad \\<Rightarrow> ('a state,bool) nondet_monad\"\n fixes select_switch :: \"'a \\<Rightarrow> bool\"\n fixes ext_init :: \"'a\"\n\ndefinition detype_ext :: \"obj_ref set \\<Rightarrow> 'z::state_ext \\<Rightarrow> 'z\" where\n \"detype_ext S \\<equiv> wrap_ext (\\<lambda>s. s\\<lparr>ekheap_internal := (\\<lambda>x. if x \\<in> S then None else ekheap_internal s x)\\<rparr>)\"\n\ninstantiation  det_ext_ext :: (type) state_ext\nbegin\n\ndefinition \"unwrap_ext_det_ext_ext == (\\<lambda>x. x) :: det_ext state \\<Rightarrow> det_ext state\"\n\ndefinition \"wrap_ext_det_ext_ext == (\\<lambda>x. x) ::\n  (det_ext \\<Rightarrow> det_ext) \\<Rightarrow> det_ext \\<Rightarrow> det_ext\"\n\ndefinition \"wrap_ext_op_det_ext_ext == (\\<lambda>x. x) ::\n  (det_ext state \\<Rightarrow> ((unit \\<times> det_ext state) set) \\<times> bool)\n  \\<Rightarrow> det_ext state  \\<Rightarrow> ((unit \\<times> det_ext state) set) \\<times> bool\"\n\ndefinition \"wrap_ext_bool_det_ext_ext == (\\<lambda>x. x) ::\n  (det_ext state \\<Rightarrow> ((bool \\<times> det_ext state) set) \\<times> bool)\n  \\<Rightarrow> det_ext state \\<Rightarrow> ((bool \\<times> det_ext state) set) \\<times> bool\"\n\ndefinition \"select_switch_det_ext_ext == (\\<lambda>_. True)  :: det_ext\\<Rightarrow> bool\"", "property": "State Extension Abstraction: Provides an abstract interface for state extensions, allowing for different instantiations such as deterministic and nondeterministic abstract specifications. It defines a set of functions for wrapping and unwrapping state extensions, handling nondeterministic operations, and selecting switches.\n\nDetype Extension: Detype a set of objects in the state extension, effectively removing their type information.\n\nDeterministic Extension Instantiation: Provides a concrete instantiation of the state extension abstraction for deterministic extensions, where the wrapping and unwrapping functions are identity functions, and the select switch is always true.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  A type class for all instantiations of the abstract specification. In\n  practice, this is restricted to basically allow only two sensible\n  implementations at present: the deterministic abstract specification and\n  the nondeterministic one.\n"}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_HYP_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_HYP_H bodies_only\n\n\nend\nend", "property": "No properties can be extracted from the given code as it appears to be a header or import section, and does not contain any specific functionality or logic that can be summarized as a property.", "title": "./spec/design/skel/ARM_HYP/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition irqInvalid :: \"irq\"\n  where\n  \"irqInvalid \\<equiv> 0\"\n\ndefinition pageColourBits :: nat\n  where\n  \"pageColourBits \\<equiv> undefined\" \\<comment> \\<open>not implemented on this platform\\<close>\n\nend\nend", "property": "Platform Constants: Define fundamental platform-specific constants, including the invalid IRQ value and page color bits, to establish a common understanding of the platform's configuration and behavior. \n\nInvalid IRQ Representation: Reserve a specific IRQ value to indicate an invalid or non-existent IRQ, ensuring proper handling and distinction from valid IRQs.\n\nPage Color Bits Configuration: Specify the number of bits used to represent page colors, which is currently undefined for this platform, indicating a platform-specific detail that requires implementation.", "title": "./spec/machine/RISCV64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": " Reserved by C to represent \"not an IRQ\" "}
{"spec": "primrec\n  execute :: \"sysOPs list \\<Rightarrow> state \\<Rightarrow> state set\"\nwhere\n  \"execute [] s = {s}\"\n| \"execute (cmd#cmds) s = \\<Union> (step cmd ` ( execute cmds s ))\"", "property": "Command Execution: Execute a list of system operations in reverse order, with each operation potentially producing multiple next states, resulting in a set of possible final states. \n\nSubproperties: \n- Empty Command List: An empty list of commands results in no state change.\n- Recursive Execution: Each command is executed on the set of states produced by the previous commands, with the results combined to form the final set of states.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " execution of a list of commands (from back of list)\n "}
{"spec": "locale Arch\n\nend", "property": "Architecture Namespace Management: Provides a locale for namespacing architecture-specific definitions, allowing for organization and separation of architecture-specific entities from generic proofs.", "title": "./spec/machine/Setup_Locale.thy", "chapter": "", "section": "", "comment": "\n   We use a locale for namespacing architecture-specific definitions.\n\n   The global_naming command changes the underlying naming of the locale. The intention is that\n   we liberally put everything into the \"ARM\" namespace, and then carefully unqualify (put into global namespace)\n   or requalify (change qualifier to \"Arch\" instead of \"ARM\") in order to refer to entities in\n   generic proofs.\n\n"}
{"spec": "definition\n  receive_ipc :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"receive_ipc thread ep_id can_grant \\<equiv> corrupt_tcb_intent thread \\<sqinter> receive_sync thread ep_id can_grant\"\n\ndefinition\n  invoke_endpoint :: \"bool \\<Rightarrow> bool \\<Rightarrow> cdl_endpoint_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_endpoint is_call can_block params \\<equiv> case params of\n    SyncMessage badge can_grant can_grant_reply ep_id \\<Rightarrow> do\n      thread \\<leftarrow> gets_the cdl_current_thread;\n      send_ipc can_block is_call badge can_grant can_grant_reply thread ep_id\n    od\"\n\ndefinition\n  invoke_notification :: \"cdl_notification_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_notification params \\<equiv> case params of\n    Signal badge ep_id \\<Rightarrow>\n      send_signal ep_id\"\n\ndefinition\n  invoke_reply :: \"cdl_reply_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_reply params \\<equiv> case params of\n    ReplyMessage recv reply_cap_ref rights \\<Rightarrow> do\n      send \\<leftarrow> gets_the cdl_current_thread;\n      do_reply_transfer send recv reply_cap_ref rights\n    od\"", "property": "IPC Invocation: Handle various types of IPC (Inter-Process Communication) invocations, including endpoint invocations, notification invocations, and reply invocations. These invocations allow for synchronous and asynchronous communication between threads, facilitating data transfer and capability exchange.\n\nEndpoint Invocation: Handle endpoint invocations, which involve sending IPC messages to endpoints, potentially blocking the current thread and granting capabilities.\n\nNotification Invocation: Handle notification invocations, which involve sending signals to notifications.\n\nReply Invocation: Handle reply invocations, which involve transferring data and capabilities between threads in response to a previous IPC message.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " This is more nonderministic than is really required, but\n   it makes the refinement proofs much easier "}
{"spec": "definition associate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"associate_vcpu_tcb vr t \\<equiv> do\n    t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n    case t_vcpu of Some p \\<Rightarrow> dissociate_vcpu_tcb p t\n                 | _ \\<Rightarrow> return ();\n    v \\<leftarrow> get_vcpu vr;\n    case vcpu_tcb v of Some p \\<Rightarrow> dissociate_vcpu_tcb vr p\n                     | _ \\<Rightarrow> return ();\n    arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := Some vr \\<rparr>) t;\n    set_vcpu vr (v\\<lparr> vcpu_tcb := Some t \\<rparr>);\n    ct \\<leftarrow> gets cur_thread;\n    when (t = ct) $ vcpu_switch (Some vr)\n  od\"", "property": "TCB-VCPU Association: Associate a TCB with a VCPU, removing any existing associations between the TCB and another VCPU or the VCPU and another TCB, and update the TCB and VCPU data structures accordingly. If the TCB being updated is the current thread, switch to the newly associated VCPU.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associating a TCB and VCPU, removing any potentially existing associations:"}
{"spec": "consts'\n  writeContextIDAndPD_impl :: \"hardware_asid \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  writeContextIDAndPD :: \"hardware_asid \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere \"writeContextIDAndPD a b \\<equiv> machine_op_lift (writeContextIDAndPD_impl a b)\"\n\nconsts'\n  HSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  HDFAR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  SCTLR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  ACTLR_val :: \"machine_state \\<Rightarrow> machine_word\"\n\ndefinition\n  getHSR :: \"machine_word machine_monad\"\nwhere \"getHSR \\<equiv> gets HSR_val\"\n\ndefinition\n  getHDFAR :: \"machine_word machine_monad\"\nwhere \"getHDFAR \\<equiv> gets HDFAR_val\"\n\nconsts'\n  setHCR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setHCR :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setHCR w \\<equiv> machine_op_lift (setHCR_impl w)\"\n\nconsts'\n  addressTranslateS1_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\n  addressTranslateS1_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition\n  addressTranslateS1 :: \"machine_word \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"addressTranslateS1 w \\<equiv> do\n    machine_op_lift (addressTranslateS1_impl w);\n    gets (addressTranslateS1_val w)\n  od\"\n\ndefinition\n  getSCTLR :: \"machine_word machine_monad\"\nwhere \"getSCTLR \\<equiv> gets SCTLR_val\"\n\nconsts'\n  setSCTLR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setSCTLR :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setSCTLR w \\<equiv> machine_op_lift (setSCTLR_impl w)\"\n\ndefinition\n  vgic_irq_active :: \"machine_word\"\nwhere\n  \"vgic_irq_active \\<equiv> 2 << 28\"\n\ndefinition\n  vgic_irq_mask :: \"machine_word\"\nwhere\n  \"vgic_irq_mask \\<equiv> 3 << 28\"\n\nconsts'\n  gic_vcpu_ctrl_hcr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_hcr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_hcr \\<equiv> gets gic_vcpu_ctrl_hcr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_hcr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_hcr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_hcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_hcr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_vmcr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_vmcr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_vmcr \\<equiv> gets gic_vcpu_ctrl_vmcr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_vmcr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_vmcr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_vmcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vmcr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_apr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_apr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_apr \\<equiv> gets gic_vcpu_ctrl_apr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_apr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_apr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_apr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_apr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_vtr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_vtr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_vtr \\<equiv> gets gic_vcpu_ctrl_vtr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_vtr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_vtr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_vtr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vtr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_misr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_misr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_misr \\<equiv> gets gic_vcpu_ctrl_misr_val\"\n\nconsts'\n  gic_vcpu_ctrl_eisr0_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_eisr0 :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_eisr0 \\<equiv> gets gic_vcpu_ctrl_eisr0_val\"\n\nconsts'\n  gic_vcpu_ctrl_eisr1_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_eisr1 :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_eisr1 \\<equiv> gets gic_vcpu_ctrl_eisr1_val\"\n\nconsts'\n  get_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\n  gic_vcpu_ctrl_lr_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_lr n \\<equiv> do\n      machine_op_lift (get_gic_vcpu_ctrl_lr_impl n);\n      gets (gic_vcpu_ctrl_lr_val n)\n    od\"\n\nconsts'\n  set_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_lr n w  \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_lr_impl n w)\"", "property": "Machine Operations: Provide low-level machine operations for managing hardware resources, including writing context IDs and page directories, getting and setting system registers (HSR, HDFAR, SCTLR, etc.), performing address translations, and controlling GIC (Generic Interrupt Controller) vCPU settings. These operations ensure that the kernel can interact with the hardware efficiently and securely.\n\nSubproperties:\n\n* System Register Management: Get and set system registers, such as HSR, HDFAR, SCTLR, and ACTLR.\n* Address Translation: Perform address translations using the addressTranslateS1 operation.\n* GIC vCPU Control: Get and set GIC vCPU control registers, including HCR, VMCR, APR, VTR, MISR, EISRs, and LRs.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "Thread State Definitions Collection: Provide an alias for the collection of thread state definitions for easier reference and usability.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "text \\<open>The CNode capability confers authority to various methods\nwhich act on CNodes and the capabilities within them. Copies of\ncapabilities may be inserted in empty CNode slots by\nInsert. Capabilities may be moved to empty slots with Move or swapped\nwith others in a three way rotate by Rotate. A Reply capability stored\nin a thread's last-caller slot may be saved into a regular CNode slot\nwith Save.  The Revoke, Delete and Recycle methods may also be\ninvoked on the capabilities stored in the CNode.\\<close>\n\ndefinition\n  invoke_cnode :: \"cnode_invocation \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"invoke_cnode i \\<equiv> case i of\n    RevokeCall dest_slot \\<Rightarrow> cap_revoke dest_slot\n  | DeleteCall dest_slot \\<Rightarrow> cap_delete dest_slot\n  | InsertCall cap src_slot dest_slot \\<Rightarrow>\n       without_preemption $ cap_insert cap src_slot dest_slot\n  | MoveCall cap src_slot dest_slot \\<Rightarrow>\n       without_preemption $ cap_move cap src_slot dest_slot\n  | RotateCall cap1 cap2 slot1 slot2 slot3 \\<Rightarrow>\n       without_preemption $\n       if slot1 = slot3 then\n         cap_swap cap1 slot1 cap2 slot2\n       else\n         do cap_move cap2 slot2 slot3; cap_move cap1 slot1 slot2 od\n  | SaveCall slot \\<Rightarrow> without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    src_slot \\<leftarrow> return (thread, tcb_cnode_index 3);\n    cap \\<leftarrow> get_cap src_slot;\n    (case cap of\n          NullCap \\<Rightarrow> return ()\n        | ReplyCap _ False _ \\<Rightarrow> cap_move cap src_slot slot\n        | _ \\<Rightarrow> fail) od\n  | CancelBadgedSendsCall (EndpointCap ep b R) \\<Rightarrow>\n    without_preemption $ when (b \\<noteq> 0) $ cancel_badged_sends ep b\n  | CancelBadgedSendsCall _ \\<Rightarrow> fail\"", "property": "CNode Invocation Actions: Authorize various operations on CNodes and their capabilities, including inserting, moving, swapping, saving, revoking, deleting, and recycling capabilities, as well as cancelling badged sends, while ensuring the integrity and consistency of the capability space.\n\nSubproperties:\n- Insert and Move: Insert copies of capabilities into empty CNode slots or move them to empty slots.\n- Rotate: Swap capabilities in a three-way rotate.\n- Save: Save a Reply capability from a thread's last-caller slot into a regular CNode slot.\n- Revoke, Delete, and Recycle: Revoke, delete, or recycle capabilities stored in the CNode.\n- Cancel Badged Sends: Cancel badged sends for a specific endpoint.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Invoking CNode capabilities", "comment": ""}
{"spec": "definition\n  tcb_update_thread_slot :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cnode_index \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_thread_slot target_tcb tcb_cap_slot target_slot pcap \\<equiv>\n         liftE (do\n           thread_cap \\<leftarrow> get_cap tcb_cap_slot;\n           when (thread_cap = TcbCap target_tcb)\n           (insert_cap_child (fst pcap) (snd pcap) (target_tcb, target_slot)\n            \\<sqinter> insert_cap_sibling (fst pcap) (snd pcap) (target_tcb,target_slot))\n         od)\"", "property": "TCB Slot Update: Update a slot of a TCB with a new capability, deleting the previous capability in the slot, ensuring the TCB's capability is updated correctly.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update the given slot of a TCB with a new cap, delete the previous\n * capability that was in the slot. "}
{"spec": "lemma throwError_bindE[simp]:\n  \"(throwError E >>=E f) = throwError E\"\n  by (simp add: bindE_def bind_def throwError_def lift_def return_def)", "property": "Exception Propagation: Throwing an exception skips subsequent execution, propagating the exception through the monad. \n\nException Handling: Bind operation with an error is equivalent to throwing that error.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Execution after throwing an exception is skipped:"}
{"spec": "primrec\n  step' :: \"sysOPs \\<Rightarrow> modify_state_n\"\nwhere\n  \"step' (SysCreate    e c\\<^sub>1 c\\<^sub>2) s   = {createOperation e c\\<^sub>1 c\\<^sub>2 s}\"\n| \"step' (SysTake      e c\\<^sub>1 c\\<^sub>2 R) s = {takeOperation  e c\\<^sub>1 c\\<^sub>2 R s}\"\n| \"step' (SysGrant     e c\\<^sub>1 c\\<^sub>2 R) s = {grantOperation  e c\\<^sub>1 c\\<^sub>2 R s}\"\n| \"step' (SysCopy      e c\\<^sub>1 c\\<^sub>2 R) s = {copyOperation e c\\<^sub>1 c\\<^sub>2 R s}\"\n| \"step' (SysRemove    e c\\<^sub>1 c\\<^sub>2)   s = {removeOperation e c\\<^sub>1 c\\<^sub>2 s}\"\n| \"step' (SysRemoveSet e c C)    s = {removeSetOperation e c C s}\"\n| \"step' (SysRevoke    e c) s      =  revokeOperation e c s\"\n| \"step' (SysDestroy   e c) s      = {destroyOperation e c s}\"", "property": "System Call Execution: Non-deterministically execute a single system call operation, such as creating, taking, granting, copying, removing, revoking, or destroying resources.\n\nSubproperties:\n- Create Operation: Create a new resource with the given parameters.\n- Take Operation: Take control of a resource from another entity.\n- Grant Operation: Grant access to a resource for another entity.\n- Copy Operation: Copy a resource from one location to another.\n- Remove Operation: Remove a resource from the system.\n- Remove Set Operation: Remove a set of resources from the system.\n- Revoke Operation: Revoke access to a resource for all entities.\n- Destroy Operation: Destroy a resource and its associated data.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Non deterministically executing system calls:\n * How we execute a single operation\n "}
{"spec": "lemma bindE_returnOk[simp]:\n  \"(m >>=E returnOk) = m\"\n  by (simp add: bindE_def returnOk_def)", "property": "Right Unit Absorption: The bind operation over a monad followed by a return operation is equivalent to the original monad, ensuring that unnecessary return operations can be eliminated without affecting the outcome.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Right @{const returnOk} absorbtion over @{term bindE}:"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masks Initialization: All IRQs are masked after kernel initialization.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "(*\nArch-specific functions for the abstract model of CSpace.\n*)\n\nchapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"sanitise_register t r v \\<equiv> case r of\n      CPSR \\<Rightarrow> (v && 0xf8000000) || 0x150\n    | _    \\<Rightarrow> v\"\n\n\ndefinition\n  arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\nwhere\n  \"arch_get_sanitise_register_info t \\<equiv> return False\"\n\ndefinition\n  arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\nwhere\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "TCB Register Management: Sanitizes and manages registers, ensuring that certain registers (e.g., CPSR) have specific values, while others remain unchanged. \n\nArch-specific Register Sanitization: Provides information for sanitizing registers, currently always returning False. \n\nPost-Register Modification: Performs any necessary actions after modifying registers, currently a no-op.", "title": "./spec/abstract/ARM/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "chapter \"Function Declarations for Endpoints\"\n\ntheory EndpointDecls_H\nimports FaultMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Endpoint.lhs decls_only\n\nend", "property": "Function Declarations for Endpoints: Declare functions for endpoint operations, providing a foundation for implementing endpoint-related functionality in the kernel.", "title": "./spec/design/skel/EndpointDecls_H.thy", "chapter": "Function Declarations for Endpoints", "section": "", "comment": ""}
{"spec": "definition\nperform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n\"perform_page_invocation iv \\<equiv> case iv of\n    PageMap cap ct_slot entries vspace \\<Rightarrow> do\n      set_cap cap ct_slot;\n      case entries of\n          (VMPTE pte, slot) \\<Rightarrow> store_pte slot pte\n        | (VMPDE pde, slot) \\<Rightarrow> store_pde slot pde\n        | (VMPDPTE pdpte, slot) \\<Rightarrow> store_pdpte slot pdpte;\n      asid \\<leftarrow> case cap of\n                  ArchObjectCap (PageCap _ _ _ _ _ (Some (as, _))) \\<Rightarrow> return as\n                | _ \\<Rightarrow> fail;\n      invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid;\n      return []\n    od\n  | PageUnmap cap ct_slot \\<Rightarrow>\n      (case cap of\n        PageCap dev base rights map_type sz mapped \\<Rightarrow> do\n            case mapped of\n              Some _ \\<Rightarrow> (case map_type of\n                          VMVSpaceMap \\<Rightarrow> perform_page_invocation_unmap cap ct_slot\n                        | _ \\<Rightarrow> fail)\n            | None \\<Rightarrow> return ();\n            return []\n        od\n      | _ \\<Rightarrow> fail)\n\\<^cancel>\\<open>| PageIOMap asid cap ct_slot entries \\<Rightarrow> undefined\\<close>\n  | PageGetAddr ptr \\<Rightarrow>\n      return [addrFromPPtr ptr]\"", "property": "Page Invocation Actions: Allow the management of memory pages, including mapping, unmapping, and flushing, while ensuring the correct handling of page table entries, invalidation of page structure caches, and retrieval of page addresses.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "The Page capability confers the authority to map, unmap and flush the\n  memory page."}
{"spec": "definition\n  cap_irq_opt :: \"cap \\<Rightarrow> irq option\" where\n \"cap_irq_opt cap \\<equiv> case cap of IRQHandlerCap irq \\<Rightarrow> Some irq | _ \\<Rightarrow> None\"\n\ndefinition\n  cap_irqs :: \"cap \\<Rightarrow> irq set\" where\n \"cap_irqs cap \\<equiv> set_option (cap_irq_opt cap)\"", "property": "IRQ Retrieval: Extract the optional IRQ or set of IRQs associated with a capability. \n\nSubproperties:\n- Optional IRQ: Retrieve the optional IRQ stored in a capability, returning None if the capability is not an IRQHandlerCap.\n- IRQ Set: Convert the optional IRQ to a set, providing a collection of IRQs associated with the capability.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "The optional IRQ stored in a capability, presented either as an optional\nvalue or a set."}
{"spec": "locale_abbrev vcpus_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> vcpu\" where\n  \"vcpus_of \\<equiv> \\<lambda>s. aobjs_of s |> vcpu_of\"\n\ndefinition get_vcpu :: \"obj_ref \\<Rightarrow> (vcpu,'z::state_ext) s_monad\" where\n  \"get_vcpu \\<equiv> gets_map vcpus_of\"\n\ndefinition set_vcpu :: \"obj_ref \\<Rightarrow> vcpu \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_vcpu ptr vcpu \\<equiv> set_object ptr (ArchObj (VCPU vcpu))\"", "property": "VCPU Accessor Functions: Provide access to VCPU-related state and registers, enabling retrieval and modification of VCPU objects.\nGet VCPU: Retrieve the VCPU object associated with a given object reference.\nSet VCPU: Update the VCPU object associated with a given object reference.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": ""}
{"spec": "text \\<open>Manipulate ASID pools, page directories and page tables in the kernel\nheap.\\<close>", "property": "Kernel Heap Access: Provide access to ASID pools, page directories, and page tables within the kernel heap, enabling manipulation of these critical data structures for efficient memory management.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "definition kernel_elf_base :: \"vspace_ref\"\n  where\n  \"kernel_elf_base \\<equiv> Platform.RISCV64.kernelELFBase\"", "property": "Kernel ELF Base Address: The kernel's ELF (Executable and Linkable Format) base address is defined as a fixed virtual address in the system's address space.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The virtual address the kernel code is mapped.\n"}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n  pt_array_len\n  vs_array_len\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\n\nlemma ptTranslationBits_vs_array_len':\n  \"2 ^ ptTranslationBits VSRootPT_T = vs_array_len\"\n  by (simp add: vs_array_len_val ptTranslationBits_vs_index_bits vs_index_bits_def\n                Kernel_Config.config_ARM_PA_SIZE_BITS_40_def)\n\nlemmas ptTranslationBits_vs_array_len = ptTranslationBits_vs_array_len'[unfolded vs_array_len_val]\n\ntype_synonym cghost_state =\n  \"(machine_word \\<rightharpoonup> vmpage_size) \\<times>   \\<comment> \\<open>Frame sizes\\<close>\n   (machine_word \\<rightharpoonup> nat) \\<times>           \\<comment> \\<open>CNode sizes\\<close>\n   (machine_word \\<rightharpoonup> pt_type) \\<times>       \\<comment> \\<open>PT types\\<close>\n   ghost_assertions\"                 \\<comment> \\<open>ASMRefine assertions\\<close>\n\ndefinition gs_clear_region :: \"addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n     (\\<lambda>x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n      \\<lambda>x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x,\n      \\<lambda>x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd (snd gs)) x,\n      snd (snd (snd gs)))\"\n\ndefinition gs_new_frames:: \"vmpage_size \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n     if bits < pageBitsForSize sz then gs\n     else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                    x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n               else fst gs x, snd gs)\"\n\ndefinition gs_new_cnodes:: \"nat \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n     if bits < sz + 4 then gs\n     else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                       then Some sz\n                       else fst (snd gs) x, snd (snd gs))\"\n\ndefinition gs_new_pt_t:: \"pt_type \\<Rightarrow> addr \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_new_pt_t pt_t ptr \\<equiv>\n     \\<lambda>gs. (fst gs, fst (snd gs), (fst (snd (snd gs))) (ptr \\<mapsto> pt_t), snd (snd (snd gs)))\"\n\nabbreviation gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> machine_word\" where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd \\<circ> snd \\<circ> snd)\"\n\nabbreviation gs_set_assn :: \"int \\<Rightarrow> machine_word \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd \\<circ> apsnd \\<circ> apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: \nManage the ghost state, which includes information about frame sizes, CNode sizes, page table types, and ASMRefine assertions. \nClear Region: Clear a region of the ghost state by setting all entries within a specified range to None. \nNew Frames: Add new frames to the ghost state by setting the size of frames within a specified range. \nNew CNodes: Add new CNodes to the ghost state by setting the size of CNodes within a specified range. \nNew Page Table: Add a new page table to the ghost state by setting its type. \nAssertion Management: Get and set the values of ghost assertions.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym cdl_io_port = nat", "property": "IO Port Representation: Represents a single IA32 IO port using a natural number.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A single IA32 IO port. "}
{"spec": "definition largePagePTE_offsets :: \"obj_ref list\"\n  where\n  \"largePagePTE_offsets \\<equiv>\n    let pts = of_nat 2\n    in [0, 2 ^ pts  .e.  (15 << 2)]\"\n\ndefinition superSectionPDE_offsets :: \"obj_ref list\"\n  where\n  \"superSectionPDE_offsets \\<equiv>\n    let pts = of_nat 2\n    in [0, 2 ^ pts  .e.  (15 << 2)]\"\n\nfun create_mapping_entries ::\n  \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vm_rights \\<Rightarrow> vm_attributes \\<Rightarrow> word32 \\<Rightarrow>\n  ((pte * word32 list) + (pde * word32 list),'z::state_ext) se_monad\"\nwhere\n  \"create_mapping_entries base vptr ARMSmallPage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (SmallPagePTE base (attrib - {Global, ParityEnabled})\n                                 vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMLargePage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (LargePagePTE base (attrib - {Global, ParityEnabled})\n                                 vm_rights, map (\\<lambda>x. x + p) largePagePTE_offsets)\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SectionPDE base (attrib - {Global}) 0 vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSuperSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SuperSectionPDE base (attrib - {Global}) vm_rights, map (\\<lambda>x. x + p) superSectionPDE_offsets)\n  odE\"\n\ndefinition get_master_pde :: \"word32 \\<Rightarrow> (pde,'z::state_ext)s_monad\"\n  where \"get_master_pde ptr \\<equiv> do\n    pde \\<leftarrow> (get_pde (ptr && ~~ mask 6));\n    (case pde of SuperSectionPDE _ _ _ \\<Rightarrow> return pde\n    | _ \\<Rightarrow> get_pde ptr)\n  od\"\n\ndefinition get_master_pte :: \"word32 \\<Rightarrow> (pte, 'z::state_ext)s_monad\"\n  where \"get_master_pte ptr \\<equiv> do\n    pte \\<leftarrow> (get_pte (ptr && ~~ mask 6));\n    (case pte of LargePagePTE _ _ _ \\<Rightarrow> return pte\n    | _ \\<Rightarrow> get_pte ptr)\n  od\"", "property": "Create Mapping Entries: Save the set of entries that would be inserted into a page table or page directory to map various different sizes of frames at a given virtual address, considering the page size, virtual machine rights, and attributes.\n\nGet Master Page Table/Directory Entry: Retrieve the master page directory or page table entry for a given virtual address, handling cases where the entry is a super section or large page.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Save the set of entries that would be inserted into a page table or\npage directory to map various different sizes of frame at a given virtual\naddress."}
{"spec": "definition\n  update_cnode_cap_data :: \"data \\<Rightarrow> nat \\<times> data\" where\n \"update_cnode_cap_data w \\<equiv>\n    let\n      guard_bits = 18;\n      guard_size' = unat ((w >> cnode_padding_bits) && mask cnode_guard_size_bits);\n      guard'' = (w >> (cnode_padding_bits + cnode_guard_size_bits)) && mask guard_bits\n    in (guard_size', guard'')\"", "property": "Cnode Capability Modification: Extract new guard bits and guard from user-provided data for modifying a cnode capability.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "On a user request to modify a cnode capability, extract new guard bits and guard."}
{"spec": "definition\n  detype :: \"cdl_object_id set \\<Rightarrow> cdl_state \\<Rightarrow> cdl_state\"\nwhere\n  \"detype detype_set s \\<equiv>\n     (s\\<lparr> cdl_objects :=\n         (\\<lambda>x. if x \\<in> detype_set then\n           Some Untyped\n         else cdl_objects s x)\\<rparr>)\"", "property": "Detype Function: Zero out a set of addresses by replacing the corresponding objects in the state with Untyped objects, effectively removing their type information.", "title": "./spec/capDL/Untyped_D.thy", "chapter": "", "section": "", "comment": " Zero out a set of addresses. "}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest\n\nend\n\nqualify RISCV64 (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"RISCV64.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"machine_word \\<Rightarrow> word8\"\n  device_state :: \"machine_word \\<Rightarrow> word8 option\"\n  machine_state_rest :: RISCV64.machine_state_rest\n\naxiomatization\n  irq_oracle :: \"nat \\<Rightarrow> RISCV64.irq\"\nwhere\n  irq_oracle_max_irq: \"\\<forall>n. irq_oracle n <= RISCV64.maxIRQ\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State Structure: The machine state consists of interrupt masks, interrupt state, underlying memory, device state, and underspecified machine state rest.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": ""}
{"spec": "definition\n  get_blocking_object :: \"thread_state \\<Rightarrow> (obj_ref,'z::state_ext) s_monad\"\nwhere\n \"get_blocking_object state \\<equiv>\n       case state of BlockedOnReceive epptr x \\<Rightarrow> return epptr\n                    | BlockedOnSend epptr x \\<Rightarrow> return epptr\n                    | _ \\<Rightarrow> fail\"", "property": "Get Blocking Object: Retrieve the endpoint pointer that a thread is blocked on, either for receiving or sending a message. \n\nSubproperties: \n- If the thread is blocked on receiving, return the endpoint pointer.\n- If the thread is blocked on sending, return the endpoint pointer.\n- If the thread is not blocked on receiving or sending, the operation fails.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "The endpoint pointer stored by a thread waiting for a message to be\ntransferred in either direction."}
{"spec": "definition\nfind_vspace_for_asid_assert :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) s_monad\" where\n\"find_vspace_for_asid_assert asid \\<equiv> do\n   pml4 \\<leftarrow> find_vspace_for_asid asid <catch> K fail;\n   get_pml4 pml4;\n   return pml4\n od\"", "property": "Find Page Directory for ASID: Locate the page directory associated with a given ASID, ensuring the process succeeds and returns a valid page directory pointer. \n\nSubproperties: \n- The search for the page directory must be successful.\n- The returned pointer must correspond to a real page directory.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory and check that this process succeeds and\nreturns a pointer to a real page directory."}
{"spec": "chapter \"Handle Hypervisor Fault Events\"\n\ntheory Hypervisor_A\nimports Exceptions_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"machine_word \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\n  where\n  \"handle_hypervisor_fault thread RISCVNoHypFaults = return ()\"\n\nend\nend", "property": "Handle Hypervisor Fault Events: Handle hypervisor fault events based on the fault type, ensuring proper response and management of faults in the system.", "title": "./spec/abstract/RISCV64/Hypervisor_A.thy", "chapter": "Handle Hypervisor Fault Events", "section": "", "comment": ""}
{"spec": "lemma state_select_def2:\n  \"state_select r \\<equiv> (do\n    s \\<leftarrow> get;\n    S \\<leftarrow> return {s'. (s, s') \\<in> r};\n    assert (S \\<noteq> {});\n    s' \\<leftarrow> select S;\n    put s'\n  od)\"\n  apply (clarsimp simp add: state_select_def get_def return_def assert_def fail_def select_def\n                            put_def bind_def fun_eq_iff\n                    intro!: eq_reflection)\n  apply fastforce\n  done", "property": "State Selection: Nondeterministically select a new state from a relation, ensuring the new state is related to the current state and the relation is not empty. \n\nRelation Non-emptiness: The relation must not be empty to ensure a valid state selection. \n\nState Transition: The new state is selected and updated, replacing the current state.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "An alternative definition of @{term state_select}"}
{"spec": "definition\n  tcb_empty_thread_slot :: \"cdl_object_id \\<Rightarrow> cdl_cnode_index \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_empty_thread_slot target_tcb target_slot \\<equiv> doE\n    cap \\<leftarrow> liftE $ get_cap (target_tcb,target_slot);\n    whenE (cap \\<noteq> NullCap) $\n      delete_cap  (target_tcb, target_slot)\n  odE\"", "property": "TCB Slot Deletion: Delete the capability in the specified slot of a TCB, ensuring the slot is empty.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Delete the given slot of a TCB. "}
{"spec": "| IOPortsCap cdl_object_id \"cdl_io_port set\"\n  | IOSpaceMasterCap\n  | IOSpaceCap cdl_object_id\n  | IOPageTableCap cdl_object_id", "property": "X86-Specific Capabilities: Provide capabilities for managing x86-specific resources, including I/O ports, I/O spaces, and I/O page tables. \n\nSubproperties:\n- I/O Port Management: Manage access to specific I/O ports.\n- I/O Space Management: Control I/O spaces, including master and specific I/O space capabilities.\n- I/O Page Table Management: Manage I/O page tables for efficient memory management.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " x86-specific capabilities "}
{"spec": "definition\n  tcb_update_cspace_root :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap \\<times> cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_cspace_root target_tcb tcb_cap_ref croot \\<equiv>\n  doE\n     tcb_empty_thread_slot target_tcb tcb_cspace_slot;\n     src_cap \\<leftarrow> liftE $ get_cap (snd croot);\n     whenE (is_cnode_cap src_cap \\<and> (cap_object src_cap = cap_object (fst croot)))\n       $ tcb_update_thread_slot target_tcb tcb_cap_ref tcb_cspace_slot croot\n  odE\"", "property": "Update Thread's CSpace Root: Update a thread's CSpace root by emptying the thread's CSpace slot, retrieving the source capability, and updating the thread slot if the source capability is a CNode capability with a matching object.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update a thread's CSpace root. "}
{"spec": "definition\nlookup_pd_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\" where\n\"lookup_pd_slot pd vptr \\<equiv>\n    let pd_index = vptr >> 20\n    in pd + (pd_index << 2)\"", "property": "Compute PDE Pointer: Calculate the pointer to the Page Directory Entry (PDE) in kernel memory given a page-directory reference and a virtual address.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PDE in kernel memory"}
{"spec": "defs makeVCPUObject_def:\n\"makeVCPUObject \\<equiv>\n    VCPUObj_ \\<lparr>\n          vcpuTCBPtr= Nothing\n        , vcpuVGIC= VGICInterface_ \\<lparr>\n                          vgicHCR= vgicHCREN\n                        , vgicVMCR= 0\n                        , vgicAPR= 0\n                        , vgicLR= (\\<lambda>_. 0)\n                        \\<rparr>\n        , vcpuRegs= funArray (const 0)  aLU  [(VCPURegSCTLR, sctlrDefault)\n                                             ,(VCPURegACTLR, actlrDefault)]\n        , vcpuVPPIMasked= (\\<lambda>_. False)\n        , vcpuVTimer= VirtTimer 0\n        \\<rparr>\"\n\ndatatype arch_kernel_object_type =\n    PDET\n  | PTET\n  | VCPUT\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPDE e) = PDET\"\n| \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOVCPU e) = VCPUT\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend", "property": "VCPU Object Creation: Creates a new VCPU object with default settings, including a VGIC interface, registers, and a virtual timer, ensuring a consistent initial state for VCPU objects.\n\nArchitectural Object Type Identification: Identifies the type of an architectural kernel object, categorizing it as a page directory entry table, page table entry table, VCPU, or ASID pool, allowing for proper management and handling of different object types.", "title": "./spec/design/skel/ARM_HYP/ArchStructures_H.thy", "chapter": "", "section": "", "comment": " we define makeVCPUObject_def manually because we want a total function vgicLR "}
{"spec": "definition pptr_from_pte :: \"pte \\<Rightarrow> vspace_ref\"\n  where\n  \"pptr_from_pte pte \\<equiv> ptrFromPAddr (addr_from_pte pte)\"\n\ndefinition pt_slot_offset :: \"vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\"\n  where\n  \"pt_slot_offset level pt_ptr vptr = pt_ptr + (pt_index level vptr << pte_bits)\"", "property": "Virtual Space Access: Provide basic operations to access and manipulate the RISCV64 virtual space, ensuring proper address alignment and calculation of page table slot offsets.\n\nAddress Calculation: Calculate the physical pointer from a page table entry (PTE) and compute the page table slot offset for a given virtual pointer and page table level.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " pte addresses will always be at least page aligned "}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified\n  part of the machine state @{typ machine_state_rest} and cannot fail.\n  We could express the latter by type (leaving out the failure flag),\n  but if we later wanted to implement them,\n  we'd have to set up a new hoare-logic\n  framework for that type. So instead, we provide a wrapper for these\n  operations that explicitly ignores the fail flag and sets it to\n  False. Similarly, these operations never return an empty set of\n  follow-on states, which would require the operation to fail.\n  So we explicitly make this (non-existing) case a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming ARM", "property": "Machine Operations: Perform low-level operations on the machine state, specifically modifying the underspecified part of the machine state, and manage the failure flag to ensure consistent behavior.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "primrec\n  runnable :: \"Structures_A.thread_state \\<Rightarrow> bool\"\nwhere\n  \"runnable (Running)               = True\"\n| \"runnable (Inactive)              = False\"\n| \"runnable (Restart)               = True\"\n| \"runnable (BlockedOnReceive x y)  = False\"\n| \"runnable (BlockedOnSend x y)     = False\"\n| \"runnable (BlockedOnNotification x) = False\"\n| \"runnable (IdleThreadState)       = False\"\n| \"runnable (BlockedOnReply)        = False\"\n\n\ndefinition\n  default_tcb :: tcb where\n  \"default_tcb \\<equiv> \\<lparr>\n      tcb_ctable   = NullCap,\n      tcb_vtable   = NullCap,\n      tcb_reply    = NullCap,\n      tcb_caller   = NullCap,\n      tcb_ipcframe = NullCap,\n      tcb_state    = Inactive,\n      tcb_fault_handler = to_bl (0::machine_word),\n      tcb_ipc_buffer = 0,\n      tcb_fault      = None,\n      tcb_bound_notification  = None,\n      tcb_mcpriority = minBound,\n      tcb_arch       = default_arch_tcb\\<rparr>\"", "property": "Thread Schedulability: Determine whether a thread in a given state can be scheduled. \n\nThread States: Define the possible states a thread can be in, including Running, Inactive, Restart, and various blocked states. \n\nDefault Thread Control Block (TCB): Establish the default values for a TCB, including capability tables, reply and caller capabilities, IPC frame, thread state, fault handler, IPC buffer, fault information, bound notification, and priority.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Determines whether a thread in a given state may be scheduled."}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\nrequalify_consts X64SmallPage X64LargePage X64HugePage\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 10\"\n\ndefinition\n  ctcb_offset :: \"64 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Appropriately Qualified Aliases: Define and requalify constants for architecture-specific page sizes and create definitions for the size and offset of the CTCB (C Thread Control Block) data structure.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "text \\<open>The architecture-specific state for the ARM model\nconsists of the first level of the ASID table (@{text \"arm_asid_table\"}), a\nmap from hardware ASIDs to seL4 ASIDs (@{text \"arm_hwasid_table\"}),\nthe next hardware ASID to preempt (@{text \"arm_next_asid\"}), the\ninverse map from seL4 ASIDs to hardware ASIDs (first component of\n@{text \"arm_asid_map\"}), and the address of the page directory and\npage tables mapping the shared address space, along with a description\nof this space (@{text \"arm_global_pd\"}, @{text \"arm_global_pts\"}, and\n@{text \"arm_kernel_vspace\"} respectively).\n\nHardware ASIDs are only ever associated with seL4 ASIDs that have a\ncurrently active page directory. The second component of\n@{text \"arm_asid_map\"} values is the address of that page directory.\n\\<close>\n\nend\n\nqualify ARM_A (in Arch)\n\nrecord arch_state =\n  arm_asid_table    :: \"7 word \\<rightharpoonup> obj_ref\"\n  arm_hwasid_table  :: \"ARM_A.hw_asid \\<rightharpoonup> ARM_A.asid\"\n  arm_next_asid     :: ARM_A.hw_asid\n  arm_asid_map      :: \"ARM_A.asid \\<rightharpoonup> (ARM_A.hw_asid \\<times> obj_ref)\"\n  arm_global_pd     :: obj_ref\n  arm_global_pts    :: \"obj_ref list\"\n  arm_kernel_vspace :: ARM_A.arm_vspace_region_uses\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  pd_bits :: \"nat\" where\n  \"pd_bits \\<equiv> pageBits + 2\"\n\ndefinition\n  pt_bits :: \"nat\" where\n  \"pt_bits \\<equiv> pageBits - 2\"", "property": "ARM Architecture State: Maintains the architecture-specific state for the ARM model, including the ASID table, hardware ASID to seL4 ASID mapping, next hardware ASID, inverse mapping from seL4 ASIDs to hardware ASIDs, and the shared address space mappings.\n\nSubproperties:\n- ASID Management: Manages the mapping between hardware ASIDs and seL4 ASIDs, ensuring that hardware ASIDs are only associated with active page directories.\n- Page Table Management: Maintains the page directory and page table addresses for the shared address space.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "type_synonym exclusive_monitors = \"(word32 \\<Rightarrow> bool) list \\<times> (word32 \\<times> nat \\<Rightarrow> bool)\"", "property": "Exclusive Monitors State: The state of exclusive monitors is observable in user mode, represented as a pair of a list of boolean functions mapping 32-bit words to booleans and a boolean function mapping 32-bit words and natural numbers to booleans.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The exclusive monitors state is observable in user mode.\n  The type for this is the type used in the Cambridge HOL4 ARM model.\n"}
{"spec": "(start, end) \\<leftarrow> liftE $ gets (bi_f_ui_pt_caps \\<circ> ki_bootinfo);\n\n     do_kernel_op $\n       (swp mapM)\n          [start..<end]\n          (\\<lambda>pos. do\n                   cap \\<leftarrow> get_cap_local $ cap_slot_pptr root_cnode_cap pos;\n                   map_it_pt_cap it_pd_cap cap\n                 od);", "property": "Kernel Initialization: Map page tables into page directories. \n\n Map Page Tables: Iterate over a range of page table positions, retrieve the corresponding capability, and map it into the page directory using the provided page directory capability.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map PTs into PD "}
{"spec": "datatype arch_copy_register_sets = X64NoExtraRegisters\n\ndefinition \"ArchDefaultExtraRegisters \\<equiv> X64NoExtraRegisters\"\n\ndatatype arch_irq_control_invocation\n  = IssueIRQHandlerIOAPIC irq cslot_ptr cslot_ptr\n      machine_word machine_word machine_word machine_word machine_word\n  | IssueIRQHandlerMSI irq cslot_ptr cslot_ptr\n      machine_word machine_word machine_word machine_word\n\nend\nend", "property": "Invoke I/O Page Table: Handle invocations related to I/O page tables, including issuing IRQ handlers for IOAPIC and MSI interrupts.", "title": "./spec/abstract/X64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "| InvokeIOPT io_pt_invocation"}
{"spec": "function cap_revoke :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n\"cap_revoke slot s = (doE\n    cap \\<leftarrow> without_preemption $ get_cap slot;\n    cdt \\<leftarrow> without_preemption $ gets cdt;\n    descendants \\<leftarrow> returnOk $ descendants_of slot cdt;\n    whenE (cap \\<noteq> NullCap \\<and> descendants \\<noteq> {}) (doE\n      child \\<leftarrow> without_preemption $ select_ext (next_revoke_cap slot) descendants;\n      cap \\<leftarrow> without_preemption $ get_cap child;\n      assertE (cap \\<noteq> NullCap);\n      cap_delete child;\n      preemption_point;\n      cap_revoke slot\n    odE)\nodE) s\"\nby auto", "property": "Revoke Capability: Revoke and delete all derived capabilities of a given capability, ensuring that all its descendants are removed from the capability derivation tree. \n\nRecursive Revocation: If the capability has non-null descendants, select the next capability to revoke, delete it, and then recursively revoke the original capability to ensure all descendants are removed.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Revoke the derived capabilities of a given capability, deleting them\nall."}
{"spec": "(*\n * The basic monads used in capDL\n *)\n\ntheory Monads_D\nimports\n  Types_D\n  Monads.Nondet_In_Monad\n  Monads.Nondet_VCG\nbegin", "property": "No specific property can be summarized from the given code as it only contains imports and no actual specification or implementation details.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs Platform=Platform.ARM CONTEXT ARM_H NOT getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory writeTTBR0 setGlobalPD  setTTBCR setHardwareASID invalidateLocalTLB invalidateLocalTLB_ASID invalidateLocalTLB_VAASID cleanByVA cleanByVA_PoU invalidateByVA invalidateByVA_I invalidate_I_PoU cleanInvalByVA branchFlush clean_D_PoU cleanInvalidate_D_PoC cleanInvalidate_D_PoU cleanInvalidateL2Range invalidateL2Range cleanL2Range isb dsb dmb getIFSR getDFSR getFAR HardwareASID wordFromPDE wordFromPTE VMFaultType VMPageSize HypFaultType pageBits pageBitsForSize toPAddr cacheLineBits cacheLine lineStart cacheRangeOp cleanCacheRange_PoC cleanInvalidateCacheRange_RAM cleanCacheRange_RAM cleanCacheRange_PoU invalidateCacheRange_RAM invalidateCacheRange_I branchFlushRange cleanCaches_PoU cleanInvalidateL1Caches addrFromPPtr ptrFromPAddr initIRQController setIRQTrigger MachineData paddrBase pptrBase pptrTop paddrTop kernelELFPAddrBase kernelELFBase kernelELFBaseOffset pptrBaseOffset addrFromKPPtr\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_H instanceproofs NOT HardwareASID VMFaultType VMPageSize HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_H ONLY wordFromPDE wordFromPTE", "property": "Hardware Abstraction: Provides an abstract interface to the underlying hardware, allowing the kernel to interact with the machine in a platform-agnostic manner. This includes operations for memory management, interrupt handling, timer configuration, and cache maintenance.\n\nMemory Management: Allows the kernel to manage memory regions, including device regions, kernel devices, and memory allocation and deallocation.\n\nInterrupt Handling: Provides functions for getting and acknowledging active interrupts, masking interrupts, and resetting timers.\n\nCache Maintenance: Offers operations for cleaning and invalidating caches, including by virtual address, address space identifier, and cache range.\n\nTimer Configuration: Allows the kernel to configure and reset timers.\n\nDebugging: Provides a function for debug printing.\n\nMemory Access: Includes functions for loading and storing words, as well as getting and setting memory regions.\n\nAddress Translation: Offers functions for translating between physical and virtual addresses.\n\nInitialization: Provides functions for initializing memory, IRQ controllers, and other hardware components.\n\nPlatform-Specific Definitions: Defines various platform-specific constants and types, such as page sizes, cache line sizes, and hardware ASID types.", "title": "./spec/design/skel/ARM/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/AARCH64.hs CONTEXT AARCH64 bodies_only NOT getRegister setRegister newContext newFPUState", "property": "AARCH64 Machine State Management: Define the AARCH64 machine state, including the register set, to manage and manipulate the machine's state effectively.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "definition store_vmid :: \"asid \\<Rightarrow> vmid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_vmid asid hw_asid \\<equiv> do\n     update_asid_pool_entry (\\<lambda>entry. Some $ ASIDPoolVSpace (Some hw_asid) (ap_vspace entry)) asid;\n     vmid_table \\<leftarrow> gets (arm_vmid_table \\<circ> arch_state);\n     vmid_table' \\<leftarrow> return $ vmid_table (hw_asid \\<mapsto> asid);\n     modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_vmid_table := vmid_table' \\<rparr>\\<rparr>)\n   od\"", "property": "Associate VMID with ASID: Maps a VMID to an ASID, updating the ASID pool entry and the VMID table to reflect the association.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associate a VMID with an ASID."}
{"spec": "definition\n  canonicalAddressAssert :: \"machine_word => bool\" where\n  canonicalAddressAssert_def[simp]:\n  \"canonicalAddressAssert p = True\"\n\nend", "property": "Canonical Address Assertion: Always returns true, indicating that the address is canonical, regardless of the architecture.", "title": "./spec/design/skel/ARM_HYP/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "text \\<open>\n  Changes user context of specified thread by running\n  specified user monad.\n\\<close>\ndefinition\n  as_user :: \"obj_ref \\<Rightarrow> 'a user_monad \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"as_user tptr f \\<equiv> do\n    tcb \\<leftarrow> gets_the $ get_tcb tptr;\n    uc \\<leftarrow> return $ arch_tcb_context_get (tcb_arch tcb);\n    (a, uc') \\<leftarrow> select_f $ f uc;\n    new_tcb \\<leftarrow> return $ tcb \\<lparr> tcb_arch := arch_tcb_context_set uc' (tcb_arch tcb)\\<rparr>;\n    set_object tptr (TCB new_tcb);\n    return a\n  od\"", "property": "Change User Context: Modify the user context of a specified thread by executing a given user monad, updating the thread's control block (TCB) with the new context.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "User Context", "comment": ""}
{"spec": "text \\<open>\n Recall that a capability may reside in either a CNode, or inside a TCB;\nthe following definitions allow the kernel model to retrieve and update\ncapabilities in a uniform fashion.\\<close>\ndefinition\n  get_cap :: \"cslot_ptr \\<Rightarrow> (cap,'z::state_ext) s_monad\"\nwhere\n  \"get_cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     caps \\<leftarrow> case obj of\n             CNode sz cnode \\<Rightarrow> do\n                                assert (well_formed_cnode_n sz cnode);\n                                return cnode\n                              od\n           | TCB tcb     \\<Rightarrow> return (tcb_cnode_map tcb)\n           | _ \\<Rightarrow> fail;\n     assert_opt (caps cref)\n   od\"\n\ndefinition\n  set_cap :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_cap cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     obj' \\<leftarrow> case obj of\n               CNode sz cn \\<Rightarrow> if cref \\<in> dom cn \\<and> well_formed_cnode_n sz cn\n                                then return $ CNode sz $ cn (cref \\<mapsto> cap)\n                                else fail\n             | TCB tcb \\<Rightarrow>\n                   if cref = tcb_cnode_index 0 then\n                       return $ TCB $ tcb \\<lparr> tcb_ctable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 1 then\n                       return $ TCB $ tcb \\<lparr> tcb_vtable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 2 then\n                       return $ TCB $ tcb \\<lparr> tcb_reply := cap \\<rparr>\n                   else if cref = tcb_cnode_index 3 then\n                       return $ TCB $ tcb \\<lparr> tcb_caller := cap \\<rparr>\n                   else if cref = tcb_cnode_index 4 then\n                       return $ TCB $ tcb \\<lparr> tcb_ipcframe := cap \\<rparr>\n                   else\n                       fail\n             | _ \\<Rightarrow> fail;\n     set_object oref obj'\n  od\"", "property": "Uniform Capability Access: Retrieve and update capabilities in a uniform fashion, regardless of whether they reside in a CNode or inside a TCB.\n\nGet Capability: Retrieve a capability from a CNode or TCB, ensuring that the CNode is well-formed and the capability exists at the specified location.\n\nSet Capability: Update a capability in a CNode or TCB, ensuring that the CNode is well-formed and the capability is valid for the specified location.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": ""}
{"spec": "definition vs_lookup_table ::\n  \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\" where\n  \"vs_lookup_table bot_level asid vptr \\<equiv> do {\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     if bot_level = asid_pool_level\n     then oreturn (asid_pool_level, pool_ptr)\n     else do {\n       top_level_pt \\<leftarrow> vspace_for_pool pool_ptr asid \\<circ> asid_pools_of;\n       pt_walk max_pt_level bot_level top_level_pt vptr \\<circ> ptes_of\n     }\n   }\"", "property": "Virtual Space Lookup: Look up an address space identifier (ASID) and virtual space reference down to a specified level in the page table, returning a pointer to a table at that level if found. The lookup may terminate early if it encounters a page or invalid entry, resulting in a level higher than the specified one.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up an @{text \"asid+vspace_ref\"} down to the provided level in the page table.\n  For level @{term bot_level}, return a pointer to a table at the returned level.\n  The level can be higher than @{term bot_level} if the lookup terminates early because\n  it hit a page or an invalid entry."}
{"spec": "fun\n  finalise_cap :: \"cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"finalise_cap NullCap                  final = return (NullCap, NullCap)\"\n| \"finalise_cap (UntypedCap dev r bits f)    final = return (NullCap, NullCap)\"\n| \"finalise_cap (ReplyCap r m R)         final = return (NullCap, NullCap)\"\n| \"finalise_cap (EndpointCap r b R)      final =\n      (liftM (K (NullCap, NullCap)) $ when final $ cancel_all_ipc r)\"\n| \"finalise_cap (NotificationCap r b R)  final =\n      (liftM (K (NullCap, NullCap)) $ when final $ do\n          unbind_maybe_notification r;\n          cancel_all_signals r\n        od)\"\n| \"finalise_cap (CNodeCap r bits g)  final =\n      return (if final then Zombie r (Some bits) (2 ^ bits) else NullCap, NullCap)\"\n| \"finalise_cap (ThreadCap r)            final =\n      do\n         when final $ unbind_notification r;\n         when final $ suspend r;\n         when final $ prepare_thread_delete r;\n         return (if final then (Zombie r None 5) else NullCap, NullCap)\n      od\"\n| \"finalise_cap DomainCap                final = return (NullCap, NullCap)\"\n| \"finalise_cap (Zombie r b n)           final =\n      do assert final; return (Zombie r b n, NullCap) od\"\n| \"finalise_cap IRQControlCap            final = return (NullCap, NullCap)\"\n| \"finalise_cap (IRQHandlerCap irq)      final = (\n       if final then do\n         deleting_irq_handler irq;\n         return (NullCap, (IRQHandlerCap irq))\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (ArchObjectCap a)        final =\n      (arch_finalise_cap a final)\"\n\ndefinition\n  can_fast_finalise :: \"cap \\<Rightarrow> bool\" where\n \"can_fast_finalise cap \\<equiv> case cap of\n    ReplyCap r m R \\<Rightarrow> True\n  | EndpointCap r b R \\<Rightarrow> True\n  | NotificationCap r b R \\<Rightarrow> True\n  | NullCap \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"", "property": "Capability Finalisation: Ensure that when a capability is deleted, necessary actions are taken to maintain system integrity, such as cancelling IPC, unbinding notifications, suspending threads, and preparing for thread deletion. This may involve replacing the deleted capability with a Zombie capability or performing post-deletion actions like clearing IRQs.\n\n Fast Finalisation: Determine whether a capability can be quickly finalised without requiring additional actions, applicable to Reply, Endpoint, Notification, and Null capabilities.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Actions that must be taken when a capability is deleted. Returns two\ncapabilities: The first is a capability to be re-inserted into the slot in place\nof the deleted capability; in particular, this will be a Zombie if the deletion\nrequires a long-running operation. The second represents some further\npost-deletion action to be performed after the slot is cleared. For example,\nan IRQHandlerCap indicates an IRQ to be cleared. Arch capabilities may also be\nassociated with arch-specific post-deletion actions. For most cases, however,\nNullCap is used to indicate that no post-deletion action is required."}
{"spec": "text \\<open>\n\n  \\texttt{handle_fault} in \\texttt{sep-abstract} always sets the thread state to\n  \\texttt{Inactive}. This is the same behaviour as \\texttt{handle_double_fault} in the abstract\n  specification.\n\n  The two \\texttt{handle_fault}s have the same behaviour under restricted capabilities because in\n  the abstract specification \\texttt{handle_fault} will call \\texttt{handle_double_fault} in all\n  cases except when the thread has an \\texttt{EndpointCap}. Since \\texttt{EndpointCap} is not part\n  of the restricted capabilities their behaviour is the same. This means, the system assumes\n  fully static virtual memory and no dynamic paging of any kind.\n  Faulting threads will be disabled by the kernel.\n\\<close>\n\ndefinition\n  handle_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault tptr ex \\<equiv> set_thread_state tptr Inactive\"\n\nend", "property": "Fault Handling: When a fault occurs, the thread is immediately set to an inactive state, effectively disabling it. This ensures that faulting threads do not compromise the stability and security of the system, assuming a fully static virtual memory with no dynamic paging.", "title": "./spec/sep-abstract/Ipc_SA.thy", "chapter": "IPC", "section": "", "comment": ""}
{"spec": "(*\n  Hypervisor stub for ARM\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  KI_Decls_H\n  InterruptDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_H decls_only ArchInv= ArchLabels=\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_H bodies_only ArchInv= ArchLabels=\n\nend\nend", "property": "Hypervisor Stub for ARM: Provides a basic framework for a hypervisor on the ARM architecture, defining necessary structures and functions for managing the interaction between the kernel and the hypervisor.", "title": "./spec/design/skel/ARM/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\ndelete_asid :: \"asid \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid asid pd \\<equiv> do\n  asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n  (case asid_table (asid_high_bits_of asid) of\n    None \\<Rightarrow> return ()\n  | Some pool_ptr \\<Rightarrow>  do\n     pool \\<leftarrow> get_asid_pool pool_ptr;\n     when (pool (ucast asid) = Some pd) $ do\n                flush_space asid;\n                invalidate_asid_entry asid;\n                pool' \\<leftarrow> return (pool (ucast asid := None));\n                set_asid_pool pool_ptr pool';\n                tcb \\<leftarrow> gets cur_thread;\n                set_vm_root tcb\n            od\n    od)\nod\"", "property": "ASID Deletion: When deleting a page directory from an ASID pool, ensure it is deactivated by flushing the address space, invalidating the ASID entry, updating the ASID pool, and resetting the VM root for the current thread.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "When deleting a page directory from an ASID pool we must deactivate\nit."}
{"spec": "lemma unat_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> unat (maxIRQ::'a word) = maxIRQ\"\n  by (metis maxIRQ_less_2p_irq_len Word.of_nat_unat of_nat_inverse of_nat_maxIRQ unat_ucast_up_simp)", "property": "IRQ Length Property: The unat (unsigned natural number) value of maxIRQ is equal to maxIRQ when the length of irq_len is less than or equal to the length of the word type 'a.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "consts' configureTimer_impl :: \"unit machine_rest_monad\"\nconsts' configureTimer_val :: \"machine_state \\<Rightarrow> irq\"\ndefinition configureTimer :: \"irq machine_monad\"\n  where\n  \"configureTimer \\<equiv> do\n     machine_op_lift configureTimer_impl;\n     gets configureTimer_val\n   od\"\n\nconsts' initTimer_impl :: \"unit machine_rest_monad\"\ndefinition initTimer :: \"unit machine_monad\"\n  where\n  \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts' resetTimer_impl :: \"unit machine_rest_monad\"\ndefinition resetTimer :: \"unit machine_monad\"\n  where\n  \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"", "property": "Timer Configuration and Control: Configure, initialize, and reset the timer, ensuring proper management of time-related operations and interrupts. \n\nConfigure Timer: Set up the timer and retrieve the resulting IRQ.\nInitialize Timer: Initialize the timer to its default state.\nReset Timer: Reset the timer to a known state.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "idx \\<leftarrow> return $ idx + 15; (* should be 2^PD_BITS - 1 *)\n     phys \\<leftarrow> return $ phys + 15 * (2^pageBitsForSize(ARMSection));", "property": "Kernel Initialization: Advance the index and physical address to match the exit of the C loop, ensuring proper alignment and incrementation of the index and physical address. \n\nIndex Incrementation: Increment the index by a fixed value (15) to match the expected value (2^PD_BITS - 1) at the end of the C loop.\n\nPhysical Address Incrementation: Increment the physical address by a calculated value (15 * (2^pageBitsForSize(ARMSection))) to maintain proper alignment and addressing.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " advance idx and phys to match exit of C loop "}
{"spec": "type_synonym io_port = \"16 word\"\ntype_synonym io_asid = \"16 word\"", "property": "Architecture-Specific Capability Types: Define specific data types for x64 architecture capabilities, including io_port and io_asid, which are both 16-word types.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific capabilities", "comment": ""}
{"spec": "definition asid_low_bits_of :: \"asid \\<Rightarrow> asid_low_index\"\n  where\n  \"asid_low_bits_of asid \\<equiv> ucast asid\"\n\nlemmas asid_bits_of_defs = asid_high_bits_of_def asid_low_bits_of_def\n\nlocale_abbrev\n  \"asid_table \\<equiv> \\<lambda>s. riscv_asid_table (arch_state s)\"", "property": "Virtual ASID Low Bits Extraction: Extract the low bits of a virtual ASID.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": "The low bits of a virtual ASID."}
{"spec": "type_synonym cdl_cap_ref = \"cdl_object_id \\<times> cdl_cnode_index\"", "property": "Capability Reference: A unique identifier for a capability slot, consisting of an object ID and a cnode index, allowing for precise referencing and management of capabilities within the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A reference to a capability slot. "}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/ARM.lhs\n\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs bodies_only\n\nend\n\n\nend", "property": "Fault Handler Management: Define the architecture-specific fault handlers for the ARM architecture, providing the necessary functions and data structures to manage faults and exceptions in the system.", "title": "./spec/design/skel/ARM/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "definition pptr_base :: \"machine_word\"\n  where\n  \"pptr_base = Platform.RISCV64.pptrBase\"\n\ntext \"Virtual address space available to users.\"\ndefinition user_vtop :: \"machine_word\"\n  where\n  \"user_vtop = Platform.RISCV64.pptrUserTop\"", "property": "Kernel Virtual Address Space: The kernel reserves a portion of the virtual address space, starting from a fixed base address (pptr_base) and extending upwards, in every virtual address space. \n\nUser Virtual Address Space: A portion of the virtual address space is available for use by users, up to a fixed top address (user_vtop).", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The lowest virtual address in the kernel window. The kernel reserves the virtual addresses\n  from here up in every virtual address space.\n"}
{"spec": "chapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\n  where\n  \"sanitise_register t r v \\<equiv> v\"\n\ndefinition arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\n  where\n  \"arch_get_sanitise_register_info t \\<equiv> return False\"\n\ndefinition arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\n  where\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "Architecture-specific TCB Functions: Provide functions for sanitizing registers, retrieving sanitization information, and handling post-modification register actions, ensuring the integrity and security of architecture-specific thread state management.\n\nSanitization: Sanitize register values to prevent unauthorized or malicious data from being propagated.\n\nInformation Retrieval: Retrieve information necessary for sanitizing registers, ensuring that the correct sanitization policies are applied.\n\nPost-Modification Handling: Perform necessary actions after modifying registers to maintain the consistency and security of the thread state.", "title": "./spec/abstract/RISCV64/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "definition\n  deleting_irq_handler :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"deleting_irq_handler irq \\<equiv> do\n    slot \\<leftarrow> get_irq_slot irq;\n    cap_delete_one slot\n  od\"", "property": "IRQ Handler Deletion: When an IRQ Handler capability is deleted, the corresponding IRQ slot is retrieved and the capability is deleted from that slot.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Actions to be taken after deleting an IRQ Handler capability."}
{"spec": "context Arch begin global_naming X64\n\ntype_synonym irq_len = 8\ntype_synonym irq = \"irq_len word\"\ntype_synonym paddr = word64\n\n\nabbreviation (input) \"toPAddr \\<equiv> id\"\nabbreviation (input) \"fromPAddr \\<equiv> id\"\n\ndefinition\n  pptrBase :: word64 where\n  \"pptrBase = 0xffffff8000000000\"\n\ndefinition\n  kernelELFBaseOffset :: word64 where\n  \"kernelELFBaseOffset = 0xffffffff80000000\"\n\ndefinition\n  pptrUserTop :: word64 where\n  \"pptrUserTop = 0x00007fffffffffff\"\n\ndefinition\n  ptrFromPAddr :: \"paddr \\<Rightarrow> word64\" where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBase\"\n\ndefinition\n  addrFromPPtr :: \"word64 \\<Rightarrow> paddr\" where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBase\"\n\ndefinition\n  addrFromKPPtr :: \"word64 \\<Rightarrow> paddr\" where\n  \"addrFromKPPtr pptr \\<equiv> pptr - kernelELFBaseOffset\"\n\ndefinition\n  pageColourBits :: \"nat\" where\n  \"pageColourBits \\<equiv> undefined\"\n\ndefinition\n  minIRQ :: \"irq\" where\n  \"minIRQ \\<equiv> 0\"\n\ndefinition\n  maxIRQ :: \"irq\" where\n  \"maxIRQ \\<equiv> 125\"\n\ndefinition\n  minUserIRQ :: \"irq\" where\n  \"minUserIRQ \\<equiv> 16\"\n\ndefinition\n  maxUserIRQ :: \"irq\" where\n  \"maxUserIRQ \\<equiv> 123\"\n\ndatatype cr3 = X64CR3 (CR3BaseAddress: word64) (cr3pcid: word64)\n\nprimrec cr3BaseAddress_update :: \"(word64 \\<Rightarrow> word64) \\<Rightarrow> cr3 \\<Rightarrow> cr3\"\nwhere\n  \"cr3BaseAddress_update f (X64CR3 v0 v1) = (X64CR3 (f v0) v1)\"\n\nprimrec cr3pcid_update :: \"(word64 \\<Rightarrow> word64) \\<Rightarrow> cr3 \\<Rightarrow> cr3\"\nwhere\n  \"cr3pcid_update f (X64CR3 v0 v1) = (X64CR3 v0 (f v1))\"\n\n\nend\nend", "property": "Platform Constants: Define the fundamental constants and data types for the X64 architecture, including the base addresses for physical and kernel ELF, user top address, and interrupt request (IRQ) ranges for the system and users. These constants provide the basis for memory management, interrupt handling, and other low-level operations. \n\nMemory Address Conversions: Provide functions to convert between physical addresses, kernel pointers, and user pointers, ensuring correct memory access and management.", "title": "./spec/machine/X64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "definition\n  send_ipc :: \"bool \\<Rightarrow> bool \\<Rightarrow> cdl_badge \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"send_ipc block call badge can_grant can_grant_reply tcb_id_sender ep_id \\<equiv>\n    do\n      waiters \\<leftarrow> gets $ get_waiting_sync_recv_threads ep_id;\n      t \\<leftarrow> option_select waiters;\n      case t of\n          None \\<Rightarrow>\n            if block then\n              block_thread_on_ipc tcb_id_sender\n                  (PendingSyncSendCap ep_id badge call can_grant can_grant_reply False)\n            else\n              return ()\n        | Some tcb_id_receiver \\<Rightarrow> do\n             \\<comment> \\<open>liftM instead of bind+return avoids early unfolding in send_ipc_corres\\<close>\n             recv_state \\<leftarrow> liftM (\\<lambda>tcb. the (cdl_tcb_caps tcb tcb_pending_op_slot)) $\n                              get_thread tcb_id_receiver;\n             reply_can_grant \\<leftarrow>\n               (case recv_state of\n                    PendingSyncRecvCap target False receiver_grant \\<Rightarrow> do\n                      do_ipc_transfer (Some ep_id) tcb_id_sender tcb_id_receiver can_grant;\n                      return receiver_grant od\n                  | _ \\<Rightarrow> fail);\n             set_cap (tcb_id_receiver,tcb_pending_op_slot) RunningCap;\n             (when (can_grant \\<or> can_grant_reply) $\n                  (inject_reply_cap tcb_id_sender tcb_id_receiver reply_can_grant))\n               \\<sqinter> set_cap (tcb_id_sender,tcb_pending_op_slot) NullCap \\<sqinter> return ()\n          od\n    od\"", "property": "Send IPC: Deliver an IPC to the specified endpoint, waking up a waiting receiver if present, or putting the sender to sleep if no receiver is waiting and blocking is enabled.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Send an IPC to the given endpoint. If someone is waiting, we wake\n * them up. Otherwise, we put the sender to sleep.\n "}
{"spec": "definition vs_lookup_table :: \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"vs_lookup_table bot_level asid vptr \\<equiv> do {\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     if bot_level = asid_pool_level\n     then oreturn (asid_pool_level, pool_ptr)\n     else do {\n       top_level_pt \\<leftarrow> vspace_for_pool pool_ptr asid \\<circ> asid_pools_of;\n       pt_walk max_pt_level bot_level top_level_pt vptr \\<circ> ptes_of\n     }\n   }\"", "property": "Virtual Space Lookup: Look up an address space identifier (ASID) and virtual space reference down to a provided level in the page table, returning a pointer to a table at the returned level, which may be higher than the provided level if the lookup terminates early due to a page or invalid entry.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up an @{text \"asid+vspace_ref\"} down to the provided level in the page table.\n  For level @{term bot_level}, return a pointer to a table at the returned level.\n  The level can be higher than @{term bot_level} if the lookup terminates early because\n  it hit a page or an invalid entry.\n"}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs Platform=Platform.AARCH64 CONTEXT AARCH64_H \\\n  NOT PT_Type plic_complete_claim getMemoryRegions getDeviceRegions getKernelDevices \\\n  loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt \\\n  configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory \\\n  clearMemoryVM initMemory freeMemory setHardwareASID wordFromPDE wordFromPTE \\\n  VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize toPAddr \\\n  addrFromPPtr ptrFromPAddr sfence physBase paddrBase pptrBase pptrBaseOffset \\\n  pptrUserTop kernelELFBase kernelELFBaseOffset kernelELFPAddrBase \\\n  addrFromKPPtr ptTranslationBits vmFaultTypeFSR setVSpaceRoot \\\n  setIRQTrigger \\\n  config_ARM_PA_SIZE_BITS_40 fpuThreadDeleteOp isFpuEnable \\\n  hcrVCPU hcrNative sctlrDefault vgicHCREN gicVCPUMaxNumLR sctlrEL1VM \\\n  get_gic_vcpu_ctrl_hcr set_gic_vcpu_ctrl_hcr get_gic_vcpu_ctrl_vmcr \\\n  set_gic_vcpu_ctrl_vmcr get_gic_vcpu_ctrl_apr set_gic_vcpu_ctrl_apr \\\n  get_gic_vcpu_ctrl_vtr get_gic_vcpu_ctrl_eisr0 get_gic_vcpu_ctrl_eisr1 \\\n  get_gic_vcpu_ctrl_misr get_gic_vcpu_ctrl_lr set_gic_vcpu_ctrl_lr read_cntpct \\\n  check_export_arch_timer \\\n  isb dsb dmb \\\n  invalidateTranslationASID invalidateTranslationSingle \\\n  cleanByVA_PoU cleanInvalidateCacheRange_RAM cleanCacheRange_RAM cleanCacheRange_PoU \\\n  invalidateCacheRange_RAM invalidateCacheRange_I branchFlushRange \\\n  enableFpuEL01 \\\n  getFAR getDFSR getIFSR getHSR setHCR getESR  getSCTLR setSCTLR \\\n  addressTranslateS1 \\\n  readVCPUHardwareReg writeVCPUHardwareReg vcpuBits\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64_H instanceproofs NOT plic_complete_claim HardwareASID VMFaultType VMPageSize VMPageEntry HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64_H ONLY wordFromPTE", "property": "Hardware Abstraction: Provides an abstract interface to the underlying hardware, allowing the kernel to interact with the hardware in a platform-agnostic manner. This includes operations for memory management, interrupt handling, timer configuration, and other hardware-specific functions.\n\nSubproperties:\n- Memory Management: Provides functions for managing memory, including loading and storing words, clearing memory, and initializing memory regions.\n- Interrupt Handling: Provides functions for handling interrupts, including getting and acknowledging active IRQs, and masking interrupts.\n- Timer Configuration: Provides functions for configuring and resetting timers.\n- Hardware-Specific Functions: Provides functions for performing hardware-specific operations, such as debug printing, getting and setting the restart PC, and setting the next PC.", "title": "./spec/design/skel/AARCH64/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "text \\<open>This definition is the toplevel decoding definition; it dispatches\nto the above definitions, after checking, in some cases, whether the\ninvocation is allowed.\n\\<close>\n\ndefinition\n  decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_invocation label args cap_index slot cap excaps \\<equiv>\n  case cap of\n    NotificationCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeNotification ptr badge\n      else throwError $ InvalidCapability 0\n  | _ \\<Rightarrow>\n      throwError $ InvalidCapability 0\"\n\nend", "property": "Toplevel Invocation Decode: Decodes system calls by dispatching to specific decoding definitions after checking invocation permissions. \n\nInvocation Permission Check: Verifies if the invocation is allowed based on the capability rights, specifically checking for the AllowSend right in NotificationCap capabilities.", "title": "./spec/sep-abstract/Decode_SA.thy", "chapter": "Decoding System Calls", "section": "Toplevel invocation decode.", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM ONLY HardwareASID VMFaultType VMPageSize HypFaultType pageBits pageBitsForSize\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM instanceproofs ONLY HardwareASID VMFaultType VMPageSize HypFaultType\n\nend\nend", "property": "ARM Machine State Properties: Defines the hardware-specific properties for ARM machine types, including hardware ASID, VM fault type, VM page size, and Hyp fault type, ensuring correct hardware configuration and management.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": " Machine/Hardware/ARM.lhs - hardware_asid, vmfault_type and vmpage_size "}
{"spec": "definition\n  ethread_get_when :: \"bool \\<Rightarrow> (etcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> 'a det_ext_monad\"\nwhere\n  \"ethread_get_when b f tptr \\<equiv> if b then (ethread_get f tptr) else return undefined\"\n\ndefinition set_eobject :: \"obj_ref \\<Rightarrow> etcb \\<Rightarrow> unit det_ext_monad\"\n  where\n \"set_eobject ptr obj \\<equiv>\n  do es \\<leftarrow> get;\n    ekh \\<leftarrow> return $ (ekheap es)(ptr \\<mapsto> obj);\n    put (es\\<lparr>ekheap := ekh\\<rparr>)\n  od\"\n\ndefinition\n  ethread_set :: \"(etcb \\<Rightarrow> etcb) \\<Rightarrow> obj_ref \\<Rightarrow> unit det_ext_monad\"\nwhere\n  \"ethread_set f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_etcb tptr;\n     set_eobject tptr $ f tcb\n   od\"\n\ndefinition\n  set_scheduler_action :: \"scheduler_action \\<Rightarrow> unit det_ext_monad\" where\n  \"set_scheduler_action action \\<equiv>\n     modify (\\<lambda>es. es\\<lparr>scheduler_action := action\\<rparr>)\"\n\ndefinition\n  thread_set_priority :: \"obj_ref \\<Rightarrow> priority \\<Rightarrow> unit det_ext_monad\" where\n  \"thread_set_priority tptr prio \\<equiv> ethread_set (\\<lambda>tcb. tcb\\<lparr>tcb_priority := prio\\<rparr>) tptr\"\n\ndefinition\n  thread_set_time_slice :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> unit det_ext_monad\" where\n  \"thread_set_time_slice tptr time \\<equiv> ethread_set (\\<lambda>tcb. tcb\\<lparr>tcb_time_slice := time\\<rparr>) tptr\"\n\ndefinition\n  thread_set_domain :: \"obj_ref \\<Rightarrow> domain \\<Rightarrow> unit det_ext_monad\" where\n  \"thread_set_domain tptr domain \\<equiv> ethread_set (\\<lambda>tcb. tcb\\<lparr>tcb_domain := domain\\<rparr>) tptr\"\n\n\ndefinition\n  get_tcb_queue :: \"domain \\<Rightarrow> priority \\<Rightarrow> ready_queue det_ext_monad\" where\n  \"get_tcb_queue d prio \\<equiv> do\n     queues \\<leftarrow> gets ready_queues;\n     return (queues d prio)\n   od\"\n\ndefinition\n  set_tcb_queue :: \"domain \\<Rightarrow> priority \\<Rightarrow> ready_queue \\<Rightarrow> unit det_ext_monad\" where\n  \"set_tcb_queue d prio queue \\<equiv>\n     modify (\\<lambda>es. es\\<lparr> ready_queues :=\n      (\\<lambda>d' p. if d' = d \\<and> p = prio then queue else ready_queues es d' p)\\<rparr>)\"\n\n\ndefinition\n  tcb_sched_action :: \"(obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list) \\<Rightarrow> obj_ref  \\<Rightarrow> unit det_ext_monad\" where\n  \"tcb_sched_action action thread \\<equiv> do\n     d \\<leftarrow> ethread_get tcb_domain thread;\n     prio \\<leftarrow> ethread_get tcb_priority thread;\n     queue \\<leftarrow> get_tcb_queue d prio;\n     set_tcb_queue d prio (action thread queue)\n   od\"\n\ndefinition\n  tcb_sched_enqueue :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list\" where\n  \"tcb_sched_enqueue thread queue \\<equiv> if (thread \\<notin> set queue) then thread # queue else queue\"\n\ndefinition\n  tcb_sched_append :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list\" where\n  \"tcb_sched_append thread queue \\<equiv> if (thread \\<notin> set queue) then queue @ [thread] else queue\"\n\ndefinition\n  tcb_sched_dequeue :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list\" where\n  \"tcb_sched_dequeue thread queue \\<equiv> filter (\\<lambda>x. x \\<noteq> thread) queue\"\n\n\ndefinition reschedule_required :: \"unit det_ext_monad\" where\n  \"reschedule_required \\<equiv> do\n     action \\<leftarrow> gets scheduler_action;\n     case action of switch_thread t \\<Rightarrow> tcb_sched_action (tcb_sched_enqueue) t | _ \\<Rightarrow> return ();\n     set_scheduler_action choose_new_thread\n   od\"\n\ndefinition\n  possible_switch_to :: \"obj_ref \\<Rightarrow> unit det_ext_monad\" where\n  \"possible_switch_to target \\<equiv> do\n     cur_dom \\<leftarrow> gets cur_domain;\n     target_dom \\<leftarrow> ethread_get tcb_domain target;\n     action \\<leftarrow> gets scheduler_action;\n\n     if (target_dom \\<noteq> cur_dom) then\n       tcb_sched_action tcb_sched_enqueue target\n     else if (action \\<noteq> resume_cur_thread) then\n       do\n         reschedule_required;\n         tcb_sched_action tcb_sched_enqueue target\n       od\n     else\n       set_scheduler_action $ switch_thread target\n   od\"\n\ndefinition\n  next_domain :: \"unit det_ext_monad\" where\n  \"next_domain \\<equiv>\n    modify (\\<lambda>s.\n      let domain_index' = (domain_index s + 1) mod length (domain_list s) in\n      let next_dom = (domain_list s)!domain_index'\n      in s\\<lparr> domain_index := domain_index',\n            cur_domain := fst next_dom,\n            domain_time := snd next_dom,\n            work_units_completed := 0\\<rparr>)\"\n\ndefinition\n  dec_domain_time :: \"unit det_ext_monad\" where\n  \"dec_domain_time = modify (\\<lambda>s. s\\<lparr>domain_time := domain_time s - 1\\<rparr>)\"\n\ndefinition set_cdt_list :: \"cdt_list \\<Rightarrow> (det_state, unit) nondet_monad\" where\n  \"set_cdt_list t \\<equiv> do\n    s \\<leftarrow> get;\n    put $ s\\<lparr> cdt_list := t \\<rparr>\n  od\"\n\ndefinition\n  update_cdt_list :: \"(cdt_list \\<Rightarrow> cdt_list) \\<Rightarrow> (det_state, unit) nondet_monad\"\nwhere\n  \"update_cdt_list f \\<equiv> do\n     t \\<leftarrow> gets cdt_list;\n     set_cdt_list (f t)\n  od\"", "property": "Nondeterministic Abstract Specification: Provides a set of abstract operations for managing threads, scheduling, and domains in a nondeterministic manner, ensuring that the system's behavior is correctly specified and constrained.\n\nThread Management: Allows for getting and setting thread properties (priority, time slice, domain), and performing scheduling actions (enqueue, dequeue, append) on threads.\n\nScheduling: Specifies rescheduling requirements, possible thread switches, and domain management (next domain, decrement domain time).\n\nDomain Management: Manages the domain list, updates the current domain, and sets the domain time.\n\nCapability Management: Updates the CDT list, allowing for the modification of capability delegations.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": " For infoflow, we want to avoid certain read actions, such as reading the priority of the\n   current thread when it could be idle. Then we need to make sure we do not rely on the result.\n   undefined is the closest we have to a result that can't be relied on "}
{"spec": "definition vs_apiobj_size where\n  \"vs_apiobj_size ty \\<equiv>\n     case ty of\n       ArchObject SmallPageObj \\<Rightarrow> pageBitsForSize ARMSmallPage\n     | ArchObject LargePageObj \\<Rightarrow> pageBitsForSize ARMLargePage\n     | ArchObject HugePageObj \\<Rightarrow> pageBitsForSize ARMHugePage\n     | ArchObject PageTableObj \\<Rightarrow> table_size NormalPT_T\n     | ArchObject VSpaceObj \\<Rightarrow> table_size VSRootPT_T\"\n\ndefinition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv>\n     if \\<not>is_device \\<and>\n        new_type \\<in> {ArchObject SmallPageObj, ArchObject LargePageObj, ArchObject HugePageObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_RAM ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else if new_type \\<in> {ArchObject PageTableObj, ArchObject VSpaceObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_PoU ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else\n       return ()\"\n\ndefinition empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (FPUState (\\<lambda>_. 0) 0 0) (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context, tcb_vcpu = None \\<rparr>\"\n\nend\nend", "property": "Initialise Architecture-Specific Objects: Initialise architecture-specific objects, including page tables, virtual space objects, and page objects, by cleaning the cache range and setting up the object's size and references. \n\nSubproperties:\n- Cache Cleaning: Clean the cache range for the newly created objects to ensure data consistency.\n- Object Size and References: Set up the object's size and references according to the object type and architecture-specific requirements.\n- Architecture-Specific TCB Initialisation: Initialise the architecture-specific parts of the TCB, including the user context and virtual CPU state.", "title": "./spec/abstract/AARCH64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "print_ast_translation \\<open>\n  let\n    fun monad_tr _ [t1, Ast.Appl [Ast.Constant @{type_syntax prod},\n                          Ast.Appl [Ast.Constant @{type_syntax set},\n                            Ast.Appl [Ast.Constant @{type_syntax prod}, t2, t3]],\n                          Ast.Constant @{type_syntax bool}]] =\n      if t3 = t1\n      then Ast.Appl [Ast.Constant @{type_syntax \"nondet_monad\"}, t1, t2]\n      else raise Match\n  in [(@{type_syntax \"fun\"}, monad_tr)] end\n\\<close>", "property": "Nondeterministic State Monad with Failure: Represents a computation that may fail, returning an error or successfully producing a value, while also encapsulating nondeterministic behavior and state modifications.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Print the type @{typ \"('s,'a) nondet_monad\"} instead of its unwieldy expansion.\n  Needs an AST translation in code, because it needs to check that the state variable\n  @{typ 's} occurs twice. This comparison is not guaranteed to always work as expected\n  (AST instances might have different decoration), but it does seem to work here."}
{"spec": "definition\nlookup_pt_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"lookup_pt_slot pd vptr \\<equiv> doE\n    pd_slot \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    (case pde of\n          PageTablePDE ptab _ _ \\<Rightarrow>   (doE\n            pt \\<leftarrow> returnOk (ptrFromPAddr ptab);\n            pt_index \\<leftarrow> returnOk ((vptr >> 12) && 0xff);\n            pt_slot \\<leftarrow> returnOk (pt + (pt_index << 2));\n            returnOk pt_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability 20)\nodE\"", "property": "Lookup Page Table Slot: Compute the pointer to the Page Table Entry (PTE) in kernel memory given a page-directory reference and a virtual address, failing if the virtual address is mapped on a section or super section. \n\nSubproperties:\n- The function first looks up the page directory slot using the page-directory reference and virtual address.\n- It then retrieves the Page Directory Entry (PDE) from the page directory slot.\n- If the PDE is a Page Table PDE, it extracts the page table address and calculates the page table index from the virtual address.\n- The function then computes the page table slot address using the page table address and index, and returns it.\n- If the PDE is not a Page Table PDE, the function throws a MissingCapability error.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PTE in kernel memory.\n  Note that the function fails if the virtual address is mapped on a section or\n  super section."}
{"spec": "definition\n  decode_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow> cdl_intent \\<Rightarrow> cdl_invocation except_monad\"\nwhere\n  \"decode_invocation invoked_cap invoked_cap_ref caps intent \\<equiv>\n    case invoked_cap of\n       \\<comment> \\<open>For endpoint-like caps, we always perform an operation,\n          regardless of the user's actual intent.\\<close>\n         EndpointCap o_id badge rights \\<Rightarrow>\n           (if Write \\<in> rights then\n             returnOk $ InvokeEndpoint (SyncMessage badge (Grant \\<in> rights) (GrantReply \\<in> rights) o_id)\n           else\n             throw)\n       | NotificationCap o_id badge rights \\<Rightarrow>\n           (if Write \\<in> rights then\n             returnOk $ InvokeNotification (Signal badge o_id)\n           else\n             throw)\n       | ReplyCap o_id rights \\<Rightarrow>\n           returnOk $ InvokeReply (ReplyMessage o_id invoked_cap_ref (Grant \\<in> rights))\n\n       \\<comment> \\<open>\n         For other operations, we only perform the user's intent\n         if it matches up with the cap.\n        \n         Note that this does not currently match the current\n         implementation: instead, the user's message will be\n         decoded into a new (undefined) intent for what the\n         cap happened to be. I propose modifying labels used to\n         avoid overlaps between different items so that we can\n         recognise when the user is invoking the wrong item.\n       \\<close>\n       | CNodeCap _ _ _ _ \\<Rightarrow>\n           doE\n             cnode_intent \\<leftarrow> throw_opt undefined $ get_cnode_intent intent;\n             liftME InvokeCNode $ decode_cnode_invocation invoked_cap invoked_cap_ref caps cnode_intent\n           odE\n       | TcbCap _ \\<Rightarrow>\n           doE\n             tcb_intent \\<leftarrow> throw_opt undefined $ get_tcb_intent intent;\n             liftME InvokeTcb $ decode_tcb_invocation invoked_cap invoked_cap_ref caps tcb_intent\n           odE\n       | IrqControlCap \\<Rightarrow>\n           doE\n             irq_control_intent \\<leftarrow> throw_opt undefined $ get_irq_control_intent intent;\n             liftME InvokeIrqControl $ decode_irq_control_invocation\n                 invoked_cap invoked_cap_ref caps irq_control_intent\n           odE\n       | IrqHandlerCap _ \\<Rightarrow>\n           doE\n             irq_handler_intent \\<leftarrow> throw_opt undefined $ get_irq_handler_intent intent;\n             liftME InvokeIrqHandler $ decode_irq_handler_invocation\n                 invoked_cap invoked_cap_ref caps irq_handler_intent\n           odE\n       | AsidPoolCap _ _\\<Rightarrow>\n           doE\n             asid_pool_intent \\<leftarrow> throw_opt undefined $ get_asid_pool_intent intent;\n             liftME InvokeAsidPool $ decode_asid_pool_invocation\n                 invoked_cap invoked_cap_ref caps asid_pool_intent\n           odE\n       | AsidControlCap \\<Rightarrow>\n           doE\n             asid_control_intent \\<leftarrow> throw_opt undefined $ get_asid_control_intent intent;\n             liftME InvokeAsidControl $ decode_asid_control_invocation\n                 invoked_cap invoked_cap_ref caps asid_control_intent\n           odE\n       | UntypedCap _ _ _ \\<Rightarrow>\n           doE\n             untyped_intent \\<leftarrow> throw_opt undefined $ get_untyped_intent intent;\n             liftME InvokeUntyped $ decode_untyped_invocation\n                 invoked_cap invoked_cap_ref caps untyped_intent\n           odE\n       | FrameCap _ _ _ _ _ _ \\<Rightarrow>\n           doE\n             page_intent \\<leftarrow> throw_opt undefined $ get_page_intent intent;\n             liftME InvokePage $ decode_page_invocation\n                 invoked_cap invoked_cap_ref caps page_intent\n           odE\n       | PageTableCap _ _ _ \\<Rightarrow>\n           doE\n             page_table_intent \\<leftarrow> throw_opt undefined $ get_page_table_intent intent;\n             liftME InvokePageTable $ decode_page_table_invocation\n                 invoked_cap invoked_cap_ref caps page_table_intent\n           odE\n       | PageDirectoryCap _ _ _ \\<Rightarrow>\n          doE\n             page_directory_intent \\<leftarrow> throw_opt undefined $ get_page_directory_intent intent;\n             liftME InvokePageDirectory $ decode_page_directory_invocation\n                 invoked_cap invoked_cap_ref caps page_directory_intent\n           odE\n       | DomainCap \\<Rightarrow>\n          doE\n            domain_intent \\<leftarrow> throw_opt undefined $ get_domain_intent intent;\n            liftME InvokeDomain $ decode_domain_invocation caps domain_intent\n          odE\n\n       \\<comment> \\<open>Don't support operations on other types of caps.\\<close>\n       | _ \\<Rightarrow> throw\"\n\nend", "property": "Decode and Validate Invocation: Transform the given intent into a validated invocation based on the type of capability, ensuring that the operation matches the capability's rights and intent. \n\nSubproperties:\n- Endpoint Capabilities: Always perform an operation (send a message) if the capability has write rights.\n- Notification Capabilities: Always perform an operation (send a signal) if the capability has write rights.\n- Reply Capabilities: Always perform an operation (send a reply message).\n- Other Capabilities: Perform the user's intent only if it matches the capability type and rights.", "title": "./spec/capDL/Decode_D.thy", "chapter": "", "section": "", "comment": "\n * Decode and validate the given intent, turning it into an\n * invocation.\n "}
{"spec": "datatype fpu_state = FPUState (fpuRegs : \"fpu_regs \\<Rightarrow> 64 word\")\n                              (fpuSr : \"32 word\")\n                              (fpuCr : \"32 word\")\n\ndatatype user_context = UserContext (fpu_state : fpu_state) (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\" where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\" where\n  \"modify_registers f uc \\<equiv> UserContext (fpu_state uc) (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\" where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext (fpu_state s) ((user_regs s) (r := v)))\"\n\ndefinition getRestartPC :: \"machine_word user_monad\" where\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition setNextPC :: \"machine_word \\<Rightarrow> unit user_monad\" where\n  \"setNextPC \\<equiv> setRegister NextIP\"", "property": "User Context Management: Provides operations to manage the user context, including getting and setting registers, modifying registers, and managing the program counter (PC) for restart and next instruction execution. \n\nGet Register: Retrieve the value of a specific register from the user context.\n\nSet Register: Update the value of a specific register in the user context.\n\nModify Registers: Apply a transformation function to the user registers in the user context.\n\nGet Restart PC: Retrieve the program counter value for restart from the user context.\n\nSet Next PC: Update the program counter value for the next instruction in the user context.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  We use Haskell naming convention here, as we translate the Haskell FPUState directly\n  to this one for use in the abstract and executable specs."}
{"spec": "type_synonym 'a preempt_monad = \"(cdl_state, cdl_preempt_error + 'a) nondet_monad\"", "property": "Preemption Monad: Represents a non-deterministic monad that handles preemption errors, providing a way to manage exceptions in a preemptive environment.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Exception monad, no further exception information "}
{"spec": "theory MachineMonad\nimports MachineTypes\nbegin\n\narch_requalify_types\n  machine_state\n  machine_state_rest\n\narch_requalify_consts\n  underlying_memory\n  underlying_memory_update\n  device_state\n  device_state_update\n  irq_masks\n  machine_state_rest\n  machine_state_rest_update", "property": "Machine State Management: Provides an interface to manage the underlying machine state, including memory, device state, and IRQ masks, allowing for controlled updates and access to these fundamental system resources.", "title": "./spec/machine/MachineMonad.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  asid_low_bits_of :: \"asid \\<Rightarrow> asid_low_index\" where\n  \"asid_low_bits_of asid \\<equiv> ucast asid\"\n\nlemmas asid_bits_of_defs =\n  asid_high_bits_of_def asid_low_bits_of_def", "property": "ASID Low Bits Extraction: Extract the low bits of a virtual ASID.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The low bits of a virtual ASID."}
{"spec": "definition\n  update_map_data :: \"arch_cap \\<Rightarrow> (word32 \\<times> word32) option \\<Rightarrow> arch_cap\" where\n  \"update_map_data cap m \\<equiv> case cap of PageCap dev p R sz _ \\<Rightarrow> PageCap dev p R sz m\n                                     | PageTableCap p _ \\<Rightarrow> PageTableCap p m\"", "property": "Update Mapping Data: Update the mapping data saved in a page or page table capability with new data. \n\nMapping Data Update Rules: \n- For a Page Capability, update the mapping data while preserving the device, physical address, read-only status, and size.\n- For a Page Table Capability, update the mapping data while preserving the physical address.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Update the mapping data saved in a page or page table capability."}
{"spec": "definition\n  receive_signal :: \"obj_ref \\<Rightarrow> cap \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n   \"receive_signal thread cap is_blocking \\<equiv> do\n    ntfnptr \\<leftarrow>\n      case cap\n        of NotificationCap ntfnptr badge rights \\<Rightarrow> return ntfnptr\n         | _ \\<Rightarrow> fail;\n    ntfn \\<leftarrow> get_notification ntfnptr;\n    case ntfn_obj ntfn\n      of IdleNtfn \\<Rightarrow>\n                   (case is_blocking of\n                     True \\<Rightarrow> do\n                          set_thread_state thread (BlockedOnNotification ntfnptr);\n                          set_notification ntfnptr $ ntfn_set_obj ntfn $ WaitingNtfn [thread]\n                        od\n                   | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n       | WaitingNtfn queue \\<Rightarrow>\n                   (case is_blocking of\n                     True \\<Rightarrow> do\n                          set_thread_state thread (BlockedOnNotification ntfnptr);\n                          set_notification ntfnptr $ ntfn_set_obj ntfn $ WaitingNtfn (queue @ [thread])\n                        od\n                   | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n       | ActiveNtfn badge \\<Rightarrow> do\n                     as_user thread $ setRegister badge_register badge;\n                     set_notification ntfnptr $ ntfn_set_obj ntfn IdleNtfn\n                   od\n    od\"", "property": "Notification Receive: Handle a receive operation on a notification object, performing the transfer if a message is waiting, or putting the thread in the endpoint's receiving queue if not, ensuring that threads can effectively receive and process notifications.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Asynchronous Message Transfers", "comment": "Handle a receive operation performed on a notification object by a\nthread. If a message is waiting then perform the transfer, otherwise put the\nthread in the endpoint's receiving queue."}
{"spec": "definition\n  freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"freeMemory ptr bits \\<equiv>\n  mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Memory Clearance: Zero out the underlying memory when freeing user memory to avoid garbage, ensuring that the exact memory content can be computed from the implementation state.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Free memory that had been initialized as user memory.\n  While freeing memory is a no-(in) the implementation,\n  we zero out the underlying memory in the specifications to avoid garbage.\n  If we know that there is no garbage,\n  we can compute from the implementation state\n  what the exact memory content in the specifications is.\n"}
{"spec": "definition\nget_hw_asid :: \"asid \\<Rightarrow> (hardware_asid,'z::state_ext) s_monad\" where\n\"get_hw_asid asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  (case maybe_hw_asid of\n    Some hw_asid \\<Rightarrow> return hw_asid\n  | None \\<Rightarrow>  do\n      new_hw_asid \\<leftarrow> find_free_hw_asid;\n      store_hw_asid asid new_hw_asid;\n      return new_hw_asid\n  od)\nod\"\n\n\nabbreviation\n  \"arm_context_switch_hwasid pd hwasid \\<equiv> do\n              set_current_pd $ addrFromPPtr pd;\n              setHardwareASID hwasid\n          od\"\n\ndefinition\n  arm_context_switch :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arm_context_switch pd asid \\<equiv> do\n      hwasid \\<leftarrow> get_hw_asid asid;\n      do_machine_op $ arm_context_switch_hwasid pd hwasid\n    od\"", "property": "Get Hardware ASID: Retrieve the hardware ASID associated with a virtual ASID, assigning a new one if none is already assigned.\nContext Switch: Perform a context switch by setting the current page directory and hardware ASID for a given virtual ASID.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get the hardware ASID associated with a virtual ASID, assigning one if\nnone is already assigned."}
{"spec": "type_synonym cdl_io_pagetable_level = nat", "property": "Pagetable Depth: The depth of an IA32 pagetable is a natural number.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The depth of a particular IA32 pagetable. "}
{"spec": "definition\n  get_tcb :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> tcb option\"\nwhere\n  \"get_tcb tcb_ref state \\<equiv>\n   case kheap state tcb_ref of\n      None      \\<Rightarrow> None\n    | Some kobj \\<Rightarrow> (case kobj of\n        TCB tcb \\<Rightarrow> Some tcb\n      | _       \\<Rightarrow> None)\"\n\ndefinition\n  thread_get :: \"(tcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"thread_get f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     return $ f tcb\n   od\"\n\ndefinition\n  thread_set :: \"(tcb \\<Rightarrow> tcb) \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"thread_set f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     set_object tptr $ TCB $ f tcb\n   od\"\n\ndefinition\n  arch_thread_get :: \"(arch_tcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"arch_thread_get f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     return $ f (tcb_arch tcb)\n   od\"\n\ndefinition\n  arch_thread_set :: \"(arch_tcb \\<Rightarrow> arch_tcb) \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"arch_thread_set f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     set_object tptr $ TCB $ tcb \\<lparr> tcb_arch := f (tcb_arch tcb) \\<rparr>\n   od\"\n\ndefinition\n  get_thread_state :: \"obj_ref \\<Rightarrow> (thread_state,'z::state_ext) s_monad\"\nwhere\n  \"get_thread_state ref \\<equiv> thread_get tcb_state ref\"\n\ndefinition\n  get_bound_notification :: \"obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\"\nwhere\n  \"get_bound_notification ref \\<equiv> thread_get tcb_bound_notification ref\"\n\ndefinition\n  set_bound_notification :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"set_bound_notification ref ntfn \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb ref;\n     set_object ref (TCB (tcb \\<lparr> tcb_bound_notification := ntfn \\<rparr>))\n   od\"\n\ndefinition set_thread_state_ext :: \"obj_ref \\<Rightarrow> unit det_ext_monad\" where\n  \"set_thread_state_ext t \\<equiv> do\n     ts \\<leftarrow> get_thread_state t;\n     cur \\<leftarrow> gets cur_thread;\n     action \\<leftarrow> gets scheduler_action;\n     when (\\<not> (runnable ts) \\<and> cur = t \\<and> action = resume_cur_thread) (set_scheduler_action choose_new_thread)\n   od\"\n\ndefinition\n  set_thread_state :: \"obj_ref \\<Rightarrow> thread_state \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_thread_state ref ts \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb ref;\n     set_object ref (TCB (tcb \\<lparr> tcb_state := ts \\<rparr>));\n     do_extended_op (set_thread_state_ext ref)\n   od\"\n\ndefinition\n  set_priority :: \"obj_ref \\<Rightarrow> priority \\<Rightarrow> unit det_ext_monad\" where\n  \"set_priority tptr prio \\<equiv> do\n     tcb_sched_action tcb_sched_dequeue tptr;\n     thread_set_priority tptr prio;\n     ts \\<leftarrow> get_thread_state tptr;\n     when (runnable ts) $ do\n       cur \\<leftarrow> gets cur_thread;\n       if tptr = cur then reschedule_required else possible_switch_to tptr\n     od\n   od\"\n\ndefinition\n  set_mcpriority :: \"obj_ref \\<Rightarrow> priority \\<Rightarrow> (unit, 'z::state_ext) s_monad\"  where\n  \"set_mcpriority ref mcp \\<equiv> thread_set (\\<lambda>tcb. tcb\\<lparr>tcb_mcpriority:=mcp\\<rparr>) ref \"", "property": "TCB Access and Modification: Provides functions to access and modify thread control blocks (TCBs) in the kernel heap, including retrieving TCBs, getting and setting thread states, priorities, and bound notifications, and updating TCB fields.\n\nSubproperties:\n- TCB Retrieval: Retrieves a TCB from the kernel heap using its object reference.\n- Thread State Management: Gets and sets the state of a thread, including its current state and bound notification.\n- Priority Management: Sets the priority of a thread and updates the scheduler accordingly.\n- TCB Field Updates: Updates specific fields of a TCB, such as its priority and bound notification.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "TCBs", "comment": ""}
{"spec": "consts' initL2Cache_impl :: \"unit machine_rest_monad\"\ndefinition initL2Cache :: \"unit machine_monad\" where\n  \"initL2Cache \\<equiv> machine_op_lift initL2Cache_impl\"\n\nconsts' isb_impl :: \"unit machine_rest_monad\"\ndefinition isb :: \"unit machine_monad\" where\n  \"isb \\<equiv> machine_op_lift isb_impl\"\n\nconsts' dsb_impl :: \"unit machine_rest_monad\"\ndefinition dsb :: \"unit machine_monad\" where\n  \"dsb \\<equiv> machine_op_lift dsb_impl\"\n\nconsts' invalidateTranslationASID_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateTranslationASID :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateTranslationASID asid \\<equiv> machine_op_lift (invalidateTranslationASID_impl asid)\"\n\nconsts' invalidateTranslationSingle_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateTranslationSingle :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateTranslationSingle r \\<equiv> machine_op_lift (invalidateTranslationSingle_impl r)\"\n\nconsts' cleanByVA_PoU_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanByVA_PoU :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanByVA_PoU vaddr paddr = machine_op_lift (cleanByVA_PoU_impl vaddr paddr)\"\n\nconsts' cleanInvalidateCacheRange_RAM_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanInvalidateCacheRange_RAM ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanInvalidateCacheRange_RAM vstart vend pstart =\n     machine_op_lift (cleanInvalidateCacheRange_RAM_impl vstart vend pstart)\"\n\nconsts' cleanCacheRange_RAM_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanCacheRange_RAM ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanCacheRange_RAM vstart vend pstart =\n     machine_op_lift (cleanCacheRange_RAM_impl vstart vend pstart)\"\n\nconsts' cleanCacheRange_PoU_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanCacheRange_PoU ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanCacheRange_PoU vstart vend pstart =\n     machine_op_lift (cleanCacheRange_PoU_impl vstart vend pstart)\"\n\nconsts' invalidateCacheRange_RAM_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateCacheRange_RAM ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateCacheRange_RAM vstart vend pstart =\n     machine_op_lift (invalidateCacheRange_RAM_impl vstart vend pstart)\"\n\nconsts' invalidateCacheRange_I_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateCacheRange_I ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateCacheRange_I vstart vend pstart =\n     machine_op_lift (invalidateCacheRange_I_impl vstart vend pstart)\"\n\nconsts' branchFlushRange_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition branchFlushRange ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"branchFlushRange vstart vend pstart = machine_op_lift (branchFlushRange_impl vstart vend pstart)\"\n\nlemmas cache_machine_op_defs =\n  invalidateTranslationASID_def\n  invalidateTranslationSingle_def\n  cleanByVA_PoU_def\n  cleanInvalidateCacheRange_RAM_def\n  cleanCacheRange_RAM_def\n  cleanCacheRange_PoU_def\n  invalidateCacheRange_RAM_def\n  invalidateCacheRange_I_def\n  branchFlushRange_def", "property": "Cache Management Operations: Provide a set of operations for managing caches, including initialization, flushing, and invalidation of cache ranges, as well as branch prediction flushing, to ensure cache coherence and consistency.\n\nSubproperties:\n- Cache Initialization: Initialize the L2 cache to a consistent state.\n- Cache Flushing: Flush cache ranges to ensure that changes are written back to memory.\n- Cache Invalidation: Invalidate cache ranges to ensure that stale data is not used.\n- Branch Prediction Flushing: Flush branch prediction caches to ensure that branch prediction is accurate.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition\nlookup_pd_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"lookup_pd_slot pd vptr \\<equiv> doE\n    pdpt_slot \\<leftarrow> lookup_pdpt_slot pd vptr;\n    pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n    (case pdpte of\n          PageDirectoryPDPTE tab _ _ \\<Rightarrow> (doE\n            pd \\<leftarrow> returnOk (ptrFromPAddr tab);\n            pd_index \\<leftarrow> returnOk (get_pd_index vptr);\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << word_size_bits));\n            returnOk pd_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability pdpt_shift_bits)\n odE\"", "property": "Lookup Page Directory Slot: Compute the pointer to the Page Directory Entry (PDE) in kernel memory given a page-directory reference and a virtual address. \n\nSubproperties:\n- Retrieve the PDPT slot for the given page-directory reference and virtual address.\n- Get the PDPT entry from the PDPT slot.\n- If the PDPT entry is a Page Directory PDPTE, extract the page directory pointer, calculate the PD index from the virtual address, and compute the PD slot address.\n- If the PDPT entry is not a Page Directory PDPTE, throw a MissingCapability error.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PDE in kernel memory"}
{"spec": "datatype arch_copy_register_sets = ARMNoExtraRegisters\n\ndefinition \"ArchDefaultExtraRegisters \\<equiv> ARMNoExtraRegisters\"\n\ndatatype arch_irq_control_invocation =\n    ArchIRQControlIssue irq cslot_ptr cslot_ptr bool\n\nend\n\nend", "property": "ARM Platform Register Sets: The ARM platform currently does not define any additional register sets for the \"CopyRegisters\" operation, with a default value of ARMNoExtraRegisters.", "title": "./spec/abstract/ARM_HYP/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": " The ARM platform currently does not define any additional register sets for\nthe \"CopyRegisters\" operation. This may be changed in future to support a floating point unit. "}
{"spec": "definition\n  set_vm_root :: \"word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"set_vm_root tcb \\<equiv> do\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    (case thread_root of\n       ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow> doE\n           pd' \\<leftarrow> find_pd_for_asid asid;\n           whenE (pd \\<noteq> pd') $ throwError InvalidRoot;\n           liftE $ arm_context_switch pd asid\n       odE\n     | _ \\<Rightarrow> throwError InvalidRoot) <catch>\n    (\\<lambda>_. do\n       global_us_pd \\<leftarrow> gets (arm_us_global_pd o arch_state);\n       do_machine_op $ set_current_pd $ addrFromKPPtr global_us_pd\n    od)\nod\"", "property": "Set Virtual Memory Root: Switch into the address space of a given thread or the global address space if the thread's address space is not correctly configured. \n\nSubproperties:\n- Validate Thread Address Space: Check if the thread's address space is correctly configured by verifying the page directory and address space identifier.\n- Switch to Global Address Space: If the thread's address space is not correctly configured, switch to the global address space.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch into the address space of a given thread or the global address\nspace if none is correctly configured."}
{"spec": "definition zipWithM_x ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> ('s,'c) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> ('s, unit) nondet_monad\"\n  where\n  \"zipWithM_x f xs ys \\<equiv> sequence_x (zipWith f xs ys)\"", "property": "Map Function over Two Lists: Apply a monadic function to two lists in parallel, discarding return values, and return a unit value in the nondeterministic state monad.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  Map a monadic function with two parameters over two lists,\n  going through both lists simultaneously, left to right, ignoring\n  return values."}
{"spec": "fun ensure_safe_mapping ::\n  \"(pte * word32 list) + (pde * word32 list) \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n\"ensure_safe_mapping (Inl (InvalidPTE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inl (SmallPagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda>slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | SmallPagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst)\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inl (LargePagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | LargePagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inr (InvalidPDE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inr (PageTablePDE _ _ _, _)) = fail\"\n|\n\"ensure_safe_mapping (Inr (SectionPDE _ _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SectionPDE _ _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"\n|\n\"ensure_safe_mapping (Inr (SuperSectionPDE _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SuperSectionPDE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"", "property": "Ensure Safe Mapping: Verify that page table or directory entries being replaced are either invalid or have the same granularity as the new entry, preventing unsafe mappings that could compromise memory integrity. \n\nSubproperties:\n- Invalid entries can be safely replaced.\n- Entries of the same granularity (e.g., SmallPagePTE, LargePagePTE, SectionPDE, SuperSectionPDE) can be safely replaced.\n- Entries of different granularities cannot be replaced, throwing a DeleteFirst error.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Placing an entry which maps a frame within the set of entries that map a\nlarger frame is unsafe. This function checks that given entries replace either\ninvalid entries or entries of the same granularity."}
{"spec": "definition debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\" where\n  debugPrint_def[simp]:\n  \"debugPrint \\<equiv> \\<lambda>message. return ()\"", "property": "Debug Print Operation: Ignore any debug print messages and do nothing.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition\n  block_thread_on_ipc :: \"cdl_object_id \\<Rightarrow> cdl_cap \\<Rightarrow> unit k_monad\"\nwhere\n  \"block_thread_on_ipc tcb cap \\<equiv> set_cap (tcb, tcb_pending_op_slot) cap\" (* Might need to do some check here *)\n\ndefinition\n  lookup_extra_caps :: \"cdl_object_id \\<Rightarrow> cdl_cptr list \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list fault_monad\"\nwhere\n  \"lookup_extra_caps thread cptrs \\<equiv>\n     mapME (\\<lambda>cptr. lookup_cap_and_slot thread cptr) cptrs\"", "property": "Thread IPC Blocking: Mark a thread as blocked on IPC, granting it an implicit \"send once\" or \"receive once\" capability to ensure the transfer can proceed even if the original capability is revoked.\n\nLookup Extra Caps: Retrieve the extra capabilities associated with a thread by looking up the capability pointers in the thread's capability space.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Mark a thread blocked on IPC.\n *\n * Theads get a new implicit \"send once\" or \"receive once\" capability\n * when they block on an IPC. This is because if the capability they\n * used to start the send/receive is revoked, the transfer will still be\n * allowed to proceed (even if it is at a much later point in time).\n "}
{"spec": "type_synonym obj_ref            = machine_word\ntype_synonym vspace_ref         = machine_word\n\ntype_synonym data               = machine_word\ntype_synonym cap_ref            = \"bool list\"\ntype_synonym length_type        = machine_word\n\ntype_synonym asid_low_len      = 9\ntype_synonym asid_low_index    = \"asid_low_len word\"\n\ntype_synonym asid_high_len      = 3\ntype_synonym asid_high_index    = \"asid_high_len word\"", "property": "Type Instantiation: Define concrete types for abstract type names in the specification for the x64 architecture, including object references, virtual space references, data, capability references, and length types. \n\n Subproperties:\n- Object Reference Type: obj_ref is instantiated as machine_word.\n- Virtual Space Reference Type: vspace_ref is instantiated as machine_word.\n- Data Type: data is instantiated as machine_word.\n- Capability Reference Type: cap_ref is instantiated as a list of boolean values.\n- Length Type: length_type is instantiated as machine_word.\n- ASID Low Length: asid_low_len is set to 9.\n- ASID Low Index Type: asid_low_index is instantiated as a 9-bit word.\n- ASID High Length: asid_high_len is set to 3.\n- ASID High Index Type: asid_high_index is instantiated as a 3-bit word.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object\n  references, user pointers, word-based data, cap references, and so\n  on. This theory provides an instantiation of these names to concrete\n  types for the x64 architecture. Other architectures may have slightly\n  different instantiations.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/AARCH64.hs CONTEXT AARCH64_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Define an enumeration of system call labels specific to the AARCH64 architecture.", "title": "./spec/design/skel/AARCH64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "hide_const (open)\n  numDomains", "property": "Name Hiding: Hide unqualified names that conflict with Kernel_Config names, forcing the use of the Kernel_C prefix to avoid naming conflicts and ensure clarity in the kernel configuration.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "definition\n  tcb_update_vspace_root :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_vspace_root target_tcb tcb_cap_ref vroot \\<equiv>\n  doE\n     tcb_empty_thread_slot target_tcb tcb_vspace_slot;\n     src_cap \\<leftarrow> liftE $ get_cap (snd vroot);\n     whenE (cdl_same_arch_obj_as (fst vroot) src_cap)\n       $ tcb_update_thread_slot target_tcb tcb_cap_ref tcb_vspace_slot vroot\n  odE\"", "property": "Update Thread's VSpace Root: Update a thread's virtual space root by emptying the current thread slot, retrieving the source capability, and updating the thread slot with the new virtual space root if the architectures match. \n\nSubproperties:\n- Empty the current thread slot for the VSpace root.\n- Retrieve the source capability for the new VSpace root.\n- Update the thread slot with the new VSpace root if the architectures match.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update a thread's VSpace root. "}
{"spec": "definition\n  vcpu_restore :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_restore vr \\<equiv> do\n     do_machine_op $ set_gic_vcpu_ctrl_hcr 0;  \\<comment> \\<open>turn off VGIC\\<close>\n     do_machine_op $ isb;\n     vcpu \\<leftarrow> get_vcpu vr;  \\<comment> \\<open>restore GIC VCPU control state\\<close>\n     vgic \\<leftarrow> return (vcpu_vgic vcpu);\n     num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     gicIndices \\<leftarrow> return [0..<num_list_regs];\n     do_machine_op $ do\n         set_gic_vcpu_ctrl_vmcr (vgic_vmcr vgic);\n         set_gic_vcpu_ctrl_apr (vgic_apr vgic);\n         mapM (\\<lambda>p. set_gic_vcpu_ctrl_lr (of_nat (fst p)) (snd p))\n              (map (\\<lambda>i. (i, (vgic_lr vgic) i)) gicIndices)\n     od;\n    \\<comment> \\<open>restore banked VCPU registers except SCTLR (that's in VCPUEnable)\\<close>\n     vcpu_restore_reg_range vr VCPURegACTLR VCPURegSPSRfiq;\n     vcpu_enable vr\n  od\"", "property": "VCPU Restore: Restore the state of a VCPU, including turning off VGIC, restoring GIC VCPU control state, and restoring banked VCPU registers, to prepare it for execution.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Register + context restore for VCPUs"}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\nrequalify_consts RISCVSmallPage RISCVLargePage RISCVHugePage\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 9\"\n\ndefinition\n  ctcb_offset :: \"64 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Appropriately Qualified Aliases: Define and requalify constants for architecture-specific page sizes and create aliases for TCB size and offset.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/ARM.lhs CONTEXT ARM_HYP_H ARMHardware=ARM_HYP bodies_only\n\nend\nend", "property": "No specific property can be summarized from the given code snippet as it appears to be a header or import section, and does not contain any specific functionality or behavior that can be described as a property.", "title": "./spec/design/skel/ARM_HYP/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masks Initialization: All IRQs are masked after kernel initialization.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  get_receive_slot :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref option k_monad\"\nwhere\n  \"get_receive_slot thread \\<equiv>\n    do\n      tcb \\<leftarrow> get_thread thread;\n      recv_slot \\<leftarrow> (case (cdl_tcb_caps tcb tcb_ipcbuffer_slot) of (Some (FrameCap _ _ rights _ _ _)) \\<Rightarrow>\n        if (Read \\<in> rights \\<and> Write \\<in> rights)\n          then return (cdl_intent_recv_slot (cdl_tcb_intent tcb))\n        else\n          return None\n      | _ \\<Rightarrow> return None);\n      case ( recv_slot ) of\n          None \\<Rightarrow>\n            return None\n        | Some (croot, index, depth) \\<Rightarrow>\n            doE\n              \\<comment> \\<open>Lookup the slot.\\<close>\n              cspace_root \\<leftarrow> unify_failure $ lookup_cap thread croot;\n              result \\<leftarrow> unify_failure $ lookup_slot_for_cnode_op cspace_root index depth;\n\n              \\<comment> \\<open>Ensure nothing is already in it.\\<close>\n              cap \\<leftarrow> liftE $ get_cap result;\n              whenE (cap \\<noteq> NullCap) throw;\n\n              returnOk $ Some result\n            odE <catch> (\\<lambda>_. return None)\n    od\n  \"", "property": "Get Receive Slot: Determine the slot where an incoming capability should be placed for a particular thread, ensuring the slot is empty and the thread has the necessary read and write rights to its IPC buffer. \n\nSlot Lookup: Perform a lookup to find the slot, handling potential failures and ensuring the slot is empty before returning it.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Get the slot where we should place an incoming cap for a\n * particular thread.\n "}
{"spec": "definition\n  load_word_offs :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n \"load_word_offs ptr offs \\<equiv>\n    do_machine_op $ loadWord (ptr + of_nat (offs * word_size))\"\ndefinition\n  load_word_offs_word :: \"obj_ref \\<Rightarrow> data \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n \"load_word_offs_word ptr offs \\<equiv>\n    do_machine_op $ loadWord (ptr + (offs * word_size))\"", "property": "Load Word Offsets: Load a machine word from a memory location specified by an object reference and an offset, either as a natural number or a data type, ensuring that the word is retrieved correctly from the memory address calculated by adding the offset to the base address.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": ""}
{"spec": "text \\<open>Interpret a set of rights from a user data word.\\<close>\ndefinition\n  data_to_rights :: \"data \\<Rightarrow> cap_rights\" where\n  \"data_to_rights data \\<equiv> let\n    w = data_to_16 data\n   in {x. case x of AllowWrite \\<Rightarrow> w !! 0\n                  | AllowRead \\<Rightarrow> w !! 1\n                  | AllowGrant \\<Rightarrow> w !! 2\n                  | AllowGrantReply \\<Rightarrow> w !! 3}\"", "property": "Data to Rights Conversion: Convert a user data word to a set of capability rights, where each right (AllowWrite, AllowRead, AllowGrant, AllowGrantReply) is determined by a specific bit in the data word.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Resolving capability references", "comment": ""}
{"spec": "definition\n  diminish :: \"right set \\<Rightarrow> cap \\<Rightarrow> cap\" where\n  \"diminish R cap \\<equiv> cap \\<lparr> rights := rights cap \\<inter> R \\<rparr>\"\n\ndefinition\n  createOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> modify_state\" where\n  \"createOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity (insert (full_cap (target c\\<^sub>2))\n                                (direct_caps_of s (target c\\<^sub>1))),\n     target c\\<^sub>2 \\<mapsto> null_entity)\"\n\nlemma createOperation_def2:\n  \"createOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  let new_cap = \\<lparr> target = target c\\<^sub>2, rights = all_rights \\<rparr>;\n      newTarget = ({new_cap} \\<union> direct_caps_of s (target c\\<^sub>1) )\n  in\n  s (target c\\<^sub>1 \\<mapsto> Entity newTarget, target c\\<^sub>2 \\<mapsto> null_entity)\"\n  by (simp add: createOperation_def Let_def full_cap_def null_entity_def)\n\ndefinition\n  takeOperation :: \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"takeOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (e \\<mapsto> Entity (insert (diminish R c\\<^sub>2) (direct_caps_of s e)))\"\n\nlemma takeOperation_def2:\n  \"takeOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (e \\<mapsto> Entity ({diminish R c\\<^sub>2} \\<union> direct_caps_of s e))\"\n  by (clarsimp simp: takeOperation_def caps_of_def)\n\ndefinition\n  grantOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"grantOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity (insert (diminish R c\\<^sub>2) (direct_caps_of s (target c\\<^sub>1)) )) \"\n\nlemma grantOperation_def2:\n  \"grantOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity ( {diminish R c\\<^sub>2} \\<union> direct_caps_of s (target c\\<^sub>1)))\"\n  by (clarsimp simp: grantOperation_def caps_of_def)\n\ndefinition\n  copyOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"copyOperation sRef c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity (insert (diminish R c\\<^sub>2) (direct_caps_of s (target c\\<^sub>1)))) \"\n\ndefinition\n  removeOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> modify_state\" where\n  \"removeOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  if is_entity s (target c\\<^sub>1)\n  then\n     s ((target c\\<^sub>1) \\<mapsto> Entity ((direct_caps_of s (target c\\<^sub>1)) - {c\\<^sub>2} ))\n  else\n     s\"\n\nlemma removeOperation_simpler:\n  \"removeOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  (case s (target c\\<^sub>1) of\n    None \\<Rightarrow> s\n  | Some (Entity caps) \\<Rightarrow> s (target c\\<^sub>1 \\<mapsto> Entity (caps - {c\\<^sub>2})))\"\n  by (rule eq_reflection, simp add: removeOperation_def is_entity_def direct_caps_of_def\n                             split: if_split_asm option.splits)\n\ndefinition\n  removeSetOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap set \\<Rightarrow> modify_state\" where\n  \"removeSetOperation e c C s \\<equiv>\n  if is_entity s (target c) then\n   s ((target c) \\<mapsto> Entity ((direct_caps_of s (target c)) - C ))\n  else\n   s\"\n\nlemma removeSetOperation_simpler:\n  \"removeSetOperation e c caps s \\<equiv>\n  (case s (target c) of\n    None \\<Rightarrow> s\n  | Some (Entity caps') \\<Rightarrow> s (target c \\<mapsto> Entity (caps' - caps)))\"\n  by (auto simp: removeSetOperation_def is_entity_def direct_caps_of_def\n         intro!: eq_reflection\n          split: if_split_asm option.splits)\n\nlemma removeSetOperation_fold_removeOperation:\n  \"removeSetOperation e c (set caps) s = fold (removeOperation e c) caps s\"\n  apply (subst foldr_fold [symmetric])\n   apply (fastforce simp: removeOperation_def direct_caps_of_def is_entity_def)\n  apply (rule sym)\n  apply (induct caps)\n   apply (fastforce simp: removeSetOperation_def removeOperation_def direct_caps_of_def is_entity_def)\n  apply (fastforce simp: removeSetOperation_def removeOperation_def direct_caps_of_def is_entity_def)\n  done\n\ndefinition\n  removeSetOfCaps :: \"(entity_id \\<Rightarrow> cap set) \\<Rightarrow> modify_state\"\nwhere\n  \"removeSetOfCaps cap_map s \\<equiv> \\<lambda>e.\n     if is_entity s e\n     then Some (Entity ((direct_caps_of s e) - cap_map e ))\n     else None\"\n\ndefinition\n  caps_to_entity :: \"entity_id \\<Rightarrow> entity_id \\<Rightarrow> state \\<Rightarrow> cap set\"\nwhere\n  \"caps_to_entity e e' s \\<equiv> {cap. cap \\<in> direct_caps_of s e' \\<and> target cap = e}\"\n\ndefinition\n  revokeOperation :: \"entity_id \\<Rightarrow> cap \\<Rightarrow> modify_state_n\" where\n  \"revokeOperation e c s \\<equiv>\n    {s'. \\<exists>cap_map. \\<forall>e'. cap_map e' \\<subseteq> caps_to_entity (target c) e' s \\<and>\n         s' = removeSetOfCaps cap_map s}\"\n\ndefinition\n  destroyOperation :: \"entity_id \\<Rightarrow> cap \\<Rightarrow> modify_state\" where\n  \"destroyOperation e c s \\<equiv> s(target c := None)\"", "property": "System Operations: Define how various system operations (create, take, grant, copy, remove, remove set, revoke, and destroy) modify the system state by manipulating capabilities and entity relationships.\n\nSubproperties:\n- Create Operation: Creates a new capability and adds it to an entity's direct capabilities.\n- Take Operation: Adds a diminished capability to an entity's direct capabilities.\n- Grant Operation: Adds a diminished capability to the direct capabilities of the target entity of another capability.\n- Copy Operation: Copies a diminished capability to the direct capabilities of the target entity of another capability.\n- Remove Operation: Removes a capability from an entity's direct capabilities.\n- Remove Set Operation: Removes a set of capabilities from an entity's direct capabilities.\n- Revoke Operation: Removes a set of capabilities related to a specific entity from the system state.\n- Destroy Operation: Removes an entity from the system state.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Following functions define how each of the sysOPs modifies the\n * system state_s\n "}
{"spec": "definition\n  cancel_ipc :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_ipc tptr \\<equiv> do\n     state \\<leftarrow> get_thread_state tptr;\n     case state\n       of\n          BlockedOnSend x y \\<Rightarrow> blocked_cancel_ipc state tptr\n        | BlockedOnReceive x y \\<Rightarrow> blocked_cancel_ipc state tptr\n        | BlockedOnNotification event \\<Rightarrow> cancel_signal tptr event\n        | BlockedOnReply \\<Rightarrow> reply_cancel_ipc tptr\n        | _ \\<Rightarrow> return ()\n   od\"", "property": "Cancel IPC Operations: Cancel any ongoing message operations that a thread is waiting on, handling different blocking scenarios such as sending, receiving, notification, and reply.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel any message operations a given thread is waiting on."}
{"spec": "definition\nlookup_pt_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"lookup_pt_slot vspace vptr \\<equiv> doE\n    pd_slot \\<leftarrow> lookup_pd_slot vspace vptr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    (case pde of\n          PageTablePDE ptab _ _ \\<Rightarrow>   (doE\n            pt \\<leftarrow> returnOk (ptrFromPAddr ptab);\n            pt_index \\<leftarrow> returnOk (get_pt_index vptr);\n            pt_slot \\<leftarrow> returnOk (pt + (pt_index << word_size_bits));\n            returnOk pt_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability pd_shift_bits)\n   odE\"", "property": "Lookup Page Table Slot: Compute the pointer to the Page Table Entry (PTE) in kernel memory for a given virtual address and page-directory reference, failing if the virtual address is mapped on a section or super section. \n\nSubproperties:\n- Retrieve the page directory slot for the given virtual address.\n- Get the Page Directory Entry (PDE) from the page directory slot.\n- If the PDE is a Page Table PDE, calculate the page table index and slot.\n- Return the page table slot if successful, or throw an error if the PDE is not a Page Table PDE.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PTE in kernel memory.\n  Note that the function fails if the virtual address is mapped on a section or\n  super section."}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversions: Define conversions between different data types, including object references, virtual references, lengths, and capability pointers, to facilitate automatic unfolding in proofs.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "(*\n * Accessor functions for objects and caps.\n *)\n\ntheory KHeap_D\nimports Monads_D\nbegin", "property": "No properties can be extracted from this code snippet as it does not contain any specific functionality or behavior. It appears to be a header or import statement for a theory in a formal verification framework.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition kernel_elf_base :: \"vspace_ref\" where\n  \"kernel_elf_base \\<equiv> Platform.AARCH64.kernelELFBase\"", "property": "Kernel ELF Base Address: The kernel ELF base address is set to a specific virtual address, providing a fixed location for the kernel code in the virtual address space.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The virtual address the kernel code is mapped.\n"}
{"spec": "definition\n  label_to_flush_type :: \"invocation_label \\<Rightarrow> flush_type\"\nwhere\n  \"label_to_flush_type label \\<equiv> case label of\n       ArchInvocationLabel ARMPDClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPageClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPDInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPageInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPDCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPageCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPDUnify_Instruction \\<Rightarrow> Unify\n     | ArchInvocationLabel ARMPageUnify_Instruction \\<Rightarrow> Unify\"", "property": "Architecture-specific System Call Decoding: Maps user-supplied invocation labels to specific flush types, determining the method to invoke for various architecture-specific system calls. \n\nFlush Type Mapping: Maps invocation labels to flush types, including Clean, Invalidate, CleanInvalidate, and Unify, to facilitate the execution of architecture-specific system calls.", "title": "./spec/abstract/ARM/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": "This definition converts a user-supplied argument into an\ninvocation label, used to determine the method to invoke.\n"}
{"spec": "record arch_tcb =\n  tcb_context :: user_context\n  tcb_vcpu    :: \"obj_ref option\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition default_arch_tcb :: arch_tcb where\n  \"default_arch_tcb \\<equiv> \\<lparr>tcb_context = new_context, tcb_vcpu = None\\<rparr>\"", "property": "Arch-Specific TCB Structure: The arch-specific part of a TCB contains fields for user context and an optional VCPU reference, ensuring that the TCB can manage user-level execution contexts and potentially associated VCPUs. \n\nDefault Arch-Specific TCB: The default arch-specific TCB has an initial user context and no associated VCPU.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Arch-specific TCB", "comment": " Arch-specific part of a TCB: this must have at least a field for user context. "}
{"spec": "definition \"irqInvalid       \\<equiv> 255 :: irq\"\ndefinition \"INTERRUPT_PMU    \\<equiv> 23 :: irq\"\ndefinition \"INTERRUPT_EPIT1  \\<equiv> 28 :: irq\"\ndefinition \"KERNEL_TIMER_IRQ \\<equiv> INTERRUPT_EPIT1\"", "property": "Platform Constants: Define specific interrupt request (IRQ) constants for the iMX31 platform, including invalid IRQ, and IRQs for the performance monitoring unit (PMU), EPIT1 timer, and kernel timer.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Platform constants (iMX31)", "comment": ""}
{"spec": "instantiation X64_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pte updateObject_pte\n  loadObject_pde updateObject_pde\n  loadObject_pdpte updateObject_pdpte\n  loadObject_pml4e updateObject_pml4e\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Object Management: Create, load, and update ASID pool objects with a fixed-size array of 2^32 entries, initialized with null values, ensuring efficient management of address space identifiers.", "title": "./spec/design/skel/X64/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "definition mapM_x :: \"('a \\<Rightarrow> ('s,'b) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"mapM_x f xs \\<equiv> sequence_x (map f xs)\"", "property": "Map Function Over List: Apply a monadic function to each element of a list from left to right, ignoring return values.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  Map a monadic function over a list by applying it to each element\n  of the list from left to right, ignoring return values."}
{"spec": "definition arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\" where\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n     (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n       delete_asid_pool b ptr;\n       return (NullCap, NullCap)\n     od\n   | (PageTableCap ptr VSRootPT_T (Some (a, v)), True) \\<Rightarrow> do\n       delete_asid a ptr;\n       return (NullCap, NullCap)\n     od\n   | (PageTableCap ptr NormalPT_T (Some (a, v)), True) \\<Rightarrow> do\n       unmap_page_table a v ptr;\n       return (NullCap, NullCap)\n     od\n   | (FrameCap ptr _ sz _ (Some (a, v)), _) \\<Rightarrow> do\n       unmap_page sz a v ptr;\n       return (NullCap, NullCap)\n     od\n   | (VCPUCap vcpu_ref, True) \\<Rightarrow> do\n      vcpu_finalise vcpu_ref;\n      return (NullCap, NullCap)\n     od\n   | _ \\<Rightarrow> return (NullCap, NullCap)\"", "property": "Architectural Capability Finalisation: Ensure that AARCH64-specific capabilities are properly cleaned up upon finalisation, including deleting ASID pools, unmapping page tables and frames, and finalising VCPUs, to maintain the integrity of the system's architectural state.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of AARCH64-specific capabilities."}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs CONTEXT Arch decls_only ArchInv=\n\nend\n\nend", "property": "No property can be extracted from this code snippet as it appears to be a header or import declaration and does not contain any specific functionality or behavior that can be summarized as a property.", "title": "./spec/design/skel/ARM_HYP/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Handle Hyperviser Fault Event\"\n\ntheory Hypervisor_A\nimports Exceptions_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"machine_word \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n\"handle_hypervisor_fault thread X64NoHypFaults = return ()\"\n\n\nend\nend", "property": "Handle Hypervisor Fault Event: Ignore X64NoHypFaults type faults.", "title": "./spec/abstract/X64/Hypervisor_A.thy", "chapter": "Handle Hyperviser Fault Event", "section": "", "comment": ""}
{"spec": "fun\n  invoke_irq_control :: \"irq_control_invocation \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"invoke_irq_control (IRQControl irq handler_slot control_slot) =\n     liftE (do set_irq_state IRQSignal irq;\n               cap_insert (IRQHandlerCap irq) control_slot handler_slot od)\"\n| \"invoke_irq_control (ArchIRQControl invok) =\n     arch_invoke_irq_control invok\"", "property": "IRQ Control Invocation: Allows the IRQControl capability to create a new IRQHandler capability and perform architecture-specific interrupt actions. \n\nSubproperties:\n- Set IRQ State: Set the IRQ state to IRQSignal for a specific IRQ.\n- Create IRQHandler Capability: Create a new IRQHandler capability for a specific IRQ and insert it into the specified slots.\n- Architecture-Specific Interrupt Actions: Perform architecture-specific interrupt actions through the ArchIRQControl invocation.", "title": "./spec/abstract/Interrupt_A.thy", "chapter": "", "section": "", "comment": "The IRQControl capability can be used to create a new IRQHandler\ncapability as well as to perform whatever architecture specific interrupt\nactions are available."}
{"spec": "definition\n  clear_object_caps :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n \"clear_object_caps ptr = do\n    ptrs \\<leftarrow> gets (\\<lambda>s. {cptr. fst cptr = ptr \\<and> opt_cap cptr s \\<noteq> None});\n    ptrlist \\<leftarrow> select {xs. set xs = ptrs \\<and> distinct xs};\n    mapM_x empty_slot ptrlist\n  od\"\n\ndefinition cdl_default_tcb :: \"cdl_object\"\nwhere \"cdl_default_tcb \\<equiv>  Tcb \\<lparr>cdl_tcb_caps =\n           [tcb_cspace_slot \\<mapsto> cdl_cap.NullCap, tcb_vspace_slot \\<mapsto> cdl_cap.NullCap, tcb_replycap_slot \\<mapsto>\n            cdl_cap.NullCap, tcb_caller_slot \\<mapsto> cdl_cap.NullCap, tcb_ipcbuffer_slot \\<mapsto> cdl_cap.NullCap,\n            tcb_pending_op_slot \\<mapsto> cdl_cap.NullCap, tcb_boundntfn_slot \\<mapsto> cdl_cap.NullCap],\n           cdl_tcb_fault_endpoint = 0,\n           cdl_tcb_intent =\n             \\<lparr>cdl_intent_op = None, cdl_intent_error = False,cdl_intent_cap = 0, cdl_intent_extras = [],\n                cdl_intent_recv_slot = None\\<rparr>, cdl_tcb_has_fault = False, cdl_tcb_domain = minBound\\<rparr>\"\n\ndefinition obj_tcb :: \"cdl_object \\<Rightarrow> cdl_tcb\"\nwhere \"obj_tcb obj \\<equiv> case obj of Tcb tcb \\<Rightarrow> tcb\"\n\ndefinition tcb_caps_merge :: \"cdl_tcb \\<Rightarrow> cdl_tcb \\<Rightarrow> cdl_tcb\"\n  where \"tcb_caps_merge regtcb captcb \\<equiv> regtcb\\<lparr>cdl_tcb_caps\n  := (cdl_tcb_caps captcb)(tcb_pending_op_slot \\<mapsto> the (cdl_tcb_caps regtcb tcb_pending_op_slot), tcb_boundntfn_slot \\<mapsto> the (cdl_tcb_caps regtcb tcb_boundntfn_slot))\\<rparr>\"\n\ndefinition merge_with_dft_tcb :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere \"merge_with_dft_tcb o_id \\<equiv>\n do\n  new_intent \\<leftarrow> select UNIV;\n  KHeap_D.update_thread o_id (cdl_tcb_intent_update (\\<lambda>x. new_intent) \\<circ> (tcb_caps_merge (obj_tcb cdl_default_tcb)))\n od\"\n\nfun\n  reset_mem_mapping :: \"cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"reset_mem_mapping (FrameCap dev p rts sz b mp) = FrameCap dev p rts sz b None\"\n| \"reset_mem_mapping (PageTableCap ptr b mp) = PageTableCap ptr b None\"\n| \"reset_mem_mapping (PageDirectoryCap ptr b ma) = PageDirectoryCap ptr b None\"\n| \"reset_mem_mapping cap = cap\"", "property": "Object Regeneration: Regenerate the target object by revoking its children, resetting it to its original state, and reinitializing its properties. This involves clearing the object's capabilities, resetting its memory mappings, and merging its attributes with default values.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Regenerate the target object.\n *\n * Any children of the cap are first revoked. The object\n * is then reset into its original (as-if just created)\n * state. But maybe not. It's complex.\n *\n * In the C implementation, attempting to recycle a\n * non-master cap may do something that is not\n * a recycle. (Should be perhaps return an error?)\n "}
{"spec": "definition canonical_user :: \"vspace_ref\" where\n  \"canonical_user \\<equiv> mask ipa_size\"", "property": "Canonical User Address: The highest user-virtual address that is still canonical, defining the upper limit of the canonical address space for users.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " The highest user-virtual address that is still canonical.\n   It can be larger than user_vtop, which is the highest address we allow to be mapped.\n   For AArch64-hyp, user-virtual addresses are IPAs and since there is no sign extension,\n   the value is the top of the entire IPA address space. "}
{"spec": "definition\nflush_space :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_space asid \\<equiv> do\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    do_machine_op cleanCaches_PoU;\n    (case maybe_hw_asid of\n          None \\<Rightarrow> return ()\n        | Some hw_asid \\<Rightarrow> do_machine_op $ invalidateLocalTLB_ASID hw_asid)\nod\"", "property": "Flush Virtual ASID: Flush all cache and TLB entries associated with a given virtual ASID, ensuring that the corresponding hardware ASID is cleaned and invalidated. \n\nCache Cleaning: Clean the caches to the point of unification (PoU) to ensure consistency across the system.\n\nTLB Invalidation: Invalidate the local TLB entries for the given hardware ASID, if it exists, to prevent stale translations from being used.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush all cache and TLB entries associated with this virtual ASID."}
{"spec": "| FrameCap bool cdl_object_id \"cdl_right set\" nat cdl_frame_cap_type \"cdl_mapped_addr option\"\n  | PageTableCap cdl_object_id cdl_frame_cap_type \"cdl_mapped_addr option\"\n  | PageDirectoryCap cdl_object_id cdl_frame_cap_type \"cdl_asid option\"\n  | AsidControlCap\n  | AsidPoolCap cdl_object_id \"cdl_cnode_index\"", "property": "Virtual Memory Capabilities: Define the capabilities for managing virtual memory, including frame, page table, page directory, ASID control, and ASID pool capabilities, each with specific attributes and options for memory mapping and access control. \n\nSubproperties:\n- Frame Capability: Represents a frame of memory with specific rights, size, and mapping attributes.\n- Page Table Capability: Manages page tables with specific mapping attributes.\n- Page Directory Capability: Controls page directories with specific mapping attributes and optional ASID.\n- ASID Control Capability: Regulates the allocation and management of ASIDs.\n- ASID Pool Capability: Manages pools of ASIDs with specific indexing.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Virtual memory capabilties "}
{"spec": "text \\<open>Helper function to handle a signal operation in the case\nwhere a receiver is waiting.\\<close>\ndefinition\n  update_waiting_ntfn :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref option \\<Rightarrow> badge \\<Rightarrow>\n                         (unit,'z::state_ext) s_monad\"\nwhere\n  \"update_waiting_ntfn ntfnptr queue bound_tcb badge \\<equiv> do\n     assert (queue \\<noteq> []);\n     (dest,rest) \\<leftarrow> return $ (hd queue, tl queue);\n     set_notification ntfnptr $ \\<lparr>\n         ntfn_obj = (case rest of [] \\<Rightarrow> IdleNtfn | _ \\<Rightarrow> WaitingNtfn rest),\n         ntfn_bound_tcb = bound_tcb \\<rparr>;\n     set_thread_state dest Running;\n     as_user dest $ setRegister badge_register badge;\n     do_extended_op (possible_switch_to dest)\n\n   od\"", "property": "Asynchronous Message Transfer to Waiting Receiver: When a receiver is waiting for a notification, update the notification object, set the receiver's thread state to running, set the badge register, and potentially switch to the receiver's thread. \n\nUpdate Notification Object: Update the notification object's state to either IdleNtfn or WaitingNtfn, depending on whether there are remaining waiting threads.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Asynchronous Message Transfers", "comment": ""}
{"spec": "definition vs_apiobj_size where\n  \"vs_apiobj_size ty \\<equiv>\n     case ty of\n       ArchObject SmallPageObj \\<Rightarrow> pageBitsForSize ARMSmallPage\n     | ArchObject LargePageObj \\<Rightarrow> pageBitsForSize ARMLargePage\n     | ArchObject SectionObj \\<Rightarrow> pageBitsForSize ARMSection\n     | ArchObject SuperSectionObj \\<Rightarrow> pageBitsForSize ARMSuperSection\n     | ArchObject PageTableObj \\<Rightarrow> pt_bits\n     | ArchObject PageDirectoryObj \\<Rightarrow> pd_bits\"\n\ndefinition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv> do\n     when (new_type = ArchObject PageDirectoryObj) $ mapM_x copy_global_mappings refs;\n     if \\<not>is_device \\<and>\n        new_type \\<in> {ArchObject SmallPageObj, ArchObject LargePageObj,\n                    ArchObject SectionObj, ArchObject SuperSectionObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_RAM ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else if new_type \\<in> {ArchObject PageTableObj, ArchObject PageDirectoryObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_PoU ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else\n       return ()\n   od\"\n\ndefinition\n  empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context, tcb_vcpu = None \\<rparr>\"\n\nend\n\nend", "property": "Initialise Architecture-Specific Objects: \nInitialise architecture-specific objects, including page tables, page directories, and various types of page objects, ensuring correct configuration and cache management for these objects.\nSubproperties:\nCache Management: Clean the cache range for page objects and page tables/directories to ensure data consistency and prevent cache-related issues.\nPage Table/Directory Configuration: Copy global mappings for page directories and configure page tables/directories according to architecture-specific requirements.\nTCB Initialisation: Initialise the architecture-specific components of a TCB (Thread Control Block), including the user context and vcpu (virtual CPU) settings.", "title": "./spec/abstract/ARM_HYP/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "end", "property": "No property can be summarized as there is no code provided.", "title": "./spec/design/skel/RISCV64/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": " None for RISCV64 "}
{"spec": "record init_data =\n  initFreeMemory   :: \"region list\"\n  initSlotPosCur :: \"machine_word\"\n  initSlotPosMax   :: \"machine_word\"\n  initBootInfo    :: \"biframe_data\"\n  initBootInfoFrame       :: paddr\n  initKernelState :: kernel_state\n\ntype_synonym 'a kernel_init_state = \"(init_data, 'a) nondet_monad\"\n\ntranslations\n  (type) \"'c kernel_init_state\" <= (type) \"(init_data, 'c) nondet_monad\"\n\ntype_synonym 'a kernel_init = \"(init_failure + 'a) kernel_init_state\"\n\ntranslations\n  (type) \"'a kernel_init\" <= (type) \"(init_failure + 'a) kernel_init\"\n\ndefinition\n  noInitFailure :: \"'a kernel_init_state \\<Rightarrow> 'a kernel_init\"\nwhere\n  noInitFailure_def[simp]:\n  \"noInitFailure \\<equiv> liftE\"\n\n\n\ndefinition\n  doKernelOp :: \"'a kernel \\<Rightarrow> 'a kernel_init\"\nwhere\n \"doKernelOp kop \\<equiv> doE\n    ms \\<leftarrow> liftE $ gets initKernelState;\n    (r, ms') \\<leftarrow> liftE $ select_f (kop ms);\n    liftE $ modify (\\<lambda>ks. ks \\<lparr> initKernelState := ms' \\<rparr>);\n    returnOk r\n  odE\"\n\nconsts\n  itASID :: asid\n  biCapNull :: machine_word\n  biCapITTCB :: machine_word\n  biCapITCNode :: machine_word\n  biCapITPD :: machine_word\n  biCapIRQControl :: machine_word\n  biCapASIDControl :: machine_word\n  biCapITASIDPool :: machine_word\n  biCapIOPort :: machine_word\n  biCapIOSpace :: machine_word\n  biCapBIFrame :: machine_word\n  biCapITIPCBuf :: machine_word\n  biCapDynStart :: machine_word\n  biFrameSizeBits :: nat\n  nopBIFrameData :: biframe_data\n\ndefinition\n  runInit :: \"machine_word \\<Rightarrow> 'a kernel_init \\<Rightarrow> 'b kernel\"\nwhere\n  \"runInit initOffset doInit \\<equiv> do\n    ks \\<leftarrow> get;\n    initData \\<leftarrow> return \\<lparr> initFreeMemory = [],\n                   initSlotPosCur = 0,\n                   initSlotPosMax = bit (pageBits),\n                   initBootInfo = nopBIFrameData,\n                   initBootInfoFrame = 0,\n                   initKernelState = ks \\<rparr>;\n    (ret, initData') \\<leftarrow> select_f (doInit initData);\n    (case ret of\n      Inr a \\<Rightarrow> fail\n    | Inl _ \\<Rightarrow> fail)\n  od\"\n\nend", "property": "Kernel Initialization: Manage the kernel's initialization process, including setting up the initial state, executing kernel operations, and handling initialization failures, to ensure the kernel is properly configured and ready for execution.\nInitialization State Management: Maintain the initialization state, including the free memory, slot positions, boot information, and kernel state, to facilitate a controlled and efficient initialization process.", "title": "./spec/design/skel/KernelInitMonad_H.thy", "chapter": "", "section": "", "comment": "This is a similar way of getting around StateT as with the kernel\nstate, we add an extra field to the record that Haskell expects to store the\ninner monad state."}
{"spec": "lemma e1_connected_trans_to_e2:\n  \"s \\<turnstile> 1 \\<leftrightarrow>* 2\"\n  apply (insert e1_connected_to_e2)\n  apply (simp add: tgs_connected_def)\n  done\n\n\nlemma caps_of_to_e1:\n  \"\\<lbrakk>c \\<in> caps_of s x; target c = 1\\<rbrakk> \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (case_tac \"x = 0\")\n   apply (fastforce simp: caps_of_s_e0_caps_2)\n  apply (case_tac \"x = 1\")\n   apply (fastforce simp: caps_of_s_e1)\n  apply (fastforce simp: caps_of_s_e3)\n  done\n\nlemma caps_of_to_e2:\n  \"\\<lbrakk>c \\<in> caps_of s x; target c = 2\\<rbrakk> \\<Longrightarrow> x = 1\"\n  apply (case_tac \"x = 0\")\n   apply (fastforce simp: caps_of_s_e0_caps_2)\n  apply (case_tac \"x = 1\")\n   apply (fastforce simp: caps_of_s_e1)\n  apply (fastforce simp: caps_of_s_e3)\n  done\n\nlemma cap_in_caps_caps_of_e1:\n  \"c \\<in>cap caps_of s 1 \\<Longrightarrow> target c = 1 \\<or> target c = 2\"\n  by (clarsimp simp: cap_in_caps_def caps_of_s_e1)\n\nlemma cap_in_caps_caps_of_e2:\n  \"c \\<in>cap caps_of s 2 \\<Longrightarrow> False\"\n  by (clarsimp simp: cap_in_caps_def caps_of_s_e2)\n\nlemma cap_in_caps_caps_of_to_e1:\n  \"\\<lbrakk>c \\<in>cap caps_of s x; target c = 1\\<rbrakk> \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (drule (1) caps_of_to_e1, simp)\n  done\n\nlemma cap_in_caps_caps_of_to_e2:\n  \"\\<lbrakk>c \\<in>cap caps_of s x; target c = 2\\<rbrakk> \\<Longrightarrow> x = 1\"\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (erule (1) caps_of_to_e2)\n  done\n\nlemma e1_connected_to:\n  \"s \\<turnstile> 1 \\<leftrightarrow> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (erule disjE)\n   apply (erule cap_in_caps_caps_of_to_e1, simp)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, simp)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, simp)\n  apply (erule disjE)\n   apply (erule cap_in_caps_caps_of_to_e1, simp)\n  apply (fastforce simp: shares_caps_def store_connected_s)\n  done\n\n\nlemma e2_connected_to:\n  \"s \\<turnstile> 2 \\<leftrightarrow> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (erule disjE, rule disjI1)\n   apply (erule cap_in_caps_caps_of_to_e2, simp)\n  apply (erule disjE, rule disjI1)\n   apply (drule cap_in_caps_caps_of_e2, simp)\n  apply (erule disjE, rule disjI1)\n   apply (drule cap_in_caps_caps_of_e2, simp)\n  apply (erule disjE, rule disjI1)\n   apply (erule cap_in_caps_caps_of_to_e2, simp)\n  apply (clarsimp simp: shares_caps_def store_connected_s)\n  done\n\n\nlemma directly_tgs_connected_in_inv_image:\n  \"(directly_tgs_connected s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  by (fastforce simp: inv_image_def\n              dest!: e1_connected_to e1_connected_to [OF directly_tgs_connected_comm]\n                     e2_connected_to e2_connected_to [OF directly_tgs_connected_comm])\n\nlemma connected_inv_image_trans:\n  \"trans (inv_image Id (\\<lambda> x. x=1 \\<or> x=2))\"\n  by (rule trans_inv_image [OF trans_Id])\n\nlemma eq_inv_image_connected:\n  \"(inv_image Id (\\<lambda> x. x=1 \\<or> x=2))\\<^sup>= = inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  by (fastforce simp: inv_image_def)\n\nlemma rtrancl_inv_image_connected:\n  \"(inv_image Id (\\<lambda> x. x=1 \\<or> x=2))\\<^sup>* = inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  apply (subst trancl_reflcl [symmetric])\n  apply (subst eq_inv_image_connected)\n  apply (rule trancl_id)\n  apply (rule connected_inv_image_trans)\n  done\n\nlemma tgs_connected_in_inv_image:\n  \"(tgs_connected s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  apply (simp add: tgs_connected_def)\n  apply (subst rtrancl_inv_image_connected [symmetric])\n  apply (rule rtrancl_mono)\n  apply (rule directly_tgs_connected_in_inv_image)\n  done\n\nlemma e0_not_connected_trans_e1:\n  \"\\<not> s \\<turnstile> 0 \\<leftrightarrow>* 1\"\n  apply clarsimp\n  apply (drule set_mp [OF tgs_connected_in_inv_image])\n  apply (simp add: inv_image_def)\n  done\n\nlemma e0_not_ever_connected_trans_e1:\n  \"s' \\<in> execute cmds s \\<Longrightarrow> \\<not> s' \\<turnstile> 0 \\<leftrightarrow>* 1\"\n  apply clarsimp\n  apply (drule (1) tgs_connected_preserved)\n  apply (simp add: e0_not_connected_trans_e1)\n  done\n\n\nlemma e0_e1_leakage:\n  \"s' \\<in> execute cmds s \\<Longrightarrow> \\<not> leak s' 0 1\"\n  apply (insert e0_not_connected_trans_e1)\n  apply (drule (2) leakage_rule)\n  done", "property": "System Connectivity: The system ensures that certain entities (e.g., 0, 1, and 2) have specific connectivity properties, such as the inability of entity 0 to be transitively connected to entity 1, even after executing commands.\n\nEntity Relationships: Entity 1 is connected to entity 2, and entity 1 can only be connected to entities 1 and 2. Entity 2 can only be connected to entities 1 and 2. Entity 0 is not connected to entity 1, even after executing commands, ensuring no leakage between them.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma op10_legal:\n  \"legal op10 s10\"\n  by  (clarsimp simp: s10_def op10_def all_rights_def)\n\nlemma e0_caps_diminished [simp]:\n  \"e0_caps - {full_cap 1, create_cap 1, create_cap 2} = e0_caps - {create_cap 1, create_cap 2}\"\n  by (fastforce simp: e0_caps_def create_cap_def full_cap_def all_rights_def)\n\n\nlemma execute_op10_safe:\n  \"step op10 s10 \\<subseteq> ({s10, s})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s10_def op10_def step_def removeSetOperation_def s4_def s_def\n              split: if_split_asm)\n  done\n\nlemma execute_op10_live:\n  \"step op10 s10 \\<supseteq> ({s10, s})\"\n  apply clarsimp\n  apply (rule conjI)\n   apply (simp add: step_def)\n  apply (simp add: step_def op10_legal)\n  apply (rule disjI2)\n  apply (clarsimp simp: s10_def op10_def removeSetOperation_def)\n  apply (rule ext)\n  apply (fastforce simp: s4_def s_def)\n  done\n\nlemma execute_op10:\n  \"step op10 s10 = ({s10, s})\"\n  apply rule\n   apply (rule execute_op10_safe)\n  apply (rule execute_op10_live)\n  done\n\n\nlemma execute_ops:\n  \"s \\<in> execute ops s0\"\n  apply (clarsimp simp: ops_def)\n  apply (insert execute_op0_live execute_op1_live execute_op2_live execute_op3_live\n                execute_op4_live execute_op5_live                  execute_op7_live\n                execute_op8_live execute_op9_live execute_op10_live)\n  apply (simp add: s7_def)\n  apply fastforce\n  done", "property": "System Execution: The system executes a sequence of operations (ops) starting from an initial state (s0), resulting in a final state (s) that is part of the execution outcome.\n\nSubproperties:\n- Operation Legality: Each operation, such as op10 (SysRemoveSet), is legal and can be executed according to the system's rules and current state.\n- Safe Execution: The execution of each operation does not lead to an unsafe or invalid state, ensuring the system's integrity.\n- Live Execution: The execution of each operation results in a valid and expected outcome, contributing to the overall system state.\n- Deterministic Execution: The execution of operations leads to a deterministic outcome, where the final state (s) is uniquely determined by the initial state (s0) and the sequence of operations (ops).", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op10 \\<equiv> SysRemoveSet 0 (full_cap 0) {full_cap 1, create_cap 1, create_cap 2} "}
{"spec": "definition vcpu_disable :: \"obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_disable vo \\<equiv> do\n    do_machine_op dsb;\n    case vo of\n      Some vr \\<Rightarrow> do\n        hcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_hcr;\n        vgic_update vr (\\<lambda>vgic. vgic\\<lparr> vgic_hcr := hcr \\<rparr>);\n        vcpu_save_reg vr VCPURegSCTLR;\n        vcpu_save_reg vr VCPURegCPACR; \\<comment> \\<open>since FPU enabled\\<close>\n        do_machine_op isb\n      od\n    | _ \\<Rightarrow> return ();\n    do_machine_op $ do\n        set_gic_vcpu_ctrl_hcr 0; \\<comment> \\<open>turn VGIC off\\<close>\n        isb;\n        setSCTLR sctlrDefault; \\<comment> \\<open>turn S1 MMU off\\<close>\n        isb;\n        setHCR hcrNative;\n        isb;\n        \\<comment> \\<open>allow FPU instructions in EL0 and EL1 for native threads\\<close>\n        enableFpuEL01\n      od;\n    case vo of\n      Some vr \\<Rightarrow> do\n          save_virt_timer vr;\n          do_machine_op $ maskInterrupt True irqVTimerEvent\n        od\n    | _ \\<Rightarrow> return ()\n    od\"", "property": "VCPU Mode Disable: Turn off VCPU mode on the hardware level by updating the VGIC control register, saving relevant VCPU registers, disabling the VGIC and S1 MMU, and configuring the HCR and FPU settings for native threads. Additionally, save the virtual timer state and mask the VTimer event interrupt if a VCPU object reference is provided.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Turn VPCU mode off on the hardware level."}
{"spec": "definition\n  lookup_pt_slot_no_fail :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\"\nwhere\n  \"lookup_pt_slot_no_fail pt vptr \\<equiv>\n     let pt_index = ((vptr >> 12) && 0xff)\n     in pt + (pt_index << 2)\"\n\nend\n\nend", "property": "Lookup PT Slot: Calculate the address of a page table slot for a given virtual address and page table.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pt_slot} when the pd is already known"}
{"spec": "ap_pptr \\<leftarrow> create_objects ASID_POOL_SIZE_BITS\n                              ASID_POOL_SIZE_BITS (ArchObject ASIDPoolObj);\n\n     ap_cap \\<leftarrow> returnOk $ ArchObjectCap $\n                 ASIDPoolCap ap_pptr (IT_ASID >> asid_low_bits);\n\n     do_kernel_op $ write_slot (cap_slot_pptr root_cnode_cap\n                                BI_CAP_IT_ASID_POOL) ap_cap;", "property": "Kernel Initialization: Create an ASID pool with the specified size and initialize its capability. The ASID pool capability is then written to the designated slot in the root CNode.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create ASID pool "}
{"spec": "definition\n  \"non_kernel_IRQs = {}\"", "property": "Non-Kernel Interrupts: No interrupts can occur while the kernel is running that are not handled by the kernel, specifically those that can occur from user mode are empty on plain ARMv7.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Interrupts that cannot occur while the kernel is running (e.g. at preemption points),\n  but that can occur from user mode. Empty on plain ARMv7.\n"}
{"spec": "definition kdev_base :: \"machine_word\" where\n  \"kdev_base = Platform.AARCH64.kdevBase\"", "property": "Kernel Device Mapping Region: The virtual address for the start of the kernel device mapping region is located in the highest 1GiB of memory.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  Virtual address for start of kernel device mapping region in highest 1GiB of memory.\n"}
{"spec": "datatype arch_gen_obj_ref = unit\n\ndefinition arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\" where\n  \"arch_gen_obj_refs ac \\<equiv> {}\"\n\ndefinition arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\" where\n  \"arch_cap_cleanup_opt ac \\<equiv> NullCap\"\n\nend\nend", "property": "Architectural Generic Object References: Provide empty set of architectural generic object references for each architectural capability, and map each architectural capability to a null capability for cleanup.", "title": "./spec/abstract/AARCH64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition\n  oref_to_data   :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_oref   :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition\n  vref_to_data   :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_vref   :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition\n  nat_to_len     :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition\n  data_to_nat    :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition\n  data_to_16     :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition\n  data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition\n  combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition\n  combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Provide functions for converting between different data types, including object references, virtual space references, natural numbers, length types, and capability pointers, to facilitate data manipulation and exchange in the system.\n\nSubproperties:\n- Identity Conversions: Define identity functions for converting between abstract type names, such as object references and data, and virtual space references and data.\n- Numeric Conversions: Specify functions for converting between natural numbers and length types, as well as between data and natural numbers.\n- Bitwise Conversions: Define functions for converting between data and 16-bit words using unsigned casting.\n- Capability Pointer Conversions: Provide a function for converting data to capability pointers using bit list representation.\n- Notification Combinations: Define functions for combining notification badges and messages using bitwise OR operations.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "With the definitions above, most conversions between abstract\ntype names boil down to just the identity function, some convert from\n@{text word} to @{typ nat} and others between different word sizes\nusing @{const ucast}."}
{"spec": "definition\n  oref_to_data   :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_oref   :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition\n  vref_to_data   :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_vref   :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition\n  nat_to_len     :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition\n  data_to_nat    :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition\n  data_to_16     :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition\n  data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition\n  combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition\n  combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Provide functions for converting between different data types, including object references, virtual space references, natural numbers, length types, and capability pointers, to facilitate data manipulation and exchange in the system.\n\nSubproperties:\n- Identity Conversions: Define identity functions for converting between abstract type names, such as object references and data, and virtual space references and data.\n- Numeric Conversions: Specify functions for converting between natural numbers and length types, as well as between data and natural numbers.\n- Bitwise Conversions: Define functions for converting between data and 16-bit words using unsigned casting.\n- Capability Pointer Conversions: Provide a function for converting data to capability pointers using bit list representation.\n- Notification Combinations: Define functions for combining notification badges and messages using bitwise OR operations.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "With the definitions above, most conversions between abstract\ntype names boil down to just the identity function, some convert from\n@{text word} to @{typ nat} and others between different word sizes\nusing @{const ucast}."}
{"spec": "definition\nhandle_vm_fault :: \"obj_ref \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n\"handle_vm_fault thread fault_type = doE\n    addr \\<leftarrow> liftE $ do_machine_op getFaultAddress;\n    fault \\<leftarrow> liftE $ as_user thread $ getRegister ErrorRegister;\n    case fault_type of\n        X64DataFault \\<Rightarrow> throwError $ ArchFault $ VMFault addr [0, fault && mask 5]\n      | X64InstructionFault \\<Rightarrow> throwError $ ArchFault $ VMFault addr [1, fault && mask 5]\nodE\"\n\ndefinition\n  get_current_cr3 :: \"(cr3, 'z::state_ext) s_monad\"\nwhere\n  \"get_current_cr3 \\<equiv> gets (x64_current_cr3 \\<circ> arch_state)\"\n\ndefinition\n  set_current_cr3 :: \"cr3 \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_current_cr3 c \\<equiv>\n     modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>x64_current_cr3 := c\\<rparr>\\<rparr>)\"\n\ndefinition\n  invalidate_page_structure_cache_asid :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"invalidate_page_structure_cache_asid vspace asid \\<equiv>\n     do_machine_op $ invalidateLocalPageStructureCacheASID vspace (ucast asid)\"\n\ndefinition\n  getCurrentVSpaceRoot :: \"(obj_ref, 'z::state_ext) s_monad\"\nwhere\n  \"getCurrentVSpaceRoot \\<equiv> do\n      cur \\<leftarrow> get_current_cr3;\n      return $ cr3_base_address cur\n   od\"\n\ndefinition\n  \"cr3_addr_mask \\<equiv> mask pml4_shift_bits << asid_bits\"\n\ndefinition\n  make_cr3 :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> cr3\"\nwhere\n  \"make_cr3 vspace asid \\<equiv> cr3 (vspace && cr3_addr_mask) asid\"\n\ndefinition\n  set_current_vspace_root :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"set_current_vspace_root vspace asid \\<equiv> set_current_cr3 $ make_cr3 vspace asid\"", "property": "VM Fault Handling: Formats a VM fault message to be passed to a thread's supervisor after encountering a page fault, providing the fault address and relevant error information.\n\nPage Table Management: Provides functions to manage the current CR3 (page table root), including getting and setting its value, invalidating the page structure cache for a given ASID, and constructing a new CR3 value from a given virtual space address and ASID.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Format a VM fault message to be passed to a thread's supervisor after\nit encounters a page fault."}
{"spec": "definition\n  cancel_signal :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_signal threadptr ntfnptr \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     queue \\<leftarrow> (case ntfn_obj ntfn of WaitingNtfn queue \\<Rightarrow> return queue\n                        | _ \\<Rightarrow> fail);\n     queue' \\<leftarrow> return $ remove1 threadptr queue;\n     newNTFN \\<leftarrow> return $ ntfn_set_obj ntfn (case queue' of [] \\<Rightarrow> IdleNtfn\n                                                      | _  \\<Rightarrow> WaitingNtfn queue');\n     set_notification ntfnptr newNTFN;\n     set_thread_state threadptr Inactive\n   od\"", "property": "Cancel Signal: Cancel a thread's message receive operation from a notification object, removing the thread from the notification queue and updating the notification object's state accordingly, ultimately setting the thread's state to inactive.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel the message receive operation of a thread queued in an\nnotification object."}

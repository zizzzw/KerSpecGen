{"spec": "text \\<open>\n\n  The Separation Kernel maintains separation between processes by limiting the capabilities that are\n  present in the system. We call these the \"restricted capabilities\" in the documentation that\n  follows.\n\n  The specification described here, the Separation Kernel Abstract Specification (abbreviated\n  \\texttt{sep-abstract} from here on in), is identical to the Abstract Specification\n  (aka. \\texttt{abstract}), except that the following system calls have been overridden to\n  provide reduced (fully static) functionality only.\n\n  \\begin{itemize}\n  \\item{handle_fault}\n  \\item{invoke_irq_handler}\n  \\item{decode_invocation}\n  \\item{perform_invocation}\n  \\item{handle_invocation}\n  \\item{handle_reply}\n  \\item{handle_event}\n  \\item{call_kernel}\n  \\end{itemize}\n\n  The resulting kernel API is simplified significantly compared to full seL4.\n  The changes to the original abstract specification are minimal, except that it contains\n  much fewer system calls.\n\n  We achieve this by modifying the cases distinctions that determine which API call is\n  to by executed. The new case distinctions\n  on capabilities only provide code for the restricted capabilities in our reduced setup,\n  otherwise they fail (i.e. throw an exception).\n\n  We then prove that \\texttt{sep-abstract} and \\texttt{abstract} have the same behaviour under the\n  restricted capabilities of the separation kernel via bi-simulation. This simply requires that we\n  prove refinement in both directions. This proof implies that the missing (failing) code branches\n  in the reduced specification can never be executed.\n\n  It is clear that the behaviour will be the same for the \"mostly identical\" overridden\n  definitions. In a few cases, which are documented below, the definitions have bigger differencess.\n  We provide ab informal explanation at the site of the overriden definition in each of these\n  cases. (The bi-simulation proof provides the formal demonstration.)\n\n\\<close>", "property": "Separation Kernel Abstract Specification: Provides a reduced set of system calls with fully static functionality, limiting capabilities to maintain separation between processes, while ensuring the same behavior as the original abstract specification under restricted capabilities.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Generic system call structure\\label{s:spec_syscall}", "comment": ""}
{"spec": "fun\n  perform_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"perform_invocation block call (InvokeNotification ep badge) =\n    doE\n      without_preemption $ send_signal ep badge;\n      returnOk []\n    odE\"\n| \"perform_invocation _ _ _ = fail\"\n\ndefinition\n  handle_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_invocation calling blocking \\<equiv> doE\n    thread \\<leftarrow> liftE $ gets cur_thread;\n    info \\<leftarrow> without_preemption $ get_message_info thread;\n    ptr \\<leftarrow> without_preemption $ liftM data_to_cptr $\n          as_user thread $ getRegister cap_register;\n    syscall\n      (doE\n         (cap, slot) \\<leftarrow> cap_fault_on_failure (of_bl ptr) False $ lookup_cap_and_slot thread ptr;\n         buffer \\<leftarrow> liftE $ lookup_ipc_buffer False thread;\n         extracaps \\<leftarrow> lookup_extra_caps thread buffer info;\n         returnOk (slot, cap, extracaps, buffer)\n       odE)\n      (\\<lambda>fault. when blocking $ handle_fault thread fault)\n      (\\<lambda>(slot,cap,extracaps,buffer). doE\n            args \\<leftarrow> liftE $ get_mrs thread buffer info;\n            decode_invocation (mi_label info) args ptr slot cap extracaps\n       odE)\n      (\\<lambda>err. when calling $\n            reply_from_kernel thread $ msg_from_syscall_error err)\n      (\\<lambda>oper. doE\n            without_preemption $ set_thread_state thread Restart;\n            reply \\<leftarrow> perform_invocation blocking calling oper;\n            without_preemption $ do\n                state \\<leftarrow> get_thread_state thread;\n                case state of\n                      Restart \\<Rightarrow> do\n                          when calling $\n                              reply_from_kernel thread (0, reply);\n                          set_thread_state thread Running\n                      od\n                    | _ \\<Rightarrow>  return ()\n            od\n       odE)\n  odE\"\n\ndefinition\n  handle_yield :: \"(unit,'z::state_ext) s_monad\" where\n  \"handle_yield \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) thread);\n     do_extended_op (tcb_sched_action (tcb_sched_append) thread);\n     do_extended_op reschedule_required\n   od\"\n\ndefinition\n  handle_send :: \"bool \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"handle_send bl \\<equiv> handle_invocation False bl\"\n\ndefinition\n  handle_call :: \"(unit,'z::state_ext) p_monad\" where\n \"handle_call \\<equiv> handle_invocation True True\"", "property": "System Call Entry Point: Handle system call invocations, including sending signals, handling faults, decoding invocations, and performing the requested operation. Ensure proper thread state management, including restarting and running threads as necessary.\n\nSubproperties:\n\n* Handle Invocation: Manage the invocation process, including retrieving message information, looking up capabilities, and performing the requested operation.\n* Handle Yield: Dequeue and re-append the current thread to the scheduler, then reschedule as required.\n* Handle Send: Handle invocations without blocking, used for sending signals.\n* Handle Call: Handle invocations with blocking, used for system calls.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": ""}
{"spec": "definition\n  handle_recv :: \"bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"handle_recv is_blocking \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n\n     ep_cptr \\<leftarrow> liftM data_to_cptr $ as_user thread $\n                 getRegister cap_register;\n\n     (cap_fault_on_failure (of_bl ep_cptr) True $ doE\n        ep_cap \\<leftarrow> lookup_cap thread ep_cptr;\n\n        let flt = (throwError $ MissingCapability 0)\n        in\n        case ep_cap\n          of\n            NotificationCap ref badge rights \\<Rightarrow>\n             (if AllowRecv \\<in> rights\n              then doE\n                ntfn \\<leftarrow> liftE $ get_notification ref;\n                boundTCB \\<leftarrow> returnOk $ ntfn_bound_tcb ntfn;\n                if boundTCB = Some thread \\<or> boundTCB = None\n                then liftE $ receive_signal thread ep_cap is_blocking\n                else flt\n               odE\n              else flt)\n           | _ \\<Rightarrow> flt\n      odE)\n      <catch> handle_fault thread\n   od\"", "property": "Handle Receive: Ensure that the current thread can receive a signal from a notification capability, checking for the required AllowRecv right and handling faults if necessary. \n\nSubproperties:\n- Retrieve the current thread and its endpoint capability pointer.\n- Check the endpoint capability for the AllowRecv right.\n- If the right is present, retrieve the notification and check if the thread is bound to it or if it is unbound.\n- If the thread is bound or the notification is unbound, receive the signal; otherwise, throw a MissingCapability error.\n- Handle any faults that occur during the process.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": "\n\n  This definition of \\texttt{handle_recv} is almost identical to the abstract specification's definition\n  for the restricted capabilities. Also, a call to \\texttt{delete_caller_cap} has been removed. They have\n  the same behaviour under the restricted capabilities since there are no caller capabilities in\n  \\texttt{sep-abstract}.\n\n"}
{"spec": "definition\n  handle_reply :: \"(unit,'z::state_ext) s_monad\" where\n \"handle_reply \\<equiv> return ()\"", "property": "System Call Entry Point: Handle Reply Action: Always returns without performing any action, ensuring that the system call entry point does not modify the system state.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": "\n\n  The definition here has been specialised to \\texttt{return ()}. The behaviour\n  is identical with the abstract specification under restricted capabilities because there\n  are no \\texttt{Reply} capabilities in \\texttt{sep-abstract}.\n\n"}
{"spec": "text \\<open>\n\n  The definition here is almost identical to that of the abstract specification (for the restricted\n  capablities), except that a call to \\texttt{handle_reply} has been removed. Since there\n  are no \\texttt{Reply}s in the restricted capabilities the behaviour is the same.\n\n\\<close>\n\n\nfun\n  handle_event :: \"event \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_event (SyscallEvent call) =\n   (case call of\n          SysSend \\<Rightarrow> handle_send True\n        | SysNBSend \\<Rightarrow> handle_send False\n        | SysCall \\<Rightarrow> handle_call\n        | SysRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysYield \\<Rightarrow> without_preemption handle_yield\n        | SysReply \\<Rightarrow> without_preemption handle_reply\n        | SysReplyRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysNBRecv \\<Rightarrow> without_preemption $ handle_recv False)\"\n\n| \"handle_event (UnknownSyscall n) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UnknownSyscallException $ of_nat n;\n    return ()\n  od)\"\n\n| \"handle_event (UserLevelFault w1 w2) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UserException w1 (w2 && mask 28);\n    return ()\n  od)\"\n\n| \"handle_event Interrupt = (without_preemption $ do\n    active \\<leftarrow> do_machine_op (getActiveIRQ False);\n    case active of\n       Some irq \\<Rightarrow> handle_interrupt irq\n     | None \\<Rightarrow> return ()\n  od)\"\n\n| \"handle_event (VMFaultEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_vm_fault thread fault_type <catch> handle_fault thread;\n    return ()\n  od)\"\n\n| \"handle_event (HypervisorEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_hypervisor_fault thread fault_type;\n    return ()\n  od)\"", "property": "Top-level Event Handling: Handle system events, including system calls, unknown system calls, user-level faults, interrupts, VM faults, and hypervisor events, ensuring that each event is processed correctly and securely, with necessary fault handling and potential preemption.\n\nSubproperties:\n- System Call Handling: Handle various system calls, such as send, receive, yield, and reply, with specific handling for each type.\n- Unknown System Call Handling: Handle unknown system calls by reporting a fault to the current thread.\n- User-Level Fault Handling: Handle user-level faults by reporting an exception to the current thread.\n- Interrupt Handling: Handle interrupts by determining the active IRQ and handling it if present.\n- VM Fault Handling: Handle VM faults by reporting the fault to the current thread and handling potential errors.\n- Hypervisor Event Handling: Handle hypervisor events by reporting the fault to the current thread.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Top-level event handling", "comment": ""}
{"spec": "text \\<open>\n  This function is the main kernel entry point. The main event loop of the\n  kernel handles events, handles a potential preemption interrupt, schedules\n  and switches back to the active thread.\n\\<close>\n\ndefinition\n  call_kernel :: \"event \\<Rightarrow> (unit,'z::state_ext_sched) s_monad\" where\n  \"call_kernel ev \\<equiv> do\n       handle_event ev <handle>\n           (\\<lambda>_. without_preemption $ do\n                  irq \\<leftarrow> do_machine_op (getActiveIRQ True);\n                  when (irq \\<noteq> None) $ handle_interrupt (the irq)\n                od);\n       schedule;\n       activate_thread\n   od\"\n\nend", "property": "Kernel Entry Point: The kernel's main entry point handles events, checks for preemption interrupts, schedules, and switches to the active thread, ensuring the kernel's core functionality and thread management. \n\nHandle Event and Interrupt: Handle an event, and then check for and handle any pending interrupts without preemption, ensuring that interrupts are processed efficiently and safely. \n\nScheduling and Thread Activation: Schedule and activate the next thread, maintaining the kernel's scheduling and thread management functionality.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Kernel entry point", "comment": ""}
{"spec": "text \\<open>This definition is the toplevel decoding definition; it dispatches\nto the above definitions, after checking, in some cases, whether the\ninvocation is allowed.\n\\<close>\n\ndefinition\n  decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_invocation label args cap_index slot cap excaps \\<equiv>\n  case cap of\n    NotificationCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeNotification ptr badge\n      else throwError $ InvalidCapability 0\n  | _ \\<Rightarrow>\n      throwError $ InvalidCapability 0\"\n\nend", "property": "Toplevel Invocation Decode: Decodes system calls by dispatching to specific decoding definitions after checking invocation permissions. \n\nInvocation Permission Check: Verifies if the invocation is allowed based on the capability rights, specifically checking for the AllowSend right in NotificationCap capabilities.", "title": "./spec/sep-abstract/Decode_SA.thy", "chapter": "Decoding System Calls", "section": "Toplevel invocation decode.", "comment": ""}
{"spec": "text \\<open>\n\n  \\texttt{handle_fault} in \\texttt{sep-abstract} always sets the thread state to\n  \\texttt{Inactive}. This is the same behaviour as \\texttt{handle_double_fault} in the abstract\n  specification.\n\n  The two \\texttt{handle_fault}s have the same behaviour under restricted capabilities because in\n  the abstract specification \\texttt{handle_fault} will call \\texttt{handle_double_fault} in all\n  cases except when the thread has an \\texttt{EndpointCap}. Since \\texttt{EndpointCap} is not part\n  of the restricted capabilities their behaviour is the same. This means, the system assumes\n  fully static virtual memory and no dynamic paging of any kind.\n  Faulting threads will be disabled by the kernel.\n\\<close>\n\ndefinition\n  handle_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault tptr ex \\<equiv> set_thread_state tptr Inactive\"\n\nend", "property": "Fault Handling: When a fault occurs, the thread is immediately set to an inactive state, effectively disabling it. This ensures that faulting threads do not compromise the stability and security of the system, assuming a fully static virtual memory with no dynamic paging.", "title": "./spec/sep-abstract/Ipc_SA.thy", "chapter": "IPC", "section": "", "comment": ""}
{"spec": "theory MachineMonad\nimports MachineTypes\nbegin\n\narch_requalify_types\n  machine_state\n  machine_state_rest\n\narch_requalify_consts\n  underlying_memory\n  underlying_memory_update\n  device_state\n  device_state_update\n  irq_masks\n  machine_state_rest\n  machine_state_rest_update", "property": "Machine State Management: Provides an interface to manage the underlying machine state, including memory, device state, and IRQ masks, allowing for controlled updates and access to these fundamental system resources.", "title": "./spec/machine/MachineMonad.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\ntranslations\n  (type) \"'c machine_monad\" <= (type) \"machine_state \\<Rightarrow> ('c \\<times> machine_state) set \\<times> bool\"\n\ntype_synonym 'a machine_rest_monad = \"(machine_state_rest, 'a) nondet_monad\"\n\ndefinition\n  machine_rest_lift :: \"'a machine_rest_monad \\<Rightarrow> 'a machine_monad\"\nwhere\n  \"machine_rest_lift f \\<equiv> do\n    mr \\<leftarrow> gets machine_state_rest;\n    (r, mr') \\<leftarrow> select_f (f mr);\n    modify (\\<lambda>s. s \\<lparr> machine_state_rest := mr' \\<rparr>);\n    return r\n  od\"\n\n\ndefinition\n  ignore_failure :: \"('s,unit) nondet_monad \\<Rightarrow> ('s,unit) nondet_monad\"\n  where\n  \"ignore_failure f \\<equiv>\n  \\<lambda>s. if fst (f s) = {} then ({((),s)},False) else (fst (f s), False)\"", "property": "Machine Monad Operations: Define a machine monad for operations on the machine state, allowing for nondeterministic computations. It provides a way to lift operations from the machine rest monad to the machine monad, ensuring proper state management. Additionally, it includes a mechanism to ignore failures in nondeterministic computations, preventing errors from propagating.", "title": "./spec/machine/MachineMonad.thy", "chapter": "", "section": "", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "lemma failure_consistent:\n  \"\\<lbrakk> empty_fail f; no_fail \\<top> f \\<rbrakk> \\<Longrightarrow> ignore_failure f = f\"\n  apply (simp add: ignore_failure_def empty_fail_def no_fail_def)\n  apply (rule ext)\n  apply (auto intro: prod_eqI)\n  done", "property": "Preservation of Semantics under Failure Handling: If an operation does not fail and has no side effects when failing, then wrapping it with failure handling does not alter its behavior.", "title": "./spec/machine/MachineMonad.thy", "chapter": "", "section": "", "comment": "The wrapper doesn't do anything for usual operations:"}
{"spec": "lemma ef_ignore_failure [simp]:\n  \"empty_fail (ignore_failure f)\"\n  by (simp add: empty_fail_def ignore_failure_def)\n\nlemma no_fail_ignore_failure [simp, intro!]:\n  \"no_fail \\<top> (ignore_failure f)\"\n  by (simp add: no_fail_def ignore_failure_def)\n\n\nlemma ef_machine_rest_lift [simp, intro!]:\n  \"empty_fail f \\<Longrightarrow> empty_fail (machine_rest_lift f)\"\n  apply (clarsimp simp: empty_fail_def machine_rest_lift_def simpler_gets_def\n                        select_f_def bind_def simpler_modify_def return_def)\n  apply force\n  done\n\nlemma no_fail_machine_state_rest [intro!]:\n  \"no_fail P f \\<Longrightarrow> no_fail (P o machine_state_rest) (machine_rest_lift f)\"\n  apply (simp add: no_fail_def machine_rest_lift_def simpler_gets_def\n                        select_f_def bind_def simpler_modify_def return_def)\n  apply force\n  done\n\nlemma no_fail_machine_state_rest_T [simp, intro!]:\n  \"no_fail \\<top> f \\<Longrightarrow> no_fail \\<top> (machine_rest_lift f)\"\n  apply (drule no_fail_machine_state_rest)\n  apply (simp add: o_def)\n  done\n\ndefinition\n  \"machine_op_lift \\<equiv> machine_rest_lift o ignore_failure\"\n\n\nend", "property": "Machine Operation Lifting: Ensures that machine operations can be safely lifted and composed while preserving their failure properties, specifically empty failure and no failure conditions. \n\nSubproperties:\n- Empty Failure Preservation: The empty failure property is preserved when lifting machine operations.\n- No Failure Preservation: The no failure property is preserved when lifting machine operations, ensuring that the lifted operation does not introduce new failure conditions.", "title": "./spec/machine/MachineMonad.thy", "chapter": "", "section": "", "comment": "And it has the desired properties"}
{"spec": "(* Architecture-independent lemmas constraining Kernel_Config definitions *)\n\ntheory Kernel_Config_Lemmas\nimports \"$L4V_ARCH/Kernel_Config\"\nbegin", "property": "No specific property can be extracted from this code snippet as it appears to be a theory import statement, which does not contain any specific functionality or behavior that can be summarized as a property.", "title": "./spec/machine/Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma numDomains_not_zero:\n  \"numDomains > 0\"\n  unfolding Kernel_Config.numDomains_def\n  by simp\n\nlemma numDomains_machine_word_safe:\n  \"unat (of_nat numDomains :: machine_word) = numDomains\"\n  unfolding Kernel_Config.numDomains_def by simp\n\nend", "property": "Configuration Constants: Ensure the validity and consistency of architecture-independent configuration constants, specifically the number of domains, to maintain proof resilience across different configurations.\n  - Non-Zero Domain Count: The number of domains is always greater than zero.\n  - Domain Count Machine Word Safety: The number of domains can be safely represented as an unsigned machine word without loss of information.", "title": "./spec/machine/Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": "\n  seL4's build system allows configuration of some architecture-independent constants, such as the\n  number of domains.\n\n  The long-term goal is to make the proofs resilient in the face of changes of these configuration\n  options. To this end this theory contains properties of these constants, to avoid unfolding\n  their values later in the proofs."}
{"spec": "term \"id :: machine_word \\<Rightarrow> machine_word_len word\"\n\narch_requalify_types\n  vmfault_type\n  hyp_fault_type\n  irq\n  user_monad\n  user_context\n\narch_requalify_consts\n  getActiveIRQ\n  maskInterrupt\n  freeMemory\n  loadWord\n  storeWord\n  storeWordVM\n  setNextPC\n  getRestartPC\n  setRegister\n  getRegister\n  initContext\n  exceptionMessage\n  syscallMessage\n  gpRegisters\n  frameRegisters\n  ackInterrupt\n  resetTimer\n  minIRQ\n  clearMemory\n  non_kernel_IRQs\n  tlsBaseRegister\n  debugPrint\n  configureTimer\n  initL2Cache\n  ptrFromPAddr\n  pageBits", "property": "Consistency of Machine Word and Machine Word Length: Ensure that the machine word and machine word length are consistent across various architecture-specific types and constants, including fault types, interrupts, memory management, register operations, and timer configurations.", "title": "./spec/machine/MachineExports.thy", "chapter": "", "section": "", "comment": " Check consistency of machine_word and machine_word_len. "}
{"spec": "lemma Suc_unat_mask_div_obfuscated:\n  \"Suc (unat (mask sz div (word_size::machine_word))) = 2 ^ (min sz word_bits - word_size_bits)\"\n  by (rule Suc_unat_mask_div)\n\nlemma word_size_size_bits_nat:\n  \"2^word_size_bits = (word_size :: nat)\"\n  by (simp add: word_size_bits_def word_size_def)\n\nlemma word_size_size_bits_word:\n  \"2^word_size_bits = (word_size :: 'a :: len word)\"\n  by (simp add: word_size_bits_def word_size_def)\n\nend", "property": "Word Size and Mask Properties: Define relationships between word sizes, mask operations, and exponentiation for various architectures, ensuring consistency and correctness in bit-level operations.\n\nSubproperties:\n- Suc Unat Mask Div: Establishes a relationship between the successor of an unsigned integer mask division and exponentiation.\n- Word Size Size Bits Nat: Relates the exponentiation of word size bits to the natural number representation of word size.\n- Word Size Size Bits Word: Relates the exponentiation of word size bits to the word representation of word size.", "title": "./spec/machine/MachineExports.thy", "chapter": "", "section": "", "comment": " HERE IS THE PLACE FOR GENERIC WORD LEMMAS FOR ALL ARCHITECTURES "}
{"spec": "locale Arch\n\nend", "property": "Architecture Namespace Management: Provides a locale for namespacing architecture-specific definitions, allowing for organization and separation of architecture-specific entities from generic proofs.", "title": "./spec/machine/Setup_Locale.thy", "chapter": "", "section": "", "comment": "\n   We use a locale for namespacing architecture-specific definitions.\n\n   The global_naming command changes the underlying naming of the locale. The intention is that\n   we liberally put everything into the \"ARM\" namespace, and then carefully unqualify (put into global namespace)\n   or requalify (change qualifier to \"Arch\" instead of \"ARM\") in order to refer to entities in\n   generic proofs.\n\n"}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified\n  part of the machine state @{typ machine_state_rest} and cannot fail.\n  We could express the latter by type (leaving out the failure flag),\n  but if we later wanted to implement them,\n  we'd have to set up a new hoare-logic\n  framework for that type. So instead, we provide a wrapper for these\n  operations that explicitly ignores the fail flag and sets it to\n  False. Similarly, these operations never return an empty set of\n  follow-on states, which would require the operation to fail.\n  So we explicitly make this (non-existing) case a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming ARM", "property": "Machine Operations: Perform low-level operations on the machine state, specifically modifying the underspecified part of the machine state, and manage the failure flag to ensure consistent behavior.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  memory_regions :: \"(paddr \\<times> paddr) list\" \n  initTimer_impl :: \"unit machine_rest_monad\"\ndefinition\n  initTimer :: \"unit machine_monad\"\nwhere \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts'\n  resetTimer_impl :: \"unit machine_rest_monad\"\n\ndefinition\n  resetTimer :: \"unit machine_monad\"\nwhere \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"\n\nconsts'\n  writeTTBR0_impl :: \"paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  writeTTBR0 :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere \"writeTTBR0 pd \\<equiv> machine_op_lift (writeTTBR0_impl pd)\"\n\n\nconsts'\n  setHardwareASID_impl :: \"hardware_asid \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setHardwareASID:: \"hardware_asid \\<Rightarrow> unit machine_monad\"\nwhere \"setHardwareASID a \\<equiv> machine_op_lift (setHardwareASID_impl a)\"", "property": "Machine Operations: Provide low-level operations for managing hardware resources, including initializing and resetting timers, writing to translation tables, and setting hardware address space identifiers (ASIDs). These operations ensure that the kernel can interact with the underlying hardware efficiently and securely.\n\nSubproperties:\n- Timer Management: Initialize and reset timers to manage time-related events and interrupts.\n- Translation Table Management: Write to translation tables to manage virtual-to-physical address mappings.\n- ASID Management: Set hardware ASIDs to manage address spaces and ensure secure memory access.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  isb_impl :: \"unit machine_rest_monad\"\ndefinition\n  isb :: \"unit machine_monad\"\nwhere \"isb \\<equiv> machine_op_lift isb_impl\"\n\nconsts'\n  dsb_impl :: \"unit machine_rest_monad\"\ndefinition\n  dsb :: \"unit machine_monad\"\nwhere \"dsb \\<equiv> machine_op_lift dsb_impl\"\n\nconsts'\n  dmb_impl :: \"unit machine_rest_monad\"\ndefinition\n  dmb :: \"unit machine_monad\"\nwhere \"dmb \\<equiv> machine_op_lift dmb_impl\"\n\nconsts'\n  invalidateLocalTLB_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB :: \"unit machine_monad\"\nwhere \"invalidateLocalTLB \\<equiv> machine_op_lift invalidateLocalTLB_impl\"\n\n\nconsts'\n  invalidateLocalTLB_ASID_impl :: \"hardware_asid \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB_ASID :: \"hardware_asid \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateLocalTLB_ASID a \\<equiv> machine_op_lift (invalidateLocalTLB_ASID_impl a)\"", "property": "Machine Memory Barriers: Ensure the ordering and visibility of memory accesses across the system, maintaining data consistency and coherence.\n\nSubproperties:\n- Instruction Synchronization Barrier (ISB): Enforce instruction ordering and completion.\n- Data Synchronization Barrier (DSB): Ensure data access ordering and completion.\n- Data Memory Barrier (DMB): Maintain data access ordering.\n- TLB Invalidations: Invalidate local Translation Lookaside Buffer (TLB) entries for memory address translation coherence.\n  - Invalidate Local TLB: Invalidate the entire local TLB.\n  - Invalidate Local TLB by ASID: Invalidate local TLB entries for a specific Address Space Identifier (ASID).", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " Memory Barriers "}
{"spec": "consts'\n  invalidateLocalTLB_VAASID_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB_VAASID :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateLocalTLB_VAASID w \\<equiv> machine_op_lift (invalidateLocalTLB_VAASID_impl w)\"\n\nconsts'\n  cleanByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanByVA w p \\<equiv> machine_op_lift (cleanByVA_impl w p)\"\n\nconsts'\n  cleanByVA_PoU_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanByVA_PoU :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanByVA_PoU w p \\<equiv> machine_op_lift (cleanByVA_PoU_impl w p)\"\n\nconsts'\n  invalidateByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateByVA w p \\<equiv> machine_op_lift (invalidateByVA_impl w p)\"\n\nconsts'\n  invalidateByVA_I_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateByVA_I :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateByVA_I w p \\<equiv> machine_op_lift (invalidateByVA_I_impl w p)\"\n\nconsts'\n  invalidate_I_PoU_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidate_I_PoU :: \"unit machine_monad\"\nwhere \"invalidate_I_PoU \\<equiv> machine_op_lift invalidate_I_PoU_impl\"\n\nconsts'\n  cleanInvalByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanInvalByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanInvalByVA w p \\<equiv> machine_op_lift (cleanInvalByVA_impl w p)\"\n\nconsts'\n  branchFlush_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  branchFlush :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"branchFlush w p \\<equiv> machine_op_lift (branchFlush_impl w p)\"\n\nconsts'\n  clean_D_PoU_impl :: \"unit machine_rest_monad\"\ndefinition\n  clean_D_PoU :: \"unit machine_monad\"\nwhere \"clean_D_PoU \\<equiv> machine_op_lift clean_D_PoU_impl\"\n\nconsts'\n  cleanInvalidate_D_PoC_impl :: \"unit machine_rest_monad\"\ndefinition\n  cleanInvalidate_D_PoC :: \"unit machine_monad\"\nwhere \"cleanInvalidate_D_PoC \\<equiv> machine_op_lift cleanInvalidate_D_PoC_impl\"\n\nconsts'\n  cleanInvalidateL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanInvalidateL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanInvalidateL2Range w p \\<equiv> machine_op_lift (cleanInvalidateL2Range_impl w p)\"\n\nconsts'\n  invalidateL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateL2Range w p \\<equiv> machine_op_lift (invalidateL2Range_impl w p)\"\n\nconsts'\n  cleanL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanL2Range w p \\<equiv> machine_op_lift (cleanL2Range_impl w p)\"\n\nconsts'\n  initL2Cache_impl :: \"unit machine_rest_monad\"\ndefinition\n  initL2Cache :: \"unit machine_monad\"\nwhere \"initL2Cache \\<equiv> machine_op_lift initL2Cache_impl\"\n\ndefinition\n  clearExMonitor :: \"unit machine_monad\"\nwhere \"clearExMonitor \\<equiv> modify (\\<lambda>s. s \\<lparr> exclusive_state := default_exclusive_state \\<rparr>)\"\n\nconsts'\n  flushBTAC_impl :: \"unit machine_rest_monad\"\ndefinition\n  flushBTAC :: \"unit machine_monad\"\nwhere \"flushBTAC \\<equiv> machine_op_lift flushBTAC_impl\"\n\nconsts'\n  initIRQController_impl :: \"unit machine_rest_monad\"\ndefinition\n  initIRQController :: \"unit machine_monad\"\nwhere \"initIRQController \\<equiv> machine_op_lift initIRQController_impl\"\n\ndefinition\n  IRQ :: \"irq \\<Rightarrow> irq\"\nwhere \"IRQ \\<equiv> id\"\n\nconsts'\n  writeContextID_impl :: \"unit machine_rest_monad\"\ndefinition\n  writeContextID :: \"unit machine_monad\"\nwhere \"writeContextID \\<equiv> machine_op_lift writeContextID_impl\"\n\nlemmas cache_machine_op_defs = isb_def dsb_def dmb_def writeContextID_def flushBTAC_def\n                               clearExMonitor_def cleanL2Range_def invalidateL2Range_def\n                               cleanInvalidateL2Range_def cleanInvalidate_D_PoC_def\n                               clean_D_PoU_def branchFlush_def cleanInvalByVA_def\n                               invalidate_I_PoU_def invalidateByVA_I_def invalidateByVA_def\n                               cleanByVA_PoU_def cleanByVA_def invalidateLocalTLB_VAASID_def\n                               invalidateLocalTLB_ASID_def invalidateLocalTLB_def\nconsts'\n  IFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  DFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  FAR_val :: \"machine_state \\<Rightarrow> machine_word\"\n\ndefinition\n  getIFSR :: \"machine_word machine_monad\"\n  where \"getIFSR \\<equiv> gets IFSR_val\"\n\ndefinition\n  getDFSR :: \"machine_word machine_monad\"\n  where \"getDFSR \\<equiv> gets DFSR_val\"\n\ndefinition\n  getFAR :: \"machine_word machine_monad\"\n  where \"getFAR \\<equiv> gets FAR_val\"\n\ndefinition\n  debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\"\nwhere\n  debugPrint_def[simp]:\n \"debugPrint \\<equiv> \\<lambda>message. return ()\"\n\nconsts'\n  ackInterrupt_impl :: \"irq \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"ackInterrupt irq \\<equiv> machine_op_lift (ackInterrupt_impl irq)\"\n\n\n\\<comment> \\<open>Interrupt controller operations\\<close>", "property": "Machine Operations: Provide a set of low-level operations for managing the machine state, including cache management (cleaning, invalidating, and flushing), TLB management (invalidating), exception handling (clearing exclusive monitor, getting IFSR, DFSR, and FAR), interrupt handling (acknowledging interrupts), and debug printing.\n\nSubproperties:\n- Cache Management: Clean, invalidate, and flush cache lines to maintain cache coherence.\n- TLB Management: Invalidate TLB entries to ensure correct virtual-to-physical address translation.\n- Exception Handling: Clear exclusive monitor, get IFSR, DFSR, and FAR to handle exceptions correctly.\n- Interrupt Handling: Acknowledge interrupts to notify the interrupt controller.\n- Debug Printing: Print debug messages to aid in system debugging.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " C implementation takes one argument, which is w || a "}
{"spec": "definition\n  \"non_kernel_IRQs = {}\"", "property": "Non-Kernel Interrupts: No interrupts can occur while the kernel is running that are not handled by the kernel, specifically those that can occur from user mode are empty on plain ARMv7.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Interrupts that cannot occur while the kernel is running (e.g. at preemption points),\n  but that can occur from user mode. Empty on plain ARMv7.\n"}
{"spec": "definition\n  getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\"\nwhere\n  \"getActiveIRQ in_kernel \\<equiv> do\n    is_masked \\<leftarrow> gets $ irq_masks;\n    modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n    active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n    if is_masked active_irq \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n    then return None\n    else return (Some active_irq)\n  od\"\n\ndefinition\n  maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"maskInterrupt m irq \\<equiv>\n  modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"\n\ndefinition\n  lineStart :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"lineStart addr = (addr >> cacheLineBits) << cacheLineBits\"", "property": "Machine Operations: Manage interrupt handling and masking, ensuring deterministic and efficient interrupt processing. This includes updating the IRQ state, retrieving the active IRQ, and masking interrupts.\n\nSubproperties:\n- IRQ State Update: Increment the IRQ state to reflect the passage of time since the last IRQ retrieval.\n- Active IRQ Retrieval: Get the active IRQ, considering IRQ masking and kernel-mode restrictions.\n- Interrupt Masking: Set or clear the mask for a specific IRQ, controlling its interruptibility.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  @{term getActiveIRQ} is now derministic.\n  It 'updates' the irq state to the reflect the passage of\n  time since last the irq was gotten, then it gets the active\n  IRQ (if there is one).\n"}
{"spec": "definition\n  cacheRangeOp :: \"(machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad)\n                 \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cacheRangeOp operation vstart vend pstart \\<equiv>\n    let pend = pstart + (vend - vstart);\n        vptrs = [lineStart vstart, lineStart vstart + of_nat cacheLine .e. lineStart vend];\n        pptrs = [lineStart pstart, lineStart pstart + of_nat cacheLine .e. lineStart pend]\n    in mapM_x (\\<lambda>(v, p). operation v p) (zip vptrs pptrs)\"\n\ndefinition\n  cleanCacheRange_PoC :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_PoC vstart vend pstart \\<equiv> cacheRangeOp cleanByVA vstart vend pstart\"\n\ndefinition\n  cleanInvalidateCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanInvalidateCacheRange_RAM vstart vend pstart \\<equiv> do\n    cleanCacheRange_PoC vstart vend pstart;\n    dsb;\n    cleanInvalidateL2Range pstart (pstart + (vend - vstart));\n    cacheRangeOp cleanInvalByVA vstart vend pstart;\n    dsb\n  od\"\n\ndefinition\n  cleanCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_RAM vstart vend pstart \\<equiv> do\n    cleanCacheRange_PoC vstart vend pstart;\n    dsb;\n    cleanL2Range pstart (pstart + (vend - vstart))\n  od\"\n\ndefinition\n  cleanCacheRange_PoU :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_PoU vstart vend pstart \\<equiv> cacheRangeOp cleanByVA_PoU vstart vend pstart\"\n\ndefinition\n  invalidateCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"invalidateCacheRange_RAM vstart vend pstart \\<equiv> do\n    when (vstart \\<noteq> lineStart vstart) $\n        cleanCacheRange_RAM vstart vstart pstart;\n    when (vend + 1 \\<noteq> lineStart (vend + 1)) $\n        cleanCacheRange_RAM (lineStart vend) (lineStart vend)\n           (pstart + ((lineStart vend) - vstart));\n    invalidateL2Range pstart (pstart + (vend - vstart));\n    cacheRangeOp invalidateByVA vstart vend pstart;\n    dsb\n  od\"\n\ndefinition\n  invalidateCacheRange_I :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"invalidateCacheRange_I vstart vend pstart \\<equiv> cacheRangeOp invalidateByVA_I vstart vend pstart\"\n\ndefinition\n  branchFlushRange :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"branchFlushRange vstart vend pstart \\<equiv> cacheRangeOp branchFlush vstart vend pstart\"\n\ndefinition\n  cleanCaches_PoU :: \"unit machine_monad\"\nwhere\n  \"cleanCaches_PoU \\<equiv> do\n    dsb;\n    clean_D_PoU;\n    dsb;\n    invalidate_I_PoU;\n    dsb\n  od\"\n\ndefinition\n  cleanInvalidateL1Caches :: \"unit machine_monad\"\nwhere\n  \"cleanInvalidateL1Caches \\<equiv> do\n    dsb;\n    cleanInvalidate_D_PoC;\n    dsb;\n    invalidate_I_PoU;\n    dsb\n  od\"", "property": "Cache Operations: Perform various cache operations (cleaning, invalidating, flushing) on a range of cache lines, ensuring cache coherence and consistency.\n\nSubproperties:\n\n* Clean Cache Range: Clean the cache lines in a specified range, ensuring that the cache is up-to-date with the latest memory values.\n* Invalidate Cache Range: Invalidate the cache lines in a specified range, ensuring that the cache is cleared of stale data.\n* Flush Cache Range: Flush the cache lines in a specified range, ensuring that the cache is cleared of all data.\n* Clean and Invalidate Cache Range: Clean and invalidate the cache lines in a specified range, ensuring that the cache is both up-to-date and cleared of stale data.\n* Branch Flush Range: Flush the branch predictor cache lines in a specified range, ensuring that the branch predictor is cleared of stale data.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Performs the given operation on every cache line that intersects the\n  supplied range.\n"}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory. Do not yet flush the cache.\\<close>\ndefinition\n  clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"clearMemory ptr bytelength \\<equiv>\n    mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"\n\ndefinition\n  clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Memory Clearance: Clear the contents of a specified memory region to prepare it for reuse as user memory, without flushing the cache. \n\nSubproperties:\n- Clear Memory Region: Set all bytes in the specified memory region to zero.\n- Virtual Memory Clearance: No operation is performed for virtual memory clearance.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": ""}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Initialize memory for user use, ensuring it is properly cleared and prepared for allocation.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Initialize memory to be used as user memory.\n  Note that zeroing out the memory is redundant in the specifications.\n  In any case, we cannot abstract from the call to cleanCacheRange,\n  which appears in the implementation.\n"}
{"spec": "definition\n  freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"freeMemory ptr bits \\<equiv>\n  mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Memory Clearance: Zero out the underlying memory when freeing user memory to avoid garbage, ensuring that the exact memory content can be computed from the implementation state.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Free memory that had been initialized as user memory.\n  While freeing memory is a no-(in) the implementation,\n  we zero out the underlying memory in the specifications to avoid garbage.\n  If we know that there is no garbage,\n  we can compute from the implementation state\n  what the exact memory content in the specifications is.\n"}
{"spec": "type_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\" where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\" where\n  \"modify_registers f uc \\<equiv> UserContext (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\" where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext ((user_regs s) (r := v)))\"\n\ndefinition\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition\n  \"setNextPC \\<equiv> setRegister NextIP\"\n\nend\n\ntranslations\n  (type) \"'a ARM.user_monad\" <= (type) \"(ARM.register \\<Rightarrow> machine_word, 'a) nondet_monad\"\n\n\nend", "property": "User Monad Operations: Provides a set of operations for managing user-level registers and context, allowing for getting and setting register values, modifying registers, and controlling the program counter.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Platform Integer Representation: The platform represents C integer literals as 32-bit signed words.", "title": "./spec/machine/ARM/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming ARM\n\nvalue_type irq_len = Kernel_Config.irqBits (* IRQ_CNODE_SLOT_BITS *)\ntype_synonym irq = \"irq_len word\"\ntype_synonym paddr = word32\n\nabbreviation (input) \"toPAddr \\<equiv> id\"\nabbreviation (input) \"fromPAddr \\<equiv> id\"\n\ndefinition pageColourBits :: nat where\n  \"pageColourBits \\<equiv> 2\"\n\ndefinition cacheLineBits :: nat where\n  \"cacheLineBits = CONFIG_L1_CACHE_LINE_SIZE_BITS\"\n\ndefinition cacheLine :: nat where\n  \"cacheLine = 2^cacheLineBits\"", "property": "Platform Constants: Define fundamental platform-specific constants, including the length of IRQs, the type of physical addresses, and the number of bits for page coloring and cache line sizes, ensuring consistency and clarity in the kernel's platform-dependent configurations.\n\nPage Coloring and Cache Line: Specify the number of bits for page coloring (2 bits) and cache line sizes (CONFIG_L1_CACHE_LINE_SIZE_BITS), and calculate the cache line size (2^cacheLineBits), providing essential parameters for optimizing memory management and performance.", "title": "./spec/machine/ARM/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "definition pptrBase :: word32 where\n  \"pptrBase \\<equiv> 0xe0000000\"\n\nabbreviation (input) \"paddrBase \\<equiv> physBase\"\n\ndefinition pptrBaseOffset :: word32 where\n  \"pptrBaseOffset \\<equiv> pptrBase - paddrBase\"\n\ndefinition kernelELFPAddrBase :: word32 where\n  \"kernelELFPAddrBase \\<equiv> physBase\"\n\ndefinition kernelELFBase :: word32 where\n  \"kernelELFBase \\<equiv> pptrBase + (kernelELFPAddrBase && mask 22)\"\n\ndefinition kernelELFBaseOffset :: word32 where\n  \"kernelELFBaseOffset \\<equiv> kernelELFBase - kernelELFPAddrBase\"\n\ndefinition ptrFromPAddr :: \"paddr \\<Rightarrow> word32\" where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBaseOffset\"\n\ndefinition addrFromPPtr :: \"word32 \\<Rightarrow> paddr\" where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBaseOffset\"\n\ndefinition addrFromKPPtr :: \"word32 \\<Rightarrow> paddr\" where\n  \"addrFromKPPtr kpptr \\<equiv> kpptr - kernelELFBaseOffset\"\n\ndefinition minIRQ :: \"irq\" where\n  \"minIRQ \\<equiv> 0\"\n\nend\n\nend", "property": "Memory Layout Definitions: Define the base addresses and offsets for the kernel's physical memory window, including the relationship between physical and virtual addresses, and the base addresses for the kernel's ELF image.\n\nAddress Conversions: Provide functions to convert between physical addresses, virtual addresses, and kernel pointers, ensuring correct address calculations and memory access within the kernel's memory space.\n\nInterrupt Handling: Define the minimum IRQ (Interrupt Request) value, establishing a baseline for interrupt handling and management within the kernel.", "title": "./spec/machine/ARM/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": " The first virtual address of the kernel's physical memory window "}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming ARM", "property": "Architecture-Specific Kernel Configuration: Provides lemmas that constrain and validate the kernel configuration for a specific architecture, ensuring that the kernel is properly set up and configured for the underlying platform.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma physBase_aligned:\n  \"is_aligned physBase 24\"\n  by (simp add: is_aligned_def Kernel_Config.physBase_def)", "property": "Physical Base Alignment: The physical base address is aligned to a 24-bit boundary, ensuring proper memory alignment for the kernel configuration.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " note: 24 = pageBitsForSize ARMSuperSection, we do not have access to ASpec at this point "}
{"spec": "lemma maxIRQ_less_2p_irqBits:\n  \"(maxIRQ::nat) < 2^irqBits\"\n  by (simp add: Kernel_Config.maxIRQ_def Kernel_Config.irqBits_def)", "property": "IRQ Configuration: The maximum IRQ value is less than 2 to the power of the number of IRQ bits.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ conditions "}
{"spec": "lemma LENGTH_irq_len_irqBits[simp]: (* [simp] will fire only for simp del: len_of_numeral_defs *)\n  \"LENGTH(irq_len) = irqBits\"\n  using irq_len_def irq_len_val\n  by simp\n\nlemma maxIRQ_less_2p_irq_len:\n  \"(maxIRQ::nat) < 2^LENGTH(irq_len)\"\n  using maxIRQ_less_2p_irqBits\n  by (simp del: len_of_numeral_defs)", "property": "IRQ Length Properties: The length of the IRQ (Interrupt Request) is equal to the number of IRQ bits. The maximum IRQ value is less than 2 raised to the power of the IRQ length.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " follows from value_type definition of irq_len "}
{"spec": "lemma of_nat_maxIRQ[simp]:\n  \"of_nat maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma of_int_maxIRQ[simp]:\n  \"of_int maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "Generic Numerals for IRQ: Allow writing rules about casts, unat, uint, etc. without referencing specific numbers, using maxIRQ as a generic numeral representation.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ as a generic numeral allows us to write rules about casts/unat/uint etc without\n   mentioning numbers: "}
{"spec": "lemma unat_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> unat (maxIRQ::'a word) = maxIRQ\"\n  by (metis maxIRQ_less_2p_irq_len Word.of_nat_unat of_nat_inverse of_nat_maxIRQ unat_ucast_up_simp)", "property": "IRQ Length Property: The unat (unsigned natural number) value of maxIRQ is equal to maxIRQ when the length of irq_len is less than or equal to the length of the word type 'a.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma uint_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> uint (maxIRQ::'a word) = maxIRQ\"\n  by (metis Kernel_Config.maxIRQ_def of_nat_numeral uint_nat unat_maxIRQ)", "property": "IRQ Length Property: The length of irq_len is less than or equal to the length of the word type 'a, ensuring that the unsigned integer representation of maxIRQ is equal to maxIRQ.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma ucast_maxIRQ[simp]:\n  \"\\<lbrakk> LENGTH(irq_len) \\<le> LENGTH('a::len); LENGTH(irq_len) \\<le> LENGTH('b::len) \\<rbrakk> \\<Longrightarrow>\n   UCAST ('a \\<rightarrow> 'b) maxIRQ = maxIRQ\"\n  by (metis of_nat_maxIRQ ucast_nat_def unat_maxIRQ)", "property": "UCast MaxIRQ Equality: The unsigned cast of maxIRQ from type 'a to type 'b is equal to maxIRQ, given that the length of irq_len is less than or equal to the lengths of both 'a and 'b.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma maxIRQ_less_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   (maxIRQ < (ucast irq :: 'a word)) = (maxIRQ < irq)\" for irq::irq\n  by (simp add: word_less_nat_alt unat_ucast_up_simp)", "property": "IRQ Comparison Property: The comparison between the maximum IRQ value and an IRQ value upcasted to a word of a larger type is equivalent to the comparison between the maximum IRQ value and the original IRQ value, as long as the length of the IRQ type is less than or equal to the length of the larger type.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma maxIRQ_le_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   ((ucast irq :: 'a word) \\<le> Kernel_Config.maxIRQ) = (irq \\<le> Kernel_Config.maxIRQ)\" for irq::irq\n  by (simp add: word_le_nat_alt unat_ucast_up_simp)", "property": "IRQ Upcast Comparison: The comparison of an IRQ value upcast to a larger word type with the maximum IRQ value is equivalent to the original IRQ value comparison, given that the IRQ length is less than or equal to the length of the larger word type.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma le_maxIRQ_machine_less_irqBits_val[simplified]:\n  \"w \\<le> maxIRQ \\<Longrightarrow> unat w < 2^LENGTH(irq_len)\" for w::machine_word\n  using maxIRQ_less_2p_irq_len\n  by (simp add: word_le_nat_alt)\n\nlemma irq_machine_le_maxIRQ_irq:\n  \"irq \\<le> Kernel_Config.maxIRQ \\<Longrightarrow> (ucast irq::irq) \\<le> maxIRQ\" for irq::machine_word\n  by (simp add: Kernel_Config.maxIRQ_def word_le_nat_alt unat_ucast)\n\nlemma maxIRQ_eq_ucast_irq_32_signed_uint:\n  \"(maxIRQ = (ucast b :: int_word)) = (uint b = maxIRQ)\" for b::irq\n  unfolding Kernel_Config.maxIRQ_def\n  apply uint_arith\n  apply (simp add: uint_up_ucast is_up)\n  done\n\nlemma sint_maxIRQ_32[simp]:\n  \"sint (maxIRQ :: int_word) = maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_machine[simp]:\n  \"scast (maxIRQ :: int_word) = (maxIRQ::machine_word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_irq[simp]:\n  \"scast (maxIRQ :: int_word) = (maxIRQ::irq)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_machine:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = x\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_irq:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = (ucast x :: irq)\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_1_plus_eq_Suc_machine[simp]:\n  \"unat (1 + maxIRQ :: machine_word) = Suc Kernel_Config.maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "IRQ Value Properties: Ensure that IRQ values are correctly represented and converted between different types (machine word, IRQ, and int word) while maintaining their relationships and bounds with respect to the maximum IRQ value.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " The following are instances -- for some we could derive general rules, but the number of\n   instances is limited and the concrete proofs are much simpler: "}
{"spec": "lemma cacheLineBits_sanity:\n  \"cacheLineBits \\<in> {2..10}\"\n  by (simp add: cacheLineBits_def Kernel_Config.CONFIG_L1_CACHE_LINE_SIZE_BITS_def)\n\nend\nend", "property": "Cache Line Bits Sanity: The cache line bits value must be within a valid range (2 to 10) to ensure reliable folding in C functions and avoid conflicts with other values used in cache operations.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Folding cacheLineBits_val in C functions only works reliably if cacheLineBits is not 1 and\n   not too large to conflict with other values used inside cache ops.\n   10 is ptBits, which is only available after ExecSpec. Anything > 1 and smaller than ptBits\n   works. "}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified\n  part of the machine state @{typ machine_state_rest} and cannot fail.\n  We could express the latter by type (leaving out the failure flag),\n  but if we later wanted to implement them,\n  we'd have to set up a new hoare-logic\n  framework for that type. So instead, we provide a wrapper for these\n  operations that explicitly ignores the fail flag and sets it to\n  False. Similarly, these operations never return an empty set of\n  follow-on states, which would require the operation to fail.\n  So we explicitly make this (non-existing) case a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming X64", "property": "Machine Operations: Perform low-level operations on the machine state, working on the underspecified part of the machine state and never failing, with any potential failure flag explicitly ignored and set to False, ensuring a non-empty set of follow-on states.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  memory_regions :: \"(paddr \\<times> paddr) list\" \n  initTimer_impl :: \"unit machine_rest_monad\"\ndefinition\n  initTimer :: \"unit machine_monad\"\nwhere \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts'\n  resetTimer_impl :: \"unit machine_rest_monad\"\n\ndefinition\n  resetTimer :: \"unit machine_monad\"\nwhere \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"\n\nconsts'\n  invalidateTLB_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidateTLB :: \"unit machine_monad\"\nwhere \"invalidateTLB \\<equiv> machine_op_lift invalidateTLB_impl\"\n\nlemmas cache_machine_op_defs = invalidateTLB_def\n\ndefinition\n  debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\"\nwhere\n  debugPrint_def[simp]:\n \"debugPrint \\<equiv> \\<lambda>message. return ()\"\n\n\n\\<comment> \\<open>Interrupt controller operations\\<close>", "property": "Machine Operations: Provide low-level operations for managing hardware components, including initializing and resetting timers, invalidating the translation lookaside buffer (TLB), and printing debug messages. These operations ensure that the machine's hardware is properly initialized and managed, supporting the kernel's execution and interaction with the hardware. \n\nTimer Management: Initialize and reset the system timer to manage timekeeping and scheduling. \n\nTLB Management: Invalidate the TLB to ensure cache coherence and proper memory management. \n\nDebugging: Print debug messages to facilitate kernel development and debugging.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition\n  \"non_kernel_IRQs = {}\"", "property": "Non-Kernel Interrupts: No interrupts can occur while the kernel is running that are not handled by the kernel itself.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Interrupts that cannot occur while the kernel is running (e.g. at preemption points),\n  but that can occur from user mode. Empty on plain x86-64.\n"}
{"spec": "definition\n  getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\"\nwhere\n  \"getActiveIRQ in_kernel \\<equiv> do\n    is_masked \\<leftarrow> gets $ irq_masks;\n    modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n    active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n    if is_masked active_irq \\<or> active_irq = 0xFF \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n    then return None\n    else return ((Some active_irq) :: irq option)\n  od\"\n\ndefinition\n  maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"maskInterrupt m irq \\<equiv>\n  modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"", "property": "IRQ Management: Manage interrupt requests (IRQs) by updating the IRQ state, retrieving the active IRQ, and masking interrupts. Ensure that IRQs are correctly handled, taking into account masked IRQs, kernel-mode IRQs, and non-kernel IRQs.\n\nSubproperties:\n- Update IRQ State: Increment the IRQ state to reflect the passage of time.\n- Get Active IRQ: Retrieve the active IRQ, considering masked IRQs and kernel-mode IRQs.\n- Mask Interrupts: Set or clear the mask for a specific IRQ.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  @{term getActiveIRQ} is now derministic.\n  It 'updates' the irq state to the reflect the passage of\n  time since last the irq was gotten, then it gets the active\n  IRQ (if there is one).\n"}
{"spec": "definition\n  ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"ackInterrupt \\<equiv> \\<lambda>irq. return ()\"", "property": "Acknowledge Interrupt: Does nothing in response to an interrupt request.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Does nothing on imx31"}
{"spec": "definition\n  setInterruptMode :: \"irq \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setInterruptMode \\<equiv> \\<lambda>irq levelTrigger polarityLow. return ()\"", "property": "Set Interrupt Mode: Does nothing, leaving interrupt settings unchanged.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Does nothing on imx31"}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory\\<close>\ndefinition\n  clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"clearMemory ptr bytelength \\<equiv> mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"\n\ndefinition\n  clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Memory Clearance: Clear the contents of a specified memory region to prepare it for reuse as user memory, ensuring that all data within the region is erased. \n\nSubproperties:\n- Clear Memory Region: Set all bytes within the specified memory region to zero, effectively erasing any data that previously existed within that region.\n- Virtual Memory Clearance: No operation is performed when clearing virtual memory.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": ""}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Initialize memory for user use, ensuring it is properly cleared and prepared for allocation.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Initialize memory to be used as user memory.\n  Note that zeroing out the memory is redundant in the specifications.\n  In any case, we cannot abstract from the call to cleanCacheRange,\n  which appears in the implementation.\n"}
{"spec": "definition\n  freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"freeMemory ptr bits \\<equiv>\n  mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Memory Clearance: Zero out the underlying memory when freeing user memory to avoid garbage, ensuring that the exact memory content can be computed from the implementation state.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Free memory that had been initialized as user memory.\n  While freeing memory is a no-(in) the implementation,\n  we zero out the underlying memory in the specifications to avoid garbage.\n  If we know that there is no garbage,\n  we can compute from the implementation state\n  what the exact memory content in the specifications is.\n"}
{"spec": "text \\<open> There are 576 bytes of FPU state. Since there are no operations on this state apart from bulk\nsave/restore, we abstract from names and just say how many bytes there are. \\<close>\ntype_synonym fpu_bytes = 576\ntype_synonym fpu_state = \"fpu_bytes \\<Rightarrow> 8 word\"\n\ntype_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (fpu_state : fpu_state) (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition\n  getRegister :: \"register \\<Rightarrow> machine_word user_monad\"\nwhere\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition\n  \"modify_registers f uc \\<equiv> UserContext (fpu_state uc) (f (user_regs uc))\"\n\ndefinition\n  setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\"\nwhere\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext (fpu_state s) ((user_regs s) (r := v)))\"\n\ndefinition\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition\n  \"setNextPC \\<equiv> setRegister NextIP\"\n\n\ndefinition\n  getFPUState :: \"fpu_state user_monad\"\nwhere\n  \"getFPUState \\<equiv> gets fpu_state\"\n\ndefinition\n  setFPUState :: \"fpu_state \\<Rightarrow> unit user_monad\"\nwhere\n  \"setFPUState fc \\<equiv> modify (\\<lambda>s. UserContext fc (user_regs s))\"\n\n\n\ndefinition\n  hwASIDInvalidate :: \"word64 \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"hwASIDInvalidate \\<equiv> invalidateASID\"\n\nconsts'\n  getFaultAddress_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\ngetFaultAddress :: \"word64 machine_monad\"\nwhere\n\"getFaultAddress \\<equiv> gets getFaultAddress_val\"\n\nconsts'\n  irqIntOffset_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\nirqIntOffset :: \"machine_word\"\nwhere\n\"irqIntOffset \\<equiv> 0x20\"\n\ndefinition\nmaxPCIBus :: \"machine_word\"\nwhere\n\"maxPCIBus \\<equiv> 0xFF\"\n\ndefinition\nmaxPCIDev :: \"machine_word\"\nwhere\n\"maxPCIDev \\<equiv> 31\"\n\ndefinition\nmaxPCIFunc :: \"machine_word\"\nwhere\n\"maxPCIFunc \\<equiv> 7\"\n\ndefinition\nioapicIRQLines :: \"machine_word\"\nwhere\n\"ioapicIRQLines \\<equiv> 24\"\n\nconsts'\n  ioapicMapPinToVector_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow>\n    machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  ioapicMapPinToVector :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow>\n    machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"ioapicMapPinToVector ioapic pin level polarity vector \\<equiv>\n    machine_op_lift (ioapicMapPinToVector_impl ioapic pin level polarity vector)\"\n\ndefinition IRQ :: \"word8 \\<Rightarrow> irq\"\nwhere\n  \"IRQ \\<equiv> id\"\n\nconsts'\n  in8_impl :: \"word16 \\<Rightarrow> unit machine_rest_monad\"\n  in8_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  in8 :: \"word16 \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"in8 port \\<equiv> do machine_op_lift $ in8_impl port; gets in8_val od\"\n\nconsts'\n  in16_impl :: \"word16 \\<Rightarrow> unit machine_rest_monad\"\n  in16_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  in16 :: \"word16 \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"in16 port \\<equiv> do machine_op_lift $ in16_impl port; gets in16_val od\"\n\nconsts'\n  in32_impl :: \"word16 \\<Rightarrow> unit machine_rest_monad\"\n  in32_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  in32 :: \"word16 \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"in32 port \\<equiv> do machine_op_lift $ in32_impl port; gets in32_val od\"\n\nconsts'\n  out8_impl :: \"word16 \\<Rightarrow> word8 \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  out8 :: \"word16 \\<Rightarrow> word8 \\<Rightarrow> unit machine_monad\"\nwhere\n  \"out8 port dat \\<equiv> machine_op_lift $ out8_impl port dat\"\n\nconsts'\n  out16_impl :: \"word16 \\<Rightarrow> word16 \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  out16 :: \"word16 \\<Rightarrow> word16 \\<Rightarrow> unit machine_monad\"\nwhere\n  \"out16 port dat \\<equiv> machine_op_lift $ out16_impl port dat\"\n\nconsts'\n  out32_impl :: \"word16 \\<Rightarrow> word32 \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  out32 :: \"word16 \\<Rightarrow> word32 \\<Rightarrow> unit machine_monad\"\nwhere\n  \"out32 port dat \\<equiv> machine_op_lift $ out32_impl port dat\"\n\nend\n\n\nend", "property": "Machine Operations: Provides low-level operations for managing user context, registers, and FPU state, as well as hardware-specific operations for ASID invalidation, interrupt handling, and I/O operations.\n\nUser Context Management: Allows getting and setting register values, FPU state, and next PC values, ensuring proper management of user context.\n\nHardware Operations: Supports hardware-specific operations, including ASID invalidation, getting fault addresses, and I/O operations (in8, in16, in32, out8, out16, out32), enabling interaction with the underlying hardware.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Platform Integer Representation: The platform represents C integer literals as 32-bit signed words.", "title": "./spec/machine/X64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming X64\n\ntype_synonym irq_len = 8\ntype_synonym irq = \"irq_len word\"\ntype_synonym paddr = word64\n\n\nabbreviation (input) \"toPAddr \\<equiv> id\"\nabbreviation (input) \"fromPAddr \\<equiv> id\"\n\ndefinition\n  pptrBase :: word64 where\n  \"pptrBase = 0xffffff8000000000\"\n\ndefinition\n  kernelELFBaseOffset :: word64 where\n  \"kernelELFBaseOffset = 0xffffffff80000000\"\n\ndefinition\n  pptrUserTop :: word64 where\n  \"pptrUserTop = 0x00007fffffffffff\"\n\ndefinition\n  ptrFromPAddr :: \"paddr \\<Rightarrow> word64\" where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBase\"\n\ndefinition\n  addrFromPPtr :: \"word64 \\<Rightarrow> paddr\" where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBase\"\n\ndefinition\n  addrFromKPPtr :: \"word64 \\<Rightarrow> paddr\" where\n  \"addrFromKPPtr pptr \\<equiv> pptr - kernelELFBaseOffset\"\n\ndefinition\n  pageColourBits :: \"nat\" where\n  \"pageColourBits \\<equiv> undefined\"\n\ndefinition\n  minIRQ :: \"irq\" where\n  \"minIRQ \\<equiv> 0\"\n\ndefinition\n  maxIRQ :: \"irq\" where\n  \"maxIRQ \\<equiv> 125\"\n\ndefinition\n  minUserIRQ :: \"irq\" where\n  \"minUserIRQ \\<equiv> 16\"\n\ndefinition\n  maxUserIRQ :: \"irq\" where\n  \"maxUserIRQ \\<equiv> 123\"\n\ndatatype cr3 = X64CR3 (CR3BaseAddress: word64) (cr3pcid: word64)\n\nprimrec cr3BaseAddress_update :: \"(word64 \\<Rightarrow> word64) \\<Rightarrow> cr3 \\<Rightarrow> cr3\"\nwhere\n  \"cr3BaseAddress_update f (X64CR3 v0 v1) = (X64CR3 (f v0) v1)\"\n\nprimrec cr3pcid_update :: \"(word64 \\<Rightarrow> word64) \\<Rightarrow> cr3 \\<Rightarrow> cr3\"\nwhere\n  \"cr3pcid_update f (X64CR3 v0 v1) = (X64CR3 v0 (f v1))\"\n\n\nend\nend", "property": "Platform Constants: Define the fundamental constants and data types for the X64 architecture, including the base addresses for physical and kernel ELF, user top address, and interrupt request (IRQ) ranges for the system and users. These constants provide the basis for memory management, interrupt handling, and other low-level operations. \n\nMemory Address Conversions: Provide functions to convert between physical addresses, kernel pointers, and user pointers, ensuring correct memory access and management.", "title": "./spec/machine/X64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming X64\n\nend\nend", "property": "No specific property can be summarized from this code snippet as it appears to be a theory or module declaration in a formal verification framework, and does not contain any specific definitions or lemmas that describe a property of the system.", "title": "./spec/machine/X64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified part of the machine state @{typ\n  machine_state_rest} and cannot fail. We could express the latter by type (leaving out the failure\n  flag), but if we later wanted to implement them, we'd have to set up a new Hoare logic framework\n  for that type. So instead, we provide a wrapper for these operations that explicitly ignores the\n  fail flag and sets it to False. Similarly, these operations never return an empty set of follow-on\n  states, which would require the operation to fail. So we explicitly make this (non-existing) case\n  a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming RISCV64", "property": "Machine Operations: Perform low-level operations on the machine state, specifically on the underspecified part of the machine state, without failing and always returning a non-empty set of follow-on states.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition loadWord :: \"machine_word \\<Rightarrow> machine_word machine_monad\"\n  where\n  \"loadWord p \\<equiv> do\n     m \\<leftarrow> gets underlying_memory;\n     assert (p && mask 3 = 0);\n     return (word_rcat (map (\\<lambda>i. m (p + (7 - of_int i))) [0 .. 7]))\n   od\"\n\ndefinition storeWord :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\n  where\n  \"storeWord p w \\<equiv> do\n     assert (p && mask 3 = 0);\n     modify (underlying_memory_update\n              (fold (\\<lambda>i m. m((p + (of_int i)) := word_rsplit w ! (7 - nat i))) [0 .. 7]))\n   od\"\n\nlemma upto0_7_def:\n  \"[0..7] = [0,1,2,3,4,5,6,7]\" by eval\n\nlemma loadWord_storeWord_is_return:\n  \"p && mask 3 = 0 \\<Longrightarrow> (do w \\<leftarrow> loadWord p; storeWord p w od) = return ()\"\n  by (auto simp: loadWord_def storeWord_def bind_def assert_def return_def word_rsplit_rcat_size\n                 modify_def gets_def get_def eval_nat_numeral put_def upto0_7_def word_size)\n\nconsts' memory_regions :: \"(paddr \\<times> paddr) list\"\ndefinition getMemoryRegions :: \"(paddr * paddr) list machine_monad\"\n  where\n  \"getMemoryRegions \\<equiv> return memory_regions\"", "property": "Memory Management: Provides fundamental operations for managing memory at the machine level, including loading and storing words, and retrieving memory regions. Ensures that memory operations are correctly aligned and that memory regions are accurately defined.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition storeWordVM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\n  where\n  \"storeWordVM w p \\<equiv> return ()\"", "property": "Store Word VM: Store a machine word at a specified virtual memory address, with no actual effect on the machine state.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "This instruction is required in the simulator, only."}
{"spec": "consts' configureTimer_impl :: \"unit machine_rest_monad\"\nconsts' configureTimer_val :: \"machine_state \\<Rightarrow> irq\"\ndefinition configureTimer :: \"irq machine_monad\"\n  where\n  \"configureTimer \\<equiv> do\n     machine_op_lift configureTimer_impl;\n     gets configureTimer_val\n   od\"\n\nconsts' initTimer_impl :: \"unit machine_rest_monad\"\ndefinition initTimer :: \"unit machine_monad\"\n  where\n  \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts' resetTimer_impl :: \"unit machine_rest_monad\"\ndefinition resetTimer :: \"unit machine_monad\"\n  where\n  \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"", "property": "Timer Configuration and Control: Configure, initialize, and reset the timer, ensuring proper management of time-related operations and interrupts. \n\nConfigure Timer: Set up the timer and retrieve the resulting IRQ.\nInitialize Timer: Initialize the timer to its default state.\nReset Timer: Reset the timer to a known state.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\"\n  where\n  debugPrint_def[simp]:\n  \"debugPrint \\<equiv> \\<lambda>message. return ()\"", "property": "Debug Print Operation: Ignore any debug print messages and do nothing, effectively disabling debug printing.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition\n  IRQ :: \"irq \\<Rightarrow> irq\"\nwhere \"IRQ \\<equiv> id\"\n\nconsts'\n  setIRQTrigger_impl :: \"irq \\<Rightarrow> bool \\<Rightarrow> unit machine_rest_monad\"\n\ndefinition\n  setIRQTrigger :: \"irq \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setIRQTrigger irq trigger \\<equiv> machine_op_lift (setIRQTrigger_impl irq trigger)\"\n\nconsts'\n  plic_complete_claim_impl :: \"irq \\<Rightarrow> unit machine_rest_monad\"\n\ndefinition\n  plic_complete_claim :: \"irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"plic_complete_claim irq \\<equiv> machine_op_lift (plic_complete_claim_impl irq)\"", "property": "Interrupt Controller Operations: Manage interrupt controller settings, allowing for the configuration of IRQ triggers and the completion of interrupt claims, ensuring proper interrupt handling and system stability. \n\nSet IRQ Trigger: Set the trigger mode for a specific IRQ, configuring whether it is edge-triggered or level-triggered.\n\nPLIC Complete Claim: Signal the completion of an interrupt claim for a specific IRQ, ensuring that the interrupt is properly acknowledged and processed.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition non_kernel_IRQs :: \"irq set\"\n  where\n  \"non_kernel_IRQs = {}\"", "property": "Non-Kernel Interrupts: Define the set of interrupts that cannot occur while the kernel is running but can occur from user mode as an empty set.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Interrupts that cannot occur while the kernel is running (e.g. at preemption points), but\nthat can occur from user mode. Empty on RISCV64."}
{"spec": "definition getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\"\n  where\n  \"getActiveIRQ in_kernel \\<equiv> do\n     is_masked \\<leftarrow> gets $ irq_masks;\n     modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n     active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n     if is_masked active_irq \\<or> active_irq = 0xFF \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n     then return None\n     else return ((Some active_irq) :: irq option)\n   od\"\n\ndefinition maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\"\n  where\n  \"maskInterrupt m irq \\<equiv> modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"\n\ndefinition ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\"\n  where\n  \"ackInterrupt \\<equiv> \\<lambda>irq. return ()\"\n\ndefinition setInterruptMode :: \"irq \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\"\n  where\n  \"setInterruptMode \\<equiv> \\<lambda>irq levelTrigger polarityLow. return ()\"", "property": "Interrupt Controller Operations: Manage interrupt-related operations, including retrieving the active IRQ, masking interrupts, acknowledging interrupts, and setting interrupt modes, ensuring proper interrupt handling and control within the system.\n\nGet Active IRQ: Retrieve the active IRQ, if any, while updating the IRQ state to reflect the passage of time and considering IRQ masking and kernel-specific restrictions.\n\nMask Interrupt: Set or clear the mask for a specific IRQ, controlling whether it can trigger an interrupt.\n\nAcknowledge Interrupt: Acknowledge a specific IRQ, currently a no-op operation.\n\nSet Interrupt Mode: Configure the mode of a specific IRQ, including level triggering and polarity, currently a no-op operation.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "@{term getActiveIRQ} is oracle-based and deterministic to allow information flow proofs. It\nupdates the IRQ state to the reflect the passage of time since last the IRQ, then it gets the active\nIRQ (if there is one)."}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory\\<close>\ndefinition clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemory ptr bytelength \\<equiv>\n     mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"", "property": "Memory Clearance: Clear a specified range of memory by setting all its contents to zero, making it available for reuse as user memory.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Clear Memory Operation: Clears a specified range of memory, defined by a pointer and a number of bits, with no actual effect in the Haskell simulator interface stub implementation.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Haskell simulator interface stub."}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Initialize memory for user use, ensuring it is properly cleared and prepared for allocation.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Initialize memory to be used as user memory. Note that zeroing out the memory is redundant\n  in the specifications. In any case, we cannot abstract from the call to cleanCacheRange, which\n  appears in the implementation.\n"}
{"spec": "definition freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"freeMemory ptr bits \\<equiv>\n   mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Clearing Memory: Zero out the memory content of a given range to prevent garbage, ensuring that the memory is properly cleared when freed.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Free memory that had been initialized as user memory. While freeing memory is a no-op in the\n  implementation, we zero out the underlying memory in the specifications to avoid garbage. If we\n  know that there is no garbage, we can compute from the implementation state what the exact memory\n  content in the specifications is.\n"}
{"spec": "type_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\"\n  where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\"\n  where\n  \"modify_registers f uc \\<equiv> UserContext (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\"\n  where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext ((user_regs s) (r := v)))\"\n\ndefinition getRestartPC :: \"machine_word user_monad\"\n  where\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition setNextPC :: \"machine_word \\<Rightarrow> unit user_monad\"\n  where\n  \"setNextPC \\<equiv> setRegister NextIP\"", "property": "User Register Management: Provides operations to manage user registers, including getting and setting register values, modifying registers, and managing program counters for restart and next instruction execution.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' initL2Cache_impl :: \"unit machine_rest_monad\"\ndefinition initL2Cache :: \"unit machine_monad\"\n  where\n  \"initL2Cache \\<equiv> machine_op_lift initL2Cache_impl\"\n\nconsts' hwASIDFlush_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition hwASIDFlush :: \"machine_word \\<Rightarrow> unit machine_monad\"\n  where\n  \"hwASIDFlush asid \\<equiv> machine_op_lift (hwASIDFlush_impl asid)\"\n\nconsts' sfence_impl :: \"unit machine_rest_monad\"\ndefinition sfence :: \"unit machine_monad\"\n  where\n  \"sfence \\<equiv> machine_op_lift sfence_impl\"\n\nlemmas cache_machine_op_defs = sfence_def hwASIDFlush_def", "property": "Machine Operations for Cache Management: Provide low-level operations for managing caches, including initializing the L2 cache, flushing the ASID (Address Space Identifier) from the hardware, and executing a store fence (sfence) operation to ensure memory consistency.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' stval_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition read_stval :: \"machine_word machine_monad\"\n  where\n  \"read_stval = gets stval_val\"", "property": "Read Stval: Retrieve the value of the stval register from the machine state.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' setVSpaceRoot_impl :: \"paddr \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition setVSpaceRoot :: \"paddr \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\n  where\n  \"setVSpaceRoot pt asid \\<equiv> machine_op_lift $ setVSpaceRoot_impl pt asid\"\n\nend\nend", "property": "Set Virtual Space Root: Set the root of the virtual memory space for a given address space identifier (ASID) to a specified page table (PT) address.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Platform Integer Representation: The platform represents C integer literals as 32-bit signed words.", "title": "./spec/machine/RISCV64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming RISCV64\n\nvalue_type irq_len = Kernel_Config.irqBits (* IRQ_CNODE_SLOT_BITS *)\ntype_synonym irq = \"irq_len word\"\ntype_synonym paddr = machine_word\n\nabbreviation (input) \"toPAddr \\<equiv> id\"\nabbreviation (input) \"fromPAddr \\<equiv> id\"", "property": "Platform Constants: Define the fundamental data types and constants for the platform, including the length of IRQs (irq_len) and the type of physical addresses (paddr).", "title": "./spec/machine/RISCV64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "definition canonical_bit :: nat\n  where\n  \"canonical_bit = 38\"\n\ndefinition kdevBase :: machine_word\n  where\n  \"kdevBase = - (1 << 30)\" (* 2^64 - 1 GiB *)\n\nlemma \"kdevBase = 0xFFFFFFFFC0000000\" (* Sanity check with C *)\n  by (simp add: kdevBase_def)\n\ndefinition kernelELFPAddrBase :: machine_word\n  where\n  \"kernelELFPAddrBase = physBase + 0x4000000\"\n\ndefinition pptrTop :: machine_word\n  where\n  \"pptrTop \\<equiv> - (1 << 31)\"\n\ndefinition kernelELFBase :: machine_word\n  where\n  \"kernelELFBase = pptrTop + (kernelELFPAddrBase && mask 30)\" (* 2^64 - 2 GiB + ... *)\n\ndefinition kernelELFBaseOffset :: machine_word\n  where\n  \"kernelELFBaseOffset = kernelELFBase - kernelELFPAddrBase\"\n\ndefinition pptrBase :: machine_word\n  where\n  \"pptrBase = - (1 << canonical_bit)\"\n\nlemma \"pptrBase = 0xFFFFFFC000000000\" (* Sanity check with C *)\n  by (simp add: pptrBase_def canonical_bit_def)\n\ndefinition pptrUserTop :: machine_word\n  where\n  \"pptrUserTop \\<equiv> mask canonical_bit && ~~mask 12\" (* for page boundary alignment *)\n\nlemma \"pptrUserTop = 0x0000003ffffff000\" (* Sanity check with C *)\n  by (simp add: pptrUserTop_def canonical_bit_def mask_def)\n\nschematic_goal pptrUserTop_def': (* direct constant definition *)\n  \"RISCV64.pptrUserTop = numeral ?x\"\n  by (simp add: RISCV64.pptrUserTop_def canonical_bit_def mask_def del: word_eq_numeral_iff_iszero)\n\ndefinition paddrBase :: machine_word\n  where\n  \"paddrBase \\<equiv> 0\"\n\ndefinition pptrBaseOffset :: machine_word\n  where\n  \"pptrBaseOffset = pptrBase - paddrBase\"\n\ndefinition ptrFromPAddr :: \"paddr \\<Rightarrow> machine_word\"\n  where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBaseOffset\"\n\ndefinition addrFromPPtr :: \"machine_word \\<Rightarrow> paddr\"\n  where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBaseOffset\"\n\ndefinition addrFromKPPtr :: \"machine_word \\<Rightarrow> paddr\"\n  where\n  \"addrFromKPPtr pptr \\<equiv> pptr - kernelELFBaseOffset\"\n\ndefinition minIRQ :: \"irq\"\n  where\n  \"minIRQ \\<equiv> 0\"\n\ndefinition maxIRQ :: \"irq\"\n  where\n  \"maxIRQ \\<equiv> 54\"", "property": "Platform Constants Definition: Define various platform-specific constants, including physical and virtual address bases, offsets, and bounds, as well as IRQ limits, to provide a foundation for the kernel's memory management and interrupt handling.\n\n Subproperties:\n- Address Space Definition: Define the base addresses and offsets for the kernel's physical and virtual address spaces, including the canonical bit, kernel ELF base, and user top addresses.\n- IRQ Limits Definition: Define the minimum and maximum IRQ values to establish the valid range for interrupt handling.", "title": "./spec/machine/RISCV64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": " NOTE: a number of these constants appear in the Haskell, but are shadowed\n   here due to more convenient formulation.\n   Examples: kernelELFBase, kernelELFBaseOffset, kernelELFAddressBase, pptrBase\n   Ideally and in future, we should converge on a single authoritative source\n   of these constants.\n"}
{"spec": "definition irqInvalid :: \"irq\"\n  where\n  \"irqInvalid \\<equiv> 0\"\n\ndefinition pageColourBits :: nat\n  where\n  \"pageColourBits \\<equiv> undefined\" \\<comment> \\<open>not implemented on this platform\\<close>\n\nend\nend", "property": "Platform Constants: Define fundamental platform-specific constants, including the invalid IRQ value and page color bits, to establish a common understanding of the platform's configuration and behavior. \n\nInvalid IRQ Representation: Reserve a specific IRQ value to indicate an invalid or non-existent IRQ, ensuring proper handling and distinction from valid IRQs.\n\nPage Color Bits Configuration: Specify the number of bits used to represent page colors, which is currently undefined for this platform, indicating a platform-specific detail that requires implementation.", "title": "./spec/machine/RISCV64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": " Reserved by C to represent \"not an IRQ\" "}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming RISCV64\n\nlemma pptrBase_kernelELFBase:\n  \"pptrBase < kernelELFBase\"\n  by (simp add: pptrBase_def canonical_bit_def kernelELFBase_def kernelELFPAddrBase_def pptrTop_def\n                Kernel_Config.physBase_def mask_def)", "property": "Memory Layout Constraint: The base address of the physical pointer (pptrBase) is less than the base address of the kernel ELF (kernelELFBase).", "title": "./spec/machine/RISCV64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma is_page_aligned_physBase:\n  \"is_aligned physBase 12\"\n  by (simp add: Kernel_Config.physBase_def is_aligned_def)", "property": "Physical Base Alignment: The physical base address is aligned to a 12-bit boundary (i.e., page-aligned).", "title": "./spec/machine/RISCV64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " 12 in this lemma and below is pageBits, which is not yet defined in this theory.\n   Definition will be folded and the lemmas shadowed in AInvs. "}
{"spec": "lemma kernel_window_sufficient:\n  \"pptrBase + (1 << 22) \\<le> kernelELFBase\"\n  unfolding pptrBase_def canonical_bit_def kernelELFBase_def kernelELFPAddrBase_def pptrTop_def\n  by (simp add: mask_def Kernel_Config.physBase_def)\n\nlemma kernel_elf_window_at_least_page:\n  \"kernelELFBase + 2 ^ 12 \\<le> kdevBase\"\n  unfolding kernelELFBase_def kernelELFPAddrBase_def kdevBase_def pptrTop_def\n  by (simp add: mask_def Kernel_Config.physBase_def)", "property": "Kernel Window Constraints: The kernel window is sufficiently large, with the base of the kernel ELF located above the base of the physical pointer space plus a 22-bit offset, and the kernel ELF window is at least one page in size, with the base of the kernel device space located above the base of the kernel ELF plus a 12-bit offset. \n\nSubproperties:\n- Kernel Window Size: The kernel window size is at least 22 bits.\n- Kernel ELF Window Size: The kernel ELF window size is at least 12 bits (one page).", "title": "./spec/machine/RISCV64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " 22 is kernel_window_bits, defined in Init_A. To be folded in AInvs. "}
{"spec": "lemma kernelELFBase_no_overflow:\n  \"kernelELFBase < kernelELFBase + 2 ^ 12\"\n  unfolding kernelELFBase_def kernelELFPAddrBase_def pptrTop_def\n  by (simp add: mask_def Kernel_Config.physBase_def)\n\nend\nend", "property": "Kernel ELF Base Address Property: The kernel ELF base address is less than the sum of the kernel ELF base address and 2^12, ensuring no overflow occurs.", "title": "./spec/machine/RISCV64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " This doesn't follow from alignment, because we need <, not \\<le> "}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified part of the machine state @{typ\n  machine_state_rest} and cannot fail. We could express the latter by type (leaving out the failure\n  flag), but if we later wanted to implement them, we'd have to set up a new Hoare logic framework\n  for that type. So instead, we provide a wrapper for these operations that explicitly ignores the\n  fail flag and sets it to False. Similarly, these operations never return an empty set of follow-on\n  states, which would require the operation to fail. So we explicitly make this (non-existing) case\n  a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\\<close>\n\ncontext Arch begin global_naming AARCH64", "property": "Machine Operations: Perform low-level operations on the machine state, working on the underspecified part of the state and never failing, with any potential failure flag explicitly ignored and set to False, ensuring a non-empty set of follow-on states.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition loadWord :: \"machine_word \\<Rightarrow> machine_word machine_monad\" where\n  \"loadWord p \\<equiv> do\n     m \\<leftarrow> gets underlying_memory;\n     assert (p && mask 3 = 0);\n     return (word_rcat (map (\\<lambda>i. m (p + (7 - of_int i))) [0 .. 7]))\n   od\"\n\ndefinition storeWord :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"storeWord p w \\<equiv> do\n     assert (p && mask 3 = 0);\n     modify (underlying_memory_update\n              (fold (\\<lambda>i m. m((p + (of_int i)) := word_rsplit w ! (7 - nat i))) [0 .. 7]))\n   od\"\n\nlemma upto0_7_def:\n  \"[0..7] = [0,1,2,3,4,5,6,7]\" by eval\n\nlemma loadWord_storeWord_is_return:\n  \"p && mask 3 = 0 \\<Longrightarrow> (do w \\<leftarrow> loadWord p; storeWord p w od) = return ()\"\n  by (auto simp: loadWord_def storeWord_def bind_def assert_def return_def word_rsplit_rcat_size\n                 modify_def gets_def get_def eval_nat_numeral put_def upto0_7_def word_size)\n\nconsts' memory_regions :: \"(paddr \\<times> paddr) list\"\ndefinition getMemoryRegions :: \"(paddr * paddr) list machine_monad\" where\n  \"getMemoryRegions \\<equiv> return memory_regions\"", "property": "Memory Management: Provides fundamental operations for managing memory at the machine level, including loading and storing words, and retrieving memory regions. Ensures that memory operations are correctly aligned and performed within the bounds of the underlying memory model.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition storeWordVM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"storeWordVM w p \\<equiv> return ()\"", "property": "Store Word VM: Store a word into the virtual machine's memory, but this operation does not modify the actual memory in this context.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "This instruction is required in the simulator, only."}
{"spec": "consts' configureTimer_impl :: \"unit machine_rest_monad\"\nconsts' configureTimer_val :: \"machine_state \\<Rightarrow> irq\"\ndefinition configureTimer :: \"irq machine_monad\" where\n  \"configureTimer \\<equiv> do\n     machine_op_lift configureTimer_impl;\n     gets configureTimer_val\n   od\"\n\nconsts' initTimer_impl :: \"unit machine_rest_monad\"\ndefinition initTimer :: \"unit machine_monad\" where\n  \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts' resetTimer_impl :: \"unit machine_rest_monad\"\ndefinition resetTimer :: \"unit machine_monad\" where\n  \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"", "property": "Timer Management: Configure, initialize, and reset the system timer, ensuring proper timekeeping and interrupt handling. \n\nConfigure Timer: Set up the timer and retrieve the resulting IRQ. \nInitialize Timer: Initialize the timer to its default state. \nReset Timer: Reset the timer to a known state, typically to recover from errors or exceptions.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\" where\n  debugPrint_def[simp]:\n  \"debugPrint \\<equiv> \\<lambda>message. return ()\"", "property": "Debug Print Operation: Ignore any debug print messages and do nothing.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition IRQ :: \"irq \\<Rightarrow> irq\" where\n  \"IRQ \\<equiv> id\"\n\nconsts' setIRQTrigger_impl :: \"irq \\<Rightarrow> bool \\<Rightarrow> unit machine_rest_monad\"\ndefinition setIRQTrigger :: \"irq \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\" where\n  \"setIRQTrigger irq trigger \\<equiv> machine_op_lift (setIRQTrigger_impl irq trigger)\"\n\nconsts' plic_complete_claim_impl :: \"irq \\<Rightarrow> unit machine_rest_monad\"\ndefinition plic_complete_claim :: \"irq \\<Rightarrow> unit machine_monad\" where\n  \"plic_complete_claim irq \\<equiv> machine_op_lift (plic_complete_claim_impl irq)\"", "property": "Interrupt Controller Operations: Manage interrupt controller settings, allowing for the configuration of IRQ triggers and the completion of interrupt claims, ensuring proper interrupt handling and system stability. \n\nSet IRQ Trigger: Set the trigger mode for a specific IRQ, configuring whether it is edge-triggered or level-triggered.\n\nPLIC Complete Claim: Signal the completion of an interrupt claim for a specific IRQ, allowing the system to resume normal operation.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition non_kernel_IRQs :: \"irq set\" where\n  \"non_kernel_IRQs = {irqVGICMaintenance, irqVTimerEvent}\"", "property": "Non-Kernel Interrupts: Define the set of interrupts that cannot occur while the kernel is running but can occur from user mode.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Interrupts that cannot occur while the kernel is running (e.g. at preemption points),\n  but that can occur from user mode."}
{"spec": "definition getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\" where\n  \"getActiveIRQ in_kernel \\<equiv> do\n     is_masked \\<leftarrow> gets $ irq_masks;\n     modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n     active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n     if is_masked active_irq \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n     then return None\n     else return (Some active_irq)\n   od\"\n\ndefinition maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\" where\n  \"maskInterrupt m irq \\<equiv> modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"\n\ndefinition ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\" where\n  \"ackInterrupt \\<equiv> \\<lambda>irq. return ()\"\n\ndefinition setInterruptMode :: \"irq \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\" where\n  \"setInterruptMode \\<equiv> \\<lambda>irq levelTrigger polarityLow. return ()\"", "property": "Interrupt Controller Operations: Manage interrupt-related operations, including retrieving the active IRQ, masking interrupts, acknowledging interrupts, and setting interrupt modes, ensuring proper interrupt handling and state updates.\n\nGet Active IRQ: Retrieve the active IRQ, updating the IRQ state to reflect the passage of time and considering IRQ masking and kernel-mode restrictions.\n\nMask Interrupt: Set the masking status of a specific IRQ.\n\nAcknowledge Interrupt: Acknowledge a specific IRQ.\n\nSet Interrupt Mode: Configure the mode of a specific IRQ, including level triggering and polarity.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "@{term getActiveIRQ} is oracle-based and deterministic to allow information flow proofs. It\nupdates the IRQ state to the reflect the passage of time since last the IRQ, then it gets the active\nIRQ (if there is one)."}
{"spec": "type_synonym user_regs = \"register \\<Rightarrow> machine_word\"", "property": "User Registers: Represent the state of the user registers as a mapping from register names to machine words.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "type_synonym fpu_regs = 64", "property": "FPU Registers: The system has 64 general FPU registers that are saved.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " There are 64 general FPU registers saved. "}
{"spec": "datatype fpu_state = FPUState (fpuRegs : \"fpu_regs \\<Rightarrow> 64 word\")\n                              (fpuSr : \"32 word\")\n                              (fpuCr : \"32 word\")\n\ndatatype user_context = UserContext (fpu_state : fpu_state) (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\" where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\" where\n  \"modify_registers f uc \\<equiv> UserContext (fpu_state uc) (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\" where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext (fpu_state s) ((user_regs s) (r := v)))\"\n\ndefinition getRestartPC :: \"machine_word user_monad\" where\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition setNextPC :: \"machine_word \\<Rightarrow> unit user_monad\" where\n  \"setNextPC \\<equiv> setRegister NextIP\"", "property": "User Context Management: Provides operations to manage the user context, including getting and setting registers, modifying registers, and managing the program counter (PC) for restart and next instruction execution. \n\nGet Register: Retrieve the value of a specific register from the user context.\n\nSet Register: Update the value of a specific register in the user context.\n\nModify Registers: Apply a transformation function to the user registers in the user context.\n\nGet Restart PC: Retrieve the program counter value for restart from the user context.\n\nSet Next PC: Update the program counter value for the next instruction in the user context.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  We use Haskell naming convention here, as we translate the Haskell FPUState directly\n  to this one for use in the abstract and executable specs."}
{"spec": "consts' enableFpuEL01_impl :: \"unit machine_rest_monad\"\ndefinition enableFpuEL01 :: \"unit machine_monad\" where\n  \"enableFpuEL01 \\<equiv> machine_op_lift enableFpuEL01_impl\"\n\ndefinition getFPUState :: \"fpu_state user_monad\" where\n  \"getFPUState \\<equiv> gets fpu_state\"\n\ndefinition setFPUState :: \"fpu_state \\<Rightarrow> unit user_monad\" where\n  \"setFPUState fc \\<equiv> modify (\\<lambda>s. UserContext fc (user_regs s))\"\n\nconsts' nativeThreadUsingFPU_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\nconsts' nativeThreadUsingFPU_val :: \"machine_state \\<Rightarrow> bool\"\ndefinition nativeThreadUsingFPU :: \"machine_word \\<Rightarrow> bool machine_monad\" where\n  \"nativeThreadUsingFPU thread_ptr \\<equiv> do\n       machine_op_lift (nativeThreadUsingFPU_impl thread_ptr);\n       gets nativeThreadUsingFPU_val\n  od\"\n\nconsts' switchFpuOwner_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition switchFpuOwner :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"switchFpuOwner new_owner cpu \\<equiv> machine_op_lift (switchFpuOwner_impl new_owner cpu)\"\n\n\nconsts' fpuThreadDeleteOp_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition fpuThreadDeleteOp :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"fpuThreadDeleteOp thread_ptr \\<equiv> machine_op_lift (fpuThreadDeleteOp_impl thread_ptr)\"\n\n\ndefinition isFpuEnable :: \"bool machine_monad\" where\n  \"isFpuEnable \\<equiv> return True\"", "property": "FPU Management: Provides operations for managing the Floating Point Unit (FPU), including enabling FPU for EL0 and EL1, getting and setting the FPU state, checking if a native thread is using the FPU, switching the FPU owner, deleting an FPU thread, and checking if the FPU is enabled.\n\nSubproperties:\n- Enable FPU: Enable the FPU for EL0 and EL1.\n- Get and Set FPU State: Retrieve and update the FPU state.\n- Native Thread FPU Usage: Check if a native thread is using the FPU.\n- Switch FPU Owner: Change the ownership of the FPU to a new thread.\n- Delete FPU Thread: Delete an FPU thread.\n- Check FPU Enable: Verify if the FPU is enabled.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' FAR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getFAR :: \"machine_word machine_monad\" where\n  \"getFAR \\<equiv> gets FAR_val\"\n\nconsts' DFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getDFSR :: \"machine_word machine_monad\" where\n  \"getDFSR \\<equiv> gets DFSR_val\"\n\nconsts' IFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getIFSR :: \"machine_word machine_monad\" where\n  \"getIFSR \\<equiv> gets IFSR_val\"", "property": "Fault Register Access: Provide access to the fault registers, including the Fault Address Register (FAR), Data Fault Status Register (DFSR), and Instruction Fault Status Register (IFSR), allowing the kernel to retrieve their current values.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' HSR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getHSR :: \"machine_word machine_monad\" where\n  \"getHSR \\<equiv> gets HSR_val\"\n\nconsts' ESR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getESR :: \"machine_word machine_monad\" where\n  \"getESR \\<equiv> gets ESR_val\"\n\nconsts' SCTLR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getSCTLR :: \"machine_word machine_monad\" where\n  \"getSCTLR \\<equiv> gets SCTLR_val\"\n\nconsts' setHCR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition setHCR :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"setHCR w \\<equiv> machine_op_lift (setHCR_impl w)\"\n\nconsts' setSCTLR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition setSCTLR :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"setSCTLR w \\<equiv> machine_op_lift (setSCTLR_impl w)\"\n\nconsts' addressTranslateS1_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\nconsts' addressTranslateS1_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition addressTranslateS1 :: \"machine_word \\<Rightarrow> machine_word machine_monad\" where\n  \"addressTranslateS1 w \\<equiv> do\n    machine_op_lift (addressTranslateS1_impl w);\n    gets (addressTranslateS1_val w)\n  od\"", "property": "Machine Register Operations: Provide access to control registers, allowing for the retrieval of values from the HSR, ESR, and SCTLR registers, as well as setting values for the HCR and SCTLR registers. Additionally, perform stage 1 address translations.\n\nSubproperties:\n- Get Register Values: Retrieve the values from the HSR, ESR, and SCTLR registers.\n- Set Register Values: Set the values for the HCR and SCTLR registers.\n- Address Translation: Perform stage 1 address translations.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' gic_vcpu_ctrl_hcr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_hcr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_hcr \\<equiv> gets gic_vcpu_ctrl_hcr_val\"\n\nconsts' set_gic_vcpu_ctrl_hcr_impl :: \"32 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_hcr :: \"32 word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_hcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_hcr_impl w)\"\n\nconsts' gic_vcpu_ctrl_vmcr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_vmcr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_vmcr \\<equiv> gets gic_vcpu_ctrl_vmcr_val\"\n\nconsts' set_gic_vcpu_ctrl_vmcr_impl :: \"32 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_vmcr :: \"32 word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_vmcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vmcr_impl w)\"\n\nconsts' gic_vcpu_ctrl_apr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_apr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_apr \\<equiv> gets gic_vcpu_ctrl_apr_val\"\n\nconsts' set_gic_vcpu_ctrl_apr_impl :: \"32 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_apr :: \"32 word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_apr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_apr_impl w)\"\n\nconsts' gic_vcpu_ctrl_vtr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_vtr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_vtr \\<equiv> gets gic_vcpu_ctrl_vtr_val\"\n\nconsts' set_gic_vcpu_ctrl_vtr_impl :: \"32 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_vtr :: \"32 word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_vtr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vtr_impl w)\"\n\nconsts' gic_vcpu_ctrl_misr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_misr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_misr \\<equiv> gets gic_vcpu_ctrl_misr_val\"\n\nconsts' gic_vcpu_ctrl_eisr0_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_eisr0 :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_eisr0 \\<equiv> gets gic_vcpu_ctrl_eisr0_val\"\n\nconsts' gic_vcpu_ctrl_eisr1_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_eisr1 :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_eisr1 \\<equiv> gets gic_vcpu_ctrl_eisr1_val\"\n\nconsts' get_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\nconsts' gic_vcpu_ctrl_lr_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition get_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word machine_monad\" where\n  \"get_gic_vcpu_ctrl_lr n \\<equiv> do\n     machine_op_lift (get_gic_vcpu_ctrl_lr_impl n);\n     gets (gic_vcpu_ctrl_lr_val n)\n   od\"\n\nconsts' set_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_lr n w  \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_lr_impl n w)\"", "property": "GIC VCPU Interface Management: Provides operations to access and modify the GIC VCPU interface, including getting and setting the values of various control registers (HCR, VMCR, APR, VTR, MISR, EISRs, and LR). These operations enable the management of the GIC VCPU interface, ensuring proper interrupt handling and virtualization support.\n\nSubproperties:\n- Get GIC VCPU Control Register Values: Retrieve the values of the GIC VCPU control registers.\n- Set GIC VCPU Control Register Values: Modify the values of the GIC VCPU control registers.\n- Get GIC VCPU LR Values: Retrieve the values of the GIC VCPU LR registers.\n- Set GIC VCPU LR Values: Modify the values of the GIC VCPU LR registers.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' check_export_arch_timer_impl :: \"unit machine_rest_monad\"\ndefinition check_export_arch_timer :: \"unit machine_monad\" where\n  \"check_export_arch_timer \\<equiv> machine_op_lift check_export_arch_timer_impl\"\n\nconsts' read_cntpct_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition read_cntpct :: \"64 word machine_monad\" where\n  \"read_cntpct \\<equiv> gets read_cntpct_val\"", "property": "Virtual Timer Interface: Provides access to the virtual timer, allowing the kernel to manage time-related operations. \n\nSubproperties:\n- Check Export Architecture Timer: Verifies the export of the architecture timer implementation.\n- Read Counter-Timer Physical Count: Retrieves the current value of the counter-timer physical count register.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' vcpuHardwareReg_val :: \"vcpureg \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition readVCPUHardwareReg :: \"vcpureg \\<Rightarrow> machine_word machine_monad\" where\n  \"readVCPUHardwareReg reg \\<equiv> gets (vcpuHardwareReg_val reg)\"\n\nconsts' writeVCPUHardwareReg_impl :: \"vcpureg \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition writeVCPUHardwareReg :: \"vcpureg \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"writeVCPUHardwareReg reg val \\<equiv> machine_op_lift (writeVCPUHardwareReg_impl reg val)\"", "property": "Hypervisor Banked Register Access: Allows reading and writing of VCPU hardware registers, providing direct access to the underlying machine state for management and control of virtual CPU operations. \n\nRead VCPU Hardware Register: Retrieves the value of a specific VCPU hardware register from the machine state.\n\nWrite VCPU Hardware Register: Updates the value of a specific VCPU hardware register, modifying the machine state to reflect the change.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' initL2Cache_impl :: \"unit machine_rest_monad\"\ndefinition initL2Cache :: \"unit machine_monad\" where\n  \"initL2Cache \\<equiv> machine_op_lift initL2Cache_impl\"\n\nconsts' isb_impl :: \"unit machine_rest_monad\"\ndefinition isb :: \"unit machine_monad\" where\n  \"isb \\<equiv> machine_op_lift isb_impl\"\n\nconsts' dsb_impl :: \"unit machine_rest_monad\"\ndefinition dsb :: \"unit machine_monad\" where\n  \"dsb \\<equiv> machine_op_lift dsb_impl\"\n\nconsts' invalidateTranslationASID_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateTranslationASID :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateTranslationASID asid \\<equiv> machine_op_lift (invalidateTranslationASID_impl asid)\"\n\nconsts' invalidateTranslationSingle_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateTranslationSingle :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateTranslationSingle r \\<equiv> machine_op_lift (invalidateTranslationSingle_impl r)\"\n\nconsts' cleanByVA_PoU_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanByVA_PoU :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanByVA_PoU vaddr paddr = machine_op_lift (cleanByVA_PoU_impl vaddr paddr)\"\n\nconsts' cleanInvalidateCacheRange_RAM_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanInvalidateCacheRange_RAM ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanInvalidateCacheRange_RAM vstart vend pstart =\n     machine_op_lift (cleanInvalidateCacheRange_RAM_impl vstart vend pstart)\"\n\nconsts' cleanCacheRange_RAM_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanCacheRange_RAM ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanCacheRange_RAM vstart vend pstart =\n     machine_op_lift (cleanCacheRange_RAM_impl vstart vend pstart)\"\n\nconsts' cleanCacheRange_PoU_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanCacheRange_PoU ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanCacheRange_PoU vstart vend pstart =\n     machine_op_lift (cleanCacheRange_PoU_impl vstart vend pstart)\"\n\nconsts' invalidateCacheRange_RAM_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateCacheRange_RAM ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateCacheRange_RAM vstart vend pstart =\n     machine_op_lift (invalidateCacheRange_RAM_impl vstart vend pstart)\"\n\nconsts' invalidateCacheRange_I_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateCacheRange_I ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateCacheRange_I vstart vend pstart =\n     machine_op_lift (invalidateCacheRange_I_impl vstart vend pstart)\"\n\nconsts' branchFlushRange_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition branchFlushRange ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"branchFlushRange vstart vend pstart = machine_op_lift (branchFlushRange_impl vstart vend pstart)\"\n\nlemmas cache_machine_op_defs =\n  invalidateTranslationASID_def\n  invalidateTranslationSingle_def\n  cleanByVA_PoU_def\n  cleanInvalidateCacheRange_RAM_def\n  cleanCacheRange_RAM_def\n  cleanCacheRange_PoU_def\n  invalidateCacheRange_RAM_def\n  invalidateCacheRange_I_def\n  branchFlushRange_def", "property": "Cache Management Operations: Provide a set of operations for managing caches, including initialization, flushing, and invalidation of cache ranges, as well as branch prediction flushing, to ensure cache coherence and consistency.\n\nSubproperties:\n- Cache Initialization: Initialize the L2 cache to a consistent state.\n- Cache Flushing: Flush cache ranges to ensure that changes are written back to memory.\n- Cache Invalidation: Invalidate cache ranges to ensure that stale data is not used.\n- Branch Prediction Flushing: Flush branch prediction caches to ensure that branch prediction is accurate.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory. Do not yet flush the cache.\\<close>\ndefinition clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\" where\n  \"clearMemory ptr bytelength \\<equiv>\n     mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"", "property": "Clear Memory Contents: Clear the contents of a specified memory region to prepare it for reuse as user memory, without flushing the cache.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\" where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Clear Memory Operation: Clears a specified range of memory, defined by a pointer and a number of bits, with no actual effect in the Haskell simulator interface stub.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Haskell simulator interface stub."}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Initialize memory for user use, ensuring it is properly cleared and prepared for allocation.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Initialize memory to be used as user memory. Note that zeroing out the memory is redundant\n  in the specifications. In any case, we cannot abstract from the call to cleanCacheRange, which\n  appears in the implementation."}
{"spec": "definition freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\" where\n  \"freeMemory ptr bits \\<equiv>\n     mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Clearing Memory: Zero out the memory content of a given range to prevent garbage, ensuring that the memory is in a known state after being freed.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Free memory that had been initialized as user memory. While freeing memory is a no-op in the\n  implementation, we zero out the underlying memory in the specifications to avoid garbage. If we\n  know that there is no garbage, we can compute from the implementation state what the exact memory\n  content in the specifications is."}
{"spec": "consts' setVSpaceRoot_impl :: \"paddr \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition setVSpaceRoot :: \"paddr \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"setVSpaceRoot pt asid \\<equiv> machine_op_lift $ setVSpaceRoot_impl pt asid\"\n\nend\nend", "property": "Set Virtual Space Root: Set the root of the virtual memory space for a given address space identifier (ASID) to a specified page table (PT) address.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Platform Integer Representation: The platform represents integer literals as 32-bit signed words.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming AARCH64\n\nvalue_type irq_len = Kernel_Config.irqBits \n\n\n\ndefinition paddrBase :: machine_word where\n  \"paddrBase \\<equiv> 0\"\n\ndefinition pptrBaseOffset :: machine_word where\n  \"pptrBaseOffset = pptrBase - paddrBase\"\n\ndefinition paddrTop :: machine_word where\n  \"paddrTop = pptrTop - pptrBaseOffset\"\n\ndefinition ptrFromPAddr :: \"paddr \\<Rightarrow> machine_word\" where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBaseOffset\"\n\ndefinition addrFromPPtr :: \"machine_word \\<Rightarrow> paddr\" where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBaseOffset\"\n\ndefinition addrFromKPPtr :: \"machine_word \\<Rightarrow> paddr\" where\n  \"addrFromKPPtr pptr \\<equiv> pptr - kernelELFBaseOffset\"\n\ndefinition minIRQ :: \"irq\" where\n  \"minIRQ \\<equiv> 0\"\n\ndefinition irqVGICMaintenance :: irq where\n  \"irqVGICMaintenance \\<equiv> 25\"\n\ndefinition irqVTimerEvent :: irq where\n  \"irqVTimerEvent \\<equiv> 27\"\n\ndefinition pageColourBits :: nat where\n  \"pageColourBits \\<equiv> undefined\" \\<comment> \\<open>not implemented on this platform\\<close>", "property": "Platform Constants: Define the fundamental constants and calculations for the AARCH64 platform, including the base addresses for physical and virtual memory, the relationships between physical and virtual addresses, and the definitions of key IRQ values. \n\nMemory Address Conversions: Provide functions to convert between physical addresses, virtual addresses, and kernel virtual addresses, ensuring accurate memory management and access. \n\nIRQ Definitions: Specify the minimum IRQ value and define specific IRQ values for VGIC maintenance and VTimer events, supporting interrupt handling and management.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "definition vs_index_bits :: nat where\n  \"vs_index_bits \\<equiv> if config_ARM_PA_SIZE_BITS_40 then 10 else (9::nat)\"\n\nend", "property": "Virtual Space Index Bits: Define the number of bits used for indexing in the virtual space, which is dependent on the ARM platform configuration, specifically the PA_SIZE_BITS_40 setting.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Page table sizes", "comment": ""}
{"spec": "declare AARCH64.vs_index_bits_def[code]\n\ncontext Arch begin global_naming AARCH64\n\nlemma vs_index_bits_ge0[simp, intro!]: \"0 < vs_index_bits\"\n  by (simp add: vs_index_bits_def)", "property": "Page Table Size Property: The size of the page table is defined by the vs_index_bits, which is guaranteed to be greater than 0.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Page table sizes", "comment": " Need to declare code equation outside Arch locale "}
{"spec": "typedef vs_index_len = \"{n :: nat. n < vs_index_bits}\" by auto\n\nend\n\ninstantiation AARCH64.vs_index_len :: len0\nbegin\n  interpretation Arch .\n  definition len_of_vs_index_len: \"len_of (x::vs_index_len itself) \\<equiv> CARD(vs_index_len)\"\n  instance ..\nend\n\ninstantiation AARCH64.vs_index_len :: len\nbegin\n  interpretation Arch .\n  instance\n  proof\n   show \"0 < LENGTH(vs_index_len)\"\n     by (simp add: len_of_vs_index_len type_definition.card[OF type_definition_vs_index_len])\n  qed\nend\n\ncontext Arch begin global_naming AARCH64\n\ntype_synonym vs_index = \"vs_index_len word\"\n\ntype_synonym pt_index_len = 9\ntype_synonym pt_index = \"pt_index_len word\"", "property": "Page Table Index Types: Define the types for page table indices, ensuring they are within specific bit length bounds. \n\n Subproperties:\n- Virtual Space Index Length: Define the length of virtual space indices (vs_index_len) to be less than vs_index_bits.\n- Page Table Index Length: Define the length of page table indices (pt_index_len) to be 9 bits.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Page table sizes", "comment": " A dependent-ish type in Isabelle. We use typedef here instead of value_type so that we can\n   retain a symbolic value (vs_index_bits) for the size of the type instead of getting a plain\n   number such as 9 or 10. "}
{"spec": "lemma length_vs_index_len[simp]:\n  \"LENGTH(vs_index_len) = vs_index_bits\"\n  by (simp add: len_of_vs_index_len type_definition.card[OF type_definition_vs_index_len])", "property": "Page Table Size Property: The length of the vs_index_len is equal to the number of bits in the vs_index.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Page table sizes", "comment": "Sanity check:"}
{"spec": "value_type pt_array_len = \"(2::nat) ^ LENGTH(pt_index_len)\"\nvalue_type vs_array_len = \"(2::nat) ^ vs_index_bits\"\n\nend\n\nend", "property": "Page Table Array Sizes: Define the sizes of C arrays corresponding to page tables, specifically the page table array length (pt_array_len) and the virtual space array length (vs_array_len), calculated as powers of 2 based on the page table index length and virtual space index bits respectively.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "C array sizes corresponding to page table sizes", "comment": ""}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming AARCH64", "property": "Architecture-Specific Kernel Configuration: Provides lemmas that constrain and validate the kernel configuration for a specific architecture (AARCH64), ensuring that the kernel is properly set up and configured for the target platform.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma irqVTimerEvent_le_maxIRQ[simp, intro!]:\n  \"irqVTimerEvent \\<le> maxIRQ\"\n  by (simp add: irqVTimerEvent_def Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_less_2p_irqBits:\n  \"(maxIRQ::nat) < 2^irqBits\"\n  by (simp add: Kernel_Config.maxIRQ_def Kernel_Config.irqBits_def)", "property": "IRQ Limits: The maximum IRQ (maxIRQ) is bounded by specific constraints, ensuring it is less than 2 to the power of irqBits and irqVTimerEvent does not exceed maxIRQ.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ conditions "}
{"spec": "lemma LENGTH_irq_len_irqBits[simp]: (* [simp] will fire only for simp del: len_of_numeral_defs *)\n  \"LENGTH(irq_len) = irqBits\"\n  using irq_len_def irq_len_val\n  by simp\n\nlemma maxIRQ_less_2p_irq_len:\n  \"(maxIRQ::nat) < 2^LENGTH(irq_len)\"\n  using maxIRQ_less_2p_irqBits\n  by (simp del: len_of_numeral_defs)", "property": "IRQ Length Properties: The length of the IRQ (Interrupt Request) is equal to the number of IRQ bits. The maximum IRQ value is less than 2 raised to the power of the IRQ length.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " follows from value_type definition of irq_len "}
{"spec": "lemma of_nat_maxIRQ[simp]:\n  \"of_nat maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma of_int_maxIRQ[simp]:\n  \"of_int maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "Generic Numerals for IRQ: Ensure that maxIRQ can be treated as a generic numeral, allowing for rules about casts, unat, uint, etc. without referencing specific numbers. \n\nSubproperties:\n- Casting maxIRQ to a natural number or integer preserves its value.\n- maxIRQ remains unchanged when converted between different word types.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ as a generic numeral allows us to write rules about casts/unat/uint etc without\n   mentioning numbers: "}
{"spec": "lemma unat_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> unat (maxIRQ::'a word) = maxIRQ\"\n  by (metis maxIRQ_less_2p_irq_len Word.of_nat_unat of_nat_inverse of_nat_maxIRQ unat_ucast_up_simp)", "property": "IRQ Length Property: The unat (unsigned natural number) value of maxIRQ is equal to maxIRQ when the length of irq_len is less than or equal to the length of the word type 'a.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma uint_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> uint (maxIRQ::'a word) = maxIRQ\"\n  by (metis Kernel_Config.maxIRQ_def of_nat_numeral uint_nat unat_maxIRQ)", "property": "IRQ Length Property: The length of irq_len is less than or equal to the length of the word type 'a, ensuring that the unsigned integer representation of maxIRQ is equal to maxIRQ.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma ucast_maxIRQ[simp]:\n  \"\\<lbrakk> LENGTH(irq_len) \\<le> LENGTH('a::len); LENGTH(irq_len) \\<le> LENGTH('b::len) \\<rbrakk> \\<Longrightarrow>\n   UCAST ('a \\<rightarrow> 'b) maxIRQ = maxIRQ\"\n  by (metis of_nat_maxIRQ ucast_nat_def unat_maxIRQ)", "property": "UCast MaxIRQ Equality: The unsigned cast of maxIRQ from type 'a to type 'b is equal to maxIRQ, given that the length of irq_len is less than or equal to the lengths of both 'a and 'b.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma maxIRQ_less_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   (maxIRQ < (ucast irq :: 'a word)) = (maxIRQ < irq)\" for irq::irq\n  by (simp add: word_less_nat_alt unat_ucast_up_simp)", "property": "IRQ Comparison Property: The comparison between the maximum IRQ value and an IRQ value upcasted to a word of a larger type is equivalent to the comparison between the maximum IRQ value and the original IRQ value, as long as the length of the IRQ type is less than or equal to the length of the larger type.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma maxIRQ_le_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   ((ucast irq :: 'a word) \\<le> Kernel_Config.maxIRQ) = (irq \\<le> Kernel_Config.maxIRQ)\" for irq::irq\n  by (simp add: word_le_nat_alt unat_ucast_up_simp)", "property": "IRQ Upcast Comparison: The upcast of an IRQ value to a larger word type preserves the comparison with the maximum IRQ value, allowing for accurate and safe comparisons.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma le_maxIRQ_machine_less_irqBits_val[simplified]:\n  \"w \\<le> maxIRQ \\<Longrightarrow> unat w < 2^LENGTH(irq_len)\" for w::machine_word\n  using maxIRQ_less_2p_irq_len\n  by (simp add: word_le_nat_alt)\n\nlemma irq_machine_le_maxIRQ_irq:\n  \"irq \\<le> Kernel_Config.maxIRQ \\<Longrightarrow> (ucast irq::irq) \\<le> maxIRQ\" for irq::machine_word\n  by (simp add: Kernel_Config.maxIRQ_def word_le_nat_alt unat_ucast)\n\nlemma maxIRQ_eq_ucast_irq_32_signed_uint:\n  \"(maxIRQ = (ucast b :: 32 signed word)) = (uint b = maxIRQ)\" for b::irq\n  unfolding Kernel_Config.maxIRQ_def\n  apply uint_arith\n  apply (simp add: uint_up_ucast is_up)\n  done\n\nlemma sint_maxIRQ_32[simp]:\n  \"sint (maxIRQ :: 32 signed word) = maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_machine[simp]:\n  \"scast (maxIRQ::32 signed word) = (maxIRQ::machine_word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_irq[simp]:\n  \"scast (maxIRQ :: 32 signed word) = (maxIRQ::irq)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_machine:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = x\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_irq:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = (ucast x :: irq)\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_1_plus_eq_Suc_machine[simp]:\n  \"unat (1 + Kernel_Config.maxIRQ :: machine_word) = Suc Kernel_Config.maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "IRQ Value Properties: Ensure that IRQ values are correctly represented and converted between different types, such as machine words and IRQ types, while maintaining their original value and respecting the maximum IRQ limit.\n\nSubproperties:\n- IRQ values are less than 2 to the power of irq_len when less than or equal to maxIRQ.\n- IRQ values are preserved when cast between machine word and IRQ types.\n- The maximum IRQ value is correctly represented and converted between signed and unsigned types.\n- Enumerations of IRQ values less than or equal to maxIRQ are correctly converted to their original values.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " The following are instances -- for some we could derive general rules, but the number of\n   instances is limited and the concrete proofs are much simpler: "}
{"spec": "lemma cacheLineBits_sanity:\n  \"cacheLineBits \\<in> {2..12}\"\n  by (simp add: cacheLineBits_def Kernel_Config.CONFIG_L1_CACHE_LINE_SIZE_BITS_def)\n\nend\nend", "property": "Cache Line Bits Sanity: The cache line bits value must be within a valid range (2 to 12) to ensure reliable folding in C functions and avoid conflicts with other values used in cache operations.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Folding cacheLineBits_val in C functions only works reliably if cacheLineBits is not 1 and\n   not too large to conflict with other values used inside cache ops.\n   12 is ptBits, which is only available after ExecSpec. Anything > 1 and smaller than ptBits\n   works. "}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified\n  part of the machine state @{typ machine_state_rest} and cannot fail.\n  We could express the latter by type (leaving out the failure flag),\n  but if we later wanted to implement them,\n  we'd have to set up a new hoare-logic\n  framework for that type. So instead, we provide a wrapper for these\n  operations that explicitly ignores the fail flag and sets it to\n  False. Similarly, these operations never return an empty set of\n  follow-on states, which would require the operation to fail.\n  So we explicitly make this (non-existing) case a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming ARM_HYP", "property": "Machine Operations: Perform low-level operations on the machine state, working on the underspecified part of the machine state and never failing, with any potential failure flag explicitly ignored and set to False, ensuring a non-empty set of follow-on states.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  memory_regions :: \"(paddr \\<times> paddr) list\" \n  initTimer_impl :: \"unit machine_rest_monad\"\ndefinition\n  initTimer :: \"unit machine_monad\"\nwhere \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts'\n  resetTimer_impl :: \"unit machine_rest_monad\"\n\ndefinition\n  resetTimer :: \"unit machine_monad\"\nwhere \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"\n\nconsts'\n  writeTTBR0_impl :: \"paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  writeTTBR0 :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere \"writeTTBR0 pd \\<equiv> machine_op_lift (writeTTBR0_impl pd)\"\n\n\nconsts'\n  setHardwareASID_impl :: \"hardware_asid \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setHardwareASID:: \"hardware_asid \\<Rightarrow> unit machine_monad\"\nwhere \"setHardwareASID a \\<equiv> machine_op_lift (setHardwareASID_impl a)\"", "property": "Machine Operations: Provide low-level operations for managing hardware resources, including initializing and resetting timers, writing to translation tables, and setting hardware address space identifiers (ASIDs). These operations ensure that the kernel can interact with the underlying hardware efficiently and securely.\n\nSubproperties:\n- Timer Management: Initialize and reset timers to manage time-related events and interrupts.\n- Translation Table Management: Write to translation tables to manage virtual-to-physical address mappings.\n- ASID Management: Set hardware ASIDs to manage address spaces and ensure secure memory access.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  isb_impl :: \"unit machine_rest_monad\"\ndefinition\n  isb :: \"unit machine_monad\"\nwhere \"isb \\<equiv> machine_op_lift isb_impl\"\n\nconsts'\n  dsb_impl :: \"unit machine_rest_monad\"\ndefinition\n  dsb :: \"unit machine_monad\"\nwhere \"dsb \\<equiv> machine_op_lift dsb_impl\"\n\nconsts'\n  dmb_impl :: \"unit machine_rest_monad\"\ndefinition\n  dmb :: \"unit machine_monad\"\nwhere \"dmb \\<equiv> machine_op_lift dmb_impl\"\n\nconsts'\n  setCurrentPDPL2_impl :: \"paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setCurrentPDPL2 :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere \"setCurrentPDPL2 pd \\<equiv> machine_op_lift (setCurrentPDPL2_impl pd)\"\n\nconsts'\n  invalidateLocalTLB_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB :: \"unit machine_monad\"\nwhere \"invalidateLocalTLB \\<equiv> machine_op_lift invalidateLocalTLB_impl\"\n\n\nconsts'\n  invalidateLocalTLB_ASID_impl :: \"hardware_asid \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB_ASID :: \"hardware_asid \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateLocalTLB_ASID a \\<equiv> machine_op_lift (invalidateLocalTLB_ASID_impl a)\"", "property": "Machine Operations: Provide low-level memory management operations, including memory barriers (isb, dsb, dmb), setting the current page directory (setCurrentPDPL2), and invalidating the local translation lookaside buffer (invalidateLocalTLB, invalidateLocalTLB_ASID), ensuring proper memory access and management.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " Memory Barriers "}
{"spec": "consts'\n  invalidateLocalTLB_VAASID_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB_VAASID :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateLocalTLB_VAASID w \\<equiv> machine_op_lift (invalidateLocalTLB_VAASID_impl w)\"\n\nconsts'\n  cleanByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanByVA w p \\<equiv> machine_op_lift (cleanByVA_impl w p)\"\n\nconsts'\n  cleanByVA_PoU_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanByVA_PoU :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanByVA_PoU w p \\<equiv> machine_op_lift (cleanByVA_PoU_impl w p)\"\n\nconsts'\n  invalidateByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateByVA w p \\<equiv> machine_op_lift (invalidateByVA_impl w p)\"\n\nconsts'\n  invalidateByVA_I_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateByVA_I :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateByVA_I w p \\<equiv> machine_op_lift (invalidateByVA_I_impl w p)\"\n\nconsts'\n  invalidate_I_PoU_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidate_I_PoU :: \"unit machine_monad\"\nwhere \"invalidate_I_PoU \\<equiv> machine_op_lift invalidate_I_PoU_impl\"\n\nconsts'\n  cleanInvalByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanInvalByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanInvalByVA w p \\<equiv> machine_op_lift (cleanInvalByVA_impl w p)\"\n\nconsts'\n  branchFlush_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  branchFlush :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"branchFlush w p \\<equiv> machine_op_lift (branchFlush_impl w p)\"\n\nconsts'\n  clean_D_PoU_impl :: \"unit machine_rest_monad\"\ndefinition\n  clean_D_PoU :: \"unit machine_monad\"\nwhere \"clean_D_PoU \\<equiv> machine_op_lift clean_D_PoU_impl\"\n\nconsts'\n  cleanInvalidate_D_PoC_impl :: \"unit machine_rest_monad\"\ndefinition\n  cleanInvalidate_D_PoC :: \"unit machine_monad\"\nwhere \"cleanInvalidate_D_PoC \\<equiv> machine_op_lift cleanInvalidate_D_PoC_impl\"\n\nconsts'\n  cleanInvalidateL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanInvalidateL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanInvalidateL2Range w p \\<equiv> machine_op_lift (cleanInvalidateL2Range_impl w p)\"\n\nconsts'\n  invalidateL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateL2Range w p \\<equiv> machine_op_lift (invalidateL2Range_impl w p)\"\n\nconsts'\n  cleanL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanL2Range w p \\<equiv> machine_op_lift (cleanL2Range_impl w p)\"\n\nconsts'\n  initL2Cache_impl :: \"unit machine_rest_monad\"\ndefinition\n  initL2Cache :: \"unit machine_monad\"\nwhere \"initL2Cache \\<equiv> machine_op_lift initL2Cache_impl\"\n\ndefinition\n  clearExMonitor :: \"unit machine_monad\"\nwhere \"clearExMonitor \\<equiv> modify (\\<lambda>s. s \\<lparr> exclusive_state := default_exclusive_state \\<rparr>)\"\n\nconsts'\n  flushBTAC_impl :: \"unit machine_rest_monad\"\ndefinition\n  flushBTAC :: \"unit machine_monad\"\nwhere \"flushBTAC \\<equiv> machine_op_lift flushBTAC_impl\"\n\nconsts'\n  initIRQController_impl :: \"unit machine_rest_monad\"\ndefinition\n  initIRQController :: \"unit machine_monad\"\nwhere \"initIRQController \\<equiv> machine_op_lift initIRQController_impl\"\n\ndefinition\n  IRQ :: \"irq \\<Rightarrow> irq\"\nwhere \"IRQ \\<equiv> id\"\n\nconsts'\n  writeContextID_impl :: \"unit machine_rest_monad\"\ndefinition\n  writeContextID :: \"unit machine_monad\"\nwhere \"writeContextID \\<equiv> machine_op_lift writeContextID_impl\"\n\nlemmas cache_machine_op_defs = isb_def dsb_def dmb_def writeContextID_def flushBTAC_def\n                               clearExMonitor_def cleanL2Range_def invalidateL2Range_def\n                               cleanInvalidateL2Range_def cleanInvalidate_D_PoC_def\n                               clean_D_PoU_def branchFlush_def cleanInvalByVA_def\n                               invalidate_I_PoU_def invalidateByVA_I_def invalidateByVA_def\n                               cleanByVA_PoU_def cleanByVA_def invalidateLocalTLB_VAASID_def\n                               invalidateLocalTLB_ASID_def invalidateLocalTLB_def\nconsts'\n  IFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  DFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  FAR_val :: \"machine_state \\<Rightarrow> machine_word\"\n\ndefinition\n  getIFSR :: \"machine_word machine_monad\"\n  where \"getIFSR \\<equiv> gets IFSR_val\"\n\ndefinition\n  getDFSR :: \"machine_word machine_monad\"\n  where \"getDFSR \\<equiv> gets DFSR_val\"\n\ndefinition\n  getFAR :: \"machine_word machine_monad\"\n  where \"getFAR \\<equiv> gets FAR_val\"\n\ndefinition\n  debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\"\nwhere\n  debugPrint_def[simp]:\n \"debugPrint \\<equiv> \\<lambda>message. return ()\"\n\nconsts'\n  ackInterrupt_impl :: \"irq \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"ackInterrupt irq \\<equiv> machine_op_lift (ackInterrupt_impl irq)\"\n\nconsts'\n  TPIDRURO_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  getTPIDRURO :: \"machine_word machine_monad\"\nwhere \"getTPIDRURO \\<equiv> gets TPIDRURO_val\"\n\nconsts'\n  setTPIDRURO_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setTPIDRURO :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setTPIDRURO w \\<equiv> machine_op_lift (setTPIDRURO_impl w)\"\n\n\\<comment> \\<open>Interrupt controller operations\\<close>", "property": "Machine Operations: Provides a set of low-level operations for managing the machine state, including cache management (cleaning, invalidating, and flushing), exception handling (getting and setting fault registers), interrupt management (acknowledging and handling interrupts), and other miscellaneous operations (debug printing, getting and setting system registers).\n\nSubproperties:\n\n* Cache Management: Clean, invalidate, and flush cache lines to maintain cache coherence and ensure correct execution.\n* Exception Handling: Get and set fault registers to handle exceptions and errors.\n* Interrupt Management: Acknowledge and handle interrupts to manage interrupt-driven execution.\n* System Register Management: Get and set system registers to manage system state and configuration.\n* Debugging: Print debug messages to aid in system debugging and testing.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " C implementation takes one argument, which is w || a "}
{"spec": "definition\n  \"non_kernel_IRQs = {irqVGICMaintenance, irqVTimerEvent}\"", "property": "Non-Kernel Interrupts: Define the set of interrupts that cannot occur while the kernel is running but can occur from user mode.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Interrupts that cannot occur while the kernel is running (e.g. at preemption points),\n  but that can occur from user mode.\n"}
{"spec": "definition\n  getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\"\nwhere\n  \"getActiveIRQ in_kernel \\<equiv> do\n    is_masked \\<leftarrow> gets $ irq_masks;\n    modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n    active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n    if is_masked active_irq \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n    then return None\n    else return (Some active_irq)\n  od\"\n\ndefinition\n  maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"maskInterrupt m irq \\<equiv>\n  modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"\n\ndefinition\n  lineStart :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"lineStart addr = (addr >> cacheLineBits) << cacheLineBits\"", "property": "Machine Operations: Manage interrupt handling and masking, ensuring deterministic and efficient interrupt processing. This includes updating the IRQ state, retrieving the active IRQ, and masking interrupts.\n\nSubproperties:\n- IRQ State Update: Increment the IRQ state to reflect the passage of time since the last IRQ retrieval.\n- Active IRQ Retrieval: Get the active IRQ, considering IRQ masking and kernel-mode restrictions.\n- Interrupt Masking: Set or clear the mask for a specific IRQ, controlling its interruptibility.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  @{term getActiveIRQ} is now derministic.\n  It 'updates' the irq state to the reflect the passage of\n  time since last the irq was gotten, then it gets the active\n  IRQ (if there is one).\n"}
{"spec": "definition\n  cacheRangeOp :: \"(machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad)\n                 \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cacheRangeOp operation vstart vend pstart \\<equiv>\n    let pend = pstart + (vend - vstart);\n        vptrs = [lineStart vstart, lineStart vstart + of_nat cacheLine .e. lineStart vend];\n        pptrs = [lineStart pstart, lineStart pstart + of_nat cacheLine .e. lineStart pend]\n    in mapM_x (\\<lambda>(v, p). operation v p) (zip vptrs pptrs)\"\n\ndefinition\n  cleanCacheRange_PoC :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_PoC vstart vend pstart \\<equiv> cacheRangeOp cleanByVA vstart vend pstart\"\n\ndefinition\n  cleanInvalidateCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanInvalidateCacheRange_RAM vstart vend pstart \\<equiv> do\n    cleanCacheRange_PoC vstart vend pstart;\n    dsb;\n    cleanInvalidateL2Range pstart (pstart + (vend - vstart));\n    cacheRangeOp cleanInvalByVA vstart vend pstart;\n    dsb\n  od\"\n\ndefinition\n  cleanCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_RAM vstart vend pstart \\<equiv> do\n    cleanCacheRange_PoC vstart vend pstart;\n    dsb;\n    cleanL2Range pstart (pstart + (vend - vstart))\n  od\"\n\ndefinition\n  cleanCacheRange_PoU :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_PoU vstart vend pstart \\<equiv> cacheRangeOp cleanByVA_PoU vstart vend pstart\"\n\ndefinition\n  invalidateCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"invalidateCacheRange_RAM vstart vend pstart \\<equiv> do\n    when (vstart \\<noteq> lineStart vstart) $\n        cleanCacheRange_RAM vstart vstart pstart;\n    when (vend + 1 \\<noteq> lineStart (vend + 1)) $\n        cleanCacheRange_RAM (lineStart vend) (lineStart vend)\n           (pstart + ((lineStart vend) - vstart));\n    invalidateL2Range pstart (pstart + (vend - vstart));\n    cacheRangeOp invalidateByVA vstart vend pstart;\n    dsb\n  od\"\n\ndefinition\n  invalidateCacheRange_I :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"invalidateCacheRange_I vstart vend pstart \\<equiv> invalidate_I_PoU\"", "property": "Cache Operations: Perform cache operations (cleaning, invalidating, or both) on a range of cache lines that intersect with a given virtual address range and physical address range, ensuring cache coherence and consistency.\n\nSubproperties:\n- Clean Cache Range: Clean the cache lines in the specified range to ensure that the data is written back to memory.\n- Invalidate Cache Range: Invalidate the cache lines in the specified range to ensure that the data is reloaded from memory on the next access.\n- Clean and Invalidate Cache Range: Both clean and invalidate the cache lines in the specified range to ensure that the data is written back to memory and reloaded from memory on the next access.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Performs the given operation on every cache line that intersects the\n  supplied range.\n"}
{"spec": "definition\n  branchFlushRange :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"branchFlushRange vstart vend pstart \\<equiv> cacheRangeOp branchFlush vstart vend pstart\"\n\ndefinition\n  cleanCaches_PoU :: \"unit machine_monad\"\nwhere\n  \"cleanCaches_PoU \\<equiv> do\n    dsb;\n    clean_D_PoU;\n    dsb;\n    invalidate_I_PoU;\n    dsb\n  od\"\n\ndefinition\n  cleanInvalidateL1Caches :: \"unit machine_monad\"\nwhere\n  \"cleanInvalidateL1Caches \\<equiv> do\n    dsb;\n    cleanInvalidate_D_PoC;\n    dsb;\n    invalidate_I_PoU;\n    dsb\n  od\"", "property": "Machine Operations: Perform low-level machine operations for cache management, including branch flushing, cache cleaning, and cache invalidation, ensuring proper synchronization and data consistency across the system.\n\nSubproperties:\n- Branch Flushing: Flush branches within a specified virtual address range.\n- Cache Cleaning: Clean data caches to the point of unification (PoU) and invalidate instruction caches to the point of unification (PoU).\n- Cache Invalidation: Clean and invalidate level 1 data caches to the point of coherence (PoC) and invalidate instruction caches to the point of unification (PoU).", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " for other than A53 and A35: \"cacheRangeOp invalidateByVA_I vstart vend pstart\" "}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory. Do not yet flush the cache.\\<close>\ndefinition\n  clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"clearMemory ptr bytelength \\<equiv>\n    mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"\n\ndefinition\n  clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Memory Clearance: Clear the contents of a specified memory region to prepare it for reuse as user memory, without flushing the cache. \n\nSubproperties:\n- Clear Memory Region: Set all bytes in the specified memory region to zero.\n- Virtual Memory Clearance: No operation is performed for virtual memory clearance.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": ""}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Initialize memory for user use, ensuring it is properly cleared and prepared for allocation.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Initialize memory to be used as user memory.\n  Note that zeroing out the memory is redundant in the specifications.\n  In any case, we cannot abstract from the call to cleanCacheRange,\n  which appears in the implementation.\n"}
{"spec": "definition\n  freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"freeMemory ptr bits \\<equiv>\n  mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Memory Clearance: Zero out the underlying memory when freeing user memory to avoid garbage, ensuring that the exact memory content can be computed from the implementation state.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Free memory that had been initialized as user memory.\n  While freeing memory is a no-(in) the implementation,\n  we zero out the underlying memory in the specifications to avoid garbage.\n  If we know that there is no garbage,\n  we can compute from the implementation state\n  what the exact memory content in the specifications is.\n"}
{"spec": "consts'\n  writeContextIDAndPD_impl :: \"hardware_asid \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  writeContextIDAndPD :: \"hardware_asid \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere \"writeContextIDAndPD a b \\<equiv> machine_op_lift (writeContextIDAndPD_impl a b)\"\n\nconsts'\n  HSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  HDFAR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  SCTLR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  ACTLR_val :: \"machine_state \\<Rightarrow> machine_word\"\n\ndefinition\n  getHSR :: \"machine_word machine_monad\"\nwhere \"getHSR \\<equiv> gets HSR_val\"\n\ndefinition\n  getHDFAR :: \"machine_word machine_monad\"\nwhere \"getHDFAR \\<equiv> gets HDFAR_val\"\n\nconsts'\n  setHCR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setHCR :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setHCR w \\<equiv> machine_op_lift (setHCR_impl w)\"\n\nconsts'\n  addressTranslateS1_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\n  addressTranslateS1_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition\n  addressTranslateS1 :: \"machine_word \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"addressTranslateS1 w \\<equiv> do\n    machine_op_lift (addressTranslateS1_impl w);\n    gets (addressTranslateS1_val w)\n  od\"\n\ndefinition\n  getSCTLR :: \"machine_word machine_monad\"\nwhere \"getSCTLR \\<equiv> gets SCTLR_val\"\n\nconsts'\n  setSCTLR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setSCTLR :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setSCTLR w \\<equiv> machine_op_lift (setSCTLR_impl w)\"\n\ndefinition\n  vgic_irq_active :: \"machine_word\"\nwhere\n  \"vgic_irq_active \\<equiv> 2 << 28\"\n\ndefinition\n  vgic_irq_mask :: \"machine_word\"\nwhere\n  \"vgic_irq_mask \\<equiv> 3 << 28\"\n\nconsts'\n  gic_vcpu_ctrl_hcr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_hcr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_hcr \\<equiv> gets gic_vcpu_ctrl_hcr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_hcr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_hcr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_hcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_hcr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_vmcr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_vmcr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_vmcr \\<equiv> gets gic_vcpu_ctrl_vmcr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_vmcr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_vmcr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_vmcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vmcr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_apr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_apr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_apr \\<equiv> gets gic_vcpu_ctrl_apr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_apr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_apr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_apr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_apr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_vtr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_vtr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_vtr \\<equiv> gets gic_vcpu_ctrl_vtr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_vtr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_vtr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_vtr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vtr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_misr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_misr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_misr \\<equiv> gets gic_vcpu_ctrl_misr_val\"\n\nconsts'\n  gic_vcpu_ctrl_eisr0_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_eisr0 :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_eisr0 \\<equiv> gets gic_vcpu_ctrl_eisr0_val\"\n\nconsts'\n  gic_vcpu_ctrl_eisr1_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_eisr1 :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_eisr1 \\<equiv> gets gic_vcpu_ctrl_eisr1_val\"\n\nconsts'\n  get_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\n  gic_vcpu_ctrl_lr_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_lr n \\<equiv> do\n      machine_op_lift (get_gic_vcpu_ctrl_lr_impl n);\n      gets (gic_vcpu_ctrl_lr_val n)\n    od\"\n\nconsts'\n  set_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_lr n w  \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_lr_impl n w)\"", "property": "Machine Operations: Provide low-level machine operations for managing hardware resources, including writing context IDs and page directories, getting and setting system registers (HSR, HDFAR, SCTLR, etc.), performing address translations, and controlling GIC (Generic Interrupt Controller) vCPU settings. These operations ensure that the kernel can interact with the hardware efficiently and securely.\n\nSubproperties:\n\n* System Register Management: Get and set system registers, such as HSR, HDFAR, SCTLR, and ACTLR.\n* Address Translation: Perform address translations using the addressTranslateS1 operation.\n* GIC vCPU Control: Get and set GIC vCPU control registers, including HCR, VMCR, APR, VTR, MISR, EISRs, and LRs.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "consts'\n  cntv_cval_64_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition\n  get_cntv_cval_64 :: \"64 word machine_monad\"\nwhere\n  \"get_cntv_cval_64 \\<equiv> gets cntv_cval_64_val\"\n\nconsts'\n  set_cntv_cval_64_impl :: \"64 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_cntv_cval_64 :: \"64 word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_cntv_cval_64 w \\<equiv> machine_op_lift (set_cntv_cval_64_impl w)\"\n\nconsts'\n  cntv_off_64_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition\n  get_cntv_off_64 :: \"64 word machine_monad\"\nwhere\n  \"get_cntv_off_64 \\<equiv> gets cntv_off_64_val\"\n\nconsts'\n  set_cntv_off_64_impl :: \"64 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_cntv_off_64 :: \"64 word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_cntv_off_64 w \\<equiv> machine_op_lift (set_cntv_off_64_impl w)\"\n\nconsts'\n  read_cntpct_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition\n  read_cntpct :: \"64 word machine_monad\"\nwhere\n  \"read_cntpct \\<equiv> gets read_cntpct_val\"", "property": "Access Hypervisor Banked Registers: Provide access to the hypervisor banked registers, including getting and setting the CNTV_CVAL_64 and CNTV_OFF_64 registers, and reading the CNTPCT register.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "consts'\n  vcpuHardwareReg_val :: \"vcpureg \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition\n  readVCPUHardwareReg :: \"vcpureg \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"readVCPUHardwareReg reg \\<equiv> gets (vcpuHardwareReg_val reg)\"\n\nconsts'\n  writeVCPUHardwareReg_impl :: \"vcpureg \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  writeVCPUHardwareReg :: \"vcpureg \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"writeVCPUHardwareReg reg val \\<equiv> machine_op_lift (writeVCPUHardwareReg_impl reg val)\"", "property": "Access Hypervisor Banked Registers: Read and write values from the hypervisor banked registers for a VCPU. \n\nRead Hypervisor Banked Register: Get the value of a specific hypervisor banked register.\nWrite Hypervisor Banked Register: Set the value of a specific hypervisor banked register.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "type_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\" where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\" where\n  \"modify_registers f uc \\<equiv> UserContext (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\" where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext ((user_regs s) (r := v)))\"\n\ndefinition\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition\n  \"setNextPC \\<equiv> setRegister NextIP\"\n\nend\n\ntranslations\n  (type) \"'a ARM_HYP.user_monad\" <= (type) \"(ARM_HYP.register \\<Rightarrow> machine_word, 'a) nondet_monad\"\n\n\nend", "property": "User Register Management: Provides operations to access and modify user registers, including getting the value of a specific register, modifying multiple registers, setting the value of a register, and getting and setting the restart and next program counter values.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Platform Integer Representation: The platform represents integer literals as 32-bit signed words.", "title": "./spec/machine/ARM_HYP/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming ARM_HYP\n\nvalue_type irq_len = Kernel_Config.irqBits (* IRQ_CNODE_SLOT_BITS *)\ntype_synonym irq = \"irq_len word\"\ntype_synonym paddr = word32\n\nabbreviation (input) \"toPAddr \\<equiv> id\"\nabbreviation (input) \"fromPAddr \\<equiv> id\"\n\ndefinition pageColourBits :: nat where\n  \"pageColourBits \\<equiv> 2\"\n\ndefinition cacheLineBits :: nat where\n  \"cacheLineBits = CONFIG_L1_CACHE_LINE_SIZE_BITS\"\n\ndefinition cacheLine :: nat where\n  \"cacheLine = 2^cacheLineBits\"", "property": "Platform Constants: Define fundamental platform-specific constants, including the length of IRQs, the type of physical addresses, and the number of bits for page coloring and cache line sizes. \n\nPage Coloring: The number of bits used for page coloring is 2.\n\nCache Line Size: The cache line size is determined by the CONFIG_L1_CACHE_LINE_SIZE_BITS constant, with the cache line size being 2 raised to the power of this value.", "title": "./spec/machine/ARM_HYP/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "definition pptrBase :: word32 where\n  \"pptrBase \\<equiv> 0xe0000000\"\n\nabbreviation (input) \"paddrBase \\<equiv> physBase\"\n\ndefinition pptrBaseOffset :: machine_word where\n  \"pptrBaseOffset = pptrBase - paddrBase\"\n\ndefinition pptrTop :: \"32 word\" where\n  \"pptrTop \\<equiv> 0xfff00000\"\n\ndefinition paddrTop :: \"32 word\" where\n  \"paddrTop \\<equiv> pptrTop - pptrBaseOffset\"\n\ndefinition kernelELFPAddrBase :: word32 where\n  \"kernelELFPAddrBase \\<equiv> physBase\"\n\ndefinition kernelELFBase :: word32 where\n  \"kernelELFBase \\<equiv> pptrBase + (kernelELFPAddrBase && mask 22)\"\n\ndefinition kernelELFBaseOffset :: word32 where\n  \"kernelELFBaseOffset \\<equiv> kernelELFBase - kernelELFPAddrBase\"\n\ndefinition ptrFromPAddr :: \"paddr \\<Rightarrow> word32\" where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBaseOffset\"\n\ndefinition addrFromPPtr :: \"word32 \\<Rightarrow> paddr\" where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBaseOffset\"\n\ndefinition addrFromKPPtr :: \"word32 \\<Rightarrow> paddr\" where\n  \"addrFromKPPtr kpptr \\<equiv> kpptr - kernelELFBaseOffset\"\n\ndefinition minIRQ :: \"irq\" where\n  \"minIRQ \\<equiv> 0\"\n\ndefinition irqVGICMaintenance :: \"irq\" where\n  \"irqVGICMaintenance \\<equiv> 25\"\n\ndefinition irqVTimerEvent :: \"irq\" where\n  \"irqVTimerEvent  \\<equiv> 27\"\n\nend\n\nend", "property": "Platform Constants Definition: Define the base addresses, offsets, and boundaries for the kernel's physical memory window, including the relationship between physical and virtual addresses. \n\n Base Addresses and Offsets: Define the base addresses and offsets for the kernel's physical memory window, including pptrBase, paddrBase, kernelELFPAddrBase, and kernelELFBase, and their corresponding offsets. \n\n Address Conversions: Provide functions to convert between physical and virtual addresses, including ptrFromPAddr, addrFromPPtr, and addrFromKPPtr. \n\n IRQ Definitions: Define the minimum IRQ value and specific IRQ values for VGIC maintenance and VTimer events.", "title": "./spec/machine/ARM_HYP/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": " The first virtual address of the kernel's physical memory window "}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming ARM_HYP", "property": "Architecture-Specific Kernel Configuration: Provides lemmas that constrain and validate the kernel configuration for a specific architecture, ensuring that the kernel is properly set up and configured for the underlying platform.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma physBase_aligned:\n  \"is_aligned physBase 25\"\n  by (simp add: is_aligned_def Kernel_Config.physBase_def)", "property": "Physical Base Alignment: The physical base address is aligned to a 25-bit boundary, ensuring proper memory alignment for the kernel configuration.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " note: 25 = pageBitsForSize ARMSuperSection, we do not have access to ASpec at this point "}
{"spec": "lemma irqVTimerEvent_le_maxIRQ[simp, intro!]:\n  \"irqVTimerEvent \\<le> maxIRQ\"\n  by (simp add: irqVTimerEvent_def Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_less_2p_irqBits:\n  \"(maxIRQ::nat) < 2^irqBits\"\n  by (simp add: Kernel_Config.maxIRQ_def Kernel_Config.irqBits_def)", "property": "IRQ Limits: The maximum IRQ (maxIRQ) is bounded by specific constraints, ensuring it is less than 2 to the power of irqBits and irqVTimerEvent does not exceed maxIRQ.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ conditions "}
{"spec": "lemma LENGTH_irq_len_irqBits[simp]: (* [simp] will fire only for simp del: len_of_numeral_defs *)\n  \"LENGTH(irq_len) = irqBits\"\n  using irq_len_def irq_len_val\n  by simp\n\nlemma maxIRQ_less_2p_irq_len:\n  \"(maxIRQ::nat) < 2^LENGTH(irq_len)\"\n  using maxIRQ_less_2p_irqBits\n  by (simp del: len_of_numeral_defs)\n\nlemma unat_2p_irqBits_machine[simp]:\n  \"unat (2 ^ irqBits :: machine_word) = 2 ^ irqBits\"\n  by (simp add: Kernel_Config.irqBits_def)", "property": "IRQ Length Properties: The length of IRQ is equal to the number of IRQ bits, and the maximum IRQ value is less than 2 to the power of the IRQ length. Additionally, the unat (unsigned natural number) value of 2 to the power of IRQ bits in machine words is equal to 2 to the power of IRQ bits.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " follows from value_type definition of irq_len "}
{"spec": "lemma of_nat_maxIRQ[simp]:\n  \"of_nat maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma of_int_maxIRQ[simp]:\n  \"of_int maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "Generic Numerals for IRQ: Allow writing rules about casts, unat, uint, etc. without referencing specific numbers, using maxIRQ as a generic numeral representation. \n\nSubproperties:\n- Of Nat MaxIRQ: The natural number representation of maxIRQ is equal to its word representation.\n- Of Int MaxIRQ: The integer representation of maxIRQ is equal to its word representation.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ as a generic numeral allows us to write rules about casts/unat/uint etc without\n   mentioning numbers: "}
{"spec": "lemma unat_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> unat (maxIRQ::'a word) = maxIRQ\"\n  by (metis maxIRQ_less_2p_irq_len Word.of_nat_unat of_nat_inverse of_nat_maxIRQ unat_ucast_up_simp)", "property": "IRQ Length Property: The unat (unsigned natural number) value of maxIRQ is equal to maxIRQ when the length of irq_len is less than or equal to the length of the word type 'a.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma uint_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> uint (maxIRQ::'a word) = maxIRQ\"\n  by (metis Kernel_Config.maxIRQ_def of_nat_numeral uint_nat unat_maxIRQ)", "property": "IRQ Length Property: The length of irq_len is less than or equal to the length of the word type 'a, ensuring that the unsigned integer representation of maxIRQ is equal to maxIRQ.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma ucast_maxIRQ[simp]:\n  \"\\<lbrakk> LENGTH(irq_len) \\<le> LENGTH('a::len); LENGTH(irq_len) \\<le> LENGTH('b::len) \\<rbrakk> \\<Longrightarrow>\n   UCAST ('a \\<rightarrow> 'b) maxIRQ = maxIRQ\"\n  by (metis of_nat_maxIRQ ucast_nat_def unat_maxIRQ)", "property": "UCast MaxIRQ: The ucast operation preserves the value of maxIRQ when casting between types 'a and 'b, provided that the length of irq_len is less than or equal to the lengths of both 'a and 'b.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma maxIRQ_less_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   (maxIRQ < (ucast irq :: 'a word)) = (maxIRQ < irq)\" for irq::irq\n  by (simp add: word_less_nat_alt unat_ucast_up_simp)", "property": "IRQ Comparison Property: The comparison between the maximum IRQ value and an IRQ value upcasted to a word of a larger type is equivalent to the comparison between the maximum IRQ value and the original IRQ value, as long as the length of the IRQ type is less than or equal to the length of the larger type.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma maxIRQ_le_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   ((ucast irq :: 'a word) \\<le> Kernel_Config.maxIRQ) = (irq \\<le> Kernel_Config.maxIRQ)\" for irq::irq\n  by (simp add: word_le_nat_alt unat_ucast_up_simp)", "property": "IRQ Upcast Comparison: The upcast of an IRQ value to a larger word type does not affect its comparison with the maximum IRQ value, as long as the length of the IRQ type is less than or equal to the length of the larger word type.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma le_maxIRQ_machine_less_irqBits_val[simplified]:\n  \"w \\<le> maxIRQ \\<Longrightarrow> unat w < 2^LENGTH(irq_len)\" for w::machine_word\n  using maxIRQ_less_2p_irq_len\n  by (simp add: word_le_nat_alt)\n\nlemma irq_machine_le_maxIRQ_irq:\n  \"irq \\<le> Kernel_Config.maxIRQ \\<Longrightarrow> (ucast irq::irq) \\<le> maxIRQ\" for irq::machine_word\n  by (simp add: Kernel_Config.maxIRQ_def word_le_nat_alt unat_ucast)\n\nlemma maxIRQ_eq_ucast_irq_32_signed_uint:\n  \"(maxIRQ = (ucast b :: 32 signed word)) = (uint b = maxIRQ)\" for b::irq\n  unfolding Kernel_Config.maxIRQ_def\n  apply uint_arith\n  apply (simp add: uint_up_ucast is_up)\n  done\n\nlemma sint_maxIRQ_32[simp]:\n  \"sint (maxIRQ :: 32 signed word) = maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_machine[simp]:\n  \"scast (maxIRQ::32 signed word) = (maxIRQ::machine_word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_irq[simp]:\n  \"scast (maxIRQ :: 32 signed word) = (maxIRQ::irq)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_machine:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = x\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_irq:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = (ucast x :: irq)\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_1_plus_eq_Suc_machine[simp]:\n  \"unat (1 + maxIRQ :: machine_word) = Suc Kernel_Config.maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_le_mask_irq_len:\n  \"x \\<le> maxIRQ \\<longrightarrow> x \\<le> mask irq_len\" for x :: machine_word\n  using le_maxIRQ_machine_less_irqBits_val\n  by (fastforce simp add: word_le_nat_alt word_less_nat_alt irq_len_val mask_def)", "property": "IRQ Value Properties: Ensure that IRQ values are correctly represented and converted between different types (machine word, 32 signed word, and irq), and that they are within the valid range defined by maxIRQ.\n\nSubproperties:\n- IRQ values are correctly converted between machine word and 32 signed word.\n- IRQ values are correctly converted between machine word and irq.\n- IRQ values are within the valid range defined by maxIRQ.\n- The maximum IRQ value is correctly represented as a machine word, 32 signed word, and irq.\n- The relationship between IRQ values and the mask irq_len is correctly established.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " The following are instances -- for some we could derive general rules, but the number of\n   instances is limited and the concrete proofs are much simpler: "}
{"spec": "lemma cacheLineBits_sanity:\n  \"cacheLineBits \\<in> {2..12}\"\n  by (simp add: cacheLineBits_def Kernel_Config.CONFIG_L1_CACHE_LINE_SIZE_BITS_def)\n\nend\nend", "property": "Cache Line Bits Sanity: The cache line bits value must be within a valid range (2 to 12) to ensure reliable folding in C functions and avoid conflicts with other values used in cache operations.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Folding cacheLineBits_val in C functions only works reliably if cacheLineBits is not 1 and\n   not too large to conflict with other values used inside cache ops.\n   12 is ptBits, which is only available after ExecSpec. Anything > 1 and smaller than ptBits\n   works. "}
{"spec": "theory Example2\nimports Isolation_S\nbegin\n\nlemma direct_caps_of_update [simp]:\n  \"direct_caps_of (s(x := y)) =\n  (direct_caps_of s)(x:= case y of None \\<Rightarrow> {} | Some (Entity c) \\<Rightarrow> c)\"\n  by (rule ext, simp add: direct_caps_of_def split:option.splits)\n\nlemma direct_caps_of_empty [simp]:\n  \"direct_caps_of Map.empty = ( \\<lambda> x. {})\"\n  by (simp add: direct_caps_of_def fun_eq_iff)\n\ndefinition \"id\\<^sub>0 \\<equiv> 0\"\ndefinition \"id\\<^sub>1 \\<equiv> 1\"\ndefinition \"id\\<^sub>2 \\<equiv> 2\"\ndefinition \"id\\<^sub>3 \\<equiv> 3\"\ndefinition \"id\\<^sub>4 \\<equiv> 4\"\ndefinition \"id\\<^sub>5 \\<equiv> 5\"", "property": "Direct Caps Update: The direct capabilities of a system state are updated when an entity is added or removed, ensuring that the capabilities are correctly propagated.\nEmpty Direct Caps: The direct capabilities of an empty system state are empty for all entities.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  e0_caps :: \"cap set\"\nwhere\n  \"e0_caps \\<equiv> range create_cap \\<union> {full_cap 0}\"\n\ndefinition\n  s0  :: \"state\"\nwhere\n  \"s0  \\<equiv> [0 \\<mapsto> Entity e0_caps]\"\n\ndefinition\n  s1  :: \"state\"\nwhere\n  \"s1  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> null_entity]\"\n\ndefinition\n  s2  :: \"state\" where\n  \"s2  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2}]\"\n\ndefinition\n  s3  :: \"state\" where\n  \"s3  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>}]\"\n\ndefinition\n  s4  :: \"state\" where\n  \"s4  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  s5  :: \"state\" where\n  \"s5  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1, write_cap 2}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  s6  :: \"state\" where\n  \"s6  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1, write_cap 2}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2, read_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  s7  :: \"state\" where \"s7  \\<equiv> s4\"\n\ndefinition\n  s8  :: \"state\" where\n  \"s8  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1, full_cap 3}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity,\n          3 \\<mapsto> null_entity]\"\n\ndefinition\n  s9  :: \"state\" where\n  \"s9  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity,\n          3 \\<mapsto> null_entity]\"\n\ndefinition\n  s10 :: \"state\" where \"s10 \\<equiv> s4\"\n\ndefinition\n  s   :: \"state\" where\n  \"s   \\<equiv> [0 \\<mapsto> Entity (e0_caps - {create_cap 1, create_cap 2}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  op0  :: \"sysOPs\" where\n  \"op0  \\<equiv> SysCreate  0 (full_cap 0) (create_cap 1)\"\ndefinition\n  op1  :: \"sysOPs\" where\n  \"op1  \\<equiv> SysGrant   0 (full_cap 1) (create_cap 2) UNIV\"\ndefinition\n  op2  :: \"sysOPs\" where\n  \"op2  \\<equiv> SysGrant   0 (full_cap 1) (full_cap   1) {Write, Store}\"\ndefinition\n  op3  :: \"sysOPs\" where\n  \"op3  \\<equiv> SysCreate  1 \\<lparr>target = 1, rights = {Write, Store}\\<rparr> (create_cap 2)\"\ndefinition\n  op4  :: \"sysOPs\" where\n  \"op4  \\<equiv> SysTake    0 (full_cap 1) (full_cap   2) {Write}\"\ndefinition\n  op5  :: \"sysOPs\" where\n  \"op5  \\<equiv> SysCopy    1 \\<lparr>target = 1, rights = {Write, Store}\\<rparr> (full_cap   2) {Read}\"\ndefinition\n  op6  :: \"sysOPs\" where\n  \"op6  \\<equiv> SysRevoke  0 (write_cap 2)\"\ndefinition\n  op7  :: \"sysOPs\" where\n  \"op7  \\<equiv> SysCreate  0 (full_cap 0) (create_cap 3)\"\ndefinition\n  op8  :: \"sysOPs\" where\n  \"op8  \\<equiv> SysRemove  0 (full_cap 0) (full_cap 3)\"\ndefinition\n  op9  :: \"sysOPs\" where\n  \"op9  \\<equiv> SysDestroy  0 (create_cap 3)\"\ndefinition\n  op10 :: \"sysOPs\" where\n  \"op10 \\<equiv> SysRemoveSet 0 (full_cap 0) {full_cap 1, create_cap 1, create_cap 2}\"\n\ndefinition ops :: \"sysOPs list\" where", "property": "Entity State Transitions: Define the initial states and transitions of entities in the system, including the creation, granting, taking, copying, revoking, removing, and destroying of capabilities. These transitions govern how entities interact and manage their capabilities, ensuring the integrity and security of the system.\n\nSubproperties:\n- Capability Creation: Define the creation of new capabilities for entities, including the initial capabilities of e0.\n- Capability Grants: Specify the rules for granting capabilities between entities, including the rights and targets involved.\n- Capability Management: Define the operations for taking, copying, revoking, removing, and destroying capabilities, ensuring the correct management of entity capabilities.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " e0 has create caps to all of memory, and full rights to itself. "}
{"spec": "\"ops \\<equiv> [op10, op9, op8, op7, op3, op2, op1, op0]\"", "property": "Skipped Operation: The operation \"op6\" and \"op5\" and \"op4\" are skipped from the list of operations \"ops\" due to undefined CDT, ensuring that only valid operations are executed.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " since the CDT isn't defined, op6 is skipped\n  \"ops \\<equiv> [op10, op9, op8, op7, op6, op5, op4, op3, op2, op1, op0]\"\n"}
{"spec": "lemma is_entity_s0_e0 [simp]:\n  \"is_entity s0 0\"\n  by (simp add: is_entity_def s0_def)\n\nlemma is_entity_s1_e0 [simp]:\n  \"is_entity s1 0\"\n  by (simp add: is_entity_def s1_def)\n\nlemma is_entity_s2_e0 [simp]:\n  \"is_entity s2 0\"\n  by (simp add: is_entity_def s2_def)\n\nlemma is_entity_s3_e0 [simp]:\n  \"is_entity s3 0\"\n  by (simp add: is_entity_def s3_def)\n\nlemma is_entity_s4_e0 [simp]:\n  \"is_entity s4 0\"\n  by (simp add: is_entity_def s4_def)\n\nlemma is_entity_s5_e0 [simp]:\n  \"is_entity s5 0\"\n  by (simp add: is_entity_def s5_def)\n\nlemma is_entity_s6_e0 [simp]:\n  \"is_entity s6 0\"\n  by (simp add: is_entity_def s6_def)\n\nlemma is_entity_s8_e0 [simp]:\n  \"is_entity s8 0\"\n  by (simp add: is_entity_def s8_def)\n\nlemma is_entity_s9_e0 [simp]:\n  \"is_entity s9 0\"\n  by (simp add: is_entity_def s9_def)\n\nlemma is_entity_s_e0 [simp]:\n  \"is_entity s 0\"\n  by (simp add: is_entity_def s_def)\n\n\nlemma is_entity_s0_e1 [simp]:\n  \"\\<not> is_entity s0 1\"\n  by (simp add: is_entity_def s0_def)\n\nlemma is_entity_s1_e1 [simp]:\n  \"is_entity s1 1\"\n  by (simp add: is_entity_def s1_def)\n\nlemma is_entity_s2_e1 [simp]:\n  \"is_entity s2 1\"\n  by (simp add: is_entity_def s2_def)\n\nlemma is_entity_s3_e1 [simp]:\n  \"is_entity s3 1\"\n  by (simp add: is_entity_def s3_def)\n\nlemma is_entity_s4_e1 [simp]:\n  \"is_entity s4 1\"\n  by (simp add: is_entity_def s4_def)\n\nlemma is_entity_s5_e1 [simp]:\n  \"is_entity s5 1\"\n  by (simp add: is_entity_def s5_def)\n\n\nlemma is_entity_s3_e2 [simp]:\n  \"\\<not> is_entity s3 2\"\n  by (simp add: is_entity_def s3_def)\n\nlemma is_entity_s4_e3 [simp]:\n  \"\\<not> is_entity s4 3\"\n  by (simp add: is_entity_def s4_def)", "property": "Entity Existence Properties: Define the existence of entities for various states (s0 to s9) and entity indices (e0 to e3). These properties ensure that specific entities exist or do not exist for each state, providing a foundation for entity management and relationships within the system.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " is_entity lemmas "}
{"spec": "lemma direct_caps_of_s0_e0_caps [simp]:\n  \"direct_caps_of s0 0 = e0_caps\"\n  by (simp add: direct_caps_of_def s0_def e0_caps_def)\n\nlemma direct_caps_of_s1_e0_caps [simp]:\n  \"direct_caps_of s1 0 = e0_caps \\<union> {full_cap 1}\"\n  by (simp add: direct_caps_of_def s1_def e0_caps_def)\n\nlemma direct_caps_of_s2_e0_caps [simp]:\n  \"direct_caps_of s2 0 = e0_caps \\<union> {full_cap 1}\"\n  by (simp add: direct_caps_of_def s2_def e0_caps_def)\n\nlemma direct_caps_of_s4_e0_caps [simp]:\n  \"direct_caps_of s4 0 = e0_caps \\<union> {full_cap 1}\"\n  by (simp add: direct_caps_of_def s4_def e0_caps_def)\n\nlemma direct_caps_of_s5_e0_caps [simp]:\n  \"direct_caps_of s5 0 = e0_caps \\<union> {full_cap 1, write_cap 2}\"\n  by (simp add: direct_caps_of_def s5_def e0_caps_def)\n\nlemma direct_caps_of_s6_e0_caps [simp]:\n  \"direct_caps_of s6 0 = e0_caps \\<union> {full_cap 1, write_cap 2}\"\n  by (simp add: direct_caps_of_def s6_def e0_caps_def)\n\nlemma direct_caps_of_s8_e0_caps [simp]:\n  \"direct_caps_of s8 0 = e0_caps \\<union> {full_cap 1, full_cap 3}\"\n  by (simp add: direct_caps_of_def s8_def e0_caps_def)\n\nlemma direct_caps_of_s9_e0_caps [simp]:\n  \"direct_caps_of s9 0 = e0_caps \\<union> {full_cap 1}\"\n  by (simp add: direct_caps_of_def s9_def e0_caps_def)\n\n\nlemma direct_caps_of_s2_e1 [simp]:\n  \"direct_caps_of s2 1 = {create_cap 2}\"\n  by (simp add: direct_caps_of_def s2_def)\n\nlemma direct_caps_of_s3_e1 [simp]:\n  \"direct_caps_of s3 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>}\"\n  by (simp add: direct_caps_of_def s3_def)\n\nlemma direct_caps_of_s4_e1 [simp]:\n  \"direct_caps_of s4 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  by (simp add: direct_caps_of_def s4_def)\n\nlemma direct_caps_of_s6_e1 [simp]:\n  \"direct_caps_of s5 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  by (simp add: direct_caps_of_def s5_def)\n\nlemma direct_caps_of_s9_e1 [simp]:\n  \"direct_caps_of s9 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  by (simp add: direct_caps_of_def s9_def)\n\n\nlemma full_cap_e0_caps_in_caps_of_s0_e0_caps [simp]:\n  \"full_cap 0 \\<in> caps_of s0 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e1_in_caps_of_s1_e0_caps [simp]:\n  \"full_cap 1 \\<in> caps_of s1 0\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma full_cap_e1_in_caps_of_s2_e0_caps [simp]:\n  \"full_cap 1 \\<in> caps_of s2 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e0_caps_in_caps_of_s4_e0_caps [simp]:\n  \"full_cap 0 \\<in> caps_of s4 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e1_in_caps_of_s4_e0_caps [simp]:\n  \"full_cap 1 \\<in> caps_of s4 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e2_in_caps_of_s4_e1 [simp]:\n  \"full_cap 2 \\<in> caps_of s4 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma full_cap_e1_in_caps_of_s5_e0_caps [simp]:\n  \"full_cap 1 \\<in> caps_of s5 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e2_in_caps_of_s5_e0_caps [simp]:\n  \"full_cap 2 \\<in> caps_of s5 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma full_cap_e0_caps_in_caps_of_s8_e0_caps [simp]:\n  \"full_cap 0 \\<in> caps_of s8 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma create_cap_in_caps_of_s0_e0_caps [simp]:\n  \"create_cap i \\<in> caps_of s0 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma create_cap_in_caps_of_s1_e0_caps [simp]:\n  \"create_cap i \\<in> caps_of s1 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma create_cap_in_caps_of_s2_e1 [simp]:\n  \"create_cap 2 \\<in> caps_of s2 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma create_cap_in_caps_of_s3_e1 [simp]:\n  \"create_cap 2 \\<in> caps_of s3 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma create_cap_in_caps_of_s4_e3 [simp]:\n  \"create_cap 3 \\<in> caps_of s4 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma create_cap_in_caps_of_s9_e3 [simp]:\n  \"create_cap 3 \\<in> caps_of s9 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma write_store_e1_in_caps_of_s3_e1 [simp]:\n  \"\\<lparr>target = 1, rights = {Write, Store}\\<rparr>  \\<in> caps_of s3 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma write_store_e1_in_caps_of_s5_e1 [simp]:\n  \"\\<lparr>target = 1, rights = {Write, Store}\\<rparr> \\<in> caps_of s5 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma write_cap_e2_in_caps_of_s6_e0_caps [simp]:\n  \"write_cap 2 \\<in> caps_of s6 0\"\n  by (rule direct_cap_in_cap, simp)", "property": "Capability Set Properties: Define the sets of capabilities associated with various states (s0, s1, s2, etc.) and entities (e0, e1, etc.), including direct capabilities and full capabilities. These properties establish the relationships between states, entities, and their respective capability sets, ensuring that capabilities are correctly attributed and managed within the system.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " direct_caps_of, caps_of and similar lemmas "}
{"spec": "lemma op0_legal:\n  \"legal op0 s0\"\n  by  (clarsimp simp: op0_def all_rights_def)\n\nlemma execute_op0_safe:\n  \"step op0 s0 \\<subseteq> ({s0, s1})\"\n  by (fastforce simp: op0_def step_def createOperation_def s0_def s1_def\n                 split: if_split_asm)\n\nlemma execute_op0_live:\n  \"step op0 s0 \\<supseteq> ({s0, s1})\"\n  apply clarsimp\n  apply (rule conjI)\n   apply (simp add: step_def)\n  apply (simp add: step_def op0_legal)\n  apply (rule disjI2)\n  apply (clarsimp simp: op0_def createOperation_def)\n  apply (rule ext)\n  apply (clarsimp simp: s0_def s1_def)\n  done\n\nlemma execute_op0:\n  \"step op0 s0 = ({s0, s1})\"\n  apply rule\n   apply (rule execute_op0_safe)\n  apply (rule execute_op0_live)\n  done", "property": "SysCreate Operation Properties: The SysCreate operation (op0) is a system call that creates a new capability. It is a legal operation, and its execution is both safe and live, meaning it only transitions between two specific states (s0 and s1) and can reach all possible outcomes from the initial state.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " \"op0 \\<equiv> SysCreate 0 (full_cap 0) (create_cap 1)\" "}
{"spec": "lemma op1_legal:\n  \"legal op1 s1\"\n  by  (clarsimp simp: op1_def all_rights_def)\n\nlemma execute_op1_safe:\n  \"step op1 s1 \\<subseteq> ({s1, s2})\"\n  by (clarsimp simp: op1_def step_def grantOperation_def diminish_def\n                     s1_def s2_def create_cap_def null_entity_def\n              split: if_split_asm)\n\nlemma execute_op1_live:\n  \"step op1 s1 \\<supseteq> ({s1, s2})\"\n  apply clarsimp\n  apply (rule conjI)\n   apply (simp add: step_def)\n  apply (simp add: step_def op1_legal)\n  apply (rule disjI2)\n  apply (clarsimp simp: op1_def grantOperation_def)\n  apply (rule ext)\n  apply (clarsimp simp: s1_def s2_def null_entity_def)\n  done\n\nlemma execute_op1:\n  \"step op1 s1 = ({s1, s2})\"\n  apply rule\n   apply (rule execute_op1_safe)\n  apply (rule execute_op1_live)\n  done", "property": "SysGrant Operation: The SysGrant operation, denoted as op1, grants a full capability to entity 1 and creates a new capability for entity 2, applicable to all entities in the system. This operation is legal and, when executed, results in a system state transition from s1 to either s1 or s2.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " \"op1 \\<equiv> SysGrant  0 (full_cap 1) (create_cap 2) UNIV\" "}
{"spec": "lemma op2_legal:\n  \"legal op2 s2\"\n  by  (clarsimp simp: op2_def all_rights_def)\n\nlemma execute_op2_safe:\n  \"step op2 s2 \\<subseteq> ({s2, s3})\"\n  apply clarsimp\n  apply (rule ext)\n  apply (auto simp: op2_def step_def grantOperation_def diminish_def s2_def s3_def full_cap_def all_rights_def\n             split: if_split_asm)\n  done\n\nlemma execute_op2_live:\n  \"step op2 s2 \\<supseteq> ({s2, s3})\"\n  apply clarsimp\n  apply (simp add: step_def op2_legal)\n  apply (rule disjI2)\n  apply (simp add: op2_def)\n  apply (rule ext)\n  apply (fastforce simp: s2_def s3_def grantOperation_def diminish_def all_rights_def full_cap_def)\n  done\n\nlemma execute_op2:\n  \"step op2 s2 = ({s2, s3})\"\n  apply rule\n   apply (rule execute_op2_safe)\n  apply (rule execute_op2_live)\n  done", "property": "SysGrant Operation: The SysGrant operation, denoted as op2, grants capabilities with specific rights (Write, Store) from one capability to another, ensuring a safe and live execution that transitions the system state from s2 to either s2 or s3.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " \"op2 \\<equiv> SysGrant  0 (full_cap 1) (full_cap   1) {Write, Store}\" "}
{"spec": "lemma op3_legal:\n  \"legal op3 s3\"\n  by  (clarsimp simp: op3_def all_rights_def)\n\nlemma execute_op3_safe:\n  \"step op3 s3 \\<subseteq> ({s3, s4})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: op3_def step_def createOperation_def s3_def s4_def\n             split: if_split_asm)\n  done\n\nlemma execute_op3_live:\n  \"step op3 s3 \\<supseteq> ({s3, s4})\"\n  apply clarsimp\n  apply (simp add: step_def op3_legal)\n  apply (rule disjI2)\n  apply (clarsimp simp: op3_def createOperation_def)\n  apply (rule ext)\n  apply (fastforce simp: s3_def s4_def)\n  done\n\nlemma execute_op3:\n  \"step op3 s3 = ({s3, s4})\"\n  apply rule\n   apply (rule execute_op3_safe)\n  apply (rule execute_op3_live)\n  done", "property": "SysCreate Operation Properties: The SysCreate operation is legal and its execution is both safe and live, resulting in a deterministic outcome of either state s3 or s4. \n\nSafety: The SysCreate operation only transitions to valid states s3 or s4, ensuring that the system remains in a valid configuration.\n\nLiveness: The SysCreate operation can transition to both s3 and s4, indicating that the operation can make progress and is not blocked.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " \"op3 \\<equiv> SysCreate 1 (full_cap 1) (create_cap 2)\" "}
{"spec": "lemma op4_legal:\n  \"legal op4 s4\"\n  by  (clarsimp simp: op4_def all_rights_def)\n\nlemma execute_op4_safe:\n  \"step op4 s4 \\<subseteq> ({s4, s5})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s4_def s5_def op4_def step_def takeOperation_def\n                    diminish_def all_rights_def write_cap_def\n             split: if_split_asm)\n  done\n\nlemma execute_op4_live:\n  \"step op4 s4 \\<supseteq> ({s4, s5})\"\n  apply clarsimp\n  apply (simp add: op4_legal step_def)\n  apply (rule disjI2)\n  apply (simp add: op4_def)\n  apply (rule ext)\n  apply (fastforce simp: s4_def s5_def takeOperation_def diminish_def all_rights_def write_cap_def)\n  done\n\nlemma execute_op4:\n  \"step op4 s4 = ({s4, s5})\"\n  apply rule\n   apply (rule execute_op4_safe)\n  apply (rule execute_op4_live)\n  done", "property": "SysTake Operation: The SysTake operation, denoted as op4, is a system call that takes a capability with all rights, except for the Write right, from one capability (full_cap 1) and transfers it to another capability (full_cap 2). \n\nOperation Safety and Liveness: The execution of op4 is both safe and live, meaning that it only transitions between two specific states (s4 and s5) and that it can reach these states.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op4 \\<equiv> SysTake    0 (full_cap 1) (full_cap   2) {Write} "}
{"spec": "lemma op5_legal:\n  \"legal op5 s5\"\n  by  (clarsimp simp: op5_def all_rights_def)\n\nlemma execute_op5_safe:\n  \"step op5 s5 \\<subseteq> ({s5, s6})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s5_def s6_def op5_def step_def copyOperation_def diminish_def all_rights_def read_cap_def\n             split: if_split_asm)\n  done\n\nlemma execute_op5_live:\n  \"step op5 s5 \\<supseteq> ({s5, s6})\"\n  apply clarsimp\n  apply (simp add: step_def op5_legal)\n  apply (rule disjI2)\n  apply (simp add: op5_def)\n  apply (rule ext)\n  apply (fastforce simp: s5_def s6_def copyOperation_def diminish_def all_rights_def read_cap_def)\n  done\n\nlemma execute_op5:\n  \"step op5 s5 = ({s5, s6})\"\n  apply rule\n   apply (rule execute_op5_safe)\n  apply (rule execute_op5_live)\n  done", "property": "SysCopy Operation: The SysCopy operation (op5) is a system call that copies the full capability 1 to capability 2 with read rights, ensuring a safe and live execution that transitions the system from state s5 to either s5 or s6.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op5  \\<equiv> SysCopy    1 (full_cap 1) (full_cap   2) {Read} "}
{"spec": "lemma op6_legal:\n  \"legal op6 s6\"\n  by  (clarsimp simp: op6_def all_rights_def)\n\nlemma execute_op6_safe:\n  \"step op6 s6 \\<subseteq> ({s6, s7})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s6_def s7_def s4_def op7_def step_def revokeOperation_def\n          split: if_split_asm)\n  oops\n\nlemma execute_op6_live:\n  \"step op6 s6 \\<supseteq> ({s6, s7})\"\n  apply (insert op6_legal)\n  oops (*\n  apply (auto simp: step_def op6_legal op6_def s6_def s7_def s4_def revokeOperation_def fun_eq_iff)\n  done*)", "property": "SysRevoke Operation: The system revoke operation (op6) is a specific instance of the SysRevoke action, targeting a capability at slot 2 with a specified argument (0). This operation ensures the revocation of the capability, adhering to the system's access control and capability management rules.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op6  \\<equiv> SysRevoke  0 (read_cap 2) "}
{"spec": "lemma execute_op6_live:\n  \"s7 \\<in> step op6 s6\"\n  oops\n\nlemma execute_op6:\n  \"step op6 s6 = ({s6, s7})\"\n  oops", "property": "Operation Execution: The execution of operation op6 from state s6 results in a set of possible next states, specifically s6 and s7. \n\nStep Relationship: State s7 is a possible next state after executing operation op6 from state s6.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " Since cdt is not defined, this proof can't be done "}
{"spec": "lemma op7_legal:\n  \"legal op7 s7\"\n  by  (clarsimp simp: s7_def op7_def all_rights_def)\n\nlemma execute_op7_safe:\n  \"step op7 s7 \\<subseteq> ({s7, s8})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s7_def s8_def s4_def op7_def step_def createOperation_def\n             split: if_split_asm)\n  done\n\nlemma execute_op7_live:\n  \"step op7 s7 \\<supseteq> ({s7, s8})\"\n  apply clarsimp\n  apply (simp add: step_def op7_legal)\n  apply (rule disjI2)\n  apply (simp add: op7_def)\n  apply (rule ext)\n  apply (fastforce simp: s7_def s8_def s4_def createOperation_def)\n  done\n\nlemma execute_op7:\n  \"step op7 s7 = ({s7, s8})\"\n  apply rule\n   apply (rule execute_op7_safe)\n  apply (rule execute_op7_live)\n  done", "property": "SysCreate Operation: The SysCreate operation (op7) creates a new capability with all rights, starting from a null capability, and results in a new state (s8) in addition to the original state (s7). The operation is both safe and live, meaning it only transitions to the specified states and always enables the transition to the new state.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op7  \\<equiv> SysCreate  0 (full_cap 0) (create_cap 3) "}
{"spec": "lemma op8_legal:\n  \"legal op8 s8\"\n  by  (clarsimp simp: op8_def)\n\nlemma execute_op8_safe:\n  \"step op8 s8 \\<subseteq> ({s8, s9})\"\n  apply clarsimp\n  apply (rule ext)\n  apply (insert op8_legal)\n  apply (fastforce simp: step_def op8_def s8_def s9_def removeOperation_def\n                        full_cap_def create_cap_def all_rights_def e0_caps_def)\n  done\n\nlemma execute_op8_live:\n  \"step op8 s8 \\<supseteq> ({s8, s9})\"\n  apply (simp add: step_def op8_legal op8_def)\n  apply (rule disjI2)\n  apply (rule ext)\n  apply (clarsimp simp: removeOperation_def)\n  apply (fastforce simp: s8_def s9_def full_cap_def create_cap_def all_rights_def e0_caps_def)\n  done\n\nlemma execute_op8:\n  \"step op8 s8 = ({s8, s9})\"\n  apply rule\n   apply (rule execute_op8_safe)\n  apply (rule execute_op8_live)\n  done", "property": "SysRemove Operation: The SysRemove operation, denoted as op8, is a system call that removes a capability from the system. When executed in state s8, it results in either the same state s8 or a new state s9, ensuring the operation's safety and liveness properties.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op8  \\<equiv> SysRemove  0 (full_cap 0) (full_cap 3) "}
{"spec": "lemma op9_legal:\n  \"legal op9 s9\"\n  apply (simp add: op9_def)\n  apply (fastforce simp: s9_def e0_caps_def null_entity_def split:if_split_asm)\n  done\n\nlemma execute_op9_safe:\n  \"step op9 s9 \\<subseteq> ({s9, s10})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s9_def s10_def s4_def op9_def step_def destroyOperation_def\n             split: if_split_asm)\n  done\n\nlemma execute_op9_live:\n  \"step op9 s9 \\<supseteq> ({s9, s10})\"\n  apply (simp add: step_def op9_legal)\n  apply (rule disjI2)\n  apply (simp add: op9_def)\n  apply (rule ext)\n  apply (clarsimp simp: destroyOperation_def step_def op9_def s9_def s10_def s4_def)\n  done\n\nlemma execute_op9:\n  \"step op9 s9 = ({s9, s10})\"\n  apply rule\n   apply (rule execute_op9_safe)\n  apply (rule execute_op9_live)\n  done", "property": "SysDelete Operation: The SysDelete operation (op9) is a system call that deletes a capability. When executed in a specific system state (s9), it results in either the same state (s9) or a new state (s10), ensuring the system remains in a valid and predictable state after the operation.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op9  \\<equiv> SysDelete  0 (create_cap 3) "}
{"spec": "lemma op10_legal:\n  \"legal op10 s10\"\n  by  (clarsimp simp: s10_def op10_def all_rights_def)\n\nlemma e0_caps_diminished [simp]:\n  \"e0_caps - {full_cap 1, create_cap 1, create_cap 2} = e0_caps - {create_cap 1, create_cap 2}\"\n  by (fastforce simp: e0_caps_def create_cap_def full_cap_def all_rights_def)\n\n\nlemma execute_op10_safe:\n  \"step op10 s10 \\<subseteq> ({s10, s})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s10_def op10_def step_def removeSetOperation_def s4_def s_def\n              split: if_split_asm)\n  done\n\nlemma execute_op10_live:\n  \"step op10 s10 \\<supseteq> ({s10, s})\"\n  apply clarsimp\n  apply (rule conjI)\n   apply (simp add: step_def)\n  apply (simp add: step_def op10_legal)\n  apply (rule disjI2)\n  apply (clarsimp simp: s10_def op10_def removeSetOperation_def)\n  apply (rule ext)\n  apply (fastforce simp: s4_def s_def)\n  done\n\nlemma execute_op10:\n  \"step op10 s10 = ({s10, s})\"\n  apply rule\n   apply (rule execute_op10_safe)\n  apply (rule execute_op10_live)\n  done\n\n\nlemma execute_ops:\n  \"s \\<in> execute ops s0\"\n  apply (clarsimp simp: ops_def)\n  apply (insert execute_op0_live execute_op1_live execute_op2_live execute_op3_live\n                execute_op4_live execute_op5_live                  execute_op7_live\n                execute_op8_live execute_op9_live execute_op10_live)\n  apply (simp add: s7_def)\n  apply fastforce\n  done", "property": "System Execution: The system executes a sequence of operations (ops) starting from an initial state (s0), resulting in a final state (s) that is part of the execution outcome.\n\nSubproperties:\n- Operation Legality: Each operation, such as op10 (SysRemoveSet), is legal and can be executed according to the system's rules and current state.\n- Safe Execution: The execution of each operation does not lead to an unsafe or invalid state, ensuring the system's integrity.\n- Live Execution: The execution of each operation results in a valid and expected outcome, contributing to the overall system state.\n- Deterministic Execution: The execution of operations leads to a deterministic outcome, where the final state (s) is uniquely determined by the initial state (s0) and the sequence of operations (ops).", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op10 \\<equiv> SysRemoveSet 0 (full_cap 0) {full_cap 1, create_cap 1, create_cap 2} "}
{"spec": "lemma store_not_in_create_cap [simp]:\n  \"Store \\<notin> rights (create_cap i)\"\n  by (simp add: create_cap_def)\n\nlemma store_not_in_create_cap2 [simp]:\n  \"Store \\<in> rights c \\<Longrightarrow> c \\<noteq> create_cap i\"\n  by (clarsimp simp: create_cap_def)", "property": "Create Capability Rights: The create_cap function does not grant Store rights.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma store_connected_direct_s_helper1:\n  \"{c'.(c' = \\<lparr>target = 0, rights = UNIV\\<rparr> \\<or> c' \\<in> range create_cap) \\<and>\n        c' \\<noteq> \\<lparr>target = 1, rights = {Create}\\<rparr> \\<and> c' \\<noteq> \\<lparr>target = 2, rights = {Create}\\<rparr> \\<and>\n        Store \\<in> rights c'} = {full_cap 0}\"\n by (auto simp: create_cap_def full_cap_def all_rights_def e0_caps_def)\n\nlemma store_connected_direct_s_helper2:\n  \"{c'. (c' = \\<lparr>target = 2, rights = {Create}\\<rparr> \\<or> c' = \\<lparr>target = 1, rights = {Write, Store}\\<rparr> \\<or>\n         c' = \\<lparr>target = 2, rights = UNIV\\<rparr>)    \\<and>  Store \\<in> rights c'}\n   = {\\<lparr>target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  by (auto simp: create_cap_def full_cap_def all_rights_def e0_caps_def)\n\n\nlemma store_connected_direct_s:\n  \"store_connected_direct s = {(0,0), (1,1), (1,2)}\"\n  by (fastforce simp: store_connected_direct_def s_def e0_caps_def\n                      full_cap_def all_rights_def create_cap_def null_entity_def\n                      store_connected_direct_s_helper1 store_connected_direct_s_helper2\n               split: if_split_asm)", "property": "Store Connected Direct: The store_connected_direct function evaluates to a set of pairs representing direct connections in the system, specifically {(0,0), (1,1), (1,2)}.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma into_rtrancl [rule_format]:\n  \"(a,b) \\<in> r^* \\<Longrightarrow> (\\<forall>x. (x,b) \\<in> r \\<longrightarrow> x = b) \\<longrightarrow> a = b\"\n  apply (erule converse_rtrancl_induct)\n   apply simp\n  apply clarsimp\n  done\n\nlemma into_rtrancl2 [rule_format]:\n  \" \\<And> B. \\<lbrakk>(a,b) \\<in> r^*; b \\<in> B\\<rbrakk> \\<Longrightarrow> (\\<forall>x.(x,b) \\<in> r \\<longrightarrow> x \\<in> B) \\<longrightarrow> a \\<in> B\"\n  thm rtrancl_induct converse_rtrancl_induct\n  apply (erule converse_rtrancl_induct)\n   apply clarsimp\n  apply clarsimp\n  oops\n\nlemma store_connected_id:\n \"{(0::word32, 0), (1, 1), (1, 2)}\\<^sup>* = {(1, 2)}\\<^sup>* \"\n  apply rule\n   apply clarsimp\n   apply (erule rtranclE)\n    apply simp\n   apply (fastforce dest: into_rtrancl)\n  apply clarsimp\n  apply (erule rtranclE)\n   apply simp\n  apply (fastforce dest: into_rtrancl)\n  done\n\nlemma store_connected_s: \"store_connected s = {(1,2)} \\<union> Id\"\n  apply simp\n  apply (rule equalityI)\n  apply (insert store_connected_direct_s)\n   apply (simp add: store_connected_def)\n   apply clarsimp\n   apply (erule converse_rtranclE)\n    apply simp\n   apply clarsimp\n   apply (erule rtranclE)\n    apply fastforce\n   apply (simp add: store_connected_id)\n   apply (drule rtranclD)\n   apply (safe, simp_all, (erule tranclE, simp, fastforce)+)\n  apply (fastforce simp: store_connected_def)\n  done", "property": "Store Connectedness: The store connected relation is defined as the union of the identity relation and the specific connection between elements 1 and 2. This relation is both reflexive and transitive, ensuring that any element connected to 1 is also connected to 2, and any element connected to itself remains unchanged.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma caps_of_s_e0_caps: \"caps_of s 0 = e0_caps - {create_cap 1, create_cap 2}\"\n  apply (clarsimp simp: caps_of_def store_connected_s Collect_disj_eq)\n  apply (simp add: s_def)\n  done\n\nlemma caps_of_s_e0_caps_2: \"caps_of s 0 = {full_cap 0} \\<union> ( range create_cap - {create_cap 1, create_cap 2})\"\n  by (fastforce simp: caps_of_s_e0_caps e0_caps_def full_cap_def create_cap_def)\n\n\nlemma caps_of_s_e1: \"caps_of s 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  apply (clarsimp simp: caps_of_def store_connected_s Collect_disj_eq)\n  apply (simp add: s_def null_entity_def)\n  done\n\nlemma caps_of_s_e2: \"caps_of s 2 = {}\"\n  apply (simp add: caps_of_def store_connected_s)\n  apply (simp add: s_def null_entity_def)\n  done\n\nlemma caps_of_s_e3: \"\\<lbrakk>e \\<noteq> 0; e \\<noteq> 1\\<rbrakk> \\<Longrightarrow> caps_of s e = {}\"\n  apply (simp add: caps_of_def store_connected_s)\n  apply (simp add: s_def null_entity_def)\n  done", "property": "Entity Capabilities: Define the capabilities associated with each entity in the system, ensuring that each entity has the correct set of capabilities. \n\nEntity 0 Capabilities: Entity 0 has a specific set of capabilities, including a full capability and a range of created capabilities, excluding certain specific capabilities.\n\nEntity 1 Capabilities: Entity 1 has a defined set of capabilities, including a created capability, a capability with specific rights, and a full capability.\n\nEntity 2 Capabilities: Entity 2 has no associated capabilities.\n\nOther Entity Capabilities: All entities other than 0 and 1 have no associated capabilities.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma extra_rights_create_cap:\n  \"extra_rights (create_cap i) = full_cap i\"\n  by (simp add: create_cap_def full_cap_def extra_rights_def)\n\n\nlemma extra_rights_full_cap:\n  \"extra_rights (full_cap i) = full_cap i\"\n  by (simp add: full_cap_def extra_rights_def)\n\nlemma extra_rights_take_cap:\n  \"extra_rights (take_cap i) = take_cap i\"\n  by (simp add: take_cap_def extra_rights_def)\n\nlemma extra_rights_grant_cap:\n  \"extra_rights (grant_cap i) = grant_cap i\"\n  by (simp add: take_cap_def extra_rights_def)\n\nlemma caps_of'_s_e0_caps_helper:\n  \"extra_rights ` (range create_cap - {create_cap 1, create_cap 2}) =\n  range full_cap - {full_cap 1, full_cap 2}\"\n  apply rule\n   apply (fastforce simp: create_cap_def extra_rights_def all_rights_def full_cap_def)\n  apply rule\n  apply (erule DiffE)\n  apply clarsimp\n  apply (rule image_eqI)\n   apply (rule extra_rights_create_cap [THEN sym])\n  apply (simp add: full_cap_def create_cap_def)\n  done", "property": "Extra Rights Properties: \nThe extra rights of capability creation, full capability, taking capability, and granting capability are equal to their respective original capabilities.\nExtra Rights Mapping: The extra rights of all created capabilities (excluding specific ones) map to the full capabilities (excluding those specific ones), establishing a correspondence between these two sets of capabilities.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma extra_rights_increases_rights:\n  \"rights c \\<subseteq> rights (extra_rights c)\"\n  by (simp add: extra_rights_def all_rights_def)\n\nlemma cap_in_caps_take_cap:\n  \"\\<lbrakk>create_cap x \\<in> caps_of s y\\<rbrakk> \\<Longrightarrow> take_cap x \\<in>cap caps_of s y\"\n  apply (auto simp: cap_in_caps_def caps_of_def extra_rights_take_cap)\n  apply (rule exI, rule conjI, assumption)\n  apply (rule rev_bexI, simp)\n  apply (rule conjI)\n   apply (subgoal_tac \"target (full_cap x) = x\", simp+)\n  apply (simp add: extra_rights_create_cap all_rights_def)\n  done\n\n\nlemma e0_connected_to:\n  \"\\<lbrakk>x \\<noteq> 1; x \\<noteq> 2\\<rbrakk> \\<Longrightarrow> s \\<turnstile> 0 \\<leftrightarrow> x\"\n  apply (rule directly_tgs_connected_comm)\n  apply (simp add: directly_tgs_connected_def4)\n  apply (rule disjI1)\n  apply (rule cap_in_caps_take_cap)\n  apply (simp add: caps_of_s_e0_caps e0_caps_def create_cap_def)\n  done\n\nlemma e1_connected_to_e2:\n  \"s \\<turnstile> 1 \\<leftrightarrow> 2\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (rule disjI2)+\n  apply (simp add: shares_caps_def)\n  apply (simp add: store_connected_s)\n  done\n\nlemma e0_caps_not_connected_to_e1:\n  \"\\<not> (s \\<turnstile> 0 \\<leftrightarrow> 1)\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (rule conjI)\n   apply (simp add: cap_in_caps_def caps_of_s_e1)\n  apply (rule conjI)\n   apply (clarsimp simp add: cap_in_caps_def caps_of_s_e0_caps e0_caps_def)\n   apply (erule disjE)\n    apply (simp add: full_cap_def)\n   apply clarsimp\n  apply (rule conjI)\n     apply (clarsimp simp add: cap_in_caps_def caps_of_s_e0_caps e0_caps_def)\n   apply (erule disjE)\n    apply (simp add: full_cap_def)\n   apply clarsimp\n  apply (rule conjI)\n   apply (simp add: cap_in_caps_def caps_of_s_e1)\n  apply (simp add: shares_caps_def)\n  apply (simp add: store_connected_s)\n  done\n\nlemma e0_caps_not_connected_to_e2:\n  \"\\<not> (s \\<turnstile> 0 \\<leftrightarrow> 2)\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (rule conjI)\n   apply (simp add: cap_in_caps_def caps_of_s_e2)\n  apply (rule conjI)\n   apply (clarsimp simp add: cap_in_caps_def caps_of_s_e0_caps e0_caps_def)\n   apply (erule disjE)\n    apply (simp add: full_cap_def)\n   apply clarsimp\n  apply (rule conjI)\n     apply (clarsimp simp add: cap_in_caps_def caps_of_s_e0_caps e0_caps_def)\n   apply (erule disjE)\n    apply (simp add: full_cap_def)\n   apply clarsimp\n  apply (rule conjI)\n   apply (simp add: cap_in_caps_def caps_of_s_e2)\n  apply (simp add: shares_caps_def)\n  apply (simp add: store_connected_s)\n  done", "property": "Capability Connection Properties: \n- Extra rights added to a capability do not decrease its existing rights.\n- Taking a capability with extra rights does not disconnect it from its original caps.\n- Endpoints 0 and x (x ≠ 1, x ≠ 2) are connected through a capability.\n- Endpoints 1 and 2 are connected through shared caps.\n- Endpoints 0 and 1 are not connected through any capability.\n- Endpoints 0 and 2 are not connected through any capability.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma e1_connected_trans_to_e2:\n  \"s \\<turnstile> 1 \\<leftrightarrow>* 2\"\n  apply (insert e1_connected_to_e2)\n  apply (simp add: tgs_connected_def)\n  done\n\n\nlemma caps_of_to_e1:\n  \"\\<lbrakk>c \\<in> caps_of s x; target c = 1\\<rbrakk> \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (case_tac \"x = 0\")\n   apply (fastforce simp: caps_of_s_e0_caps_2)\n  apply (case_tac \"x = 1\")\n   apply (fastforce simp: caps_of_s_e1)\n  apply (fastforce simp: caps_of_s_e3)\n  done\n\nlemma caps_of_to_e2:\n  \"\\<lbrakk>c \\<in> caps_of s x; target c = 2\\<rbrakk> \\<Longrightarrow> x = 1\"\n  apply (case_tac \"x = 0\")\n   apply (fastforce simp: caps_of_s_e0_caps_2)\n  apply (case_tac \"x = 1\")\n   apply (fastforce simp: caps_of_s_e1)\n  apply (fastforce simp: caps_of_s_e3)\n  done\n\nlemma cap_in_caps_caps_of_e1:\n  \"c \\<in>cap caps_of s 1 \\<Longrightarrow> target c = 1 \\<or> target c = 2\"\n  by (clarsimp simp: cap_in_caps_def caps_of_s_e1)\n\nlemma cap_in_caps_caps_of_e2:\n  \"c \\<in>cap caps_of s 2 \\<Longrightarrow> False\"\n  by (clarsimp simp: cap_in_caps_def caps_of_s_e2)\n\nlemma cap_in_caps_caps_of_to_e1:\n  \"\\<lbrakk>c \\<in>cap caps_of s x; target c = 1\\<rbrakk> \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (drule (1) caps_of_to_e1, simp)\n  done\n\nlemma cap_in_caps_caps_of_to_e2:\n  \"\\<lbrakk>c \\<in>cap caps_of s x; target c = 2\\<rbrakk> \\<Longrightarrow> x = 1\"\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (erule (1) caps_of_to_e2)\n  done\n\nlemma e1_connected_to:\n  \"s \\<turnstile> 1 \\<leftrightarrow> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (erule disjE)\n   apply (erule cap_in_caps_caps_of_to_e1, simp)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, simp)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, simp)\n  apply (erule disjE)\n   apply (erule cap_in_caps_caps_of_to_e1, simp)\n  apply (fastforce simp: shares_caps_def store_connected_s)\n  done\n\n\nlemma e2_connected_to:\n  \"s \\<turnstile> 2 \\<leftrightarrow> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (erule disjE, rule disjI1)\n   apply (erule cap_in_caps_caps_of_to_e2, simp)\n  apply (erule disjE, rule disjI1)\n   apply (drule cap_in_caps_caps_of_e2, simp)\n  apply (erule disjE, rule disjI1)\n   apply (drule cap_in_caps_caps_of_e2, simp)\n  apply (erule disjE, rule disjI1)\n   apply (erule cap_in_caps_caps_of_to_e2, simp)\n  apply (clarsimp simp: shares_caps_def store_connected_s)\n  done\n\n\nlemma directly_tgs_connected_in_inv_image:\n  \"(directly_tgs_connected s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  by (fastforce simp: inv_image_def\n              dest!: e1_connected_to e1_connected_to [OF directly_tgs_connected_comm]\n                     e2_connected_to e2_connected_to [OF directly_tgs_connected_comm])\n\nlemma connected_inv_image_trans:\n  \"trans (inv_image Id (\\<lambda> x. x=1 \\<or> x=2))\"\n  by (rule trans_inv_image [OF trans_Id])\n\nlemma eq_inv_image_connected:\n  \"(inv_image Id (\\<lambda> x. x=1 \\<or> x=2))\\<^sup>= = inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  by (fastforce simp: inv_image_def)\n\nlemma rtrancl_inv_image_connected:\n  \"(inv_image Id (\\<lambda> x. x=1 \\<or> x=2))\\<^sup>* = inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  apply (subst trancl_reflcl [symmetric])\n  apply (subst eq_inv_image_connected)\n  apply (rule trancl_id)\n  apply (rule connected_inv_image_trans)\n  done\n\nlemma tgs_connected_in_inv_image:\n  \"(tgs_connected s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  apply (simp add: tgs_connected_def)\n  apply (subst rtrancl_inv_image_connected [symmetric])\n  apply (rule rtrancl_mono)\n  apply (rule directly_tgs_connected_in_inv_image)\n  done\n\nlemma e0_not_connected_trans_e1:\n  \"\\<not> s \\<turnstile> 0 \\<leftrightarrow>* 1\"\n  apply clarsimp\n  apply (drule set_mp [OF tgs_connected_in_inv_image])\n  apply (simp add: inv_image_def)\n  done\n\nlemma e0_not_ever_connected_trans_e1:\n  \"s' \\<in> execute cmds s \\<Longrightarrow> \\<not> s' \\<turnstile> 0 \\<leftrightarrow>* 1\"\n  apply clarsimp\n  apply (drule (1) tgs_connected_preserved)\n  apply (simp add: e0_not_connected_trans_e1)\n  done\n\n\nlemma e0_e1_leakage:\n  \"s' \\<in> execute cmds s \\<Longrightarrow> \\<not> leak s' 0 1\"\n  apply (insert e0_not_connected_trans_e1)\n  apply (drule (2) leakage_rule)\n  done", "property": "System Connectivity: The system ensures that certain entities (e.g., 0, 1, and 2) have specific connectivity properties, such as the inability of entity 0 to be transitively connected to entity 1, even after executing commands.\n\nEntity Relationships: Entity 1 is connected to entity 2, and entity 1 can only be connected to entities 1 and 2. Entity 2 can only be connected to entities 1 and 2. Entity 0 is not connected to entity 1, even after executing commands, ensuring no leakage between them.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma island_e0:\n  \"island s 0 = {i. i \\<noteq> 1 \\<and> i \\<noteq> 2}\"\n  apply rule\n   apply (clarsimp simp: island_def)\n   apply (insert tgs_connected_in_inv_image)[1]\n   apply fastforce\n  apply (clarsimp simp: island_def)\n  apply (drule (1) e0_connected_to)\n  apply (drule directly_tgs_connected_comm)\n  by (metis directly_tgs_connected_def2 tgs_connected_comm leakImplyConnectedTrans)\n\nlemma island_e1:\n  \"island s 1 = {1,2}\"\n  apply rule\n   apply (clarsimp simp: island_def)\n   apply (insert tgs_connected_in_inv_image)[1]\n   apply fastforce\n  apply (clarsimp simp: island_def)\n  apply (rule e1_connected_trans_to_e2)\n  done\n\nlemma island_e2:\n  \"island s 2 = {1,2}\"\n  apply rule\n   apply (clarsimp simp: island_def)\n   apply (insert tgs_connected_in_inv_image)[1]\n   apply fastforce\n  apply (clarsimp simp: island_def)\n  apply (rule e1_connected_trans_to_e2  [THEN tgs_connected_comm])\n  done\n\nlemma island_e3:\n  \"\\<lbrakk>x \\<noteq> 1; x \\<noteq> 2\\<rbrakk> \\<Longrightarrow> island s x =  {i. i \\<noteq> 1 \\<and> i \\<noteq> 2}\"\n  apply rule\n   apply (clarsimp simp: island_def)\n   apply (insert tgs_connected_in_inv_image)[1]\n   apply fastforce\n  apply (clarsimp simp: island_def)\n  apply (frule_tac x=x  in e0_connected_to, simp)\n  apply (frule_tac x=xa in e0_connected_to, simp)\n  apply (drule_tac x=0 and y=xa in directly_tgs_connected_comm)\n  apply (rule tgs_connected_comm)\n  apply (simp add: tgs_connected_def)\n  done", "property": "Island Properties: Define the island sets for different nodes (0, 1, 2, and others) in a system, where an island is a set of nodes that are connected to each other through certain edges. Specifically, island 0 consists of all nodes except 1 and 2, while islands 1 and 2 consist of nodes 1 and 2 only. For any other node x not equal to 1 or 2, its island is the same as island 0. \n\n Subproperties:\n- Island 0: {i. i ≠ 1 ∧ i ≠ 2}\n- Island 1: {1, 2}\n- Island 2: {1, 2}\n- Island x (x ≠ 1, x ≠ 2): {i. i ≠ 1 ∧ i ≠ 2}", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma e1_flow_to:\n  \"s \\<turnstile> 1 \\<leadsto> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (rule ccontr)\n  apply (clarsimp simp: flow_def set_flow_def island_e1 island_e3)\n  apply (erule disjE, clarsimp)\n   apply (erule disjE)\n    apply (drule cap_in_caps_caps_of_to_e1, clarsimp+)\n   apply (drule cap_in_caps_caps_of_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_to_e2, clarsimp+)\n  apply (drule cap_in_caps_caps_of_e2, clarsimp+)\n  done\n\nlemma e2_flow_to:\n  \"s \\<turnstile> 2 \\<leadsto> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (rule ccontr)\n  apply (clarsimp simp: flow_def set_flow_def island_e2 island_e3)\n  apply (erule disjE, clarsimp)\n   apply (erule disjE)\n    apply (drule cap_in_caps_caps_of_to_e1, clarsimp+)\n   apply (drule cap_in_caps_caps_of_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_to_e2, clarsimp+)\n  apply (drule cap_in_caps_caps_of_e2, clarsimp+)\n  done\n\nlemma flow_to_e1:\n  \"s \\<turnstile> x \\<leadsto> 1 \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (rule ccontr)\n  apply (clarsimp simp: flow_def set_flow_def island_e1 island_e3)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_to_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e2, clarsimp+)\n  apply (drule cap_in_caps_caps_of_to_e2, clarsimp+)\n  done\n\nlemma flow_to_e2:\n  \"s \\<turnstile> x \\<leadsto> 2 \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (rule ccontr)\n  apply (clarsimp simp: flow_def set_flow_def island_e2 island_e3)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_to_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e2, clarsimp+)\n  apply (drule cap_in_caps_caps_of_to_e2, clarsimp+)\n  done\n\n\nlemma flow_in_inv_image:\n  \"(flow s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  by (fastforce simp: inv_image_def\n              dest!: e1_flow_to flow_to_e1\n                     e2_flow_to flow_to_e2)\n\n\nlemma flow_trans_in_inv_image:\n  \"(flow_trans s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  apply (simp add: flow_trans_def)\n  apply (subst rtrancl_inv_image_connected [symmetric])\n  apply (rule rtrancl_mono)\n  apply (rule flow_in_inv_image)\n  done\n\nlemma e0_not_flow_trans_e1:\n  \"\\<not> s \\<turnstile> 0 \\<leadsto>* 1\"\n  apply clarsimp\n  apply (drule set_mp [OF flow_trans_in_inv_image])\n  apply (simp add: inv_image_def)\n  done\n\nlemma e1_not_flow_trans_e0:\n  \"\\<not> s \\<turnstile> 1 \\<leadsto>* 0\"\n  apply clarsimp\n  apply (drule set_mp [OF flow_trans_in_inv_image])\n  apply (simp add: inv_image_def)\n  done\n\nlemma e0_e1_isolated:\n  \"s' \\<in> execute cmds s \\<Longrightarrow> \\<not> s' \\<turnstile> 0 \\<leadsto>* 1 \\<and> \\<not> s' \\<turnstile> 1 \\<leadsto>* 0\"\n  apply (rule conjI)\n   apply (erule information_flow)\n   apply (rule e0_not_flow_trans_e1)\n  apply (erule information_flow)\n  apply (rule e1_not_flow_trans_e0)\n  done\n\nend", "property": "Information Flow Isolation: The system ensures that there is no information flow between entities 0 and 1, meaning that entity 0 cannot flow to entity 1 and vice versa, maintaining their isolation.\n\nEntity Flow Restrictions: The flow of information is restricted to entities 1 and 2, meaning that any flow in the system can only occur between these two entities.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "(* Title:   Confinement_S\n * Description: confinement proof of the security model\n *)\n\ntheory Confine_S\nimports System_S\nbegin", "property": "System Confinement: Ensures that the system's security model is confined, meaning that sensitive information and resources are properly isolated and protected from unauthorized access or manipulation.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  extra_rights :: \"cap \\<Rightarrow> cap\" where\n  \"extra_rights c \\<equiv>\n  if (Create \\<in> rights c)\n  then c\\<lparr>rights := all_rights\\<rparr>\n  else c\"\n\n\nlemma extra_rights_idem [simp]:\n  \"(extra_rights (extra_rights c)) = (extra_rights c)\"\n  apply (clarsimp simp add: extra_rights_def)\n  done\n\nlemma extra_rights_image_idem [simp]:\n  \"(extra_rights ` (extra_rights ` S)) = (extra_rights ` S)\"\n  by (rule set_eqI) (simp add: image_iff)\n\nlemma extra_rights_empty_rights_ident [simp]:\n   \"extra_rights \\<lparr> target = e, rights = {} \\<rparr> = \\<lparr> target = e, rights = {} \\<rparr>\"\n  by (simp add: extra_rights_def)\n\nlemma entity_extra_rights [simp]:\n  \"target (extra_rights c) = target c\"\n  by (simp add: extra_rights_def)\n\nlemma rights_extra_rights:\n  \"rights (extra_rights c) =\n   (if Create \\<in> (rights c)\n    then all_rights\n    else rights c)\"\n  by (simp add: extra_rights_def)", "property": "Capability Rights Expansion: If a capability has the Create right, expand its rights to all_rights, otherwise leave the capability unchanged.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " These translate Create into all_rights "}
{"spec": "definition\n  cap_in_caps :: \"cap \\<Rightarrow> cap set \\<Rightarrow> bool\" (infix \"\\<in>cap\" 50) where\n  \"c \\<in>cap C \\<equiv> \\<exists>c' \\<in> C. target c = target c' \\<and> rights (extra_rights c) \\<subseteq> rights (extra_rights c')\"\n\nabbreviation not_cap_in_caps where\n  \"not_cap_in_caps x A \\<equiv> ~ (x \\<in>cap A)\" \\<comment> \\<open>non-membership\\<close>\n\nnotation (input) cap_in_caps (infix \":cap\" 50)\nnotation (latex output)  cap_in_caps (infix \"\\<in>\\<^sub>c\\<^sub>a\\<^sub>p\" 50)\n\nnotation\n  not_cap_in_caps  (\"(\\<notin>cap)\") and\n  not_cap_in_caps  (\"(_/ \\<notin>cap _)\" [51, 51] 50)\n\nnotation (latex output)\n  not_cap_in_caps  (\"(\\<notin>\\<^sub>c\\<^sub>a\\<^sub>p)\") and\n  not_cap_in_caps  (infix \"\\<notin>\\<^sub>c\\<^sub>a\\<^sub>p\" 50)", "property": "Check Capability Membership: Determine if a capability is in a set of capabilities, considering not only exact matches but also capabilities with more access.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " A cap is in a set, or a cap with more access is. "}
{"spec": "definition\n  caps_dominated_by :: \"cap set \\<Rightarrow> cap \\<Rightarrow> bool\" (infix \"\\<le>cap\" 50) where\n  \"caps \\<le>cap cap \\<equiv> \\<forall>cap' \\<in> caps. target cap' = target cap \\<longrightarrow> rights (extra_rights cap') \\<subseteq> rights (extra_rights cap)\"\n\nnotation (input) caps_dominated_by (infix \"<=cap\" 50)\nnotation (latex output) caps_dominated_by (infix \"\\<unlhd>\\<^sub>c\\<^sub>a\\<^sub>p\" 50)\n\ndefinition\n  shares_caps :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" where\n  \"shares_caps s e\\<^sub>x e\\<^sub>y \\<equiv> \\<exists>e\\<^sub>i . (e\\<^sub>x, e\\<^sub>i) \\<in> store_connected s \\<and> (e\\<^sub>y, e\\<^sub>i) \\<in> store_connected s\"\n\ndefinition\n  leak :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<rightarrow> _\") where\n  \"leak s e\\<^sub>x e\\<^sub>y \\<equiv> take_cap e\\<^sub>x \\<in>cap caps_of s e\\<^sub>y \\<or> grant_cap e\\<^sub>y \\<in>cap caps_of s e\\<^sub>x \\<or> shares_caps s e\\<^sub>x e\\<^sub>y\"\n\n\ndefinition\n  directly_tgs_connected :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"directly_tgs_connected s \\<equiv> {(e\\<^sub>x, e\\<^sub>y). leak s e\\<^sub>x e\\<^sub>y \\<or> leak s e\\<^sub>y e\\<^sub>x}\"\n\nlemma directly_tgs_connected_def2:\n  \"(e\\<^sub>x, e\\<^sub>y) \\<in> directly_tgs_connected s = (leak s e\\<^sub>x e\\<^sub>y \\<or> leak s e\\<^sub>y e\\<^sub>x)\"\n  by (simp add: directly_tgs_connected_def)\n\nabbreviation\n  in_directly_tgs_connected :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<leftrightarrow> _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x \\<leftrightarrow> y \\<equiv> (x,y) \\<in> directly_tgs_connected s\"\n\ndefinition\n  tgs_connected :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"tgs_connected s \\<equiv> (directly_tgs_connected s)\\<^sup>*\"\n\nabbreviation\n  in_tgs_connected :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<leftrightarrow>* _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x \\<leftrightarrow>* y == (x,y) \\<in> tgs_connected s\"\n\nnotation (latex output)\n  in_tgs_connected (\"_ \\<turnstile> _ \\<leftrightarrow>\\<^sup>* _\" [60,0,60] 61)\n\ntranslations\n  \"\\<not> (s \\<turnstile> x \\<leftrightarrow> y)\" <= \"(x,y) \\<notin> CONST directly_tgs_connected s\"\n  \"\\<not> (s \\<turnstile> x \\<leftrightarrow>* y)\" <= \"(x,y) \\<notin> CONST tgs_connected s\"\n\nlemma shares_caps_sym [simp]:\n \"shares_caps s y x = shares_caps s x y\"\n  by (auto simp: shares_caps_def)\n\nlemma directly_tgs_connected_def4:\n  \"s \\<turnstile> e\\<^sub>x \\<leftrightarrow> e\\<^sub>y = (take_cap e\\<^sub>x \\<in>cap caps_of s e\\<^sub>y \\<or> take_cap e\\<^sub>y \\<in>cap caps_of s e\\<^sub>x \\<or>\n                  grant_cap e\\<^sub>y \\<in>cap caps_of s e\\<^sub>x \\<or> grant_cap e\\<^sub>x \\<in>cap caps_of s e\\<^sub>y \\<or>\n                  shares_caps s e\\<^sub>x e\\<^sub>y)\"\n  by (auto simp: directly_tgs_connected_def leak_def)", "property": "Entity Connection Properties: \n- Direct Connection: Two entities are directly connected if there is a leak between them, meaning one entity's take capability is dominated by the other's capabilities, or one entity's grant capability is dominated by the other's capabilities, or they share caps.\n- Indirect Connection: Two entities are indirectly connected if they are connected through a sequence of direct connections.\n- Symmetry: Sharing caps is a symmetric relation, meaning if entity x shares caps with entity y, then entity y also shares caps with entity x.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " A set of caps \"caps\" have less (or equal) access to an entity as \"cap\" does. "}
{"spec": "definition\n  generalOperation ::\n  \"entity_id \\<Rightarrow> entity_id \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"generalOperation e\\<^sub>0 e\\<^sub>1 c r s \\<equiv>\n  s (e\\<^sub>1 \\<mapsto> Entity ( insert (diminish r (extra_rights c)) (direct_caps_of s e\\<^sub>1) ))\"\n\nlemma is_entity_general [simp]:\n  \"is_entity s e\\<^sub>1 \\<Longrightarrow> is_entity (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) e' = is_entity s e'\"\n  by (simp add: is_entity_def generalOperation_def)\n\ndefinition\n  make_entity :: \"entity_id \\<Rightarrow> modify_state\" where\n  \"make_entity n s \\<equiv>\n  s (n \\<mapsto> null_entity)\"\n\nlemma direct_caps_of_store_connected_eq:\n  \"\\<forall> e. direct_caps_of s e = direct_caps_of s' e\n  \\<Longrightarrow> store_connected s = store_connected s'\"\n  by (simp add: store_connected_def store_connected_direct_def\n                direct_caps_of_def)\n\nlemma direct_caps_of_caps_of_eq:\n  \"\\<forall> e. direct_caps_of s e = direct_caps_of s' e \\<Longrightarrow> caps_of s e = caps_of s' e\"\n  by (simp add: caps_of_def store_connected_def store_connected_direct_def\n                direct_caps_of_def)\n\nlemma direct_caps_of_caps_of_eq2:\n  \"\\<lbrakk>\\<forall> e. direct_caps_of s e = direct_caps_of s' e; c \\<in>cap caps_of s e\\<rbrakk> \\<Longrightarrow> c \\<in>cap caps_of s' e\"\n  apply (drule direct_caps_of_caps_of_eq)\n  apply (simp add: cap_in_caps_def)\n  by auto\n\nlemma direct_caps_of_directly_tgs_connected_eq:\n  \"\\<forall> e. direct_caps_of s e = direct_caps_of s' e \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y = s' \\<turnstile> x \\<leftrightarrow> y\"\n  apply (simp add: directly_tgs_connected_def4 shares_caps_def)\n  apply rule\n   apply (erule disjE, drule (1) direct_caps_of_caps_of_eq2, clarsimp)+\n   apply (drule direct_caps_of_store_connected_eq, clarsimp)\n  apply (erule disjE, drule direct_caps_of_caps_of_eq2 [rotated, where s=s' and s'=s], simp+)+\n  apply (drule direct_caps_of_store_connected_eq, simp)\n  done\n\nlemma direct_caps_of_make_entity:\n  \"\\<not> is_entity s n \\<Longrightarrow> direct_caps_of (make_entity n s) e = direct_caps_of s e\"\n  by (simp add: direct_caps_of_def make_entity_def is_entity_def\n                null_entity_def)\n\nlemma caps_of_make_entity:\n  \"\\<not> is_entity s n \\<Longrightarrow> caps_of (make_entity n s) e = caps_of s e\"\n  apply (rule direct_caps_of_caps_of_eq)\n  apply clarsimp\n  apply (erule direct_caps_of_make_entity)\n  done\n\nlemma caps_of_make_entity2:\n  \"\\<lbrakk>\\<not> is_entity s n; c \\<in> caps_of (make_entity n s) e\\<rbrakk> \\<Longrightarrow> c \\<in> caps_of s e\"\n  apply (drule caps_of_make_entity)\n  apply fastforce\n  done\n\nlemma directly_tgs_connected_make_entity:\n \"\\<not> is_entity s n \\<Longrightarrow> make_entity n s \\<turnstile> x \\<leftrightarrow> y = s \\<turnstile> x \\<leftrightarrow> y\"\n  apply (rule direct_caps_of_directly_tgs_connected_eq)\n  apply clarsimp\n  apply (drule (1) direct_caps_of_make_entity)\n  done\n\nlemma directly_tgs_connected_make_entity2:\n \"\\<lbrakk>\\<not> is_entity s n; make_entity n s \\<turnstile> x \\<leftrightarrow> y\\<rbrakk> \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y\"\n  apply (drule directly_tgs_connected_make_entity)\n  apply fastforce\n  done\n\nlemma diminish_extra_rights [simp]:\n  \"diminish (rights c) (extra_rights c) = c\"\n  by (simp add: diminish_def all_rights_def rights_extra_rights)\n\nlemma diminish_extra_rights2 [simp]:\n  \"diminish (r \\<inter> rights c) (extra_rights c) = diminish r c\"\n  apply (simp add: diminish_def extra_rights_def all_rights_def)\n  apply (simp add: Int_commute)\n  apply (subgoal_tac \"rights c \\<inter> (r \\<inter> rights c) = r \\<inter> rights c\")\n   apply simp\n  apply fastforce\n  done\n\nlemma create_general_helper:\n  \"Create \\<in> rights c\\<^sub>2 \\<Longrightarrow>\n   \\<lparr>target = target c\\<^sub>2, rights = UNIV\\<rparr> = c\\<^sub>2\\<lparr>rights := UNIV\\<rparr>\"\n  by auto\n\nlemma extra_rights_full_cap [simp]:\n  \"extra_rights (full_cap e) = full_cap e\"\n  by (simp add: extra_rights_def)\n\nlemma create_general_alt:\n  \"createOperation e c\\<^sub>1 c\\<^sub>2 s =\n   make_entity (target c\\<^sub>2)\n               (generalOperation  e (target c\\<^sub>1) (full_cap (target c\\<^sub>2)) (all_rights) s)\"\n  by (simp add: createOperation_def generalOperation_def make_entity_def)\n\nlemma create_general:\n  \"Create \\<in> rights c\\<^sub>2 \\<Longrightarrow> createOperation e c\\<^sub>1 c\\<^sub>2 s =\n   make_entity (target c\\<^sub>2)\n               (generalOperation  e (target c\\<^sub>1) c\\<^sub>2 (all_rights) s)\"\n  by (simp add: createOperation_def generalOperation_def make_entity_def\n                full_cap_def all_rights_def diminish_def\n                extra_rights_def create_general_helper null_entity_def)\n\nlemma take_general:\n  \"takeOperation e c\\<^sub>1 c\\<^sub>2 r s =\n   generalOperation (target c\\<^sub>1) e c\\<^sub>2 (r \\<inter> rights c\\<^sub>2) s\"\n  by (simp add: takeOperation_def generalOperation_def)\n\nlemma grant_general:\n  \"grantOperation e c\\<^sub>1 c\\<^sub>2 r s =\n   generalOperation e (target c\\<^sub>1) c\\<^sub>2 (r \\<inter> rights c\\<^sub>2) s\"\n  by (simp add: grantOperation_def generalOperation_def)\n\nlemma copy_general:\n  \"copyOperation e c\\<^sub>1 c\\<^sub>2 r s =\n   generalOperation e (target c\\<^sub>1) c\\<^sub>2 (r \\<inter> rights c\\<^sub>2) s\"\n  by (simp add: copyOperation_def generalOperation_def)", "property": "Entity Operations: Manage entity creation, modification, and capability transfers while maintaining system integrity and connectivity.\n\n* Entity Creation: Create a new entity with the specified identifier and initialize its capabilities.\n* Entity Modification: Update an entity's capabilities by inserting or modifying existing capabilities.\n* Capability Transfers: Transfer capabilities between entities while ensuring the system remains connected and secure.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Note: e\\<^sub>0 is unused. "}
{"spec": "lemma directly_tgs_connected_comm:\n  \"s \\<turnstile> x \\<leftrightarrow> y \\<Longrightarrow> s \\<turnstile> y \\<leftrightarrow> x\"\n  by(auto simp: directly_tgs_connected_def)\n\nlemma tgs_connected_refl [simp]:\n  \"s \\<turnstile> x \\<leftrightarrow>* x\"\n  by (metis tgs_connected_def rtrancl.rtrancl_refl)\n\nlemma tgs_connected_comm:\n  \"s \\<turnstile> x \\<leftrightarrow>* y \\<Longrightarrow> s \\<turnstile> y \\<leftrightarrow>* x\"\n  apply(simp add: tgs_connected_def)\n  apply(erule rtrancl_induct, simp)\n  apply(case_tac \"s \\<turnstile> z \\<leftrightarrow> y\")\n   apply(simp add: directly_tgs_connected_comm)\n  apply(simp add: directly_tgs_connected_comm)\n  done\n\nlemma tgs_connected_comm_eq:\n  \"s \\<turnstile> x \\<leftrightarrow>* y = s \\<turnstile> y \\<leftrightarrow>* x\"\n  by (metis tgs_connected_comm)\n\nlemmas tgs_connected_trans =\n       rtrancl_trans [where r=\"directly_tgs_connected s\"  for s, simplified tgs_connected_def[symmetric]]\n\nlemmas directly_tgs_connected_rtrancl_into_rtrancl =\n       rtrancl_into_rtrancl [where r=\"directly_tgs_connected s\" for s, simplified tgs_connected_def[symmetric]]\n\nlemma take_caps_directly_tgs_connected:\n  \"\\<lbrakk>c \\<in> caps_of s e; Take \\<in> rights c\\<rbrakk> \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\"\n  by (auto simp: directly_tgs_connected_def leak_def take_cap_def cap_in_caps_def extra_rights_def all_rights_def)\n\nlemma grant_caps_directly_tgs_connected:\n  \"\\<lbrakk>c \\<in> caps_of s e; Grant \\<in> rights c\\<rbrakk> \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\"\n  by (auto simp: directly_tgs_connected_def leak_def grant_cap_def cap_in_caps_def extra_rights_def all_rights_def)\n\nlemma create_caps_directly_tgs_connected:\n  \"\\<lbrakk>c \\<in> caps_of s e; Create \\<in> rights c\\<rbrakk> \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\"\n  by (auto simp: directly_tgs_connected_def leak_def cap_in_caps_def rights_extra_rights all_rights_def)\n\nlemma store_connected_directly_tgs_connected:\n  \"(x, y) \\<in> store_connected s \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y\"\n  by (auto simp: directly_tgs_connected_def leak_def shares_caps_def store_connected_def)", "property": "Directly TGS Connected Predicate Properties: The directly_tgs_connected predicate is symmetric, and its transitive closure (tgs_connected) is reflexive, symmetric, and transitive. \n\nSubproperties:\n- Symmetry: The directly_tgs_connected relation is symmetric, i.e., if x is directly connected to y, then y is directly connected to x.\n- Reflexivity: The tgs_connected relation is reflexive, i.e., every element is connected to itself.\n- Transitivity: The tgs_connected relation is transitive, i.e., if x is connected to y, and y is connected to z, then x is connected to z.\n- Equivalence: The tgs_connected relation is an equivalence relation, i.e., it is reflexive, symmetric, and transitive.\n- Capabilities: Take, Grant, and Create capabilities imply direct connection between entities.\n- Store Connection: Store-connected entities are directly connected.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas on the directly_tgs_connected predicate "}
{"spec": "lemma cap_in_caps_insert [simp]:\n  \"c \\<in>cap insert c' S = (target c = target c' \\<and>\n  rights (extra_rights c) \\<subseteq> rights (extra_rights c') \\<or> c \\<in>cap S)\"\n  by (simp add: cap_in_caps_def)\n\nlemma cap_in_caps_singleton [simp]:\n  \"c \\<in>cap {c'} = (target c = target c' \\<and> rights (extra_rights c) \\<subseteq> rights (extra_rights c'))\"\n  by (simp add: cap_in_caps_def)\n\nlemma not_in [simp]:\n  \"{} \\<le>cap c\"\n  by(simp add: caps_dominated_by_def)\n\nlemma extra_rights_diminish:\n  \"x \\<in> rights (extra_rights (diminish r c))\n   \\<Longrightarrow> x \\<in> rights (extra_rights c)\"\n  by (auto simp: rights_extra_rights all_rights_def split:if_split_asm)", "property": "Capability Set Properties: \n- A capability is in the set of capabilities after inserting a new capability if the new capability has the same target and its rights are a superset of the original capability's rights, or if the original capability is already in the set.\n- A capability is in a singleton set of capabilities if the targets match and the rights of the original capability are a subset of the rights of the capability in the set.\n- An empty set of capabilities is dominated by any capability.\n- Diminishing the rights of a capability does not add new rights to the capability.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas on caps "}
{"spec": "definition\n  in_store_connected :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" where\n  \"in_store_connected s x y \\<equiv> (x, y) \\<in> store_connected s\"", "property": "System Connection Property: The system maintains a connection relationship between entities, defined as a binary relation over entity IDs, which can be queried to determine if two entities are connected in the system's store.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas on system operations "}
{"spec": "lemma direct_caps_of_generalOp:\n  \"direct_caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) e =\n  (if e = e\\<^sub>1\n   then insert (diminish r (extra_rights c)) (direct_caps_of s (e\\<^sub>1))\n   else direct_caps_of s e)\"\n  by (clarsimp simp: generalOperation_def direct_caps_of_def split:option.splits)\n\nlemma direct_caps_of_generalOp2:\n  \"\\<lbrakk>c' \\<in> direct_caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x\\<rbrakk> \\<Longrightarrow>\n   c' \\<in> direct_caps_of s x \\<or> (c' \\<in>cap {c} \\<and> x = e\\<^sub>1)\"\n  apply (clarsimp simp: direct_caps_of_generalOp extra_rights_diminish\n           split:if_split_asm)\n  apply (drule extra_rights_diminish)\n  by simp\n\nlemma store_connected_direct_generalOp:\n  \"\\<lbrakk>(x, y) \\<in> store_connected_direct (generalOperation e\\<^sub>0 e\\<^sub>1 c r s)\\<rbrakk> \\<Longrightarrow>\n   (x, y) \\<in> store_connected_direct s \\<or>\n   (x = e\\<^sub>1 \\<and> y = target c \\<and> Store \\<in> rights (extra_rights c))\"\n  by (auto simp: store_connected_direct_def direct_caps_of_generalOp all_rights_def\n          split: if_split_asm)\n\nlemma store_connected_generalOp:\n  \"\\<lbrakk>(x, y) \\<in> store_connected (generalOperation e\\<^sub>0 e\\<^sub>1 c r s)\\<rbrakk> \\<Longrightarrow>\n   (x, y) \\<in> store_connected s \\<or>\n   ((x, e\\<^sub>1) \\<in> store_connected s \\<and>\n   (e\\<^sub>1, target c) \\<in> store_connected_direct (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) \\<and>\n   (target c, y) \\<in> store_connected s)\"\n  apply (unfold store_connected_def)\n  apply (erule rtrancl_induct)\n   apply clarsimp\n  apply (clarsimp)\n  apply (fold store_connected_def)\n  apply (subgoal_tac \"(y, z) \\<in> store_connected_direct s\")\n   apply (clarsimp simp: store_connected_def)\n   apply (erule disjE)\n    apply fastforce\n   apply clarsimp\n   apply (erule notE)\n   apply fastforce\n  apply (frule store_connected_direct_generalOp)\n  apply (clarsimp simp: store_connected_def)\n  done\n\n\nlemma store_connected_generalOp_not_new:\n  \"\\<lbrakk>(e\\<^sub>1, target c) \\<in> store_connected_direct (generalOperation e\\<^sub>0 e\\<^sub>1 c r s);\n   c \\<in> caps_of s e\\<^sub>0\\<rbrakk> \\<Longrightarrow>\n   (e\\<^sub>1, target c) \\<in> store_connected_direct s \\<or>\n   (e\\<^sub>0, target c) \\<in> store_connected s \\<or>\n   Create \\<in> rights c\"\n  apply (drule store_connected_direct_generalOp)\n  apply (clarsimp simp: rights_extra_rights split:if_split_asm)\n   apply (drule (1) store_caps_store_connected, simp)\n  done\n\nlemma store_connected_generalOp2:\n  \"\\<lbrakk>(x, y) \\<in> store_connected (generalOperation e\\<^sub>0 e\\<^sub>1 c r s);\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n   s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (drule store_connected_generalOp)\n  apply (erule disjE)\n   apply (simp add: tgs_connected_def)\n   apply (drule store_connected_directly_tgs_connected, simp)\n  apply clarsimp\n  apply (drule store_connected_directly_tgs_connected [where x=x and y=e\\<^sub>1])\n  apply (drule store_connected_directly_tgs_connected [where x=\"target c\" and y=y])\n  apply (drule (1) store_connected_generalOp_not_new)\n  apply (erule disjE)\n   apply (drule store_connected_direct_in_store_connected)\n   apply (drule store_connected_directly_tgs_connected [where x=e\\<^sub>1 and y=\"target c\"])\n   apply (simp add: tgs_connected_def)\n  apply (drule directly_tgs_connected_comm [where x=\"e\\<^sub>0\" and y=\"e\\<^sub>1\"])\n  apply (erule disjE)\n   apply (drule store_connected_directly_tgs_connected [where x=e\\<^sub>0 and y=\"target c\"])\n   apply (simp add: tgs_connected_def)\n  apply (drule (1) create_caps_directly_tgs_connected)\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma shares_caps_of_generalOp:\n  \"\\<lbrakk>shares_caps (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x y;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (clarsimp simp: shares_caps_def)\n  apply (frule (2) store_connected_generalOp2 [where x=x])\n  apply (drule (2) store_connected_generalOp2 [where x=y])\n  apply (drule tgs_connected_comm [where x=y])\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma caps_of_generalOp:\n  \"\\<lbrakk>c' \\<in> caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (simp add: caps_of_def[where e=x])\n  apply clarsimp\n  apply (frule (2) store_connected_generalOp2)\n  apply (drule direct_caps_of_generalOp2)\n  apply (erule disjE)\n   apply (drule direct_cap_in_cap)\n   apply (fastforce simp: cap_in_caps_def)\n  apply (subgoal_tac \"s \\<turnstile> x \\<leftrightarrow>* e\\<^sub>0\")\n   apply (subgoal_tac \"c' \\<in>cap caps_of s e\\<^sub>0\")\n    apply fastforce\n   apply (fastforce simp: cap_in_caps_def)\n  apply clarsimp\n  apply (drule directly_tgs_connected_comm [where x=\"e\\<^sub>0\" and y=\"e\\<^sub>1\"])\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma take_cap_generalOp:\n  \"\\<lbrakk>take_cap y \\<in>cap caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z.  s \\<turnstile> x \\<leftrightarrow>* z \\<and> take_cap y \\<in>cap caps_of s z\"\n  apply (simp add: cap_in_caps_def)\n  apply clarsimp\n  apply (drule (2) caps_of_generalOp)\n  apply (fastforce simp: cap_in_caps_def)\n  done\n\nlemma grant_cap_generalOp:\n  \"\\<lbrakk>grant_cap y \\<in>cap caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z.  s \\<turnstile> x \\<leftrightarrow>* z \\<and> grant_cap y \\<in>cap caps_of s z\"\n  apply (simp add: cap_in_caps_def)\n  apply clarsimp\n  apply (drule (2) caps_of_generalOp)\n  apply (fastforce simp: cap_in_caps_def)\n  done\n\nlemma take_cap_generalOp2:\n  \"\\<lbrakk>take_cap y \\<in>cap caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply (drule (2) take_cap_generalOp)\n  apply clarsimp\n  apply (subgoal_tac \"s \\<turnstile> z \\<leftrightarrow> y\")\n   apply (simp add: tgs_connected_def)\n  apply (simp add: directly_tgs_connected_def leak_def)\n  done\n\nlemma grant_cap_generalOp2:\n  \"\\<lbrakk>grant_cap y \\<in>cap caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply (drule (2) grant_cap_generalOp)\n  apply clarsimp\n  apply (subgoal_tac \"s \\<turnstile> z \\<leftrightarrow> y\")\n   apply (simp add: tgs_connected_def)\n  apply (simp add: directly_tgs_connected_def leak_def)\n  done\n\nlemma generalOp_directly_tgs_connected:\n \"\\<lbrakk>generalOperation e\\<^sub>0 e\\<^sub>1 c r s \\<turnstile> x \\<leftrightarrow> y;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (simp add: directly_tgs_connected_def [where s=\"generalOperation e\\<^sub>0 e\\<^sub>1 c r s\"] leak_def)\n  apply safe\n       apply (rule tgs_connected_comm)\n       apply (drule (3) take_cap_generalOp2)\n      apply (drule (3) grant_cap_generalOp2)\n     apply (erule (2) shares_caps_of_generalOp)\n    apply (drule (3) take_cap_generalOp2)\n   apply (rule tgs_connected_comm)\n   apply (drule (3) grant_cap_generalOp2)\n  apply (erule (2) shares_caps_of_generalOp)\n  done", "property": "General Operation Properties: The general operation ensures that the resulting state maintains connectivity and capability properties. Specifically, it preserves direct caps, store-connectedness, and shares caps relationships. Additionally, it ensures that caps and take/grant caps are properly propagated and connected in the resulting state. \n\nSubproperties:\n- Direct Caps Preservation: The general operation preserves direct caps relationships.\n- Store-Connectedness Preservation: The general operation preserves store-connectedness relationships.\n- Shares Caps Preservation: The general operation preserves shares caps relationships.\n- Caps Propagation: The general operation properly propagates caps and ensures their connectivity in the resulting state.\n- Take/Grant Caps Propagation: The general operation properly propagates take/grant caps and ensures their connectivity in the resulting state.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas about the general operation "}
{"spec": "lemma create_legal_directly_tgs_connected:\n  \"legal (SysCreate e c\\<^sub>1 c\\<^sub>2) s \\<Longrightarrow> s  \\<turnstile> target c\\<^sub>1 \\<leftrightarrow> e\"\n  apply clarsimp\n  apply (rule directly_tgs_connected_comm)\n  apply (drule (1) create_caps_directly_tgs_connected)\n  apply (drule (1) store_caps_store_connected)\n  apply (drule (1) store_connected_directly_tgs_connected)\n  done\n\nlemma take_legal_directly_tgs_connected:\n  \"legal (SysTake e c\\<^sub>1 c\\<^sub>2 r) s \\<Longrightarrow> s  \\<turnstile> target c\\<^sub>1 \\<leftrightarrow> e\"\n  apply clarsimp\n  apply (rule directly_tgs_connected_comm)\n  apply (drule (2) take_caps_directly_tgs_connected)\n  done\n\nlemma grant_legal_directly_tgs_connected:\n  \"legal (SysGrant e c\\<^sub>1 c\\<^sub>2 r) s \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\\<^sub>1\"\n  apply clarsimp\n  apply (drule (2) grant_caps_directly_tgs_connected)\n  done\n\nlemma copy_legal_directly_tgs_connected:\n  \"legal (SysCopy e c\\<^sub>1 c\\<^sub>2 r) s \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\\<^sub>1\"\n  apply clarsimp\n  apply (drule (1) store_caps_store_connected)\n  apply (drule (1) store_connected_directly_tgs_connected)\n  done\n\nlemma caps_of_create:\n  \"\\<lbrakk>c' \\<in> caps_of (createOperation e c\\<^sub>1 c\\<^sub>2 s) x; legal (SysCreate e c\\<^sub>1 c\\<^sub>2) s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (frule create_legal_directly_tgs_connected)\n  apply (clarsimp simp: create_general)\n  apply (drule caps_of_make_entity2 [rotated], clarsimp)\n  apply (drule (1) caps_of_generalOp)\n   apply (drule (2) directly_tgs_connected_comm)\n  done\n\nlemma caps_of_take:\n  \"\\<lbrakk>c' \\<in> caps_of (takeOperation e c\\<^sub>1 c\\<^sub>2 r s) x; legal (SysTake e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (frule take_legal_directly_tgs_connected)\n  apply (clarsimp simp: take_general)\n  apply (drule (2) caps_of_generalOp)\n   apply (drule (1) directly_tgs_connected_comm)\n  done\n\nlemma caps_of_grant:\n  \"\\<lbrakk>c' \\<in> caps_of (grantOperation e c\\<^sub>1 c\\<^sub>2 r s) x; legal (SysGrant e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (frule grant_legal_directly_tgs_connected)\n  apply (clarsimp simp: grant_general)\n  apply (drule (2) caps_of_generalOp)\n   apply (drule (1) directly_tgs_connected_comm)\n  done\n\nlemma caps_of_copy:\n  \"\\<lbrakk>c' \\<in> caps_of (copyOperation e c\\<^sub>1 c\\<^sub>2 r s) x; legal (SysCopy e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (frule copy_legal_directly_tgs_connected)\n  apply (clarsimp simp: copy_general)\n  apply (drule (2) caps_of_generalOp)\n   apply (drule (1) directly_tgs_connected_comm)\n  done\n\nlemma create_directly_tgs_connected:\n \"\\<lbrakk>createOperation e c\\<^sub>1 c\\<^sub>2 s \\<turnstile> x \\<leftrightarrow> y; legal (SysCreate e c\\<^sub>1 c\\<^sub>2) s\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (frule create_legal_directly_tgs_connected)\n  apply (clarsimp simp: create_general)\n  apply (drule directly_tgs_connected_make_entity2 [rotated], clarsimp)\n  apply (drule (1) generalOp_directly_tgs_connected)\n   apply (drule (2) directly_tgs_connected_comm)\n  done\n\nlemma take_directly_tgs_connected:\n \"\\<lbrakk>takeOperation e c\\<^sub>1 c\\<^sub>2 r s \\<turnstile> x \\<leftrightarrow> y; legal (SysTake e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (frule take_legal_directly_tgs_connected)\n  apply (clarsimp simp: take_general)\n  apply (drule (3) generalOp_directly_tgs_connected)\n  done\n\nlemma grant_directly_tgs_connected:\n \"\\<lbrakk>grantOperation e c\\<^sub>1 c\\<^sub>2 r s \\<turnstile> x \\<leftrightarrow> y; legal (SysGrant e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (frule grant_legal_directly_tgs_connected)\n  apply (clarsimp simp: grant_general)\n  apply (drule (3) generalOp_directly_tgs_connected)\n  done\n\nlemma copy_directly_tgs_connected:\n \"\\<lbrakk>copyOperation e c\\<^sub>1 c\\<^sub>2 r s \\<turnstile> x \\<leftrightarrow> y; legal (SysCopy e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (frule copy_legal_directly_tgs_connected)\n  apply (clarsimp simp: copy_general)\n  apply (drule (3) generalOp_directly_tgs_connected)\n  done\n\n\n\nlemma create_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysCreate e c\\<^sub>1 c\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n   apply (erule disjE, fastforce simp: tgs_connected_def, clarsimp)\n   apply (drule create_directly_tgs_connected, clarsimp, assumption)\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma take_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysTake e c\\<^sub>1 c\\<^sub>2 r)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n   apply (erule disjE, fastforce simp: tgs_connected_def, clarsimp)\n   apply (drule take_directly_tgs_connected, clarsimp, assumption)\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma grant_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysGrant e c\\<^sub>1 c\\<^sub>2 r)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n   apply (erule disjE, fastforce simp: tgs_connected_def, clarsimp)\n   apply (drule grant_directly_tgs_connected, clarsimp, assumption)\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma copy_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysCopy e c\\<^sub>1 c\\<^sub>2 r)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n   apply (erule disjE, fastforce simp: tgs_connected_def, clarsimp)\n   apply (drule copy_directly_tgs_connected, clarsimp, assumption)\n  apply (simp add: tgs_connected_def)\n  done", "property": "General Operation Results: Ensure that the results of general operations (create, take, grant, copy) maintain the integrity of the system's connectivity and capability management. Specifically, the lemmas guarantee that the directly connected entities in the resulting state are also connected in the original state, and that the capabilities of the resulting state are derived from the original state.\n\nSubproperties:\n- Create Operation Results: The create operation maintains the connectivity and capability management integrity.\n- Take Operation Results: The take operation maintains the connectivity and capability management integrity.\n- Grant Operation Results: The grant operation maintains the connectivity and capability management integrity.\n- Copy Operation Results: The copy operation maintains the connectivity and capability management integrity.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " results from general operation "}
{"spec": "lemma direct_caps_of_destroy:\n  \"c \\<in> direct_caps_of (s(e := None)) x \\<Longrightarrow> c \\<in> direct_caps_of s x\"\n  by (simp add: direct_caps_of_def split: option.splits split: if_split_asm)\n\nlemma store_connected_destroy:\n \"(x, y) \\<in> store_connected (s(e := None)) \\<Longrightarrow> (x, y) \\<in> store_connected s\"\n  apply (simp add: store_connected_def)\n  apply (erule rtrancl_induct)\n   apply simp\n  apply (fold store_connected_def)\n  apply (subgoal_tac \"(y,z) \\<in> store_connected_direct s\")\n   apply (fastforce simp: store_connected_def)\n  apply (simp add: store_connected_direct_def)\n  apply clarsimp\n  by (metis direct_caps_of_destroy)\n\nlemma shares_caps_destroy:\n  \"shares_caps (destroyOperation e c s) x y\n  \\<Longrightarrow> shares_caps s x y\"\n  apply (clarsimp simp: shares_caps_def destroyOperation_def)\n  apply (frule store_connected_destroy [where x=x])\n  apply (drule store_connected_destroy [where x=y])\n  by auto\n\nlemma caps_of_destroy:\n  \"c \\<in> caps_of (destroyOperation e' c' s) e \\<Longrightarrow>\n  c \\<in> caps_of s e\"\n  apply (clarsimp simp add: destroyOperation_def caps_of_def)\n  apply (rule_tac x=x in exI)\n  apply (drule direct_caps_of_destroy)\n  apply simp\n  apply (erule store_connected_destroy)\n  done\n\nlemma destroy_directly_tgs_connected:\n  \"\\<lbrakk>s' \\<in> step (SysDestroy e c) s; (x, y) \\<in> directly_tgs_connected s'\\<rbrakk> \\<Longrightarrow>\n  (x, y) \\<in> directly_tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n  apply(erule disjE, simp)\n  apply(simp add: directly_tgs_connected_def leak_def)\n  apply (erule disjE)\n   apply(fastforce simp add: cap_in_caps_def dest!: caps_of_destroy)\n  apply (erule disjE)\n   apply(fastforce simp add: cap_in_caps_def dest!: caps_of_destroy)\n  apply (erule disjE)\n   apply (drule shares_caps_destroy, simp)\n  apply (erule disjE)\n   apply(fastforce simp add: cap_in_caps_def dest!: caps_of_destroy)\n  apply (erule disjE)\n   apply(fastforce simp add: cap_in_caps_def dest!: caps_of_destroy)\n  apply (drule shares_caps_destroy, simp)\n  done\n\nlemma destroy_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysDestroy e c)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in>  directly_tgs_connected s\"\n  by(auto dest!: destroy_directly_tgs_connected)", "property": "Destroy Operation Properties: \nThe destroy operation preserves existing capability relationships and does not introduce new ones. Specifically, if a capability is present after destruction, it was also present before destruction. Similarly, if two entities are connected after destruction, they were also connected before destruction. The destroy operation does not create new capability connections. \n\nSubproperties:\n- Direct Capability Preservation: A capability directly associated with an entity after destruction was also associated with it before destruction.\n- Store Connected Preservation: If two entities are connected through the store after destruction, they were also connected before destruction.\n- Capability Sharing Preservation: If two entities share a capability after destruction, they also shared it before destruction.\n- Capability Relationship Preservation: The destroy operation preserves existing capability relationships, including direct and indirect connections between entities.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas about destroy "}
{"spec": "lemma direct_caps_of_remove:\n  \"c \\<in> direct_caps_of (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x \\<Longrightarrow>\n  c \\<in> direct_caps_of s x\"\n  by (clarsimp simp: removeOperation_simpler direct_caps_of_def\n              split: option.splits if_split_asm)\n\nlemma direct_caps_of_remove_eq:\n  \"direct_caps_of (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x =\n  ( if   is_entity s (target c\\<^sub>1) \\<and> x = target c\\<^sub>1\n   then  direct_caps_of s (target c\\<^sub>1) - {c\\<^sub>2}\n   else  direct_caps_of s x )\"\n  by(simp add: direct_caps_of_def is_entity_def removeOperation_def)\n\nlemma store_connected_remove [rule_format]:\n  \"(x, y) \\<in> store_connected (s(e \\<mapsto> Entity C')) \\<Longrightarrow>\n  s e = Some (Entity C) \\<longrightarrow> C' \\<subseteq> C \\<longrightarrow> (x, y) \\<in> store_connected s\"\n  apply (unfold store_connected_def)\n  apply (erule rtrancl_induct)\n   apply simp\n  apply clarsimp\n  apply (subgoal_tac \"(y,z) \\<in> store_connected_direct s\")\n   apply (erule rtrancl_trans)\n   apply fastforce\n  apply (fold store_connected_def)\n  apply (clarsimp simp add: store_connected_direct_def)\n  apply (fastforce simp: direct_caps_of_def\n                  split: option.splits if_split_asm)\n  done\n\nlemma caps_of_remove:\n  \"c \\<in> caps_of (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x \\<Longrightarrow>\n  c \\<in> caps_of s x\"\n  apply (clarsimp simp: caps_of_def)\n  apply (rule_tac x=xa in exI)\n  apply (drule direct_caps_of_remove)\n  apply (simp add: removeOperation_simpler\n            split: option.splits)\n  apply (erule (1) store_connected_remove)\n  apply blast\n  done", "property": "Remove Operation Properties: \nThe \"removeOperation\" does not introduce new capabilities, and any capability present after removal was also present before removal. \nDirect capabilities after removal are either unchanged or have a specific capability removed from the target entity. \nConnected capabilities in the store after removal were also connected before removal if the updated entity's new capabilities are a subset of its original capabilities.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " lemmas about remove "}
{"spec": "lemma caps_of_remove2:\n  \"caps_of (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x \\<subseteq> caps_of s x\"\n  apply(simp add: caps_of_def is_entity_def removeOperation_def direct_caps_of_def)\n  apply (clarsimp split: if_split_asm)\n   apply (auto dest!: store_connected_remove)\n  done\n\nlemma shares_caps_remove:\n  \"shares_caps (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x y\n  \\<Longrightarrow> shares_caps s x y\"\n  apply (clarsimp simp: shares_caps_def removeOperation_simpler\n                 split:option.splits)\n  apply (frule (1) store_connected_remove [where x=x], clarsimp)\n  apply (drule (1) store_connected_remove [where x=y], clarsimp)\n  by auto\n\nlemma remove_directly_tgs_connected:\n  \"\\<lbrakk>s' \\<in> step (SysRemove e c\\<^sub>1 c\\<^sub>2) s; (x, y) \\<in> directly_tgs_connected s'\\<rbrakk> \\<Longrightarrow>\n  (x, y) \\<in> directly_tgs_connected s\"\n  apply(simp add: step_def split: if_split_asm)\n  apply(erule disjE, simp)\n  apply(simp add: directly_tgs_connected_def leak_def)\n  apply(simp add: cap_in_caps_def)\n  apply(clarsimp)\n  apply safe\n     prefer 3\n     apply (drule shares_caps_remove, simp)\n    prefer 5\n    apply (drule shares_caps_remove, simp)\n   apply(auto dest!: caps_of_remove)\n  done\n\nlemma remove_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysRemove e c\\<^sub>1 c\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in>  directly_tgs_connected s\"\n  by(auto dest!: remove_directly_tgs_connected)\n\nlemma direct_caps_of_removeSet:\n  \"c' \\<in> direct_caps_of (removeSetOperation e c C s) x \\<Longrightarrow>\n  c' \\<in> direct_caps_of s x\"\n  by (clarsimp simp: removeSetOperation_simpler direct_caps_of_def\n              split: option.splits if_split_asm)\n\nlemma caps_of_removeSet:\n  \"c' \\<in> caps_of (removeSetOperation e c C s) x \\<Longrightarrow>\n  c' \\<in> caps_of s x\"\n  apply (clarsimp simp: caps_of_def)\n  apply (rule_tac x=xa in exI)\n  apply (drule direct_caps_of_removeSet)\n  apply (simp add: removeSetOperation_simpler split: option.splits)\n  apply (erule (1) store_connected_remove)\n  apply blast\n  done\n\nlemma shares_caps_removeSet:\n  \"shares_caps (removeSetOperation e c C s) x y\n  \\<Longrightarrow> shares_caps s x y\"\n  apply (clarsimp simp: shares_caps_def removeSetOperation_simpler split:option.splits)\n  apply (frule (1) store_connected_remove [where x=x], clarsimp)\n  apply (drule (1) store_connected_remove [where x=y], clarsimp)\n  by auto\n\nlemma removeSet_connected:\n  \" \\<lbrakk>s' \\<in> step (SysRemoveSet e c C) s; s' \\<turnstile> x \\<leftrightarrow> y\\<rbrakk> \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y\"\n  apply(simp add: step_def split: if_split_asm)\n  apply(erule disjE, simp)\n  apply(simp add: directly_tgs_connected_def leak_def)\n  apply(simp add: cap_in_caps_def)\n  apply(clarsimp)\n  apply safe\n     prefer 3\n     apply (drule shares_caps_removeSet, simp)\n    prefer 5\n    apply (drule shares_caps_removeSet, simp)\n   apply (auto dest!: caps_of_removeSet)\n  done\n\nlemma removeSet_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; s' \\<turnstile> x \\<leftrightarrow> y; cmd = (SysRemoveSet n c C)\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y\"\n  by(auto dest!: removeSet_connected)", "property": "Remove Operation Properties: The remove operation ensures that the resulting state does not introduce new capabilities or connections between entities. Specifically, the capabilities of an entity after removal are a subset of its original capabilities, and any shared capabilities or connections between entities in the resulting state were already present in the original state.\n\nSubproperties:\n- Capability Subset: The capabilities of an entity after removal are a subset of its original capabilities.\n- Shared Capabilities Preservation: If two entities share a capability in the resulting state, they also shared it in the original state.\n- Connection Preservation: If two entities are connected in the resulting state, they were also connected in the original state.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Might equal either  \"caps s (target c\\<^sub>1) - {c\\<^sub>2}\" or \"caps s x\" depending if the caps are duplicated."}
{"spec": "lemma direct_caps_of_removeSetOfCaps:\n  \"c' \\<in> direct_caps_of (removeSetOfCaps cap_map s) x \\<Longrightarrow>\n  c' \\<in> direct_caps_of s x\"\n  by (clarsimp simp: removeSetOfCaps_def direct_caps_of_def\n              split: option.splits if_split_asm)\nthm store_connected_remove\n\nlemma store_connected_removeSetOfCaps:\n  \"(x, y) \\<in> store_connected (\\<lambda>e. if is_entity s e\n                                 then Some (Entity (direct_caps_of s e - cap_map e))\n                                 else None) \\<Longrightarrow>\n    (x, y) \\<in> store_connected s\"\n  apply (unfold store_connected_def)\n  apply (erule rtrancl_induct)\n   apply simp\n  apply (subgoal_tac \"(y,z) \\<in> store_connected_direct s\")\n   apply (erule rtrancl_trans)\n   apply fastforce\n  apply (fold store_connected_def)\n  apply (clarsimp simp add: store_connected_direct_def)\n  apply (fastforce simp: direct_caps_of_def\n                  split: option.splits if_split_asm)\n  done\n\nlemma caps_of_removeSetOfCaps:\n  \"c' \\<in> caps_of (removeSetOfCaps cap_map s) x \\<Longrightarrow>\n  c' \\<in> caps_of s x\"\n  apply (clarsimp simp: caps_of_def)\n  apply (rule_tac x=xa in exI)\n  apply (drule direct_caps_of_removeSetOfCaps)\n  apply (simp add: removeSetOfCaps_def split: option.splits)\n  apply (erule store_connected_removeSetOfCaps)\n  done\n\nlemma caps_of_revoke:\n  \"\\<lbrakk>s' \\<in> revokeOperation sub c\\<^sub>1 s ;  c \\<in> caps_of s' e \\<rbrakk>\n  \\<Longrightarrow> c \\<in> caps_of s e\"\n  apply (clarsimp simp: revokeOperation_def\n                 split: if_split_asm)\n  apply (drule (1) caps_of_removeSetOfCaps)\n  done\n\nlemma direct_caps_of_revoke:\n  \"\\<lbrakk>s' \\<in> revokeOperation e c s; c' \\<in> direct_caps_of s' x\\<rbrakk>\n   \\<Longrightarrow> c' \\<in> direct_caps_of s x\"\n  apply (clarsimp simp: revokeOperation_def\n                 split: if_split_asm)\n  apply (drule (1) direct_caps_of_removeSetOfCaps)\n  done\n\nlemma store_connected_revoke:\n \"\\<lbrakk>(x, y) \\<in> store_connected s'; s' \\<in> revokeOperation e c s\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> store_connected s\"\n  apply (simp add: store_connected_def)\n  apply (erule rtrancl_induct)\n   apply simp\n  apply (fold store_connected_def)\n  apply (subgoal_tac \"(y,z) \\<in> store_connected_direct s\")\n   apply (fastforce simp: store_connected_def)\n  apply (clarsimp simp: store_connected_direct_def)\n  apply (metis direct_caps_of_revoke)\n  done\n\nlemma shares_caps_revoke:\n  \"\\<lbrakk>shares_caps s' x y; s' \\<in> revokeOperation e c s\\<rbrakk>\n  \\<Longrightarrow> shares_caps s x y\"\n  apply (clarsimp simp: shares_caps_def)\n  apply (frule (1) store_connected_revoke [where x=x])\n  apply (drule (1) store_connected_revoke [where x=y])\n  by auto\n\nlemma removeOperation_entity_ids [simp]:\n  \"is_entity (removeOperation e c c' s) e' = is_entity s e'\"\n  by (simp add: is_entity_def removeOperation_def)\n\nlemma removeSetOfCaps_entity_ids [simp]:\n  \"is_entity (removeSetOfCaps cap_map s) e' = is_entity s e'\"\n  by (simp add: is_entity_def removeSetOfCaps_def)\n\nlemma revoke_entities:\n  \"s' \\<in> revokeOperation sub c\\<^sub>1 s \\<Longrightarrow> is_entity s' e = is_entity s e\"\n  by (clarsimp simp: revokeOperation_def split: if_split_asm)\n\nlemma revoke_directly_tgs_connected:\n  \"\\<lbrakk>s' \\<in> step (SysRevoke n c\\<^sub>1) s; (x, y) \\<in> directly_tgs_connected s'\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in>  directly_tgs_connected s\"\n  apply (simp add: step_def split: if_split_asm)\n  apply (erule disjE, simp)\n  apply (simp add: directly_tgs_connected_def leak_def)\n  apply (erule disjE)\n   apply(auto simp add: cap_in_caps_def dest!: caps_of_revoke)[1]\n  apply (erule disjE)\n   apply(auto simp add: cap_in_caps_def dest!: caps_of_revoke)[1]\n  apply (erule disjE)\n   apply (drule (1) shares_caps_revoke, simp)\n  apply (erule disjE)\n   apply(auto simp add: cap_in_caps_def dest!: caps_of_revoke)[1]\n  apply (erule disjE)\n   apply(auto simp add: cap_in_caps_def dest!: caps_of_revoke)[1]\n  apply (drule (1) shares_caps_revoke, simp)\n  done\n\nlemma revoke_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysRevoke n c\\<^sub>1)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in>  directly_tgs_connected s\"\n  by(auto dest!: revoke_directly_tgs_connected)", "property": "Revoke Operation Properties: The revoke operation preserves existing capabilities, direct capabilities, and store connections. Specifically, if a capability exists in the state after a revoke operation, it also existed in the original state. Similarly, direct capabilities and store connections are preserved across revoke operations. Additionally, entity identities and shares are also preserved. The revoke operation does not introduce new capabilities or connections.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " lemmas about revoke "}
{"spec": "lemma is_entity_grant [simp]:\n  \"is_entity s (target c\\<^sub>1) \\<Longrightarrow>\n  is_entity (grantOperation e c\\<^sub>1 c\\<^sub>2 r s) e' = is_entity s e'\"\n  by (simp add: is_entity_def grantOperation_def)\n\nlemma is_entity_destroy:\n  \"is_entity (destroyOperation e' c s) e \\<Longrightarrow> is_entity s e\"\n  by (simp add: destroyOperation_def is_entity_def split: if_split_asm)", "property": "Entity Properties: The \"is_entity\" property of an entity remains unchanged after a grant operation. If an entity exists after a destroy operation, it must have existed before the operation.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " lemmas about grant "}
{"spec": "lemma connected_tgs_connected:\n  \"\\<lbrakk>s' \\<in> step cmd s; (e\\<^sub>x, e\\<^sub>y) \\<in> directly_tgs_connected s'\\<rbrakk> \\<Longrightarrow>\n  (e\\<^sub>x, e\\<^sub>y) \\<in> tgs_connected s\"\n  apply(case_tac \"(e\\<^sub>x, e\\<^sub>y) \\<in> directly_tgs_connected s\")\n   apply(simp add: tgs_connected_def)\n   apply(case_tac cmd)\n         apply(rule create_conTrans, fastforce+)\n        apply(rule take_conTrans, fastforce+)\n       apply(rule grant_conTrans, fastforce+)\n      apply(frule copy_conTrans, fastforce+)\n     apply(frule remove_conTrans, fastforce+)\n    apply(frule removeSet_conTrans, fastforce+)\n   apply(frule revoke_conTrans, fastforce+)\n  apply(frule destroy_conTrans, fastforce+)\n  done\n\nlemma tgs_connected_preserved_step:\n  \"\\<lbrakk>s' \\<in> step cmd s; s' \\<turnstile> x \\<leftrightarrow>* z\\<rbrakk> \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* z\"\n  thm rtrancl_induct [where r=\"directly_tgs_connected s'\" and a=x and b=z and P=\"\\<lambda>z. (x, z) \\<in> (directly_tgs_connected s)\\<^sup>*\", simplified,\n                      simplified tgs_connected_def [symmetric]]\n  apply(erule rtrancl_induct [where r=\"directly_tgs_connected s'\",\n                              simplified tgs_connected_def [symmetric]], simp)\n  apply(case_tac \"s \\<turnstile> y \\<leftrightarrow>* z\")\n   apply (erule (1) tgs_connected_trans)\n  apply (simp add: connected_tgs_connected)\n  done\n\nlemma leakImplyConnected:\n  \"leak s\\<^sub>i e\\<^sub>x e\\<^sub>i \\<Longrightarrow> (e\\<^sub>x, e\\<^sub>i) \\<in> directly_tgs_connected s\\<^sub>i\"\n by(simp add: directly_tgs_connected_def)\n\nlemma leakImplyConnectedTrans:\n  \"leak s\\<^sub>i e\\<^sub>x e\\<^sub>i \\<Longrightarrow> (e\\<^sub>x, e\\<^sub>i) \\<in> tgs_connected s\\<^sub>i\"\n  by(simp add: tgs_connected_def, frule leakImplyConnected, auto)\n\n\nlemma tgs_connected_preserved [rule_format]:\n  \"\\<forall>s'. s' \\<in> execute cmds s \\<longrightarrow>\n    s' \\<turnstile> x \\<leftrightarrow>* y \\<longrightarrow>\n    s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply(induct_tac cmds, simp)\n  apply clarsimp\n  apply(rename_tac cmd cmds s'' s')\n  apply(erule_tac x=s' in allE)\n  apply(simp add: tgs_connected_preserved_step)\n  done\n\nlemma leak_conTrans [rule_format]:\n  \"\\<lbrakk>s \\<in> execute cmds s\\<^sub>0; leak s x y\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\\<^sub>0\"\n  by (auto intro: leakImplyConnectedTrans tgs_connected_preserved)\n\nlemma leakage_rule:\n  \"\\<lbrakk>s' \\<in> execute cmds s; \\<not> s \\<turnstile> x \\<leftrightarrow>* y\\<rbrakk> \\<Longrightarrow> \\<not> (s' \\<turnstile> x \\<rightarrow> y)\"\n  by(auto simp add: leak_conTrans)", "property": "Transitive Connection Preservation: The transitive connection between entities is preserved across system execution, ensuring that if two entities are connected after a series of commands, they were also connected initially.\n\nSubproperties:\n- Direct Connection Preservation: Direct connections between entities are preserved across single execution steps.\n- Transitive Connection Stability: Transitive connections are stable across system execution, meaning that if a transitive connection exists after execution, it also existed before.\n- Leakage Implies Connection: Information leakage between entities implies a direct or transitive connection between them.\n- Connection Preservation Across Execution: Transitive connections are preserved across the execution of multiple commands, ensuring that initial connections are maintained throughout system execution.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": "*******************************************\n ********************************************\n ***** Connected transitively preserved *****\n ********************************************\n *******************************************"}
{"spec": "lemma caps_of_op:\n  \"\\<lbrakk>s' \\<in> step cmd s; c' \\<in> caps_of s' x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. s \\<turnstile> x \\<leftrightarrow>* z \\<and> c' \\<in>cap caps_of s z\"\n  apply (simp add: step_def split:if_split_asm)\n   prefer 2\n   apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n  apply (erule disjE)\n   apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n  apply (case_tac cmd)\n         apply (simp add: caps_of_create)\n        apply (simp add: caps_of_take)\n       apply (simp add: caps_of_grant)\n      apply (simp add: caps_of_copy)\n     apply (clarsimp, drule caps_of_remove)\n     apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n    apply (clarsimp, drule caps_of_removeSet)\n    apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n   apply (clarsimp, drule (1) caps_of_revoke)\n   apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n  apply (clarsimp, drule caps_of_destroy)\n  apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n  done\n\nlemma authority_confinement_induct_step:\n  \"\\<lbrakk>s' \\<in> step cmd s;\n    \\<forall>e\\<^sub>i. s \\<turnstile> e\\<^sub>x \\<leftrightarrow>* e\\<^sub>i \\<longrightarrow> caps_of s e\\<^sub>i \\<le>cap c\\<rbrakk>\n  \\<Longrightarrow> caps_of s' e\\<^sub>x \\<le>cap c\"\n  apply (clarsimp simp: caps_dominated_by_def)\n  apply (drule (1) caps_of_op)\n  apply (fastforce simp: cap_in_caps_def)\n  done\n\nlemma authority_confinement_helper:\n  \"s' \\<in> execute cmds s \\<longrightarrow>\n   (\\<forall>e\\<^sub>i. s \\<turnstile> e\\<^sub>x \\<leftrightarrow>* e\\<^sub>i \\<longrightarrow> caps_of s e\\<^sub>i \\<le>cap c) \\<longrightarrow>\n   (\\<forall>e\\<^sub>i. s' \\<turnstile> e\\<^sub>x \\<leftrightarrow>* e\\<^sub>i \\<longrightarrow> caps_of s' e\\<^sub>i \\<le>cap c)\"\nproof (induct cmds arbitrary: s')\ncase Nil\n  show ?case by clarsimp\nnext\ncase (Cons cmd cmds s')\nshow ?case\n  apply clarsimp\n  apply (rule authority_confinement_induct_step, assumption)\n  apply clarsimp\n  apply (rule Cons.hyps[rule_format], simp_all)\n  apply (drule(1) tgs_connected_preserved_step)\n  apply (simp add: tgs_connected_def)\n  done\nqed\n\nlemma authority_confinement:\n  \"\\<lbrakk>s' \\<in> execute cmds s;\n    \\<forall>e\\<^sub>i. s \\<turnstile> e\\<^sub>x \\<leftrightarrow>* e\\<^sub>i \\<longrightarrow> caps_of s e\\<^sub>i \\<le>cap c\\<rbrakk>\n  \\<Longrightarrow> caps_of s' e\\<^sub>x \\<le>cap c\"\n  by (erule authority_confinement_helper [rule_format, where e\\<^sub>x=e\\<^sub>x], simp_all)\n\nend", "property": "Authority Confinement: The capabilities of an entity are confined to a specific set, ensuring that the entity cannot exceed its assigned authority. \n\nSubproperties:\n- Capability Domination: The capabilities of an entity are dominated by a specific capability, meaning that the entity's capabilities are a subset of the dominating capability.\n- Capability Preservation: The capabilities of an entity are preserved across system execution, ensuring that the entity's authority is not escalated or diminished.\n- Connected Entity Preservation: The connected entities of a subject are preserved across system execution, maintaining the subject's authority and ensuring that its capabilities are not transferred to unauthorized entities.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": "******************************************\n *******************************************\n *****      Authority confinement     *****\n *******************************************\n ******************************************"}
{"spec": "(* Title:   System_S\n * Description: High-level security model of the kernel.\n *)", "property": "System Security Model: Provides a high-level security model for the kernel, ensuring the protection and integrity of system resources and data.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym entity_id = word32 (* kernel objects - identified by a UID *)\n\ndatatype\n  right = Read      (* Authorise reading of information *)\n         | Write    (* Authorise writing of information *)\n         | Take     (* Having sufficient authority to take a capability from another entity *)\n         | Grant    (* Having sufficient authority to propagate a capability to another entity *)\n         | Create   (* Confers the authority to create new entities *)\n         | Store    (* Simulates CNodeCap - get caps of said entity *)\n\nrecord cap =\n  target :: entity_id      (* The entity over which it has control *)\n  rights :: \"right set\"    (* The control it has over that entity  *)\n\ndatatype entity = Entity \"cap set\"\ndeclare entity.splits [split]\n\ntype_synonym state = \"entity_id \\<Rightarrow> entity option\"\n\ntype_synonym modify_state   = \"state \\<Rightarrow> state\"\ntype_synonym modify_state_n = \"state \\<Rightarrow> state set\"\ntype_synonym mask = \"right set\"\n\ndefinition\n  null_entity :: \"entity\" where\n  \"null_entity \\<equiv> Entity {}\"\n\ndefinition\n  all_rights :: \"right set\" where\n  \"all_rights \\<equiv> UNIV\"\n\nlemma all_rights_def2:\n  \"all_rights = {Read, Write, Take, Grant, Create, Store}\"\n  apply (clarsimp simp: all_rights_def, rule, simp_all, rule, simp)\n  apply (metis right.exhaust)\n  done\n\ndefinition\n  entity_ids :: \"state \\<Rightarrow> entity_id set\" where\n  \"entity_ids s \\<equiv> dom s\"\n\ndefinition\n  is_entity :: \"state \\<Rightarrow> entity_id \\<Rightarrow> bool\" where\n  \"is_entity s e \\<equiv> s e \\<noteq> None\"\n\ndefinition\n  exist :: \"state \\<Rightarrow> cap \\<Rightarrow> bool\" where\n  \"exist s c \\<equiv> is_entity s (target c)\"", "property": "System Entities: The system consists of entities, each identified by a unique 32-bit entity ID and represented as a set of capabilities. Each capability has a target entity ID and a set of rights (Read, Write, Take, Grant, Create, Store) that define the control it has over the target entity. The system state is a mapping from entity IDs to entities, and various functions are defined to manipulate and query the state, including checking entity existence and capability existence.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " System entities: Definition of entities that constitute the system\n "}
{"spec": "definition\n  direct_caps :: \"entity \\<Rightarrow> cap set\"\nwhere\n  \"direct_caps e \\<equiv> case e of (Entity c) \\<Rightarrow> c\"\n\ndefinition\n  direct_caps_of :: \"state \\<Rightarrow> entity_id \\<Rightarrow> cap set\"\nwhere\n  \"direct_caps_of s p \\<equiv>\n  case s p of\n    None \\<Rightarrow> {}\n  | Some (Entity e) \\<Rightarrow> e\"\n\ndefinition\n  store_connected_direct :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"store_connected_direct s \\<equiv> {(e\\<^sub>x, e\\<^sub>y). \\<exists>cap. cap \\<in> direct_caps_of s e\\<^sub>x \\<and>\n                                               Store \\<in> rights cap \\<and>\n                                               target cap = e\\<^sub>y}\"\n\ndefinition\n  store_connected :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"store_connected s \\<equiv> (store_connected_direct s)^*\"\n\ndefinition", "property": "Entity Manipulation: Manage the relationships and capabilities of entities in the system, including direct capabilities, connections between entities based on store rights, and transitive connections. \n\nDirect Capabilities: Define the set of direct capabilities associated with an entity.\n\nDirect Capabilities of an Entity: Retrieve the set of direct capabilities associated with an entity in a given state.\n\nStore Connected Entities (Direct): Identify pairs of entities connected by a direct store capability, where one entity has store rights to the other.\n\nStore Connected Entities (Transitive): Determine the transitive closure of store-connected entities, capturing indirect connections through multiple store capabilities.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Manipulating entities. "}
{"spec": "caps_of :: \"state \\<Rightarrow> entity_id \\<Rightarrow> cap set\" where\n  \"caps_of s e  \\<equiv> \\<Union>(direct_caps_of s ` {e' . (e,e') \\<in> store_connected s})\"\n\nlemma caps_rel:\n  \"caps_of s e = \\<Union>(direct_caps_of s ` store_connected s `` {e})\"\n  by (simp add: caps_of_def Image_def)\n\ndefinition  (* All the different capabilities of the system *)\n  all_caps_of :: \"state \\<Rightarrow> cap set\" where\n  \"all_caps_of s \\<equiv> \\<Union>e. direct_caps_of s e\"\n\ndefinition\n  read_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"read_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Read}\\<rparr>\"\n\ndefinition\n  write_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"write_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Write}\\<rparr>\"\n\ndefinition\n  take_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"take_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Take}\\<rparr>\"\n\ndefinition\n  grant_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"grant_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Grant}\\<rparr>\"\n\ndefinition\n  create_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"create_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Create}\\<rparr>\"\n\ndefinition\n  store_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"store_cap e \\<equiv> \\<lparr>target = e, rights = {Store}\\<rparr>\"\n\ndefinition\n  full_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"full_cap e \\<equiv> \\<lparr>target = e, rights = all_rights \\<rparr>\"", "property": "Capability Access and Definition: Returns all capabilities an entity has access to, including direct and indirect capabilities via store connections, and defines various capability types (read, write, take, grant, create, store, and full) with specific rights. \n\nSubproperties:\n- Direct Capability Access: Retrieves the capabilities directly associated with an entity.\n- Indirect Capability Access: Retrieves the capabilities accessible via store connections.\n- Capability Types: Defines the different types of capabilities (read, write, take, grant, create, store, and full) with distinct rights.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " returns all capabilities an entity has access to\n    (via store or directly) "}
{"spec": "datatype sysOPs =\n    SysCreate entity_id cap cap\n  | SysTake   entity_id cap cap mask\n  | SysGrant  entity_id cap cap mask\n  | SysCopy   entity_id cap cap mask\n  | SysRemove entity_id cap cap\n  | SysRemoveSet entity_id cap \"cap set\"\n  | SysRevoke entity_id cap\n  | SysDestroy entity_id cap", "property": "System Operations: Provides primitive kernel operations for managing entities and capabilities, including creating, taking, granting, copying, removing, revoking, and destroying entities and capabilities. \n\nSubproperties:\n- Entity Creation: Create a new entity with specified capabilities.\n- Capability Management: Perform various operations on capabilities, such as taking, granting, copying, and removing.\n- Entity Destruction: Destroy an entity and its associated capabilities.\n- Capability Revocation: Revoke a capability from an entity.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " System operations: primitive kernel operations "}
{"spec": "primrec\n  legal :: \"sysOPs \\<Rightarrow> state \\<Rightarrow> bool\"\nwhere\n  \"legal (SysCreate e c\\<^sub>1 c\\<^sub>2) s = (is_entity s e \\<and> is_entity s (target c\\<^sub>1) \\<and> \\<not> (is_entity s (target c\\<^sub>2)) \\<and>\n                                   {c\\<^sub>1, c\\<^sub>2} \\<subseteq> caps_of s e \\<and>\n                                   Write \\<in> rights c\\<^sub>1 \\<and> Store \\<in> rights c\\<^sub>1 \\<and> Create \\<in> rights c\\<^sub>2)\"\n\n| \"legal (SysTake  e c\\<^sub>1 c\\<^sub>2 r) s = (is_entity s e \\<and>  is_entity s (target c\\<^sub>1) \\<and>\n                                  c\\<^sub>1 \\<in> caps_of s e \\<and> c\\<^sub>2 \\<in> caps_of s (target c\\<^sub>1) \\<and> Take \\<in> rights c\\<^sub>1)\"\n\n| \"legal (SysGrant e c\\<^sub>1 c\\<^sub>2 r) s = (is_entity s e \\<and>  is_entity s (target c\\<^sub>1) \\<and>\n                                  {c\\<^sub>1,c\\<^sub>2} \\<subseteq> caps_of s e \\<and> Grant \\<in> rights c\\<^sub>1)\"\n\n| \"legal (SysCopy  e c\\<^sub>1 c\\<^sub>2 r) s   = (is_entity s e \\<and>  is_entity s (target c\\<^sub>1) \\<and>\n                                  {c\\<^sub>1,c\\<^sub>2} \\<subseteq> caps_of s e \\<and> Store \\<in> rights c\\<^sub>1)\"\n\n| \"legal (SysRemove e c\\<^sub>1 c\\<^sub>2) s = (is_entity s e \\<and> c\\<^sub>1 \\<in> caps_of s e)\"\n\n| \"legal (SysRemoveSet e c C) s = (is_entity s e \\<and> c \\<in> caps_of s e)\"\n\n| \"legal (SysRevoke e c) s = (is_entity s e \\<and> c \\<in> caps_of s e)\"\n\n| \"legal (SysDestroy e c) s = (is_entity s e \\<and> c \\<in> caps_of s e \\<and> {Create} = rights c \\<and>\n                              target c \\<notin> target ` (all_caps_of s - {c}))\"", "property": "Operation Legality: Determine if an operation is allowed in the given state by checking the existence of entities, capability ownership, and sufficient rights.\n\nSubproperties:\n- Entity existence and capability ownership are verified for all operations.\n- Specific rights are required for each operation, such as Write, Store, and Create for SysCreate, Take for SysTake, Grant for SysGrant, and Store for SysCopy.\n- SysDestroy requires the capability to have only the Create right and the target not to be referenced by other capabilities.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " determine if an operation is allowed in the given state_s "}
{"spec": "definition\n  diminish :: \"right set \\<Rightarrow> cap \\<Rightarrow> cap\" where\n  \"diminish R cap \\<equiv> cap \\<lparr> rights := rights cap \\<inter> R \\<rparr>\"\n\ndefinition\n  createOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> modify_state\" where\n  \"createOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity (insert (full_cap (target c\\<^sub>2))\n                                (direct_caps_of s (target c\\<^sub>1))),\n     target c\\<^sub>2 \\<mapsto> null_entity)\"\n\nlemma createOperation_def2:\n  \"createOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  let new_cap = \\<lparr> target = target c\\<^sub>2, rights = all_rights \\<rparr>;\n      newTarget = ({new_cap} \\<union> direct_caps_of s (target c\\<^sub>1) )\n  in\n  s (target c\\<^sub>1 \\<mapsto> Entity newTarget, target c\\<^sub>2 \\<mapsto> null_entity)\"\n  by (simp add: createOperation_def Let_def full_cap_def null_entity_def)\n\ndefinition\n  takeOperation :: \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"takeOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (e \\<mapsto> Entity (insert (diminish R c\\<^sub>2) (direct_caps_of s e)))\"\n\nlemma takeOperation_def2:\n  \"takeOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (e \\<mapsto> Entity ({diminish R c\\<^sub>2} \\<union> direct_caps_of s e))\"\n  by (clarsimp simp: takeOperation_def caps_of_def)\n\ndefinition\n  grantOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"grantOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity (insert (diminish R c\\<^sub>2) (direct_caps_of s (target c\\<^sub>1)) )) \"\n\nlemma grantOperation_def2:\n  \"grantOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity ( {diminish R c\\<^sub>2} \\<union> direct_caps_of s (target c\\<^sub>1)))\"\n  by (clarsimp simp: grantOperation_def caps_of_def)\n\ndefinition\n  copyOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"copyOperation sRef c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity (insert (diminish R c\\<^sub>2) (direct_caps_of s (target c\\<^sub>1)))) \"\n\ndefinition\n  removeOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> modify_state\" where\n  \"removeOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  if is_entity s (target c\\<^sub>1)\n  then\n     s ((target c\\<^sub>1) \\<mapsto> Entity ((direct_caps_of s (target c\\<^sub>1)) - {c\\<^sub>2} ))\n  else\n     s\"\n\nlemma removeOperation_simpler:\n  \"removeOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  (case s (target c\\<^sub>1) of\n    None \\<Rightarrow> s\n  | Some (Entity caps) \\<Rightarrow> s (target c\\<^sub>1 \\<mapsto> Entity (caps - {c\\<^sub>2})))\"\n  by (rule eq_reflection, simp add: removeOperation_def is_entity_def direct_caps_of_def\n                             split: if_split_asm option.splits)\n\ndefinition\n  removeSetOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap set \\<Rightarrow> modify_state\" where\n  \"removeSetOperation e c C s \\<equiv>\n  if is_entity s (target c) then\n   s ((target c) \\<mapsto> Entity ((direct_caps_of s (target c)) - C ))\n  else\n   s\"\n\nlemma removeSetOperation_simpler:\n  \"removeSetOperation e c caps s \\<equiv>\n  (case s (target c) of\n    None \\<Rightarrow> s\n  | Some (Entity caps') \\<Rightarrow> s (target c \\<mapsto> Entity (caps' - caps)))\"\n  by (auto simp: removeSetOperation_def is_entity_def direct_caps_of_def\n         intro!: eq_reflection\n          split: if_split_asm option.splits)\n\nlemma removeSetOperation_fold_removeOperation:\n  \"removeSetOperation e c (set caps) s = fold (removeOperation e c) caps s\"\n  apply (subst foldr_fold [symmetric])\n   apply (fastforce simp: removeOperation_def direct_caps_of_def is_entity_def)\n  apply (rule sym)\n  apply (induct caps)\n   apply (fastforce simp: removeSetOperation_def removeOperation_def direct_caps_of_def is_entity_def)\n  apply (fastforce simp: removeSetOperation_def removeOperation_def direct_caps_of_def is_entity_def)\n  done\n\ndefinition\n  removeSetOfCaps :: \"(entity_id \\<Rightarrow> cap set) \\<Rightarrow> modify_state\"\nwhere\n  \"removeSetOfCaps cap_map s \\<equiv> \\<lambda>e.\n     if is_entity s e\n     then Some (Entity ((direct_caps_of s e) - cap_map e ))\n     else None\"\n\ndefinition\n  caps_to_entity :: \"entity_id \\<Rightarrow> entity_id \\<Rightarrow> state \\<Rightarrow> cap set\"\nwhere\n  \"caps_to_entity e e' s \\<equiv> {cap. cap \\<in> direct_caps_of s e' \\<and> target cap = e}\"\n\ndefinition\n  revokeOperation :: \"entity_id \\<Rightarrow> cap \\<Rightarrow> modify_state_n\" where\n  \"revokeOperation e c s \\<equiv>\n    {s'. \\<exists>cap_map. \\<forall>e'. cap_map e' \\<subseteq> caps_to_entity (target c) e' s \\<and>\n         s' = removeSetOfCaps cap_map s}\"\n\ndefinition\n  destroyOperation :: \"entity_id \\<Rightarrow> cap \\<Rightarrow> modify_state\" where\n  \"destroyOperation e c s \\<equiv> s(target c := None)\"", "property": "System Operations: Define how various system operations (create, take, grant, copy, remove, remove set, revoke, and destroy) modify the system state by manipulating capabilities and entity relationships.\n\nSubproperties:\n- Create Operation: Creates a new capability and adds it to an entity's direct capabilities.\n- Take Operation: Adds a diminished capability to an entity's direct capabilities.\n- Grant Operation: Adds a diminished capability to the direct capabilities of the target entity of another capability.\n- Copy Operation: Copies a diminished capability to the direct capabilities of the target entity of another capability.\n- Remove Operation: Removes a capability from an entity's direct capabilities.\n- Remove Set Operation: Removes a set of capabilities from an entity's direct capabilities.\n- Revoke Operation: Removes a set of capabilities related to a specific entity from the system state.\n- Destroy Operation: Removes an entity from the system state.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Following functions define how each of the sysOPs modifies the\n * system state_s\n "}
{"spec": "primrec\n  step' :: \"sysOPs \\<Rightarrow> modify_state_n\"\nwhere\n  \"step' (SysCreate    e c\\<^sub>1 c\\<^sub>2) s   = {createOperation e c\\<^sub>1 c\\<^sub>2 s}\"\n| \"step' (SysTake      e c\\<^sub>1 c\\<^sub>2 R) s = {takeOperation  e c\\<^sub>1 c\\<^sub>2 R s}\"\n| \"step' (SysGrant     e c\\<^sub>1 c\\<^sub>2 R) s = {grantOperation  e c\\<^sub>1 c\\<^sub>2 R s}\"\n| \"step' (SysCopy      e c\\<^sub>1 c\\<^sub>2 R) s = {copyOperation e c\\<^sub>1 c\\<^sub>2 R s}\"\n| \"step' (SysRemove    e c\\<^sub>1 c\\<^sub>2)   s = {removeOperation e c\\<^sub>1 c\\<^sub>2 s}\"\n| \"step' (SysRemoveSet e c C)    s = {removeSetOperation e c C s}\"\n| \"step' (SysRevoke    e c) s      =  revokeOperation e c s\"\n| \"step' (SysDestroy   e c) s      = {destroyOperation e c s}\"", "property": "System Call Execution: Non-deterministically execute a single system call operation, such as creating, taking, granting, copying, removing, revoking, or destroying resources.\n\nSubproperties:\n- Create Operation: Create a new resource with the given parameters.\n- Take Operation: Take control of a resource from another entity.\n- Grant Operation: Grant access to a resource for another entity.\n- Copy Operation: Copy a resource from one location to another.\n- Remove Operation: Remove a resource from the system.\n- Remove Set Operation: Remove a set of resources from the system.\n- Revoke Operation: Revoke access to a resource for all entities.\n- Destroy Operation: Destroy a resource and its associated data.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Non deterministically executing system calls:\n * How we execute a single operation\n "}
{"spec": "definition\n  step :: \"sysOPs \\<Rightarrow> modify_state_n\" where\n  \"step cmd s \\<equiv> if legal cmd s then (step' cmd s) \\<union> {s} else {s}\"", "property": "System Operation Execution: Only execute a system operation if it is legal in the current state, ensuring that the system remains in a valid state after the operation. \n\nState Preservation: If the operation is not legal, preserve the current state.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " single operation is allowed only if it is legal in the current state_s "}
{"spec": "primrec\n  execute :: \"sysOPs list \\<Rightarrow> state \\<Rightarrow> state set\"\nwhere\n  \"execute [] s = {s}\"\n| \"execute (cmd#cmds) s = \\<Union> (step cmd ` ( execute cmds s ))\"", "property": "Command Execution: Execute a list of system operations in reverse order, with each operation potentially producing multiple next states, resulting in a set of possible final states. \n\nSubproperties: \n- Empty Command List: An empty list of commands results in no state change.\n- Recursive Execution: Each command is executed on the set of states produced by the previous commands, with the results combined to form the final set of states.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " execution of a list of commands (from back of list)\n "}
{"spec": "lemma Int_all_rights [simp]: \"c \\<inter> all_rights = c\"\n  by (simp add: all_rights_def)\n\nlemma is_entity_dom: \"is_entity s e = (e \\<in> dom s)\"\n  by (simp add: is_entity_def dom_def)\n\nlemma is_entity_imp_not_None:\n  \"is_entity s e \\<Longrightarrow> s e \\<noteq> None\"\n  by (simp add: is_entity_def)\n\nlemma store_connected_refl [simp]:\n  \"(e, e) \\<in> store_connected s\"\n  by (simp add: store_connected_def)\n\nlemma no_caps_of_imp_not_connected [rule_format]:\n  \"\\<lbrakk>(e, x) \\<in> store_connected s\\<rbrakk>\n  \\<Longrightarrow> direct_caps_of s e = {} \\<longrightarrow> x = e\"\n  apply (unfold store_connected_def)\n  apply (erule rtrancl.induct)\n   apply simp\n  apply (clarsimp simp: store_connected_direct_def direct_caps_of_def)\n  done\n\nlemma no_direct_caps_of_no_caps_of:\n  \"(direct_caps_of s e = {}) = (caps_of s e = {})\"\n  apply (rule iffI)\n   apply (clarsimp simp add: caps_of_def)\n   apply (drule (1) no_caps_of_imp_not_connected)\n   apply simp\n  apply (clarsimp simp add: caps_of_def store_connected_def)\n  done\n\nlemma no_direct_caps_of_imp_no_caps_of:\n  \"direct_caps_of s e = {} \\<Longrightarrow> caps_of s e = {}\"\n  by (rule no_direct_caps_of_no_caps_of [THEN iffD1])\n\nlemma no_caps_of_imp_no_direct_caps_of:\n  \"caps_of s e = {} \\<Longrightarrow> direct_caps_of s e = {}\"\n  by (rule no_direct_caps_of_no_caps_of [THEN iffD2])\n\nlemma store_connected_direct_in_store_connected:\n  \"(x, y) \\<in> store_connected_direct s \\<Longrightarrow> (x, y) \\<in> store_connected s\"\n  by (simp add: store_connected_def)\n\nlemma no_diminish [simp]:\n  \"diminish all_rights c = c\"\n  by (simp add: diminish_def)\n\nlemma no_diminish_image [simp]:\n  \"diminish all_rights ` C = C\"\n  by (fastforce)\n\nlemma diminish_diminish [simp]:\n  \"diminish dimR2 (diminish dimR1 sc) = diminish (dimR1 \\<inter> dimR2) sc\"\n  by (clarsimp simp add: diminish_def Int_assoc)\n\nlemma diminish_range_diminish [simp]:\n  \"diminish dimR2 ` diminish dimR1 ` ssc = diminish (dimR1 \\<inter> dimR2) ` ssc\"\n  apply (rule set_eqI)\n  apply (rule iffI)\n   apply (clarsimp)\n  apply (clarsimp simp del: diminish_diminish simp add: diminish_diminish [symmetric])\n  done\n\nlemma execute_not_empty:\n  \"execute ops s \\<noteq> {}\"\n  apply (induct ops)\n   apply (simp)\n  apply (simp add: step_def del: if_image_distrib, fast)\n  done\n\nlemma execute_append [intro]:\n  \"\\<And> s s' s'' opsA. \\<lbrakk> s'' \\<in> execute opsA s; s' \\<in> execute opsB s'' \\<rbrakk> \\<Longrightarrow> s' \\<in> execute (opsB @ opsA) s\"\n  apply (induct opsB)\n   apply (simp)\n  apply (atomize)\n  apply (clarsimp)\n  apply (rule bexI)\n   apply (assumption)\n  by (drule spec | drule(1) mp)+", "property": "Entity Properties: Define the fundamental properties of entities in the system, including the intersection of rights, entity existence, and the implications of entity relationships.\n\nSubproperties:\n- Entity Rights Intersection: The intersection of any capability with all rights is equal to the capability itself.\n- Entity Existence: An entity exists in the system if it is in the domain of the system state.\n- Entity Relationship Implications: Various implications of entity relationships, including the reflexivity of store connections, the absence of direct capabilities implying no capabilities, and the equivalence of direct and indirect capabilities in certain cases.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": "**************************\n * Lemmas about the model. *\n **************************"}
{"spec": "lemma heapAdd_read_cap [simp]:\n  \"target (read_cap e) = e\"\n  by (simp add: read_cap_def)\n\nlemma rights_read_cap [simp]:\n  \"rights (read_cap e) = {Read}\"\n  by (simp add: read_cap_def)\n\nlemma heapAdd_write_cap [simp]:\n  \"target (write_cap e) = e\"\n  by (simp add: write_cap_def)\n\nlemma rights_write_cap [simp]:\n  \"rights (write_cap e) = {Write}\"\n  by (simp add: write_cap_def)\n\nlemma heapAdd_take_cap [simp]:\n  \"target (take_cap e) = e\"\n  by (simp add: take_cap_def)\n\nlemma rights_take_cap [simp]:\n  \"rights (take_cap e) = {Take}\"\n  by (simp add: take_cap_def)\n\nlemma heapAdd_grant_cap [simp]:\n  \"target (grant_cap e) = e\"\n  by (simp add: grant_cap_def)\n\nlemma rights_grant_cap [simp]:\n  \"rights (grant_cap e) = {Grant}\"\n  by (simp add: grant_cap_def)\n\nlemma heapAdd_create_cap [simp]:\n  \"target (create_cap e) = e\"\n  by (simp add: create_cap_def)\n\nlemma rights_create_cap [simp]:\n  \"rights (create_cap e) = {Create}\"\n  by (simp add: create_cap_def)\n\nlemma heapAdd_store_cap [simp]:\n  \"target (store_cap e) = e\"\n  by (simp add: store_cap_def)\n\nlemma rights_store_cap [simp]:\n  \"rights (store_cap e) = {Store}\"\n  by (simp add: store_cap_def)\n\nlemma heapAdd_full_cap [simp]:\n  \"target (full_cap e) = e\"\n  by (simp add: full_cap_def)\n\nlemma rights_full_cap [simp]:\n  \"rights (full_cap e) = all_rights\"\n  by (simp add: full_cap_def)\n\nlemma entity_diminish [simp]:\n  \"target (diminish R c) = target c\"\n  by (simp add: diminish_def)\n\nlemma rights_diminish [simp]:\n  \"rights (diminish R c) = rights c \\<inter> R\"\n  by (simp add: diminish_def)", "property": "Capability Properties: Define the properties of various capability operations, including read, write, take, grant, create, store, and full capabilities, ensuring that each operation has the correct target and rights. Additionally, diminishing a capability preserves its target while restricting its rights to the specified set.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Lemma on caps "}
{"spec": "lemma caps_of_imp_some_direct_cap:\n  \"c \\<in> caps_of s e \\<Longrightarrow> \\<exists>e'. c \\<in> direct_caps_of s e'\"\n  by (auto simp: caps_of_def)\n\nlemma caps_of_imp_some_store_connected_direct_cap:\n  \"c \\<in> caps_of s e \\<Longrightarrow> \\<exists>e'. (e, e') \\<in> store_connected s \\<and> c \\<in> direct_caps_of s e'\"\n  by (auto simp: caps_of_def)\n\nlemma direct_cap_in_cap:\n  \"c \\<in> direct_caps_of s e \\<Longrightarrow> c \\<in> caps_of s e\"\n  by (auto simp: caps_of_def store_connected_def)\n\nlemma all_caps_ofE [elim!]:\n  \"\\<lbrakk> c \\<in> all_caps_of s; \\<And>e'. c \\<in> direct_caps_of s e' \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"\n  by (fastforce simp add: all_caps_of_def)\n\nlemma all_caps_ofI [intro]:\n  \"c \\<in> direct_caps_of s e' \\<Longrightarrow> c \\<in> all_caps_of s\"\n  by (fastforce simp add: all_caps_of_def)", "property": "Caps of Lemmas: Establish relationships between capabilities and their storage in the system, including the existence of direct capabilities, store-connected direct capabilities, and the inclusion of direct capabilities in the set of all capabilities.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Lemmas on caps_of "}
{"spec": "lemma entity_not_not_entity:\n  \"\\<lbrakk>is_entity s e\\<^sub>1; \\<not> is_entity s e\\<^sub>2\\<rbrakk> \\<Longrightarrow> e\\<^sub>1 \\<noteq> e\\<^sub>2\"\n  by (auto simp: is_entity_def)\n\nlemma no_direct_caps_of_in_nonEntity:\n  \"\\<not> is_entity s e \\<Longrightarrow> direct_caps_of s e = {}\"\n  by (auto simp: direct_caps_of_def is_entity_def split:option.splits)\n\nlemma not_is_entity_imp_no_direct_caps_of:\n  \"\\<not> is_entity s e \\<Longrightarrow> caps_of s e = {}\"\n  by (drule no_direct_caps_of_in_nonEntity, erule no_direct_caps_of_imp_no_caps_of)\n\nlemma direct_caps_of_imp_is_entity:\n  \"c \\<in> direct_caps_of s e \\<Longrightarrow> is_entity s e\"\n  by (auto intro: classical dest: no_direct_caps_of_in_nonEntity)\n\nlemma caps_of_imp_is_entity:\n  \"c \\<in> caps_of s e \\<Longrightarrow> is_entity s e\"\n  by (auto intro: classical dest: not_is_entity_imp_no_direct_caps_of)", "property": "Entity Properties: \nAn entity in the system has the following properties: \n- Distinctness: An entity is distinct from a non-entity. \n- Containment: A non-entity does not contain any direct capabilities. \n- Implication: If an entity does not exist, it does not have any capabilities. \n- Direct capability implication: If an entity has a direct capability, then it must be an entity. \n- Capability implication: If an entity has a capability, then it must be an entity.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Lemmas on entities "}
{"spec": "lemma store_caps_of_store_connected_direct:\n  \"\\<lbrakk>c \\<in> direct_caps_of s e; Store \\<in> rights c\\<rbrakk>\n  \\<Longrightarrow> (e, target c) \\<in> store_connected_direct s\"\n  by (fastforce simp: store_connected_direct_def)\n\nlemma store_caps_store_connected:\n  \"\\<lbrakk>c \\<in> caps_of s e; Store \\<in> rights c\\<rbrakk> \\<Longrightarrow> (e, target c) \\<in> store_connected s\"\n  apply (clarsimp simp: store_connected_def caps_of_def)\n  by (frule (1) store_caps_of_store_connected_direct, simp)\n\nend", "property": "Store Connected Properties: Ensure that if a capability has Store rights, then the corresponding endpoint and target are considered store-connected, both directly and in general.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Lemmas on store_connected "}
{"spec": "(* Title:   Confinement_S\n * Description: Rephrasing of the confinement proof using the concept of islands.\n *)\n\ntheory Islands_S\nimports Confine_S\nbegin\n\ndefinition\n  island :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id set\" where\n  \"island s x \\<equiv> {e\\<^sub>i. s \\<turnstile> x \\<leftrightarrow>* e\\<^sub>i}\"\n\ndefinition\n  island_caps :: \"state \\<Rightarrow> entity_id \\<Rightarrow> cap set\" where\n  \"island_caps s x \\<equiv> \\<Union>(caps_of s ` island s x)\"\n\nlemma island_caps_def2:\n  \"island_caps s x \\<equiv> \\<Union> e \\<in> island s x. caps_of s e\"\n  by(simp add: island_caps_def)\n\nlemma island_caps_def3:\n  \"island_caps s x =  \\<Union>(direct_caps_of s ` island s x)\"\n  apply (clarsimp simp: island_caps_def)\n  apply rule\n   apply (clarsimp simp: island_def caps_of_def)\n   apply (drule store_connected_directly_tgs_connected)\n   apply (metis directly_tgs_connected_rtrancl_into_rtrancl)\n  apply (fastforce simp: caps_of_def store_connected_def)\n  done\n\nlemma island_caps_dom:\n  \"island_caps s e\\<^sub>x \\<le>cap c =\n  (\\<forall>e\\<^sub>i. (e\\<^sub>x, e\\<^sub>i) \\<in> tgs_connected s \\<longrightarrow> caps_of s e\\<^sub>i \\<le>cap c)\"\n  by (auto simp add: island_caps_def caps_dominated_by_def island_def)\n\nlemma authority_confinement_islands:\n  \"\\<lbrakk>s' \\<in> execute cmds s;\n    island_caps s x \\<le>cap c\\<rbrakk>\n  \\<Longrightarrow> island_caps s' x \\<le>cap c\"\n  apply (simp add: island_caps_dom)\n  apply clarsimp\n  apply (frule (1) tgs_connected_preserved)\n  apply (subst (asm) tgs_connected_comm_eq)\n  apply (erule authority_confinement)\n  apply clarsimp\n  apply (erule_tac x=e\\<^sub>i' in allE)\n  apply (erule impE)\n  apply (metis (opaque_lifting, no_types) tgs_connected_comm_eq tgs_connected_def rtrancl_trans)\n  apply clarsimp\n  done\n\nend", "property": "Authority Confinement: The island capabilities are confined within a certain capability, meaning that if the island capabilities are dominated by a capability in the initial state, they will remain dominated by that capability in any subsequent state after executing a sequence of commands. \n\nIsland Capabilities: The island capabilities of an entity are the union of the capabilities of all entities in the same island, which are the entities reachable from the given entity through the store connection relation.", "title": "./spec/take-grant/Islands_S.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Isolation_S\nimports Islands_S\nbegin\n\ndefinition\n  set_flow :: \"state \\<Rightarrow> (entity_id set \\<times> entity_id set) set\" where\n  \"set_flow s \\<equiv> {(X,Y). \\<exists>x \\<in> X. \\<exists>y \\<in> Y.\n                        (read_cap x \\<in>cap caps_of s y \\<or>\n                        write_cap y \\<in>cap caps_of s x)}\"\n\nlemma set_flow_def2:\n  \"(X, Y) \\<in> set_flow s = (\\<exists>x \\<in> X. \\<exists>y \\<in> Y.\n                        (read_cap x \\<in>cap caps_of s y \\<or>\n                        write_cap y \\<in>cap caps_of s x))\"\n  by (simp add: set_flow_def)\n\ndefinition\n  flow :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"flow s \\<equiv>  {(x,y). (island s x, island s y) \\<in> set_flow s}\"\n\nlemma flow_def2:\n  \"(x, y) \\<in> flow s = ((island s x, island s y) \\<in> set_flow s)\"\n  by (simp add: flow_def)\n\n\nabbreviation\n  in_flow :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<leadsto> _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x \\<leadsto> y \\<equiv> (x,y) \\<in> flow s\"\n\ndefinition\n  flow_trans :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" (\"flow\\<^sup>*\") where\n  \"flow_trans s \\<equiv> (flow s)\\<^sup>*\"\n\nabbreviation\n  in_flow_trans :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<leadsto>* _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x \\<leadsto>* y == (x,y) \\<in> flow_trans s\"\n\nnotation (latex output)\n  in_flow_trans (\"_ \\<turnstile> _ \\<leadsto>\\<^sup>* _\" [60,0,60] 61)\n\ntranslations\n  \"\\<not> (s \\<turnstile> x \\<leadsto> y)\" <= \"(x,y) \\<notin> CONST flow s\"\n  \"\\<not> (s \\<turnstile> x \\<leadsto>* y)\" <= \"(x,y) \\<notin> CONST flow_trans s\"", "property": "Information Flow: Define the flow of information between entities in a system, including direct and transitive flows, based on the capabilities and island relationships in a given state.", "title": "./spec/take-grant/Isolation_S.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma rights_extra_rights_read_cap [simp]:\n  \"rights (extra_rights (read_cap e)) = {Read}\"\n  by (simp add: rights_extra_rights)\n\nlemma rights_extra_rights_write_cap [simp]:\n  \"rights (extra_rights (write_cap e)) = {Write}\"\n  by (simp add: rights_extra_rights)\n\nlemma flow_trans_refl [simp]:\n  \"s \\<turnstile> x \\<leadsto>* x\"\n  by (metis flow_trans_def rtrancl.rtrancl_refl)\n\nlemma flow_connected_step:\n  \"\\<lbrakk>s' \\<turnstile> x \\<leadsto>* y; s' \\<in> step cmd s\\<rbrakk> \\<Longrightarrow>\n    s \\<turnstile> x \\<leadsto>* y\"\n  apply (erule rtrancl_induct [where r=\"flow s'\",\n                              simplified flow_trans_def[symmetric]])\n   apply simp\n  apply (subgoal_tac \"s \\<turnstile> y \\<leadsto> z\")\n   apply (fastforce simp: flow_trans_def rtrancl.rtrancl_into_rtrancl)\n  apply (clarsimp simp: flow_def island_def set_flow_def)\n  apply (frule_tac x=y in tgs_connected_preserved_step, simp)\n  apply (frule_tac x=z in tgs_connected_preserved_step, simp)\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (erule disjE)\n   apply clarsimp\n   apply (drule (1) caps_of_op)\n   apply (clarsimp simp: cap_in_caps_def)\n   apply (metis (no_types) tgs_connected_trans subsetD)\n  apply clarsimp\n  apply (drule (1) caps_of_op)\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (metis (no_types) tgs_connected_trans subsetD)\n  done\n\nlemma flow_connected [rule_format]:\n  \"\\<forall>s'.  s' \\<in> execute cmds s \\<longrightarrow>\n    s' \\<turnstile> x \\<leadsto>* y \\<longrightarrow>\n    s \\<turnstile> x \\<leadsto>* y\"\n  apply (induct_tac cmds, simp)\n  apply clarsimp\n  apply (drule (1) flow_connected_step)\n  apply auto\n  done\n\nlemma information_flow:\n  \"\\<lbrakk>s' \\<in> execute cmds s;\n  \\<not> s \\<turnstile> x \\<leadsto>* y\\<rbrakk> \\<Longrightarrow>\n  \\<not> s' \\<turnstile> x \\<leadsto>* y\"\n  by (auto simp: flow_connected)\n\nend", "property": "Information Flow Preservation: The execution of commands preserves the non-existence of an information flow between two points. If there is no flow from x to y initially, then there will still be no flow after executing a sequence of commands.", "title": "./spec/take-grant/Isolation_S.thy", "chapter": "", "section": "", "comment": " Proof "}
{"spec": "theory Example\nimports System_S\nbegin\n\ndefinition \"id0 \\<equiv> 0\"\ndefinition  \"id1 \\<equiv> 1\"\ndefinition  \"id2 \\<equiv> 2\"\n\ndefinition \"e0 \\<equiv> Entity {\\<lparr> target = id1, rights = {Store}\\<rparr>}\"\ndefinition \"e1 \\<equiv> Entity {\\<lparr> target = id2, rights = {Grant}\\<rparr>}\"\ndefinition \"e2 \\<equiv> Entity {}\"\n\nlemmas id_defs = id0_def id1_def id2_def\nlemmas entity_defs = e0_def e1_def e2_def\n\ndefinition example_state :: \"state\" where\n\"example_state \\<equiv> [0 \\<mapsto> e0, 1 \\<mapsto> e1, 2 \\<mapsto> e2] \"\n\nlemma de0:\n  \"direct_caps_of example_state id0 =\n   {\\<lparr> target = id1, rights = {Store}\\<rparr>}\"\n  by (simp add: direct_caps_of_def example_state_def\n                id_defs entity_defs\n         split: option.splits)\n\nlemma de1:\n  \"direct_caps_of example_state id1 =\n   {\\<lparr> target = id2, rights = {Grant}\\<rparr>}\"\n  by (simp add: direct_caps_of_def example_state_def\n                id_defs entity_defs\n         split: option.splits)\n\nlemma de2: \"direct_caps_of example_state id2 = {}\"\n  by (simp add: direct_caps_of_def example_state_def\n                id_defs entity_defs\n         split: option.splits)\n\n\nlemma scd:\n  \"store_connected_direct example_state = {(id0,id1)}\"\n  by (auto simp: store_connected_direct_def direct_caps_of_def\n                 example_state_def id_defs entity_defs\n          split: if_split_asm option.splits\n           cong: conj_cong)\n\nlemma sc:\n  \"store_connected example_state = {(id0,id1)} \\<union> Id\"\n  apply simp\n  apply (rule equalityI)\n  apply (insert scd)\n   apply (simp add: store_connected_def)\n   apply clarsimp\n   apply (erule converse_rtranclE)\n    apply simp\n   apply clarsimp\n   apply (erule rtranclE)\n    apply simp\n   apply clarsimp\n  apply (fastforce simp: store_connected_def)\n  done\n\nlemma sc': \"store_connected example_state = Id \\<union> {(0,1)}\"\n  by (clarsimp simp: sc id_defs)\n\nlemma ce0:\n  \"caps_of example_state id0 =\n   {\\<lparr>target = id1, rights = {Store}\\<rparr>,\n    \\<lparr>target = id2, rights = {Grant}\\<rparr>}\"\n  by (fastforce simp: caps_of_def sc Collect_disj_eq de0 de1)\n\nlemma ce1:\n  \"caps_of example_state id1 =\n   {\\<lparr> target = id2, rights = {Grant}\\<rparr>}\"\n  apply (clarsimp simp: caps_of_def sc Collect_disj_eq de0 de1)\n  apply (simp add: id0_def id1_def)\n  done\n\nlemma ce2: \"caps_of example_state id2 = {}\"\n  apply (simp add: caps_of_def sc)\n  apply (rule allI)\n  apply (rule conjI)\n   apply (simp add: id0_def id2_def)\n  apply (simp add: de2)\n  done\n\nend", "property": "Entity Relationships and Capabilities: Define the relationships and capabilities between entities in a system, including direct capabilities, store-connected relationships, and the overall capabilities of each entity. Ensure that the relationships and capabilities are correctly propagated and calculated based on the system's definitions and rules. \n\nSubproperties:\n- Direct Capabilities: Define the direct capabilities of each entity, including the target entity and the associated rights.\n- Store-Connected Relationships: Determine the store-connected relationships between entities based on their direct capabilities.\n- Overall Capabilities: Calculate the overall capabilities of each entity by considering the direct capabilities and store-connected relationships.", "title": "./spec/take-grant/Example.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Defines the instances of pspace_storable objects.\n*)\n\nchapter \"Storable Object Instances\"\n\ntheory ObjectInstances_H\nimports\n  Structures_H\n  State_H\n  PSpaceStorable_H\n  Config_H\nbegin\n\narch_requalify_consts (H)\n  VPtr\n  newContext\n\nlemma projectKO_eq2:\n  \"((obj,s') \\<in> fst (projectKO ko s)) = (projectKO_opt ko = Some obj \\<and> s' = s)\"\n  by (auto simp: projectKO_def fail_def return_def split: option.splits)\n\n\n\\<comment> \\<open>-----------------------------------\\<close>\n\ninstantiation endpoint :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_ep:\n  \"projectKO_opt e \\<equiv> case e of KOEndpoint e \\<Rightarrow> Some e | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_ep [simp]:\n  \"injectKO e \\<equiv> KOEndpoint e\"\n\ndefinition\n  koType_ep [simp]:\n  \"koType (t::endpoint itself) \\<equiv> EndpointT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_ep split: kernel_object.splits)\n\nend\n\ninstantiation notification :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_ntfn:\n  \"projectKO_opt e \\<equiv> case e of KONotification e \\<Rightarrow> Some e | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_ntfn [simp]:\n  \"injectKO e \\<equiv> KONotification e\"\n\ndefinition\n  koType_ntfn [simp]:\n  \"koType (t::notification itself) \\<equiv> NotificationT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_ntfn split: kernel_object.splits)\n\nend\n\n\ninstantiation cte :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_cte:\n  \"projectKO_opt e \\<equiv> case e of KOCTE e \\<Rightarrow> Some e | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_cte [simp]:\n  \"injectKO c \\<equiv> KOCTE c\"\n\ndefinition\n  koType_cte [simp]:\n  \"koType (t::cte itself) \\<equiv> CTET\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_cte split: kernel_object.splits)\n\nend\n\ninstantiation user_data_device :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_user_data_device:\n  \"projectKO_opt e \\<equiv> case e of KOUserDataDevice \\<Rightarrow> Some UserDataDevice | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_user_data_device [simp]:\n  \"injectKO (t :: user_data_device) \\<equiv> KOUserDataDevice\"\n\ndefinition\n  koType_user_data_device [simp]:\n  \"koType (t::user_data_device itself) \\<equiv> UserDataDeviceT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_user_data_device split: kernel_object.splits)\nend\n\ninstantiation user_data :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_user_data:\n  \"projectKO_opt e \\<equiv> case e of KOUserData \\<Rightarrow> Some UserData | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_user_data [simp]:\n  \"injectKO (t :: user_data) \\<equiv> KOUserData\"\n\ndefinition\n  koType_user_data [simp]:\n  \"koType (t::user_data itself) \\<equiv> UserDataT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_user_data split: kernel_object.splits)\n\nend\n\n\ninstantiation tcb :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_tcb:\n  \"projectKO_opt e \\<equiv> case e of KOTCB e \\<Rightarrow> Some e | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_tcb [simp]:\n  \"injectKO t \\<equiv> KOTCB t\"\n\ndefinition\n  koType_tcb [simp]:\n  \"koType (t::tcb itself) \\<equiv> TCBT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_tcb split: kernel_object.splits)\n\nend\n\n\nlemmas projectKO_opts_defs =\n  projectKO_opt_tcb projectKO_opt_cte projectKO_opt_ntfn projectKO_opt_ep\n  projectKO_opt_user_data projectKO_opt_user_data_device\n\nlemmas injectKO_defs =\n  injectKO_tcb injectKO_cte injectKO_ntfn injectKO_ep injectKO_user_data injectKO_user_data_device\n\nlemmas koType_defs =\n  koType_tcb koType_cte koType_ntfn koType_ep koType_user_data koType_user_data_device\n\n\\<comment> \\<open>-----------------------------------\\<close>\n\ninstantiation endpoint :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY Endpoint\n\ninstance\n  apply (intro_classes)\n  apply simp\n  apply (case_tac ko, auto simp: projectKO_opt_ep updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\ninstantiation notification :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY Notification\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_ntfn updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\ninstantiation cte :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY CTE\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_cte updateObject_cte\n                                 in_monad projectKO_eq2 typeError_def alignError_def\n                           split: kernel_object.splits if_split_asm)\n  done\n\nend\n\n\ninstantiation user_data :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY UserData\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_user_data updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\ninstantiation user_data_device :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY UserDataDevice\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_user_data_device updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\ninstantiation tcb :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY TCB\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_tcb updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\nend", "property": "Storable Object Instances: Define the instances of pspace_storable objects, including endpoint, notification, cte, user_data, user_data_device, and tcb, to ensure that these objects can be stored and managed in the kernel's memory space.\n\nSubproperties:\n- Endpoint Instance: Define the endpoint instance of pspace_storable to manage endpoint objects.\n- Notification Instance: Define the notification instance of pspace_storable to manage notification objects.\n- CTE Instance: Define the cte instance of pspace_storable to manage cte objects.\n- User Data Instance: Define the user_data instance of pspace_storable to manage user_data objects.\n- User Data Device Instance: Define the user_data_device instance of pspace_storable to manage user_data_device objects.\n- TCB Instance: Define the tcb instance of pspace_storable to manage tcb objects.", "title": "./spec/design/skel/ObjectInstances_H.thy", "chapter": "Storable Object Instances", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels.lhs ArchLabels= ONLY GenInvocationLabels InvocationLabel\n#INCLUDE_HASKELL SEL4/API/InvocationLabels.lhs instanceproofs\n\nend", "property": "System Call Labels: Enumerate all system call labels, providing a comprehensive list of invocation labels for the system.", "title": "./spec/design/skel/InvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of all system call labels.\n"}
{"spec": "theory PSpaceStorable_H\nimports\n  Structures_H\n  KernelStateData_H\n  \"Lib.DataMap\"\nbegin\n\narch_requalify_types (H)\n  arch_kernel_object_type\n\narch_requalify_consts (H)\n  archTypeOf\n\nlemma UserData_singleton [simp]:\n  \"(v = UserData) = True\" \"(UserData = v) = True\"\n  by (cases v, simp)+\n\nlemma UserDataDevice_singleton [simp]:\n  \"(v = UserDataDevice) = True\" \"(UserDataDevice = v) = True\"\n  by (cases v, simp)+\n\ndatatype\n  kernel_object_type =\n    EndpointT\n  | NotificationT\n  | CTET\n  | TCBT\n  | UserDataT\n  | UserDataDeviceT\n  | KernelDataT\n  | ArchT arch_kernel_object_type\n\nprimrec\n  koTypeOf :: \"kernel_object \\<Rightarrow> kernel_object_type\"\nwhere\n  \"koTypeOf (KOEndpoint e) = EndpointT\"\n| \"koTypeOf (KONotification e) = NotificationT\"\n| \"koTypeOf (KOCTE e) = CTET\"\n| \"koTypeOf (KOTCB e) = TCBT\"\n| \"koTypeOf (KOUserData) = UserDataT\"\n| \"koTypeOf (KOUserDataDevice) = UserDataDeviceT\"\n| \"koTypeOf (KOKernelData) = KernelDataT\"\n| \"koTypeOf (KOArch e) = ArchT (archTypeOf e)\"\n\ndefinition\n  typeError :: \"unit list \\<Rightarrow> kernel_object \\<Rightarrow> 'a kernel\" where\n  \"typeError t1 t2 \\<equiv> fail\"\n\ndefinition\n  alignError :: \"nat \\<Rightarrow> 'a kernel\" where\n  \"alignError n \\<equiv> fail\"\n\ndefinition\n  alignCheck :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit kernel\" where\n  \"alignCheck x n \\<equiv> unless ((x && mask n) = 0) $ alignError n\"\n\ndefinition\n  magnitudeCheck :: \"machine_word \\<Rightarrow> machine_word option \\<Rightarrow> nat \\<Rightarrow> unit kernel\"\nwhere\n \"magnitudeCheck x y n \\<equiv> case y of None \\<Rightarrow> return ()\n               | Some z \\<Rightarrow> when (z - x < 1 << n) fail\"\n\nclass pre_storable =\n  fixes injectKO :: \"'a \\<Rightarrow> kernel_object\"\n  fixes projectKO_opt :: \"kernel_object \\<Rightarrow> 'a option\"\n  fixes koType :: \"'a itself \\<Rightarrow> kernel_object_type\"\n\n  assumes project_inject: \"(projectKO_opt ko = Some v) = (injectKO v = ko)\"\n  assumes project_koType: \"(\\<exists>v. projectKO_opt ko = Some (v::'a)) = (koTypeOf ko = koType TYPE('a))\"\nbegin\n\ndefinition\n  projectKO :: \"kernel_object \\<Rightarrow> 'a kernel\"\nwhere\n  \"projectKO e \\<equiv>\n  case projectKO_opt e of None \\<Rightarrow> fail | Some k \\<Rightarrow> return k\"\n\ndefinition\n  objBits :: \"'a \\<Rightarrow> nat\"\nwhere\n  \"objBits v \\<equiv> objBitsKO (injectKO v)\"\n\ndefinition\n  loadObject_default :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word option \\<Rightarrow> kernel_object \\<Rightarrow> 'a kernel\"\nwhere\n  \"loadObject_default ptr ptr' next obj \\<equiv> do\n     assert (ptr = ptr');\n     val \\<leftarrow> projectKO obj;\n     alignCheck ptr (objBits val);\n     magnitudeCheck ptr next (objBits val);\n     return val\n  od\"\n\ndefinition\n  updateObject_default :: \"'a \\<Rightarrow> kernel_object \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word option \\<Rightarrow> kernel_object kernel\"\nwhere\n  \"updateObject_default val oldObj ptr ptr' next \\<equiv> do\n     assert (ptr = ptr');\n     (_ :: 'a) \\<leftarrow> projectKO oldObj;\n     alignCheck ptr (objBits val);\n     magnitudeCheck ptr next (objBits val);\n     return (injectKO val)\n  od\"\n\nend\n\nclass pspace_storable = pre_storable +\n  fixes makeObject :: 'a\n\n  \\<comment>\\<open>\n    `loadObject` is only used in the generic definition of `getObject`. It\n    describes how to extract a value of type `'a` from memory.\n\n    If `(obj, _) \\<in> loadObjext p before after ko` within `getObject`, then:\n      - @{term \"p :: machine_word\"} is the addres that we want to read an\n        instance of `'a` from.\n      - @{term \"before :: machine_word\"} is the address of the nearest\n        object at or before `p`.\n      - @{term \"after :: machine_word option\"} is the address of the nearest\n        object after `p`, if any (for checking overlap).\n      - @{term \"ko :: kernel_object\"} is the object currently at `before`.\n      - @{term \"obj :: 'a\"} is the value extracted from `ko`.\n\n    Graphically, the \"memory\" looks like this:\n\n    before  p              after\n    |-------|--+-----+-----|---|\n    |       +~~+ <---+---------- The span of obj, the object we want to extract.\n    +~~~~~~~~~~~~~~~~+ <-------- The span of ko, the existing object that spans obj.\n\n                           +~~~+ The span of whatever object comes after obj.\n                                 We don't care about this beyond making sure\n                                 it doesn't overlap with ko.\n\n    In almost every case, the object in memory (ko) is the same type of object\n    as the one being loaded (obj). For example, for a reply object our parameters\n    look like this:\n\n    p, before\n    |-----------|\n    +~~~~~~~~~~~+ <- The span of two objects:\n                     - ko, the existing object (which should be a reply object).\n                     - obj, the object that we want to load from memory. This will\n                       just be ko projected through @{term projectKO}.\n\n    In these simple cases, @{term loadObject_default} is a good specification\n    for how to load an instance of `'a` from memory.\n\n    The only interesting case is when we're loading a CTE, which might be\n    inside a TCB. Then memory looks like this:\n\n    before  p\n    |-------|--+-----+\n    |       +~~+ <---+---- The span of obj, i.e. the CTE which we're reading from\n    |                |     memory.\n    +~~~~~~~~~~~~~~~~+ <-- The span of ko, i.e. the TCB surrounding and containing\n                           obj.\n\n    In this case, the process for extracting the CTE from the surrounding TCB\n    is more involved. See `loadObject_cte` in `ObjectInstances_H`.\n  \\<close>\n  fixes loadObject :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word option \\<Rightarrow> kernel_object \\<Rightarrow> 'a kernel\"\n\n  \\<comment>\\<open>\n    `updateObject` is only used in the generic definition of `setObject`,\n    but it shows up in a few lemma statements as well. It describes how to update\n    the kernel object contents of memory depending on what's already in that\n    memory.\n\n    If `(ko', _) \\<in> updateObject v ko p before after s` within `setObject`, then:\n      - @{term \"v :: 'a\"} is the new object you want to write at pointer\n        @{term \"p :: machine_word\"}.\n      - @{term \"before :: machine_word\"} is the address of the nearest\n        object at or before `p`.\n      - @{term \"ko :: kernel_object\"} is the object currently at `before`.\n      - @{term \"after :: machine_word option\"} should be the address of the nearest\n        object after `p`, if any (for checking overlap).\n      - The returned value @{term \"ko' :: kernel_object\"} is the old object `ko`,\n        updated as required by `v`. This value gets inserted by `setObject` into\n        memory at the address `before`.\n\n    Graphically, the \"memory\" looks like this:\n\n    before  p              after\n    |-------|--+-----+-----|---|\n    |       +~~+ <---+---------- The span of v, the object we want to insert.\n    +~~~~~~~~~~~~~~~~+ <-------- The span of ko, the existing object that spans v.\n                                 This is also the span of ko', which will be what\n                                 gets put into memory after the update.\n\n                           +~~~+ The span of whatever object comes after ko.\n                                 We don't care about this beyond making sure\n                                 it doesn't overlap with ko before or after it\n                                 gets updated with v.\n\n    In almost every case, the object in memory (ko) is the same type of object\n    as the one being inserted (v). For example, for a reply object our parameters\n    look like this:\n\n    p, before\n    |-----------|\n    +~~~~~~~~~~~+ <- The span of three objects:\n                     - v, the new reply object we want to insert.\n                     - ko, the existing object (which should be a reply object).\n                     - ko', the new object (which should be a reply object if\n                       the previous one was).\n\n    In these simple cases, @{term updateObject_default} is a good specification\n    for how to update the existing kernel object.\n\n    The only interesting case is when we're updating a CTE, which might be\n    inside a TCB. Then memory looks like this:\n\n    before  p\n    |-------|--+-----+\n    |       +~~+ <---+---- The span of v, i.e. the CTE which we're inserting into\n    |                |     memory.\n    +~~~~~~~~~~~~~~~~+ <-- The span of ko, i.e. the TCB surrounding and containing v.\n                           This is also the span of ko', which is \"just\" a copy\n                           of ko with the relevant CTE updated.\n\n    In this case, the process for updating the surrounding TCB is more involved.\n    See `updateObject_cte` in `ObjectInstances_H`.\n  \\<close>\n  fixes updateObject :: \"'a \\<Rightarrow> kernel_object \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow>\n                              machine_word option \\<Rightarrow> kernel_object kernel\"\n\n  \\<comment>\\<open>\n    If updating an object succeeds, then the type of the updated object (ko')\n    should be the same as the original object (ko).\n  \\<close>\n  assumes updateObject_type:\n  \"(ko', s') \\<in> fst (updateObject v ko p p' p'' s) \\<Longrightarrow> koTypeOf ko' = koTypeOf ko\"\n\nend", "property": "Kernel Object Management: Provides a framework for managing kernel objects, including injecting and projecting objects, checking object types, and updating object contents while ensuring type consistency and alignment. \n\nType Consistency: Ensures that updating an object preserves its type, maintaining the integrity of kernel object management. \n\nAlignment and Magnitude Checks: Enforces alignment and magnitude constraints on object addresses to prevent memory corruption and ensure proper object placement.", "title": "./spec/design/skel/PSpaceStorable_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"CNodes\"\n\ntheory CNode_H\nimports\n  FaultMonad_H\n  ThreadDecls_H\n  RetypeDecls_H\n  TCBDecls_H\n  CSpaceDecls_H\n  EndpointDecls_H\n  PSpaceFuns_H\nbegin\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs\n\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs decls_only NOT cteRevoke\n\nfunction\n  cteRevoke :: \"machine_word \\<Rightarrow> unit kernel_p\"\nwhere\n \"cteRevoke p s =\n\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY cteRevoke\n\n  p s\"\nby auto\n\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs bodies_only NOT finaliseSlot cteRevoke cteDeleteOne noReplyCapsFor\n\nend", "property": "CNode Management: Revoke a capability from a CNode, ensuring that the associated memory is properly cleaned up and the capability is removed from the CNode's table.", "title": "./spec/design/skel/CNode_H.thy", "chapter": "CNodes", "section": "", "comment": ""}
{"spec": "theory InterruptDecls_H\nimports\n  RetypeDecls_H\n  KI_Decls_H\nbegin\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs\n#INCLUDE_HASKELL SEL4/Object/Interrupt.lhs Arch=ArchInterrupt_H decls_only NOT deletedIRQHandler\n\nend", "property": "Interrupt Management: Provides structures and functions for managing interrupts, including interrupt handlers and their associated data.", "title": "./spec/design/skel/InterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"CSpace\"\n\ntheory CSpace_H\nimports CSpaceDecls_H Object_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/CSpace.lhs bodies_only NOT resolveAddressBits\n\n\nfunction\n  resolveAddressBits ::\n  \"capability \\<Rightarrow> cptr \\<Rightarrow> nat \\<Rightarrow>\n   (lookup_failure, (machine_word * nat)) kernel_f\"\nwhere\n \"resolveAddressBits a b c =\n#INCLUDE_HASKELL SEL4/Kernel/CSpace.lhs BODY resolveAddressBits\na b c\"\n  by auto\n\ntermination\n  apply (relation \"measure (snd o snd)\")\n  apply (auto simp add: in_monad split: if_split_asm)\n  done\n\ndefs\n  resolveAddressBits_decl_def:\n  \"CSpaceDecls_H.resolveAddressBits \\<equiv> resolveAddressBits\"\ndeclare resolveAddressBits_decl_def[simp]\n\nend", "property": "Resolve Address Bits: Resolve the address bits of a capability to obtain a machine word and the remaining number of bits.", "title": "./spec/design/skel/CSpace_H.thy", "chapter": "CSpace", "section": "", "comment": ""}
{"spec": "definition\n  ptrBits_def[simp]:\n \"ptrBits \\<equiv> to_bl\"\n\n#INCLUDE_HASKELL SEL4/Model/PSpace.lhs ONLY ptrBitsForSize", "property": "Pointer Bits Conversion: Convert a pointer to a list of bits.", "title": "./spec/design/skel/PSpaceStruct_H.thy", "chapter": "", "section": "", "comment": "Helper Functions"}
{"spec": "#INCLUDE_HASKELL SEL4/Model/PSpace.lhs Data.Map=DataMap ONLY PSpace\n\nend", "property": "Physical Memory Structures: Organize and manage physical memory using data structures such as Data.Map.", "title": "./spec/design/skel/PSpaceStruct_H.thy", "chapter": "", "section": "", "comment": "Physical Memory Structures"}
{"spec": "chapter \"Function Declarations for Threads\"\n\ntheory ThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\n  ArchThreadDecls_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs decls_only NOT transferCapsToSlots\n\nend", "property": "Function Declarations for Threads: Provides function declarations for thread-related operations, importing necessary structures, fault monads, kernel initialization monads, and architecture-specific thread declarations.", "title": "./spec/design/skel/ThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "(*\n    The fault datatype.\n*)\n\nchapter \"Fault Structures\"\n\ntheory Fault_H\nimports ArchFault_H\nbegin\n\narch_requalify_types (H)\n  arch_fault\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Types.lhs\n#INCLUDE_HASKELL SEL4/API/Failures.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Failures.lhs bodies_only\n\nend", "property": "Fault Structures: Define the data structures and types for representing faults in the system, providing a foundation for fault handling and management.", "title": "./spec/design/skel/Fault_H.thy", "chapter": "Fault Structures", "section": "", "comment": ""}
{"spec": "chapter \"Function Declarations for Retyping Objects\"\n\ntheory RetypeDecls_H\nimports\n  ArchRetypeDecls_H\n  Structures_H\n  FaultMonad_H\n  Invocations_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType.lhs decls_only\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt.lhs decls_only ONLY deletedIRQHandler\n\nend", "property": "Function Declarations for Retyping Objects: Provides function declarations for retype operations on kernel objects, including object type and interrupt-related functions, to facilitate the creation and management of kernel objects.", "title": "./spec/design/skel/RetypeDecls_H.thy", "chapter": "Function Declarations for Retyping Objects", "section": "", "comment": ""}
{"spec": "end", "property": "No specific property can be derived from the given information as it does not contain any specific code or logic that describes a system's behavior, requirements, or constraints.", "title": "./spec/design/skel/Object_H.thy", "chapter": "", "section": "", "comment": "\n  this theory collects the SEL4.Model.* modules\n"}
{"spec": "requalify_consts\n  activateIdleThread", "property": "Activate Idle Thread: Transition the idle thread to a runnable state, allowing it to be scheduled and executed by the kernel.", "title": "./spec/design/skel/Thread_H.thy", "chapter": "", "section": "", "comment": " match Haskell, expects these under Arch. "}
{"spec": "requalify_consts (aliasing)\n  configureIdleThread\n  switchToIdleThread\n  switchToThread\n\ncontext begin global_naming global\n\nrequalify_consts (aliasing)\n  ThreadDecls_H.configureIdleThread\n  ThreadDecls_H.switchToIdleThread\n  ThreadDecls_H.switchToThread\n\nend\nend\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs Arch=Arch bodies_only NOT doNormalTransfer doIPCTransfer doReplyTransfer doNormalTransfer transferCaps transferCapsToSlots\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs Arch=Arch ONLY transferCapsToSlots\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs Arch=Arch bodies_only ONLY doNormalTransfer doIPCTransfer doReplyTransfer doNormalTransfer transferCaps\n\nend", "property": "Name Disambiguation: Disambiguate name clashes between architecture-specific and non-architecture-specific constants with the same names, ensuring unique references to these constants in the code.", "title": "./spec/design/skel/Thread_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "chapter \"Function Declarations for Notifications\"\n\ntheory NotificationDecls_H imports    \"FaultMonad_H\"\n begin\n\n#INCLUDE_HASKELL SEL4/Object/Notification.lhs decls_only\n\nend", "property": "Function Declarations for Notifications: Declare functions for notification-related operations, providing a foundation for implementing notification mechanisms in the system.", "title": "./spec/design/skel/NotificationDecls_H.thy", "chapter": "Function Declarations for Notifications", "section": "", "comment": ""}
{"spec": "chapter \"Deleting Capabilities\"\n\ntheory Delete_H\nimports\n  CNode_H\n  Interrupt_H\n  Endpoint_H\n  Thread_H\nbegin\n\ndefinition\n  slotsPointed :: \"capability \\<Rightarrow> machine_word set\"\nwhere\n \"slotsPointed cap \\<equiv> case cap of\n   CNodeCap ptr a b c   \\<Rightarrow> {ptr}\n | ThreadCap ptr        \\<Rightarrow> {ptr}\n | Zombie ptr bits num  \\<Rightarrow> {ptr}\n | _                    \\<Rightarrow> {}\"\n\nprimrec\n  sethelper :: \"bool \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\nwhere\n  \"sethelper True  s = {}\"\n| \"sethelper False s = s\"\n\nfunction\n  finaliseSlot' :: \"machine_word \\<Rightarrow> bool \\<Rightarrow> (bool * capability) kernel_p\"\nwhere\n \"finaliseSlot' x b s =\n(\\<lambda> finaliseSlot.\n(\\<lambda> cteDelete.\n(\\<lambda> reduceZombie.\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY finaliseSlot\n)\n(\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY reduceZombie\n)\n)\n(\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY cteDelete\n)\n)\nfinaliseSlot' x b s\"\n\n  by auto\n\ndefs\n  finaliseSlot_def:\n \"finaliseSlot \\<equiv> finaliseSlot'\"\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs\n\nfunction\n  cteDeleteOne' :: \"machine_word \\<Rightarrow> unit kernel\"\nwhere\n \"cteDeleteOne' x s =\n(\\<lambda> cteDeleteOne.\n(\\<lambda> deletingIRQHandler.\n(\\<lambda> cancelIPC.\n(\\<lambda> suspend.\n(\\<lambda> finaliseCap.\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY cteDeleteOne\n)\n(\n#INCLUDE_HASKELL SEL4/Object/ObjectType.lhs Arch=Arch BODY finaliseCap\n)\n)\n(\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs BODY suspend\n)\n)\n(\n#INCLUDE_HASKELL SEL4/Object/Endpoint.lhs BODY cancelIPC\n)\n)\n(\n#INCLUDE_HASKELL SEL4/Object/Interrupt.lhs BODY deletingIRQHandler\n)\n)\ncteDeleteOne' x s\"\n\n  by auto\n\ndefs\n  cteDeleteOne_def1:\n \"cteDeleteOne \\<equiv> cteDeleteOne'\"\n\ntermination cteDeleteOne'\n  by (rule cteDeleteOne'.termination[OF wf_empty], simp+)\n\nlemma cteDeleteOne_def:\n \"cteDeleteOne =\n(\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY cteDeleteOne\n)\"\n  apply (rule ext)+\n  apply (subst cteDeleteOne_def1)\n  apply (subst cteDeleteOne'.simps)\n  apply (unfold finaliseCap_def suspend_def cancelIPC_def\n                deletingIRQHandler_def cteDeleteOne_def1)\n  apply (rule refl)\n  done\n\nlemma card_reduce:\n  \"(s :: ('a :: finite) set) \\<inter> s' = {} \\<Longrightarrow> card (UNIV - (s \\<union> s')) < card (UNIV - s) = (s' \\<noteq> {})\"\n  apply (case_tac \"s' \\<subseteq> s\")\n   apply (simp add: Un_absorb2)\n   apply (simp add: Int_absorb1)\n  apply (clarsimp simp: subset_iff)\n  apply (subst psubset_card_mono)\n    apply simp\n   apply blast\n  apply blast\n  done\n\nlemma isCapDs:\n  \"isUntypedCap cap \\<Longrightarrow> \\<exists>dev ptr size freeIndex. cap = UntypedCap dev ptr size freeIndex\"\n  \"isEndpointCap cap \\<Longrightarrow> \\<exists>ptr bdg cans canr cang cangr. cap = EndpointCap ptr bdg cans canr cang cangr\"\n  \"isNotificationCap cap \\<Longrightarrow> \\<exists>ptr bdg cans canr. cap = NotificationCap ptr bdg cans canr\"\n  \"isCNodeCap cap \\<Longrightarrow> \\<exists>ptr bits grd gsize. cap = CNodeCap ptr bits grd gsize\"\n  \"isThreadCap cap \\<Longrightarrow> \\<exists>ptr. cap = ThreadCap ptr\"\n  \"isArchObjectCap cap \\<Longrightarrow> \\<exists>archcap. cap = ArchObjectCap archcap\"\n  \"isZombie cap \\<Longrightarrow> \\<exists>ptr bits num. cap = Zombie ptr bits num\"\n  apply (case_tac cap, simp_all add: isUntypedCap_def)\n  apply (case_tac cap, simp_all add: isEndpointCap_def)\n  apply (case_tac cap, simp_all add: isNotificationCap_def)\n  apply (case_tac cap, simp_all add: isCNodeCap_def)\n  apply (case_tac cap, simp_all add: isThreadCap_def)\n  apply (case_tac cap, simp_all add: isArchObjectCap_def)\n  apply (case_tac cap, simp_all add: isZombie_def)\n  done\n\nend", "property": "Capability Deletion: Delete capabilities from the system, ensuring that all references to the capability are removed and the capability is properly finalized. This involves updating the capability's slot, handling any dependent objects, and removing any zombie capabilities.\n\nSubproperties:\n- Slot Update: Update the capability's slot to reflect the deletion of the capability.\n- Dependent Object Handling: Handle any dependent objects, such as child capabilities or mapped pages, to ensure that they are properly updated or deleted.\n- Zombie Capability Removal: Remove any zombie capabilities that are no longer referenced by any other capabilities.", "title": "./spec/design/skel/Delete_H.thy", "chapter": "Deleting Capabilities", "section": "", "comment": ""}
{"spec": "(*\n    Hypervisor code.\n*)\n\ntheory Hypervisor_H\nimports\n  CNode_H\n  ArchHypervisor_H\n  KernelInitMonad_H\nbegin\n\narch_requalify_consts (H)\n  handleHypervisorFault\n\nend", "property": "Hypervisor Fault Handling: Handle faults occurring in the hypervisor, ensuring proper error management and system stability.", "title": "./spec/design/skel/Hypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "requalify_types (in Arch)\n  copy_register_sets irqcontrol_invocation\n  invocation\n\n#INCLUDE_HASKELL SEL4/API/Invocation.lhs Arch=Arch NOT GenInvocationLabels InvocationLabel\n#INCLUDE_HASKELL SEL4/API/InvocationLabels.lhs ONLY invocationType genInvocationType", "property": "Invocation Management: Provides functions to manage and handle invocations, including copying register sets and irqcontrol invocations, which enables the kernel to handle various system calls and interrupts efficiently.", "title": "./spec/design/skel/Invocations_H.thy", "chapter": "", "section": "", "comment": " Haskell expects these with Arch prefix "}
{"spec": "context Arch begin\ncontext begin global_naming global\nrequalify_types (aliasing)\n  Invocations_H.invocation\nend\nend\n\nend", "property": "Name Disambiguation: Disambiguate name clashes between architecture-specific and non-architecture-specific constants with the same names.", "title": "./spec/design/skel/Invocations_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "(*\n   Types visible in the API.\n*)\n\nchapter \"Types visible in the API\"\n\ntheory Types_H\nimports\n  MachineExports\n  ArchTypes_H\nbegin\n\narch_requalify_types (H)\n  object_type\n  paddr\n  vptr\n\narch_requalify_consts (H)\n  getObjectSize\n  fromAPIType\n  toAPIType\n  isFrameType\n  pageType\n  tcbBlockSizeBits\n\narch_requalify_facts (H)\n  tcbBlockSizeBits_def\n\n#INCLUDE_HASKELL SEL4/API/Types.lhs all_bits NOT wordsFromBootInfo messageInfoFromWord wordFromMessageInfo ObjectType getObjectSize fromAPIType toAPIType isFrameType pageType\n#INCLUDE_HASKELL SEL4/API/Types.lhs all_bits ONLY wordsFromBootInfo messageInfoFromWord wordFromMessageInfo\n\nend", "property": "API Type Definitions: Define and requalify various types and constants for the API, including object types, addresses, and frame types, to ensure consistency and correctness in API interactions.", "title": "./spec/design/skel/Types_H.thy", "chapter": "Types visible in the API", "section": "", "comment": ""}
{"spec": "record init_data =\n  initFreeMemory   :: \"region list\"\n  initSlotPosCur :: \"machine_word\"\n  initSlotPosMax   :: \"machine_word\"\n  initBootInfo    :: \"biframe_data\"\n  initBootInfoFrame       :: paddr\n  initKernelState :: kernel_state\n\ntype_synonym 'a kernel_init_state = \"(init_data, 'a) nondet_monad\"\n\ntranslations\n  (type) \"'c kernel_init_state\" <= (type) \"(init_data, 'c) nondet_monad\"\n\ntype_synonym 'a kernel_init = \"(init_failure + 'a) kernel_init_state\"\n\ntranslations\n  (type) \"'a kernel_init\" <= (type) \"(init_failure + 'a) kernel_init\"\n\ndefinition\n  noInitFailure :: \"'a kernel_init_state \\<Rightarrow> 'a kernel_init\"\nwhere\n  noInitFailure_def[simp]:\n  \"noInitFailure \\<equiv> liftE\"\n\n\n\ndefinition\n  doKernelOp :: \"'a kernel \\<Rightarrow> 'a kernel_init\"\nwhere\n \"doKernelOp kop \\<equiv> doE\n    ms \\<leftarrow> liftE $ gets initKernelState;\n    (r, ms') \\<leftarrow> liftE $ select_f (kop ms);\n    liftE $ modify (\\<lambda>ks. ks \\<lparr> initKernelState := ms' \\<rparr>);\n    returnOk r\n  odE\"\n\nconsts\n  itASID :: asid\n  biCapNull :: machine_word\n  biCapITTCB :: machine_word\n  biCapITCNode :: machine_word\n  biCapITPD :: machine_word\n  biCapIRQControl :: machine_word\n  biCapASIDControl :: machine_word\n  biCapITASIDPool :: machine_word\n  biCapIOPort :: machine_word\n  biCapIOSpace :: machine_word\n  biCapBIFrame :: machine_word\n  biCapITIPCBuf :: machine_word\n  biCapDynStart :: machine_word\n  biFrameSizeBits :: nat\n  nopBIFrameData :: biframe_data\n\ndefinition\n  runInit :: \"machine_word \\<Rightarrow> 'a kernel_init \\<Rightarrow> 'b kernel\"\nwhere\n  \"runInit initOffset doInit \\<equiv> do\n    ks \\<leftarrow> get;\n    initData \\<leftarrow> return \\<lparr> initFreeMemory = [],\n                   initSlotPosCur = 0,\n                   initSlotPosMax = bit (pageBits),\n                   initBootInfo = nopBIFrameData,\n                   initBootInfoFrame = 0,\n                   initKernelState = ks \\<rparr>;\n    (ret, initData') \\<leftarrow> select_f (doInit initData);\n    (case ret of\n      Inr a \\<Rightarrow> fail\n    | Inl _ \\<Rightarrow> fail)\n  od\"\n\nend", "property": "Kernel Initialization: Manage the kernel's initialization process, including setting up the initial state, executing kernel operations, and handling initialization failures, to ensure the kernel is properly configured and ready for execution.\nInitialization State Management: Maintain the initialization state, including the free memory, slot positions, boot information, and kernel state, to facilitate a controlled and efficient initialization process.", "title": "./spec/design/skel/KernelInitMonad_H.thy", "chapter": "", "section": "", "comment": "This is a similar way of getting around StateT as with the kernel\nstate, we add an extra field to the record that Haskell expects to store the\ninner monad state."}
{"spec": "requalify_consts (in Arch)\n  deleteGhost\n\ndefinition deleteRange :: \"( machine_word , 'a ) DataMap.map \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> ( machine_word , 'a ) DataMap.map\"\nwhere \"deleteRange m ptr bits \\<equiv>\n        let inRange = (\\<lambda> x. x && ((- mask bits) - 1) = fromPPtr ptr) in\n        data_map_filterWithKey (\\<lambda> x _. Not (inRange x)) m\"\n\n#INCLUDE_HASKELL SEL4/Model/PSpace.lhs decls_only Data.Map=DataMap NOT PSpace ptrBits ptrBitsForSize lookupAround maybeToMonad lookupAround2 typeError alignError alignCheck sizeCheck objBits deleteRange\n\nconsts\nlookupAround2 :: \"('k :: {linorder,finite}) \\<Rightarrow> ( 'k , 'a ) DataMap.map \\<Rightarrow> (('k * 'a) option * 'k option)\"\n\n#INCLUDE_HASKELL SEL4/Model/PSpace.lhs bodies_only Data.Map=DataMap NOT PSpace ptrBits ptrBitsForSize lookupAround maybeToMonad typeError alignError alignCheck sizeCheck objBits deletionIsSafe deletionIsSafe_delete_locale cNodePartialOverlap pointerInUserData ksASIDMapSafe deleteRange\n\nend", "property": "Delete Range from Data Map: Remove a range of entries from a data map based on a given pointer and bit size, ensuring that only entries outside the specified range are retained in the map.", "title": "./spec/design/skel/PSpaceFuns_H.thy", "chapter": "", "section": "", "comment": " Haskell expects this with Arch prefix "}
{"spec": "consts\ninsertNewCaps :: \"object_type \\<Rightarrow> machine_word \\<Rightarrow> machine_word list \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> unit kernel\"\n\nconsts\ncreateObjects :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> Structures_H.kernel_object \\<Rightarrow> nat \\<Rightarrow> machine_word list kernel\"\n\nconsts\ncreateObjects' :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> kernel_object \\<Rightarrow> nat \\<Rightarrow> unit kernel\"\n\nconsts\ncreateNewCaps :: \"object_type \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> capability list kernel\"\n\nconsts\nArch_createNewCaps :: \"object_type \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_capability list kernel\"\n\ndefs insertNewCaps_def:\n\"insertNewCaps newType srcSlot destSlots regionBase magnitudeBits dev \\<equiv> (do\n    caps \\<leftarrow> createNewCaps newType regionBase (length destSlots) magnitudeBits dev;\n    zipWithM_x (insertNewCap srcSlot) destSlots caps\n  od)\"\n\ndefs createNewCaps_def:\n\"createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    (case toAPIType t of\n          Some TCBObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject ::tcb)) 0;\n            curdom \\<leftarrow> curDomain;\n            mapM_x (\\<lambda>tptr. threadSet (tcbDomain_update (\\<lambda>_. curdom)) tptr) addrs;\n            return $ map (\\<lambda> addr. ThreadCap addr) addrs\n          od)\n        | Some EndpointObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject ::endpoint)) 0;\n            return $ map (\\<lambda> addr. EndpointCap addr 0 True True True True) addrs\n          od)\n        | Some NotificationObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject ::notification)) 0;\n            return $ map (\\<lambda> addr. NotificationCap addr 0 True True) addrs\n          od)\n        | Some ArchTypes_H.CapTableObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject ::cte)) userSize;\n            modify (\\<lambda> ks. ks \\<lparr> gsCNodes := (\\<lambda> addr.\n              if addr `~elem~` map fromPPtr addrs then Just userSize\n              else gsCNodes ks addr)\\<rparr>);\n            return $ map (\\<lambda> addr. CNodeCap addr userSize 0 0) addrs\n          od)\n        | Some ArchTypes_H.Untyped \\<Rightarrow>\n            return $ map\n                (\\<lambda> n. UntypedCap dev (regionBase + n * 2 ^ (fromIntegral userSize)) userSize 0)\n                [0  .e.  (fromIntegral numObjects) - 1]\n        | None \\<Rightarrow>   (do\n            archCaps \\<leftarrow> Arch_createNewCaps t regionBase numObjects userSize dev;\n            return $ map ArchObjectCap archCaps\n          od)\n        )\"\n\ndefs createObjects_def:\n\"createObjects ptr numObjects val gSize \\<equiv> (do\n        oBits \\<leftarrow> return ( objBitsKO val);\n        gBits \\<leftarrow> return ( oBits + gSize);\n        createObjects' ptr numObjects val gSize;\n        return (map (\\<lambda> n. (ptr + n `~shiftL~` gBits))\n                [0  .e.  (of_nat numObjects) - 1])\n  od)\"\n\ndefs createObjects'_def:\n\"createObjects' ptr numObjects val gSize\\<equiv> (do\n        oBits \\<leftarrow> return ( objBitsKO val);\n        gBits \\<leftarrow> return ( oBits + gSize);\n        unless (fromPPtr ptr && mask gBits = 0) $\n            alignError gBits;\n        ps \\<leftarrow> gets ksPSpace;\n        end \\<leftarrow> return ( fromPPtr ptr + fromIntegral ((numObjects `~shiftL~` gBits) - 1));\n        (before, _) \\<leftarrow> return ( lookupAround2 end (psMap ps));\n        (case before of\n              None \\<Rightarrow>   return ()\n            | Some (x, _) \\<Rightarrow>   haskell_assert (x < fromPPtr ptr)\n                []\n            );\n        addresses \\<leftarrow> return ( map\n                (\\<lambda> n. fromPPtr ptr + n `~shiftL~` oBits)\n                [0  .e.  (fromIntegral numObjects `~shiftL~` gSize) - 1]);\n        map' \\<leftarrow> return ( foldR\n               (\\<lambda> addr map. data_map_insert addr val map)\n               (psMap ps) addresses);\n        ps' \\<leftarrow> return ( ps \\<lparr> psMap := map' \\<rparr>);\n        modify (\\<lambda> ks. ks \\<lparr> ksPSpace := ps'\\<rparr>)\nod)\"\n\n\nend", "property": "Object Creation and Capability Insertion: Create new objects of various types (TCB, endpoint, notification, cap table, untyped) and insert their corresponding capabilities into the system. The creation process involves allocating memory, initializing the objects, and updating the system's state.\n\n Subproperties:\n- Memory Allocation: Allocate memory for the new objects, ensuring proper alignment and space requirements.\n- Object Initialization: Initialize the new objects with their respective properties and attributes.\n- Capability Creation: Create capabilities for the new objects, which are then inserted into the system.\n- System State Update: Update the system's state to reflect the creation of new objects and capabilities.", "title": "./spec/design/skel/Intermediate_H.thy", "chapter": "", "section": "", "comment": "\n * Intermediate function bodies that were once in the Haskell spec, but are\n * now no longer.\n *\n * The idea is that these \"Old Haskell\" specs allow us to have refinement as\n * follows:\n *\n *  C <---> Haskell <---> Old Haskell <---> Abstract\n *\n * This provides a stepping stone for refactoring the Haskell without breaking\n * the upper proofs until a later time.\n "}
{"spec": "(*\n   datatypes/records for the various kernel data structures.\n*)\n\nchapter \"Kernel Data Structures\"\n\ntheory Structures_H\nimports\n  Config_H\n  State_H\n  Fault_H\n  Types_H\n  ArchStructures_H\nbegin\n\narch_requalify_types (H)\n  arch_capability\n  arch_kernel_object\n  asid\n  arch_tcb\n\narch_requalify_consts (H)\n  archObjSize\n  nullPointer\n  newArchTCB\n  fromPPtr\n  PPtr\n  atcbContextGet\n  atcbContextSet\n\n#INCLUDE_HASKELL SEL4/Object/Structures.lhs decls_only NOT isNullCap isUntypedCap isIRQControlCap isReplyCap isDomainCap isNotificationCap\n#INCLUDE_HASKELL SEL4/Object/Structures.lhs bodies_only NOT kernelObjectTypeName isNullCap isUntypedCap isIRQControlCap isReplyCap isDomainCap isNotificationCap\n\n\nend", "property": "Kernel Data Structures: Define the datatypes and records for various kernel data structures, including capabilities, kernel objects, ASIDs, and TCBs, providing the foundation for the kernel's data management and organization.", "title": "./spec/design/skel/Structures_H.thy", "chapter": "Kernel Data Structures", "section": "", "comment": ""}
{"spec": "definition\n  withoutFailure :: \"'a kernel \\<Rightarrow> ('f, 'a) kernel_f\"\nwhere\n  withoutFailure_def[simp]:\n  \"withoutFailure \\<equiv> liftE\"\n\ndefinition\n  throw :: \"'f \\<Rightarrow> ('f, 'a) kernel_f\"\nwhere\n  throw_def[simp]:\n  \"throw \\<equiv> throwError\"\n\ndefinition\n  catchFailure :: \"('f, 'a) kernel_f \\<Rightarrow> ('f \\<Rightarrow> 'a kernel) \\<Rightarrow> 'a kernel\"\nwhere\n  catchFailure_def[simp]:\n \"catchFailure \\<equiv> catch\"\n\ndefinition\n  rethrowFailure :: \"('f1 \\<Rightarrow> 'f2) \\<Rightarrow> ('f1, 'a) kernel_f \\<Rightarrow> ('f2, 'a) kernel_f\"\nwhere\n \"rethrowFailure f m \\<equiv> m <handle2> (throwError \\<circ> f)\"\n\ndefinition\n  ignoreFailure :: \"( 'f , unit ) kernel_f \\<Rightarrow> unit kernel\"\nwhere\n  \"ignoreFailure x \\<equiv> (catchFailure x (const (return ())))\"\n\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures.lhs\n#INCLUDE_HASKELL SEL4/Model/Failures.lhs NOT KernelF withoutFailure catchFailure throw rethrowFailure nullCapOnFailure nothingOnFailure ignoreFailure emptyOnFailure\n\ndefinition\n  nullCapOnFailure :: \"('f, capability) kernel_f \\<Rightarrow> capability kernel\"\nwhere\n \"nullCapOnFailure m \\<equiv> m <catch> (\\<lambda>x. return NullCap)\"\n\ndefinition\n  emptyOnFailure :: \"('f, 'a list) kernel_f \\<Rightarrow> 'a list kernel\"\nwhere\n \"emptyOnFailure m \\<equiv> m <catch> (\\<lambda>x. return [])\"\n\ndefinition\n  nothingOnFailure :: \"('f, 'a option) kernel_f \\<Rightarrow> 'a option kernel\"\nwhere\n \"nothingOnFailure m \\<equiv> m <catch> (\\<lambda>x. return Nothing)\"", "property": "Fault Handling: Provides mechanisms for handling and propagating faults within the kernel, allowing for flexible error management and recovery.\n\nSubproperties:\n- Without Failure: Lifts a kernel action into a fault-handling context, assuming no faults occur.\n- Throw Fault: Explicitly throws a fault in the kernel.\n- Catch Failure: Catches and handles faults that occur during kernel actions.\n- Rethrow Failure: Transforms and re-throws faults to propagate error information.\n- Ignore Failure: Ignores faults and continues execution, returning a unit value.\n- Null Capability on Failure: Returns a null capability when a fault occurs.\n- Empty on Failure: Returns an empty list when a fault occurs.\n- Nothing on Failure: Returns nothing (an empty option) when a fault occurs.", "title": "./spec/design/skel/FaultMonad_H.thy", "chapter": "The Fault Monad", "section": "", "comment": ""}
{"spec": "type_synonym 'a kernel_p = \"(irq + 'a) kernel\"\n\ntranslations\n  (type) \"'a kernel_p\" <= (type) \"(irq + 'a) kernel\"\n\ndefinition\n  withoutPreemption :: \"'a kernel \\<Rightarrow> 'a kernel_p\"\nwhere\n  withoutPreemption_def[simp]:\n \"withoutPreemption \\<equiv> liftE\"\n\ndefinition\n  workUnitsLimit :: machine_word\nwhere\n  \"workUnitsLimit \\<equiv> 0x64\"\n\ndefinition\n  preemptionPoint :: \"unit kernel_p\"\nwhere\n  \"preemptionPoint \\<equiv> doE\n     liftE $ modifyWorkUnits (\\<lambda>u. u + 1);\n     workUnits <- liftE $ getWorkUnits;\n     whenE (workUnitsLimit <= workUnits) $ doE\n       liftE $ setWorkUnits 0;\n       preempt <- liftE $ doMachineOp (getActiveIRQ True);\n       case preempt of\n           Some irq => throwError irq\n           | None => returnOk ()\n     odE\n   odE\"\n\n\nend", "property": "Preemption Management: Manage preemption points in the kernel, ensuring that work units are tracked and preemption occurs when the work units limit is reached, allowing for efficient and controlled interrupt handling. \n\nWork Units Tracking: Increment work units, check if the work units limit is reached, and reset work units when necessary. \n\nPreemption Point Handling: Handle preemption points by checking for active IRQs and throwing an error if an IRQ is present, or returning successfully if no IRQ is present.", "title": "./spec/design/skel/FaultMonad_H.thy", "chapter": "The Fault Monad", "section": "", "comment": ""}
{"spec": "chapter \"Notifications\"\n\ntheory Notification_H imports    \"NotificationDecls_H\"\n    \"TCB_H\"\n  TCB_H\n  ThreadDecls_H\n  CSpaceDecls_H\n  ObjectInstances_H\nbegin\n\narch_requalify_consts (H)\n  badgeRegister\n\n#INCLUDE_HASKELL SEL4/Object/Notification.lhs bodies_only\n\nend", "property": "Notification Management: Provides functionality for managing notifications, allowing threads to interact with each other through asynchronous signals.", "title": "./spec/design/skel/Notification_H.thy", "chapter": "Notifications", "section": "", "comment": ""}
{"spec": "chapter \"Endpoints\"\n\ntheory Endpoint_H\nimports\n  EndpointDecls_H\n  TCB_H\n  ThreadDecls_H\n  CSpaceDecls_H\n  FaultHandlerDecls_H\n  Notification_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Endpoint.lhs bodies_only\n\nend", "property": "Endpoint Management: Provides a mechanism for managing endpoints, which are used for inter-thread communication.", "title": "./spec/design/skel/Endpoint_H.thy", "chapter": "Endpoints", "section": "", "comment": ""}
{"spec": "chapter \"Function Declarations for CSpace\"\n\ntheory CSpaceDecls_H\nimports FaultMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/CSpace.lhs decls_only\n\nend", "property": "Function Declarations for CSpace: Provides function declarations for Capability Space (CSpace) management, enabling the kernel to manage and manipulate capabilities efficiently.", "title": "./spec/design/skel/CSpaceDecls_H.thy", "chapter": "Function Declarations for CSpace", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (aliasing, H)\n  gpRegisters\n  frameRegisters\n  tlsBaseRegister\n\nabbreviation \"mapMaybe \\<equiv> option_map\"\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= bodies_only NOT liftFnMaybe assertDerived archThreadGet archThreadSet asUser sanitiseRegister getSanitiseRegisterInfo\n\ndefs asUser_def:\n\"asUser tptr f\\<equiv> (do\n        uc \\<leftarrow> threadGet  (atcbContextGet o tcbArch) tptr;\n        (a, uc') \\<leftarrow> select_f (f uc);\n        threadSet (\\<lambda> tcb. tcb \\<lparr> tcbArch := atcbContextSet uc' (tcbArch tcb)\\<rparr>) tptr;\n        return a\nod)\"\n\nend", "property": "Requalify Abstract Spec Constants: Overwrite previously defined abstract spec constants with design spec versions for architecture-dependent values, ensuring consistency and accuracy in the specification.\n\nThread Context Management: Manage the context of a thread, allowing for getting and setting the thread's architecture-specific context, and executing a function as a specific user, ensuring proper thread state management and execution.", "title": "./spec/design/skel/TCB_H.thy", "chapter": "", "section": "", "comment": " clobbers previously requalified abstract spec constants with design spec versions "}
{"spec": "requalify_consts\n  cteRightsBits cteGuardBits", "property": "Requalify Constants: Ensure compatibility with Haskell by requalifying constants cteRightsBits and cteGuardBits under the Arch module.", "title": "./spec/design/skel/Retype_H.thy", "chapter": "", "section": "", "comment": " match Haskell, expects these under Arch. "}
{"spec": "requalify_consts (aliasing)\n  deriveCap finaliseCap postCapDeletion isCapRevocable\n  hasCancelSendRights sameRegionAs isPhysicalCap\n  sameObjectAs updateCapData maskCapRights\n  createObject capUntypedPtr capUntypedSize\n  performInvocation decodeInvocation prepareThreadDelete\n\ncontext begin global_naming global\n\nrequalify_consts (aliasing)\n  RetypeDecls_H.deriveCap RetypeDecls_H.finaliseCap RetypeDecls_H.postCapDeletion\n  RetypeDecls_H.isCapRevocable\n  RetypeDecls_H.hasCancelSendRights RetypeDecls_H.sameRegionAs RetypeDecls_H.isPhysicalCap\n  RetypeDecls_H.sameObjectAs RetypeDecls_H.updateCapData RetypeDecls_H.maskCapRights\n  RetypeDecls_H.createObject RetypeDecls_H.capUntypedPtr RetypeDecls_H.capUntypedSize\n  RetypeDecls_H.performInvocation RetypeDecls_H.decodeInvocation\nend\n\nend\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType.lhs Arch=Arch bodies_only\n\nend", "property": "Disambiguate Name Clash: Resolve naming conflicts between architecture-specific and non-architecture-specific constants with identical names by requalifying the constants to ensure unique references.", "title": "./spec/design/skel/Retype_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "(*\n    VSpace lookup code.\n*)\n\ntheory VSpace_H\nimports\n  CNode_H\n  ArchVSpace_H\n  KernelInitMonad_H\nbegin\n\narch_requalify_consts (H)\n  mapKernelWindow\n  activateGlobalVSpace\n  initIRQController\n  createIPCBufferFrame\n  createBIFrame\n  createFramesOfRegion\n  createITPDPTs\n  writeITPDPTs\n  createITASIDPool\n  writeITASIDPool\n  createDeviceFrames\n  handleVMFault\n  isValidVTableRoot\n  checkValidIPCBuffer\n  lookupIPCBuffer\n  vptrFromPPtr\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace.lhs Arch= ONLY initKernelVM initPlatform initCPU\n\nend", "property": "Virtual Space Management: Initializes and manages the virtual space for the kernel, including mapping kernel windows, activating global virtual spaces, creating frames for IPC buffers, and handling VM faults, ensuring the kernel's virtual memory is properly set up and maintained.", "title": "./spec/design/skel/VSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "requalify_consts\n  checkIRQ\n  handleReservedIRQ\n  maskIrqSignal", "property": "IRQ Management: Provides functions to check, handle, and mask IRQ signals, ensuring proper interrupt handling and management in the system.", "title": "./spec/design/skel/Interrupt_H.thy", "chapter": "", "section": "", "comment": " match Haskell, expects these under Arch. "}
{"spec": "requalify_consts (aliasing)\n  decodeIRQControlInvocation\n  invokeIRQHandler\n  performIRQControl\n  initInterruptController\n\ncontext begin global_naming global\nrequalify_consts (aliasing)\n  InterruptDecls_H.decodeIRQControlInvocation\n  InterruptDecls_H.invokeIRQHandler\n  InterruptDecls_H.performIRQControl\n  InterruptDecls_H.initInterruptController\n\nend\nend", "property": "Resolve Name Clashes: Disambiguate naming conflicts between architecture-specific and non-architecture-specific constants with identical names, ensuring clear and distinct references to each constant.", "title": "./spec/design/skel/Interrupt_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "arch_requalify_consts (aliasing, H)\n  maxIRQ\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs\n#INCLUDE_HASKELL SEL4/Object/Interrupt.lhs bodies_only\n\nend", "property": "Interrupt Configuration: Override the kernel configuration constant for the maximum number of interrupts (maxIRQ) with a constrained value from the hardware configuration.", "title": "./spec/design/skel/Interrupt_H.thy", "chapter": "", "section": "", "comment": " override Kernel_Config const with constrained abbreviation from Hardware_H "}
{"spec": "#INCLUDE_HASKELL SEL4/API/Syscall.lhs ONLY Event Syscall\n\nend", "property": "User-Level and Machine-Generated Events: The kernel reacts to user-level and machine-generated events, which are categorized as system calls.", "title": "./spec/design/skel/Event_H.thy", "chapter": "", "section": "", "comment": "\n  \\label{sec:Event_H}\n\n  These are the user-level and machine generated events the kernel reacts to.\n"}
{"spec": "theory Config_H\nimports Types_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Config.lhs NOT numDomains timeSlice resetChunkBits retypeFanOutLimit\n\nend", "property": "System Configuration: Define fundamental system configuration parameters, including the number of domains, time slice, reset chunk bits, and retype fan-out limit. These parameters determine the basic operating characteristics of the system.", "title": "./spec/design/skel/Config_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"System Calls\"\n\ntheory Syscall_H\nimports Kernel_H Event_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Model/Syscall.lhs\n#INCLUDE_HASKELL SEL4/API/Syscall.lhs decls_only NOT Event Syscall\n#INCLUDE_HASKELL SEL4/API/Syscall.lhs bodies_only\n\nend", "property": "System Call Execution: Provides a mechanism for applications to interact with the kernel, allowing them to request services and execute system calls.", "title": "./spec/design/skel/Syscall_H.thy", "chapter": "System Calls", "section": "", "comment": ""}
{"spec": "type_synonym ready_queue = tcb_queue", "property": "Kernel State: The kernel maintains a ready queue, which is a queue of threads that are ready to be executed.", "title": "./spec/design/skel/KernelStateData_H.thy", "chapter": "Kernel State and Monads", "section": "", "comment": ""}
{"spec": "record kernel_state =\n  ksPSpace             :: pspace\n  gsUserPages          :: \"machine_word \\<Rightarrow> vmpage_size option\"\n  gsCNodes             :: \"machine_word \\<Rightarrow> nat option\"\n  gsUntypedZeroRanges  :: \"(machine_word \\<times> machine_word) set\"\n  gsMaxObjectSize      :: nat\n  ksDomScheduleIdx     :: nat\n  ksDomSchedule        :: \"(domain \\<times> machine_word) list\"\n  ksCurDomain          :: domain\n  ksDomainTime         :: machine_word\n  ksReadyQueues        :: \"domain \\<times> priority \\<Rightarrow> ready_queue\"\n  ksReadyQueuesL1Bitmap :: \"domain \\<Rightarrow> machine_word\"\n  ksReadyQueuesL2Bitmap :: \"domain \\<times> nat \\<Rightarrow> machine_word\"\n  ksCurThread          :: machine_word\n  ksIdleThread         :: machine_word\n  ksSchedulerAction    :: scheduler_action\n  ksInterruptState     :: interrupt_state\n  ksWorkUnitsCompleted :: machine_word\n  ksArchState          :: Arch.kernel_state\n  ksMachineState       :: machine_state\n\ncontext Arch begin\ncontext begin global_naming global\nrequalify_types KernelStateData_H.kernel_state\nend\nend\n\ntype_synonym 'a kernel = \"(kernel_state, 'a) nondet_monad\"\n\ntranslations\n  (type) \"'c kernel\" <= (type) \"(kernel_state, 'c) nondet_monad\"", "property": "Kernel State Structure: The kernel state is a record that contains various components, including the process space, user pages, CNodes, untyped zero ranges, maximum object size, domain schedule, current domain, domain time, ready queues, current thread, idle thread, scheduler action, interrupt state, work units completed, architecture-specific state, and machine state. This structure encapsulates the essential data for managing the kernel's operation and interactions with the machine.\n\nKernel Monad: The kernel monad is a type synonym for a nondeterministic monad that operates on the kernel state, providing a way to express kernel functions that interact with and modify the kernel state.", "title": "./spec/design/skel/KernelStateData_H.thy", "chapter": "Kernel State and Monads", "section": "", "comment": "We pull a fast one on haskell here ... although Haskell expects\na KernelMonad which is a StateT monad in KernelData that wraps a MachineMonad,\nwe push the extra MachineMonad data into the KernelState. Fortunately the\nupdate and accessor functions all still work."}
{"spec": "definition\n  doMachineOp :: \"(machine_state, 'a) nondet_monad  \\<Rightarrow> 'a kernel\"\nwhere\n \"doMachineOp mop \\<equiv> do\n    ms \\<leftarrow> gets ksMachineState;\n    (r, ms') \\<leftarrow> select_f (mop ms);\n    modify (\\<lambda>ks. ks \\<lparr> ksMachineState := ms' \\<rparr>);\n    return r\n  od\"\n\n#INCLUDE_HASKELL SEL4/Model/StateData.lhs decls_only ONLY capHasProperty ksReadyQueues_asrt ready_qs_runnable idleThreadNotQueued\n#INCLUDE_HASKELL SEL4/Model/StateData.lhs NOT doMachineOp KernelState ReadyQueue Kernel assert stateAssert findM funArray newKernelState capHasProperty ksReadyQueues_asrt ready_qs_runnable idleThreadNotQueued\n\nend", "property": "Kernel State Management: Ensure that kernel functions correctly manage the kernel state by performing machine operations, accessing and modifying kernel state components, and maintaining the integrity of kernel data structures.\n\nSubproperties:\n- Machine Operation Execution: Execute machine operations and update the kernel state accordingly.\n- Kernel State Access and Modification: Provide controlled access to kernel state components and ensure that modifications are correctly applied.\n- Kernel Data Structure Integrity: Maintain the consistency and correctness of kernel data structures, such as ready queues and capability properties.", "title": "./spec/design/skel/KernelStateData_H.thy", "chapter": "Kernel State and Monads", "section": "", "comment": ""}
{"spec": "chapter \"Function Declarations for TCBs\"\n\ntheory TCBDecls_H\nimports FaultMonad_H Invocations_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs decls_only \\\n  NOT archThreadGet archThreadSet sanitiseRegister getSanitiseRegisterInfo\n\nend", "property": "Function Declarations for TCBs: Provides function declarations for Thread Control Blocks (TCBs), including operations for getting and setting thread state, handling faults, and invoking TCB-related actions.", "title": "./spec/design/skel/TCBDecls_H.thy", "chapter": "Function Declarations for TCBs", "section": "", "comment": ""}
{"spec": "chapter \"Kernel\"\n\ntheory Kernel_H\nimports\n  KernelInit_H\n  Thread_H\n  FaultHandler_H\n  CSpace_H\n  Hypervisor_H\nbegin\nend", "property": "Kernel Structure: The kernel is composed of multiple components, including initialization, thread management, fault handling, capability space management, and hypervisor management, which together provide the foundation for the operating system's functionality.", "title": "./spec/design/skel/Kernel_H.thy", "chapter": "Kernel", "section": "", "comment": ""}
{"spec": "chapter \"Function Declarations for Endpoints\"\n\ntheory EndpointDecls_H\nimports FaultMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Endpoint.lhs decls_only\n\nend", "property": "Function Declarations for Endpoints: Declare functions for endpoint operations, providing a foundation for implementing endpoint-related functionality in the kernel.", "title": "./spec/design/skel/EndpointDecls_H.thy", "chapter": "Function Declarations for Endpoints", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (aliasing, H)\n  syscallMessage\n  exceptionMessage\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures.lhs\n\n#INCLUDE_HASKELL SEL4/Kernel/FaultHandler.lhs bodies_only\n#INCLUDE_HASKELL SEL4/API/Faults.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults.lhs bodies_only\n\nend", "property": "Requalify Abstract Spec Constants: Overwrite previously defined abstract spec constants with their design spec versions for syscallMessage and exceptionMessage.", "title": "./spec/design/skel/FaultHandler_H.thy", "chapter": "", "section": "", "comment": " clobbers previously requalified abstract spec constants with design spec versions "}
{"spec": "(*\n    Declarations from SEL4.Kernel.FaultHandler\n*)\n\nchapter \"Function Declarations for Fault Handlers\"\n\ntheory FaultHandlerDecls_H\nimports Structures_H FaultMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/FaultHandler.lhs decls_only\n\nend", "property": "Function Declarations for Fault Handlers: Declare functions for handling faults in the kernel, providing a foundation for implementing fault handling mechanisms.", "title": "./spec/design/skel/FaultHandlerDecls_H.thy", "chapter": "Function Declarations for Fault Handlers", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4.lhs decls_only NOT callKernel\n\n#INCLUDE_HASKELL SEL4.lhs NOT kernelExitAssertions fastpathKernelAssertions\n\nend", "property": "API Module Collection: Collects and integrates all API modules, ensuring a unified interface for kernel interactions.", "title": "./spec/design/skel/API_H.thy", "chapter": "", "section": "", "comment": "collects all API modules"}
{"spec": "chapter \"Initialisation\"\n\ntheory KI_Decls_H\nimports\n  ThreadDecls_H\n  KernelInitMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/Init.lhs decls_only NOT isAligned funArray newKernelState distinct rangesBy doKernelOp runInit\n\nend", "property": "Kernel Initialisation: Establish the initial state of the kernel, defining the necessary data structures and configurations for kernel operation.", "title": "./spec/design/skel/KI_Decls_H.thy", "chapter": "Initialisation", "section": "", "comment": ""}
{"spec": "chapter \"Untyped Objects\"\n\ntheory Untyped_H\nimports\n  RetypeDecls_H\n  CSpaceDecls_H\n  CNode_H\n  Invocations_H\n  InvocationLabels_H\n  Config_H\nbegin\n\narch_requalify_consts (H)\n  minUntypedSizeBits\n  maxUntypedSizeBits\n\nconsts\n  cNodeOverlap :: \"(machine_word \\<Rightarrow> nat option) \\<Rightarrow> (machine_word \\<Rightarrow> bool) \\<Rightarrow> bool\"\n\n#INCLUDE_HASKELL SEL4/Object/Untyped.lhs decls_only ONLY archOverlap\n\n#INCLUDE_HASKELL SEL4/Object/Untyped.lhs NOT cNodeOverlap canonicalAddressAssert archOverlap\n\nend", "property": "Untyped Objects Management: Provide definitions and constants for managing untyped objects, including minimum and maximum size bits, and functions for checking overlap with CNodes and asserting canonical addresses.", "title": "./spec/design/skel/Untyped_H.thy", "chapter": "Untyped Objects", "section": "", "comment": ""}
{"spec": "context Arch begin\nrequalify_facts (aliasing)\n   newKernelState_def\nrequalify_consts (aliasing)\n   newKernelState\n\ncontext begin global_naming global\nrequalify_facts (aliasing)\n   KernelInit_H.newKernelState_def\nrequalify_consts (aliasing)\n   KernelInit_H.newKernelState\nend\nend\n\nend", "property": "Name Disambiguation: Disambiguate name clashes between architecture-specific and non-architecture-specific constants with the same names.", "title": "./spec/design/skel/KernelInit_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/ARM.hs\n\nend (* context Arch *)\n\nend", "property": "Arch-Specific Ghost Update Functions: Provide functions for updating the ghost state of physical memory, specific to the ARM architecture.", "title": "./spec/design/skel/ARM/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/ARM.lhs CONTEXT Arch decls_only\n\nend\nend", "property": "Function Declarations for Threads: Provide function declarations for thread-related operations, importing necessary structures, fault monads, and kernel initialization monads, and establishing the context for architecture-specific thread declarations.", "title": "./spec/design/skel/ARM/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify ARM_H (in Arch)\ninstantiation ARM_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [PageDirectoryObject,\n      SmallPageObject,\n      LargePageObject,\n      SectionObject,\n      SuperSectionObject,\n      PageTableObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation ARM_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation ARM_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Define an enumeration of object types, including API object types and architecture-specific object types such as page directories, page tables, and various page objects, ensuring that all object types are distinct and can be exhaustively checked.\n\nSubproperties:\n\n* Enum Class Definition: Define an enumeration class for object types, allowing for checking of properties across all object types.\n* Exhaustive Checking: Enable exhaustive checking of properties across all object types using the enum_all and enum_ex definitions.\n* Alternative Enumeration: Define an alternative enumeration of object types using the alt_from_ord function, providing an additional way to iterate over object types.\n* Enumeration Consistency: Ensure consistency between the enum and enum_alt definitions, allowing for seamless switching between the two.", "title": "./spec/design/skel/ARM/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/ARM.lhs CONTEXT ARM_H NOT ArmVSpaceRegionUse\n\nend\n\nend", "property": "Architecture Specific Kernel State: Defines the architecture-specific kernel state and monads, incorporating necessary imports for SEL4.Model.", "title": "./spec/design/skel/ARM/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_H bodies_only\n\n\nend\nend", "property": "No properties can be extracted from the given code as it does not contain any specific functionality or logic, only import statements and comments.", "title": "./spec/design/skel/ARM/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation ARM_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pde updateObject_pde\n  loadObject_pte updateObject_pte\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Object Management: Create, load, and update ASID pool objects with a fixed-size array of 2^32 entries, initialized with null values, ensuring efficient management of address space identifiers.", "title": "./spec/design/skel/ARM/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Main Setup_Locale\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/ARM.lhs CONTEXT ARM_H ONLY ArmVSpaceRegionUse\n\nend\nend", "property": "Architecture-Specific Data Types: Define data types specific to a particular architecture, such as ARM, to be shared by specification and abstraction.", "title": "./spec/design/skel/ARM/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  Untyped_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/ARM.lhs CONTEXT ARM_H bodies_only ArchInv=ArchRetypeDecls_H.ARM ArchLabels=ArchInvocationLabels_H.ARM NOT checkPDAt checkPTAt checkPDASIDMapMembership checkValidMappingSize vptrFromPPtr\n\ndefs checkValidMappingSize_def:\n  \"checkValidMappingSize sz \\<equiv> stateAssert\n    (\\<lambda>s. 2 ^ pageBitsForSize sz <= gsMaxObjectSize s) []\"\n\nend\nend", "property": "Valid Mapping Size: Ensure that the mapping size is valid by checking if the page size corresponding to the given size is less than or equal to the maximum object size in the current state.", "title": "./spec/design/skel/ARM/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/ARM.lhs RegisterSet= CONTEXT ARM_H\n\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\nend\nend", "property": "No properties can be extracted from this code as it appears to be a setup or configuration file for a larger system, and does not contain any specific functional or behavioral descriptions that can be summarized as properties.", "title": "./spec/design/skel/ARM/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchVSpaceDecls_H\nimports ArchRetypeDecls_H InvocationLabels_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT ARM_H\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/ARM.lhs CONTEXT ARM_H decls_only ArchInv=\n\nend\nend", "property": "Retype Objects: Allow the kernel to retype objects, modifying their internal structure and properties to adapt to changing system requirements.", "title": "./spec/design/skel/ARM/ArchVSpaceDecls_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "definition\n  canonicalAddressAssert :: \"machine_word => bool\" where\n  canonicalAddressAssert_def[simp]:\n  \"canonicalAddressAssert p = True\"\n\nend", "property": "Canonical Address Assertion: Always returns true, indicating that the address is canonical, regardless of the architecture.", "title": "./spec/design/skel/ARM/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/ARM.lhs CONTEXT ARM_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Define a set of labels for architecture-specific system calls.", "title": "./spec/design/skel/ARM/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/ARM.lhs CONTEXT ARM_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch Invocation Label Requalification: Requalify the invocation labels for the ARM architecture to ensure correct enumeration and instance proofs.", "title": "./spec/design/skel/ARM/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext ((K 0) aLU initContext)\"\n\nend\nend", "property": "Initial Register Context: The system initializes a new user context with all registers set to zero.", "title": "./spec/design/skel/ARM/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/ARM.lhs\n\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs bodies_only\n\nend\n\n\nend", "property": "Fault Handler Management: Define the architecture-specific fault handlers for the ARM architecture, providing the necessary functions and data structures to manage faults and exceptions in the system.", "title": "./spec/design/skel/ARM/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_H decls_only\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_H instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_H bodies_only\n\ndatatype arch_kernel_object_type =\n    PDET\n  | PTET\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPDE e) = PDET\"\n| \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend\nend", "property": "Architectural Object Classification: Classify architectural kernel objects into distinct types, including Page Directory Entries (PDET), Page Table Entries (PTET), and ASID Pool objects (ASIDPoolT), to facilitate proper management and handling of these objects within the kernel.", "title": "./spec/design/skel/ARM/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=ARM CONTEXT ARM_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Memory and Pointer Management: Define the basic operations and types for managing memory and pointers in the system, including the definition of word bits, pointer types (PPtr), and the null pointer constant. Ensure that the system can correctly represent and manipulate memory addresses and pointers. \n\nPointer Conversion: Provide functions to convert between different pointer types, specifically the identity functions PPtr and fromPPtr, which enable the system to map between machine words and physical pointers.", "title": "./spec/design/skel/ARM/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs Arch= CONTEXT ARM_H bodies_only ArchInv=\n\nend\nend", "property": "No property can be summarized from the given code as it appears to be a header or import section, and does not contain any specific functionality or behavior that can be described as a property.", "title": "./spec/design/skel/ARM/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  KI_Decls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/ARM.lhs CONTEXT ARM_H Arch.Types= ArchInv= bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/ARM.lhs bodies_only CONTEXT ARM_H NOT isPDFlushLabel isPageFlushLabel\n\nend\nend", "property": "Retype Objects: Allow the kernel to retype objects, changing their type and purpose, while maintaining the integrity and consistency of the system's object model and memory management.", "title": "./spec/design/skel/ARM/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewPageCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        when (\\<not>dev) $\n          mapM_x (\\<lambda>addr. doMachineOp $\n                            cleanCacheRange_RAM addr\n                                                (addr + mask (pageBitsForSize pSize))\n                                                (addrFromPPtr addr)) addrs;\n        return $ map (\\<lambda>n. PageCap dev (PPtr (fromPPtr n)) VMReadWrite pSize Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects tableBits objectProto cap initialiseMappings \\<equiv> (do\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      initialiseMappings pts;\n      mapM_x (\\<lambda>addr. doMachineOp $\n                       cleanCacheRange_PoU addr (addr + mask tableBits) (addrFromPPtr addr)) addrs;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 0 ARMSmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 4 ARMLargePage\n        | SectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 8 ARMSection\n        | SuperSectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 12 ARMSuperSection\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects ptBits (makeObject::pte) PageTableCap\n              (\\<lambda>pts. return ())\n        | PageDirectoryObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pdBits (makeObject::pde) PageDirectoryCap\n              (\\<lambda>pds. do objSize \\<leftarrow> return (((1::nat) `~shiftL~` pdBits));\n                        mapM_x copyGlobalMappings pds\n                     od)\n        )\"\n\nend\nend\n\nend", "property": "Create New Capability Objects: Supports the creation of new capability objects for various object types, including small, large, section, and super section pages, as well as page tables and directories. The creation process involves allocating memory, initializing the object's properties, and cleaning the cache. For page tables and directories, it also involves initializing mappings and copying global mappings.", "title": "./spec/design/skel/ARM/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/ARM.lhs CONTEXT ARM_H ARMHardware=ARM bodies_only\n\nend\nend", "property": "No specific property can be summarized from the given code snippet as it appears to be a header or import section, and does not contain any specific functionality or behavior that can be described as a property.", "title": "./spec/design/skel/ARM/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/API/Invocation/ARM.lhs CONTEXT ARM_H ONLY isPDFlushLabel isPageFlushLabel\n\nend\nend", "property": "Arch-Specific Invocation Label Checks: Identify whether an invocation label corresponds to a PD flush or page flush on the ARM architecture.", "title": "./spec/design/skel/ARM/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": "\n  Arch-specific functions on invocation labels\n"}
{"spec": "(*\n  Hypervisor stub for ARM\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  KI_Decls_H\n  InterruptDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_H decls_only ArchInv= ArchLabels=\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_H bodies_only ArchInv= ArchLabels=\n\nend\nend", "property": "Hypervisor Stub for ARM: Provides a basic framework for a hypervisor on the ARM architecture, defining necessary structures and functions for managing the interaction between the kernel and the hypervisor.", "title": "./spec/design/skel/ARM/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs CONTEXT ARM_H decls_only ArchInv=\n\nend\n\nend", "property": "No property can be summarized from the given code as it appears to be a header or import statement and does not contain any specific functionality or behavior that can be described as a property.", "title": "./spec/design/skel/ARM/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs Platform=Platform.ARM CONTEXT ARM_H NOT getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory writeTTBR0 setGlobalPD  setTTBCR setHardwareASID invalidateLocalTLB invalidateLocalTLB_ASID invalidateLocalTLB_VAASID cleanByVA cleanByVA_PoU invalidateByVA invalidateByVA_I invalidate_I_PoU cleanInvalByVA branchFlush clean_D_PoU cleanInvalidate_D_PoC cleanInvalidate_D_PoU cleanInvalidateL2Range invalidateL2Range cleanL2Range isb dsb dmb getIFSR getDFSR getFAR HardwareASID wordFromPDE wordFromPTE VMFaultType VMPageSize HypFaultType pageBits pageBitsForSize toPAddr cacheLineBits cacheLine lineStart cacheRangeOp cleanCacheRange_PoC cleanInvalidateCacheRange_RAM cleanCacheRange_RAM cleanCacheRange_PoU invalidateCacheRange_RAM invalidateCacheRange_I branchFlushRange cleanCaches_PoU cleanInvalidateL1Caches addrFromPPtr ptrFromPAddr initIRQController setIRQTrigger MachineData paddrBase pptrBase pptrTop paddrTop kernelELFPAddrBase kernelELFBase kernelELFBaseOffset pptrBaseOffset addrFromKPPtr\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_H instanceproofs NOT HardwareASID VMFaultType VMPageSize HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_H ONLY wordFromPDE wordFromPTE", "property": "Hardware Abstraction: Provides an abstract interface to the underlying hardware, allowing the kernel to interact with the machine in a platform-agnostic manner. This includes operations for memory management, interrupt handling, timer configuration, and cache maintenance.\n\nMemory Management: Allows the kernel to manage memory regions, including device regions, kernel devices, and memory allocation and deallocation.\n\nInterrupt Handling: Provides functions for getting and acknowledging active interrupts, masking interrupts, and resetting timers.\n\nCache Maintenance: Offers operations for cleaning and invalidating caches, including by virtual address, address space identifier, and cache range.\n\nTimer Configuration: Allows the kernel to configure and reset timers.\n\nDebugging: Provides a function for debug printing.\n\nMemory Access: Includes functions for loading and storing words, as well as getting and setting memory regions.\n\nAddress Translation: Offers functions for translating between physical and virtual addresses.\n\nInitialization: Provides functions for initializing memory, IRQ controllers, and other hardware components.\n\nPlatform-Specific Definitions: Defines various platform-specific constants and types, such as page sizes, cache line sizes, and hardware ASID types.", "title": "./spec/design/skel/ARM/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ == Kernel_Config.maxIRQ\"", "property": "IRQ Range Limitation: The maximum IRQ value is defined as a generic numeral in Kernel_Config and is denoted as maxIRQ.", "title": "./spec/design/skel/ARM/Hardware_H.thy", "chapter": "", "section": "", "comment": " Kernel_Config provides a generic numeral, Haskell expects type irq "}
{"spec": "abbreviation (input) initIRQController where\n  \"initIRQController \\<equiv> ARM.initIRQController\"\n\nend\nend", "property": "Initialization of IRQ Controller: The ARM IRQ controller is initialized using the ARM.initIRQController function, ensuring proper setup and configuration of interrupt handling on the ARM architecture.", "title": "./spec/design/skel/ARM/Hardware_H.thy", "chapter": "", "section": "", "comment": " provide ARM/ARM_HYP machine op in _H global_prefix for arch-split "}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/X64.hs\n\nend (* context Arch *)\n\nend", "property": "Arch-Specific Ghost Update Functions: Provide functions for updating the ghost state of physical memory, specific to the X64 architecture.", "title": "./spec/design/skel/X64/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/X64.lhs CONTEXT X64_H decls_only\n\nend (* context X64 *)\n\nend", "property": "Function Declarations for Threads: Provide the function declarations necessary for managing threads in the kernel, including those related to thread creation, management, and execution.", "title": "./spec/design/skel/X64/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify X64_H (in Arch)\ninstantiation X64_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [PDPointerTableObject,\n      PML4Object,\n      HugePageObject,\n      SmallPageObject,\n      LargePageObject,\n      PageTableObject,\n      PageDirectoryObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation X64_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation X64_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Provides an enumeration of object types, including API object types and architecture-specific object types such as page tables, page directories, and large page objects. Ensures that object types are distinct and can be exhaustively listed, enabling efficient and accurate object type management.", "title": "./spec/design/skel/X64/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "chapter \"ArchHook\"\n\ntheory ArchHook_H\nimports KernelStateData_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  cEntryHook :: \"unit kernel\"\nwhere\n  \"cEntryHook\\<equiv> return ()\"\n\ndefinition\n  cExitHook :: \"unit kernel\"\nwhere\n  \"cExitHook\\<equiv> return ()\"\n\nend\nend", "property": "ArchHooks: Provide hooks for architecture-specific entry and exit points in the kernel. \n\nEntry Hook: No operation is performed when entering the kernel.\nExit Hook: No operation is performed when exiting the kernel.", "title": "./spec/design/skel/X64/ArchHook_H.thy", "chapter": "ArchHook", "section": "", "comment": ""}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/X64.lhs CONTEXT X64_H NOT X64VSpaceRegionUse\n\nend\nend", "property": "Architecture Specific Kernel State: Defines the architecture-specific kernel state and monads, providing the necessary structures and types for the kernel's operation on a specific architecture.", "title": "./spec/design/skel/X64/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/Failures/X64.lhs CONTEXT X64_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/X64.lhs CONTEXT X64_H bodies_only\n\nend\nend", "property": "No specific property can be summarized from the given code snippet as it appears to be a setup or configuration section for the ArchFault_H theory, importing necessary modules and including Haskell files, without defining any specific functionality or behavior.", "title": "./spec/design/skel/X64/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation X64_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pte updateObject_pte\n  loadObject_pde updateObject_pde\n  loadObject_pdpte updateObject_pdpte\n  loadObject_pml4e updateObject_pml4e\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Object Management: Create, load, and update ASID pool objects with a fixed-size array of 2^32 entries, initialized with null values, ensuring efficient management of address space identifiers.", "title": "./spec/design/skel/X64/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Main Setup_Locale\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/X64.lhs CONTEXT X64_H ONLY X64VSpaceRegionUse\n\nend (* context X64 *)\n\nend", "property": "Architecture-Specific Data Types: Define data types specific to the X64 architecture, shared by specification and abstraction, to facilitate accurate modeling and analysis of architecture-dependent components.", "title": "./spec/design/skel/X64/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  Untyped_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/X64.lhs CONTEXT X64_H bodies_only ArchInv=ArchRetypeDecls_H NOT checkPML4At checkPDPTAt checkPDAt checkPTAt checkValidMappingSize\n#INCLUDE_HASKELL SEL4/Object/IOPort/X64.lhs CONTEXT X64_H bodies_only ArchInv=ArchRetypeDecls_H\n\ndefs checkValidMappingSize_def:\n  \"checkValidMappingSize sz \\<equiv> stateAssert\n    (\\<lambda>s. 2 ^ pageBitsForSize sz <= gsMaxObjectSize s) []\"\n\nend\n\nend", "property": "Valid Mapping Size: Ensure that the mapping size is valid by checking if the page size corresponding to the given size is less than or equal to the maximum object size in the current state.", "title": "./spec/design/skel/X64/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/X64.lhs RegisterSet= CONTEXT X64_H\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\nend\nend", "property": "Architectural TCB Management: Provide architectural-specific TCB (Thread Control Block) management functions, including getting and setting thread registers, for the X64 architecture.", "title": "./spec/design/skel/X64/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchVSpaceDecls_H\nimports ArchRetypeDecls_H InvocationLabels_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT X64_H\n#INCLUDE_HASKELL_PREPARSE SEL4/API/InvocationLabels/X64.lhs CONTEXT X64\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/X64.lhs CONTEXT X64_H decls_only ArchInv=\n#INCLUDE_HASKELL SEL4/Object/IOPort/X64.lhs CONTEXT X64_H decls_only ArchInv=\n\nend (* context X64 *)\n\nend", "property": "Retype Objects: Allow the kernel to retype objects, modifying their type and structure to accommodate different uses and requirements, while maintaining the integrity and consistency of the system's object model.", "title": "./spec/design/skel/X64/ArchVSpaceDecls_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "definition\n  canonicalAddressAssert :: \"machine_word => bool\" where\n  canonicalAddressAssert_def[simp]:\n  \"canonicalAddressAssert p = True\"\n\nend", "property": "Canonical Address Assertion: Always returns true, indicating that the address is canonical, regardless of the architecture.", "title": "./spec/design/skel/X64/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/X64.lhs CONTEXT X64_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Define an enumeration of system call labels specific to the x64 architecture.", "title": "./spec/design/skel/X64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/X64.lhs CONTEXT X64_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch Invocation Label Requalification: Requalify the invocation labels for the X64 architecture to ensure correct instance proofs.", "title": "./spec/design/skel/X64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext FPUNullState ((K 0) aLU initContext)\"\n\nend\nend", "property": "Initial Register State: The initial register state is defined as a new user context with FPU state set to null and all registers initialized to zero.", "title": "./spec/design/skel/X64/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/X64.lhs\n\n#INCLUDE_HASKELL SEL4/API/Faults/X64.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/X64.lhs bodies_only\n\nend\n\nend", "property": "Fault Handler Management: Define and manage fault handlers for the X64 architecture, ensuring proper handling of faults and errors within the system.", "title": "./spec/design/skel/X64/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/X64.lhs CONTEXT X64_H decls_only\n#INCLUDE_HASKELL SEL4/Object/Structures/X64.lhs CONTEXT X64_H instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/X64.lhs CONTEXT X64_H bodies_only\n\ndatatype arch_kernel_object_type =\n    PDET\n  | PTET\n  | PDPTET\n  | PML4ET\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPDE e) = PDET\"\n| \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOPDPTE e) = PDPTET\"\n| \"archTypeOf (KOPML4E e) = PML4ET\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend\nend", "property": "Architectural Object Classification: Classify architectural kernel objects into distinct types, including Page Directory Entries (PDET), Page Table Entries (PTET), Page Directory Pointer Table Entries (PDPTET), Page Map Level 4 Entries (PML4ET), and ASID Pool Entries (ASIDPoolT).", "title": "./spec/design/skel/X64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=X64 CONTEXT X64_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Memory and Pointer Management: Define the basic operations and types for managing memory and pointers in the system, including the definition of word bits, pointer types (PPtr), and conversion functions (fromPPtr), as well as the representation of a null pointer.", "title": "./spec/design/skel/X64/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/X64.lhs CONTEXT X64_H bodies_only ArchInv= Arch=\n\nend\n\nend", "property": "Arch Interrupt Management: Provides definitions and functions for managing interrupts on the X64 architecture, ensuring proper handling and routing of interrupts within the system.", "title": "./spec/design/skel/X64/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  KI_Decls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/X64.lhs CONTEXT X64_H Arch.Types=ArchTypes_H ArchInv=ArchRetypeDecls_H NOT bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/X64.lhs CONTEXT X64_H bodies_only\n\nend (* context X64 *)\nend", "property": "Retype Objects: Allow the kernel to retype objects, changing their type and purpose, while maintaining the integrity and consistency of the system's object model and architecture.", "title": "./spec/design/skel/X64/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewPageCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        return $ map (\\<lambda>n. PageCap (PPtr (fromPPtr n)) VMReadWrite VMNoMap pSize dev Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects tableBits objectProto cap initialiseMappings \\<equiv> (do\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      initialiseMappings pts;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 0 X64SmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev ptTranslationBits X64LargePage\n        | HugePageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev (ptTranslationBits + ptTranslationBits) X64HugePage\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects ptBits (makeObject::pte) PageTableCap\n              (\\<lambda>pts. return ())\n        | PageDirectoryObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pdBits (makeObject::pde) PageDirectoryCap\n              (\\<lambda>pts. return ())\n        | PDPointerTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pdptBits (makeObject::pdpte) PDPointerTableCap\n              (\\<lambda>pts. return ())\n        | PML4Object \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pml4Bits (makeObject::pml4e) PML4Cap\n              (\\<lambda>pms. mapM_x copyGlobalMappings pms)\n        )\"\n\nend\nend\n\nend", "property": "Create New Capability Objects: Supports the creation of new capability objects for various page and table types, including small, large, and huge pages, as well as page tables, directories, PD pointers, and PML4 objects. The creation process involves allocating memory, initializing the objects, and returning the corresponding capabilities. \n\nSubproperties:\n- Create New Page Objects: Create new page capabilities for small, large, and huge pages, considering the device type, global size, and page size.\n- Create New Table Objects: Create new table capabilities for page tables, directories, PD pointers, and PML4 objects, handling the table size, object prototype, and initialization of mappings.", "title": "./spec/design/skel/X64/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\nbegin\n\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/X64.lhs CONTEXT X64_H Arch=MachineOps ArchReg=MachineTypes bodies_only\n\nend (* context X64 *)\n\nend", "property": "Thread Management: Provides the foundation for managing threads within the kernel, including definitions and operations specific to the X64 architecture.", "title": "./spec/design/skel/X64/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "end", "property": "No property is defined.", "title": "./spec/design/skel/X64/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": " None for x64 "}
{"spec": "(*\n  Hypervisor stub for X64\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  KI_Decls_H\n  InterruptDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/X64.lhs Arch= CONTEXT X64_H decls_only ArchInv= ArchLabels=\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/X64.lhs Arch= CONTEXT X64_H bodies_only ArchInv= ArchLabels=\n\nend\nend", "property": "Hypervisor Stub for X64 Architecture: Provides the necessary definitions and declarations for the X64 architecture in the context of a hypervisor.", "title": "./spec/design/skel/X64/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/X64.lhs CONTEXT X64_H decls_only ArchInv= Arch=MachineOps\n\nend (* context X64 *)\n\nend", "property": "Arch Interrupt Management: Provides definitions and functions for managing interrupts on the X64 architecture, ensuring proper handling and invocation of interrupt-related operations.", "title": "./spec/design/skel/X64/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs Platform=Platform.X64 CONTEXT X64_H NOT getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory wordFromPDE wordFromPTE VMFaultType HypFaultType VMMapType VMPageSize pageBits pageBitsForSize paddrBase pptrBase pptrTop pptrBaseOffset kernelELFBaseOffset kernelELFPAddrBase kernelELFBase toPAddr addrFromPPtr ptrFromPAddr addrFromKPPtr setCurrentUserCR3 getCurrentUserCR3 invalidateTLB invalidateTLBEntry mfence wordFromPML4E wordFromPDPTE firstValidIODomain numIODomainIDBits hwASIDInvalidate getFaultAddress irqIntOffset maxPCIBus maxPCIDev maxPCIFunc ioapicIRQLines ioapicMapPinToVector irqStateIRQIOAPICNew irqStateIRQMSINew updateIRQState in8 out8 in16 out16 in32 out32 invalidatePageStructureCache writeCR3 invalidateASID invalidateTranslationSingleASID invalidateLocalPageStructureCacheASID ptTranslationBits nativeThreadUsingFPU switchFpuOwner\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs CONTEXT X64_H instanceproofs NOT VMFaultType VMPageSize VMPageEntry VMMapType HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs CONTEXT X64_H ONLY wordFromPDE wordFromPTE wordFromPML4E wordFromPDPTE", "property": "Hardware Abstraction: Provides an abstract interface to the underlying hardware, allowing the kernel to interact with the machine in a platform-agnostic manner. This includes operations for memory management, interrupt handling, timer configuration, and other low-level hardware interactions.\n\nSubproperties:\n- Memory Management: Allows the kernel to manage memory, including loading and storing words, clearing memory, and initializing memory regions.\n- Interrupt Handling: Provides functions for acknowledging and masking interrupts, as well as getting the active IRQ.\n- Timer Configuration: Allows the kernel to configure and reset the timer.\n- Debugging: Provides a function for debug printing.\n- Address Translation: Provides functions for translating between physical and virtual addresses.\n- TLB Management: Allows the kernel to invalidate TLB entries and manage the translation lookaside buffer.\n- I/O Operations: Provides functions for performing I/O operations, such as reading and writing to I/O ports.\n- IRQ State Management: Allows the kernel to update the IRQ state.\n- FPU Management: Provides functions for managing the floating-point unit (FPU).", "title": "./spec/design/skel/X64/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ \\<equiv> Platform.X64.maxIRQ\"\n\nend (* context X64 *)\n\nend", "property": "IRQ Maximum Value: The maximum IRQ value is defined as a constant obtained from the Platform definitions, specifically for the X64 architecture.", "title": "./spec/design/skel/X64/Hardware_H.thy", "chapter": "", "section": "", "comment": " Unlike on Arm architectures, maxIRQ comes from Platform definitions.\n   We provide this abbreviation to match arch-split expectations. "}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/RISCV64.hs\n\nend (* context Arch *)\n\nend", "property": "Arch-Specific Ghost Update Functions: Provide functions for updating the ghost state of physical memory, specific to the RISCV64 architecture.", "title": "./spec/design/skel/RISCV64/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/RISCV64.hs CONTEXT RISCV64_H decls_only\n\nend (* context RISCV64 *)\n\nend", "property": "Function Declarations for Threads: Provide the function declarations necessary for managing threads in the kernel, including initialization, execution, and management of thread-related data structures.", "title": "./spec/design/skel/RISCV64/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify RISCV64_H (in Arch)\ninstantiation RISCV64_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [HugePageObject,\n      SmallPageObject,\n      LargePageObject,\n      PageTableObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation RISCV64_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation RISCV64_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Define an enumeration of object types, including API object types and architecture-specific object types (HugePageObject, SmallPageObject, LargePageObject, PageTableObject), ensuring that all object types are distinct and can be iterated over.\n\nSubproperties:\n- Enum Class Definition: Define an enumeration class for object types, allowing for checking of properties over all object types (enum_all) and existence of object types satisfying a property (enum_ex).\n- Enum Alt Definition: Define an alternative enumeration (enum_alt) for object types based on their ordinal values.\n- Enumeration Both Instance: Instantiate the object type as an enumeration_both, ensuring compatibility with both enum and enum_alt definitions.", "title": "./spec/design/skel/RISCV64/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/RISCV64.hs CONTEXT RISCV64_H NOT RISCVVSpaceRegionUse\n\nend\nend", "property": "Architecture Specific Kernel State: Defines the architecture-specific kernel state and monads, providing the necessary structures and types for the kernel's operation on a specific architecture.", "title": "./spec/design/skel/RISCV64/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/Failures/RISCV64.hs CONTEXT RISCV64_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/RISCV64.hs CONTEXT RISCV64_H bodies_only\n\nend\nend", "property": "No specific property can be summarized from the given code snippet as it appears to be a setup or import section for a theory in a formal verification context, and does not describe any specific functionality or behavior.", "title": "./spec/design/skel/RISCV64/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation RISCV64_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pte updateObject_pte\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Object Management: Create, load, and update ASID pool objects with a fixed-size array of 2^32 entries, initialized with null values, ensuring efficient management of address space identifiers.", "title": "./spec/design/skel/RISCV64/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Setup_Locale\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/RISCV64.hs CONTEXT RISCV64_H ONLY RISCVVSpaceRegionUse\n\nend\n\nend", "property": "Architecture-Specific Data Types: Define data types specific to the RISCV64 architecture, shared by specification and abstraction, to facilitate accurate modeling and analysis of architecture-dependent components.", "title": "./spec/design/skel/RISCV64/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  Untyped_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/RISCV64.hs CONTEXT RISCV64_H bodies_only ArchInv=ArchRetypeDecls_H ONLY pteAtIndex getPPtrFromHWPTE isPageTablePTE ptBitsLeft\n\nfun\n  lookupPTSlotFromLevel :: \"nat => machine_word => machine_word => (nat * machine_word) kernel\"\nwhere\n  \"lookupPTSlotFromLevel 0 ptPtr vPtr =\n     return (ptBitsLeft 0, ptSlotIndex 0 ptPtr vPtr)\"\n| \"lookupPTSlotFromLevel level ptPtr vPtr = do\n     pte <- pteAtIndex level ptPtr vPtr;\n     if isPageTablePTE pte\n     then do\n       checkPTAt (getPPtrFromHWPTE pte);\n       lookupPTSlotFromLevel (level - 1) (getPPtrFromHWPTE pte) vPtr\n     od\n     else return (ptBitsLeft level, ptSlotIndex level ptPtr vPtr)\n   od\"\n\nfun\n  lookupPTFromLevel :: \"nat => machine_word => machine_word => machine_word =>\n    (lookup_failure, machine_word) kernel_f\"\nwhere\n  \"lookupPTFromLevel level ptPtr vPtr targetPtPtr = doE\n    assertE (ptPtr \\<noteq> targetPtPtr);\n    unlessE (0 < level) $ throw InvalidRoot;\n    slot <- returnOk $ ptSlotIndex level ptPtr vPtr;\n    pte <- withoutFailure $ getObject slot;\n    unlessE (isPageTablePTE pte) $ throw InvalidRoot;\n    ptr <- returnOk (getPPtrFromHWPTE pte);\n    if ptr = targetPtPtr\n        then returnOk slot\n        else doE\n          liftE $ checkPTAt ptr;\n          lookupPTFromLevel (level - 1) ptr vPtr targetPtPtr\n        odE\n  odE\"\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/RISCV64.hs CONTEXT RISCV64_H bodies_only ArchInv=ArchRetypeDecls_H NOT lookupPTSlotFromLevel lookupPTFromLevel pteAtIndex getPPtrFromHWPTE isPageTablePTE ptBitsLeft checkPTAt\n\nend\n\nend", "property": "Virtual Address Space Lookup: Traverse the page table hierarchy to find the slot corresponding to a given virtual address, ensuring that each page table is valid and present in memory.\n\nSubproperties:\n- Page Table Validation: Verify that each page table in the hierarchy is a valid page table.\n- Page Table Present Check: Ensure that each page table in the hierarchy is present in memory.\n- Slot Calculation: Calculate the slot index within the page table where the virtual address is mapped.", "title": "./spec/design/skel/RISCV64/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/RISCV64.hs RegisterSet= CONTEXT RISCV64_H\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\nend\nend", "property": "Architectural TCB Properties: Provides architectural-specific TCB (Thread Control Block) functions for RISCV64, including register set management and thread get/set operations.", "title": "./spec/design/skel/RISCV64/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchVSpaceDecls_H\nimports ArchRetypeDecls_H InvocationLabels_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT RISCV64_H\n#INCLUDE_HASKELL_PREPARSE SEL4/API/InvocationLabels/RISCV64.hs CONTEXT RISCV64\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/RISCV64.hs CONTEXT RISCV64_H decls_only ArchInv= NOT lookupPTSlotFromLevel lookupPTFromLevel\n\nend (* context RISCV64 *)\n\nend", "property": "Retype Objects: Allow the kernel to retype objects, modifying their structure and properties to adapt to changing system requirements.", "title": "./spec/design/skel/RISCV64/ArchVSpaceDecls_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "consts canonicalAddressAssert :: \"machine_word => bool\"\n\nend", "property": "Canonical Address Assertion: Ensures that a given machine word represents a valid canonical address, with its definition varying across different architectures.", "title": "./spec/design/skel/RISCV64/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/RISCV64.hs CONTEXT RISCV64_H ONLY ArchInvocationLabel\n\nend", "property": "Arch Invocation Labels: Define a set of architecture-specific system call labels for RISCV64.", "title": "./spec/design/skel/RISCV64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/RISCV64.hs CONTEXT RISCV64_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch Invocation Label Requalification: Requalify the invocation labels for the RISCV64 architecture to ensure correct instance proofs.", "title": "./spec/design/skel/RISCV64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext ((K 0) aLU initContext)\"\n\nend\nend", "property": "Initial Register State: The register set is initialized with a new user context where all registers are set to zero.", "title": "./spec/design/skel/RISCV64/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/RISCV64.hs\n\n#INCLUDE_HASKELL SEL4/API/Faults/RISCV64.hs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/RISCV64.hs bodies_only\n\nend\n\nend", "property": "Fault Handler Management: Define the architecture-specific fault handlers for the RISCV64 platform, providing the necessary functionality for handling faults and failures in the system.", "title": "./spec/design/skel/RISCV64/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/RISCV64.hs CONTEXT RISCV64_H decls_only\n#INCLUDE_HASKELL SEL4/Object/Structures/RISCV64.hs CONTEXT RISCV64_H instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/RISCV64.hs CONTEXT RISCV64_H bodies_only\n\ndatatype arch_kernel_object_type =\n    PTET\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend\nend", "property": "Architectural Object Classification: Classify architectural kernel objects into distinct types, specifically Page Table Entries (PTET) and ASID Pool objects (ASIDPoolT), to facilitate proper management and handling of these objects within the kernel.", "title": "./spec/design/skel/RISCV64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=RISCV64 CONTEXT RISCV64_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Memory and Pointer Management: Define the basic operations and types for managing memory and pointers in the system, including the definition of physical pointers (PPtr), conversion from physical pointers (fromPPtr), and the null pointer constant. Ensure that memory and pointer operations are correctly defined and managed, providing a foundation for the system's memory management and data integrity.", "title": "./spec/design/skel/RISCV64/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/RISCV64.hs CONTEXT RISCV64_H bodies_only ArchInv= Arch= NOT plic_complete_claim\n\nend\n\nend", "property": "No property can be summarized from the given code as it appears to be a header or import section, and does not contain any specific functionality or behavior that can be described as a property.", "title": "./spec/design/skel/RISCV64/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  KI_Decls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/RISCV64.hs CONTEXT RISCV64_H Arch.Types=ArchTypes_H ArchInv=ArchRetypeDecls_H NOT bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/RISCV64.hs CONTEXT RISCV64_H bodies_only\n\nend (* context RISCV64 *)\nend", "property": "Retype Objects: Allow the kernel to retype objects, changing their type and purpose, while maintaining the integrity and consistency of the system's object model and architecture.", "title": "./spec/design/skel/RISCV64/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewFrameCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        return $ map (\\<lambda>n. FrameCap  (PPtr (fromPPtr n)) VMReadWrite pSize dev Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects tableBits objectProto cap initialiseMappings \\<equiv> (do\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      initialiseMappings pts;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev 0 RISCVSmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev ptTranslationBits RISCVLargePage\n        | HugePageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev (ptTranslationBits + ptTranslationBits) RISCVHugePage\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects ptBits (makeObject::pte) PageTableCap\n              (\\<lambda>pts. return ())\n        )\"\n\nend\nend\n\nend", "property": "Create New Capability Objects: Create new capability objects for various object types, including frames and page tables, with specified attributes such as size, device type, and access rights.\n\nSubproperties:\n- Create New Frame Capability Objects: Create new frame capability objects for different page sizes (small, large, huge) with specified attributes such as device type and access rights.\n- Create New Page Table Capability Objects: Create new page table capability objects with specified attributes such as table size and access rights, and initialize their mappings.", "title": "./spec/design/skel/RISCV64/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/RISCV64.hs CONTEXT RISCV64_H Arch=MachineOps ArchReg=MachineTypes bodies_only\n\nend (* context RISCV64 *)\n\nend", "property": "Thread Management: Provides the foundation for managing threads in the kernel, including definitions and operations for thread creation, execution, and control.", "title": "./spec/design/skel/RISCV64/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "end", "property": "No property can be summarized as there is no code provided.", "title": "./spec/design/skel/RISCV64/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": " None for RISCV64 "}
{"spec": "(*\n  Hypervisor stub for RISCV64\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  KI_Decls_H\n  InterruptDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/RISCV64.hs Arch= CONTEXT RISCV64_H decls_only ArchInv= ArchLabels=\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/RISCV64.hs Arch= CONTEXT RISCV64_H bodies_only ArchInv= ArchLabels=\n\nend\nend", "property": "Hypervisor Stub for RISCV64: Provides the necessary definitions and imports for the RISCV64 architecture's hypervisor stub.", "title": "./spec/design/skel/RISCV64/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/RISCV64.hs CONTEXT RISCV64_H decls_only ArchInv= Arch=MachineOps NOT plic_complete_claim\n\nend (* context RISCV64 *)\n\nend", "property": "Arch Interrupt Management: Provides definitions and functions for managing interrupts on the RISCV64 architecture, ensuring proper handling and routing of interrupts within the system.", "title": "./spec/design/skel/RISCV64/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs Platform=Platform.RISCV64 CONTEXT RISCV64_H NOT plic_complete_claim getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory setHardwareASID wordFromPDE wordFromPTE VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize toPAddr addrFromPPtr ptrFromPAddr sfence physBase paddrBase pptrBase pptrBaseOffset pptrTop pptrUserTop kernelELFBase kernelELFBaseOffset kernelELFPAddrBase addrFromKPPtr ptTranslationBits vmFaultTypeFSR read_stval setVSpaceRoot hwASIDFlush setIRQTrigger\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64_H instanceproofs NOT plic_complete_claim HardwareASID VMFaultType VMPageSize VMPageEntry HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64_H ONLY wordFromPTE", "property": "Hardware Abstraction: Provide a hardware abstraction layer for the RISCV64 architecture, encapsulating low-level operations and hardware-specific details, such as memory management, interrupt handling, and timer configuration, to facilitate platform-agnostic kernel development.\n\nSubproperties:\n- Memory Management: Manage memory regions, kernel devices, and hardware ASIDs, ensuring efficient memory allocation and deallocation.\n- Interrupt Handling: Handle interrupts, including getting active IRQs, acknowledging and masking interrupts, and configuring timers.\n- Low-Level Operations: Perform low-level operations, such as loading and storing words, setting the next PC, and clearing memory.\n- Virtual Memory: Manage virtual memory, including page table translations, VM fault types, and VM page sizes.\n- Hardware-Specific Details: Encapsulate hardware-specific details, such as physical base addresses, page bits, and VM rights.", "title": "./spec/design/skel/RISCV64/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ \\<equiv> Platform.RISCV64.maxIRQ\"\n\nend (* context RISCV64 *)\n\nend", "property": "IRQ Maximum Value: The maximum IRQ value is defined as a constant obtained from the Platform definitions for RISCV64 architecture.", "title": "./spec/design/skel/RISCV64/Hardware_H.thy", "chapter": "", "section": "", "comment": " Unlike on Arm architectures, maxIRQ comes from Platform definitions.\n   We provide this abbreviation to match arch-split expectations. "}
{"spec": "chapter \"VCPU\"\n\ntheory VCPU_H\nimports\n  Hardware_H\n  Structures_H\n  Invocations_H\n  TCB_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT AARCH64_H\n#INCLUDE_HASKELL SEL4/Object/VCPU/AARCH64.hs CONTEXT AARCH64_H ArchInv=Arch \\\n  NOT vcpuUpdate vgicUpdate vgicUpdateLR vcpuSaveReg vcpuRestoreReg \\\n    vcpuSaveRegRange vcpuRestoreRegRange vcpuWriteReg vcpuReadReg saveVirtTimer \\\n    restoreVirtTimer vcpuDisable vcpuEnable vcpuRestore vcpuSave vcpuSwitch \\\n    vcpuInvalidateActive vcpuCleanInvalidateActive countTrailingZeros virqType \\\n    virqSetEOIIRQEN vgicMaintenance vppiEvent irqVPPIEventIndex armvVCPUSave \\\n    curVCPUActive\n\nend\nend", "property": "VCPU Management: Provides a set of functions for managing Virtual CPUs (VCPU), including updating, saving, and restoring VCPU state, as well as handling VCPU-related events and interrupts.", "title": "./spec/design/skel/AARCH64/VCPU_H.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/AARCH64.hs decls_only ONLY pTablePartialOverlap\n#INCLUDE_HASKELL SEL4/Model/PSpace/AARCH64.hs NOT pTablePartialOverlap\n\nend (* context Arch *)\n\nend", "property": "Arch-specific Ghost Update Functions for Physical Memory: Provide functions to manage and update the ghost state of physical memory, ensuring consistency and correctness of the memory model.", "title": "./spec/design/skel/AARCH64/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/AARCH64.hs CONTEXT AARCH64_H decls_only\n\nend (* context AARCH64 *)\n\nend", "property": "Function Declarations for Threads: Provides function declarations for thread management, including initialization and execution of threads on the AARCH64 architecture.", "title": "./spec/design/skel/AARCH64/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify AARCH64_H (in Arch)\ninstantiation AARCH64_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [HugePageObject,\n      VSpaceObject,\n      SmallPageObject,\n      LargePageObject,\n      PageTableObject,\n      VCPUObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation AARCH64_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation AARCH64_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Define an enumeration of object types, including API object types and architecture-specific object types such as HugePageObject, VSpaceObject, SmallPageObject, LargePageObject, PageTableObject, and VCPUObject. Ensure that the enumeration is correct, complete, and consistent with the object type definitions. \n\nSubproperties:\n- Injectivity: Ensure that the enumeration is injective, meaning that each object type is uniquely represented.\n- Completeness: Ensure that the enumeration covers all possible object types.\n- Consistency: Ensure that the enumeration is consistent with the object type definitions and other related enumerations.", "title": "./spec/design/skel/AARCH64/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/AARCH64.hs CONTEXT AARCH64_H NOT ArmVSpaceRegionUse\n\nend\nend", "property": "Architecture Specific Kernel State: Defines the architecture-specific kernel state and monads, providing the necessary structures and types for the kernel's operation on a specific architecture.", "title": "./spec/design/skel/AARCH64/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/Failures/AARCH64.hs CONTEXT AARCH64_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/AARCH64.hs CONTEXT AARCH64_H bodies_only\n\nend\nend", "property": "No property can be summarized from the given code as it does not contain any specific functionality or logic. It appears to be a setup or configuration code for including Haskell files in a theory context.", "title": "./spec/design/skel/AARCH64/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation AARCH64_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pte updateObject_pte\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Object Management: Create, load, and update ASID pool objects with a fixed-size array of 2^32 entries, initialized with a constant value of Nothing, ensuring efficient and safe management of ASID pools in the kernel.", "title": "./spec/design/skel/AARCH64/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Setup_Locale\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/AARCH64.hs CONTEXT AARCH64_H ONLY ArmVSpaceRegionUse\n\n#INCLUDE_HASKELL SEL4/API/Invocation/AARCH64.hs CONTEXT AARCH64_H ONLY FlushType\n\nend\n\nend", "property": "Architecture-Specific Data Types: Define data types specific to the AARCH64 architecture, including ArmVSpaceRegionUse and FlushType, to provide a common understanding of architecture-specific concepts.", "title": "./spec/design/skel/AARCH64/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/AARCH64.hs CONTEXT AARCH64_H bodies_only ArchInv=ArchRetypeDecls_H ONLY pteAtIndex getPPtrFromHWPTE isPageTablePTE ptBitsLeft\n\nfun\n  lookupPTSlotFromLevel :: \"nat => machine_word => machine_word => (nat * machine_word) kernel\"\nwhere\n  \"lookupPTSlotFromLevel 0 ptPtr vPtr =\n     return (ptBitsLeft 0, ptSlotIndex 0 ptPtr vPtr)\"\n| \"lookupPTSlotFromLevel level ptPtr vPtr = do\n     pte <- pteAtIndex level ptPtr vPtr;\n     if isPageTablePTE pte\n     then do\n       checkPTAt NormalPT_T (getPPtrFromPTE pte);\n       lookupPTSlotFromLevel (level - 1) (getPPtrFromPTE pte) vPtr\n     od\n     else return (ptBitsLeft level, ptSlotIndex level ptPtr vPtr)\n   od\"\n\nfun\n  lookupPTFromLevel :: \"nat => machine_word => machine_word => machine_word =>\n    (lookup_failure, machine_word) kernel_f\"\nwhere\n  \"lookupPTFromLevel level ptPtr vPtr targetPtPtr = doE\n    assertE (ptPtr \\<noteq> targetPtPtr);\n    unlessE (0 < level) $ throw InvalidRoot;\n    slot <- returnOk $ ptSlotIndex level ptPtr vPtr;\n    pte <- withoutFailure $ getObject slot;\n    unlessE (isPageTablePTE pte) $ throw InvalidRoot;\n    ptr <- returnOk (getPPtrFromPTE pte);\n    if ptr = targetPtPtr\n        then returnOk slot\n        else doE\n          liftE $ checkPTAt NormalPT_T ptr;\n          lookupPTFromLevel (level - 1) ptr vPtr targetPtPtr\n        odE\n  odE\"\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/AARCH64.hs CONTEXT AARCH64_H bodies_only ArchInv=ArchRetypeDecls_H NOT lookupPTSlotFromLevel lookupPTFromLevel pteAtIndex getPPtrFromHWPTE isPageTablePTE ptBitsLeft checkPTAt checkValidMappingSize\n\ndefs checkValidMappingSize_def:\n  \"checkValidMappingSize sz \\<equiv> stateAssert (\\<lambda>s. 2 ^ sz <= gsMaxObjectSize s) []\"\n\nend\n\nend", "property": "Virtual Address Space Lookup: Perform a hierarchical lookup in the virtual address space to find the page table slot or physical address corresponding to a given virtual address, ensuring that the lookup traverses the page table levels correctly and handles errors such as invalid roots or non-page-table entries.\n\nSubproperties:\n- Page Table Slot Lookup: Find the page table slot at a specific level in the virtual address space, returning the slot index and remaining page table bits.\n- Page Table Lookup: Perform a recursive lookup in the page table hierarchy to find the slot containing a specific page table pointer, handling errors and ensuring that the lookup is valid.", "title": "./spec/design/skel/AARCH64/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/AARCH64.hs RegisterSet= CONTEXT AARCH64_H\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\nend\nend", "property": "Architectural TCB Properties: Provides architectural-specific TCB (Thread Control Block) functions for AARCH64, including register set management and thread get/set operations.", "title": "./spec/design/skel/AARCH64/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "consts'\npageBase :: \"('a :: len word) \\<Rightarrow> nat \\<Rightarrow> 'a word\"\n\nend (* context AARCH64 *)\n\nend", "property": "Page Base Calculation: Calculate the base address of a page given a word and a specific size, ensuring proper address alignment and calculation for the AARCH64 architecture.", "title": "./spec/design/skel/AARCH64/ArchVSpaceDecls_H.thy", "chapter": "", "section": "", "comment": " no \"wordlike\" class with a direct translation available, use more constrained spec "}
{"spec": "consts canonicalAddressAssert :: \"machine_word => bool\"\n\nend", "property": "Canonical Address Assertion: Ensures that a given machine word represents a valid canonical address, with its definition varying across different architectures.", "title": "./spec/design/skel/AARCH64/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/AARCH64.hs CONTEXT AARCH64_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Define an enumeration of system call labels specific to the AARCH64 architecture.", "title": "./spec/design/skel/AARCH64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/AARCH64.hs CONTEXT AARCH64_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch Invocation Label Requalification: Requalify the invocation labels for the AARCH64 architecture to ensure correct instance proofs.", "title": "./spec/design/skel/AARCH64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition newFPUState :: \"fpu_state\" where\n  \"newFPUState \\<equiv> FPUState (K 0) 0 0 \"\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext newFPUState ((K 0) aLU initContext)\"\n\nend\nend", "property": "Initial Register Set: The system initializes the register set with default values for floating-point unit (FPU) state and user context.", "title": "./spec/design/skel/AARCH64/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/AARCH64.hs\n\n#INCLUDE_HASKELL SEL4/API/Faults/AARCH64.hs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/AARCH64.hs bodies_only\n\nend\n\nend", "property": "Fault Handler Management: Define and manage fault handlers for the AARCH64 architecture, ensuring proper handling of faults and errors within the system.", "title": "./spec/design/skel/AARCH64/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64_H decls_only \\\n  NOT VPPIEventIRQ VirtTimer\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64_H instanceproofs \\\n  NOT VPPIEventIRQ VirtTimer\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64_H bodies_only \\\n  NOT makeVCPUObject", "property": "Architectural Structures: Define the structures and settings for the AARCH64 architecture, including the ASID pool and arch TCB, and exclude VPPIEventIRQ and VirtTimer.", "title": "./spec/design/skel/AARCH64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "defs makeVCPUObject_def:\n\"makeVCPUObject \\<equiv>\n    VCPUObj_ \\<lparr>\n          vcpuTCBPtr= Nothing\n        , vcpuVGIC= VGICInterface_ \\<lparr>\n                          vgicHCR= vgicHCREN\n                        , vgicVMCR= 0\n                        , vgicAPR= 0\n                        , vgicLR= (\\<lambda>_. 0)\n                        \\<rparr>\n        , vcpuRegs= funArray (const 0)  aLU  [(VCPURegSCTLR, sctlrEL1VM)]\n        , vcpuVPPIMasked= (\\<lambda>_. False)\n        , vcpuVTimer= VirtTimer 0\n        \\<rparr>\"\n\ndatatype arch_kernel_object_type =\n    PTET\n  | VCPUT\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOVCPU e) = VCPUT\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend", "property": "VCPU Object Creation: Creates a new VCPU object with default settings, including a VGIC interface, registers, and a virtual timer, ensuring a consistent initial state for VCPUs.\n\nArchitectural Object Type Identification: Identifies the type of an architectural kernel object, categorizing it as a page table entry, VCPU, or ASID pool, allowing for proper management and handling of different object types.", "title": "./spec/design/skel/AARCH64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": " we define makeVCPUObject_def manually because we want a total function vgicLR "}
{"spec": "arch_requalify_types (H)\n  vcpu\n\nend", "property": "Requalification of VCPU Type: Requalify the VCPU type for specific architectures, as it is not possible to do so generically due to architecture-specific variations.", "title": "./spec/design/skel/AARCH64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, as some arches don't have vcpu "}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=AARCH64 CONTEXT AARCH64_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Memory and Pointer Management: Define the basic operations and types for managing memory and pointers in the system, including the definition of word bits, pointer types (PPtr), and the null pointer constant. Ensure that the system can correctly represent and manipulate memory addresses and pointers. \n\nPointer Conversion: Provide functions to convert between different pointer types, specifically from and to PPtr, which are defined as identity functions.", "title": "./spec/design/skel/AARCH64/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/AARCH64.hs CONTEXT AARCH64_H bodies_only ArchInv= Arch= NOT plic_complete_claim\n\nend\n\nend", "property": "Arch Interrupt Management: Provides the necessary definitions and functions for managing interrupts on the AARCH64 architecture.", "title": "./spec/design/skel/AARCH64/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  KI_Decls_H\n  VCPU_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/AARCH64.hs CONTEXT AARCH64_H Arch.Types=ArchTypes_H ArchInv=ArchRetypeDecls_H NOT bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/AARCH64.hs CONTEXT AARCH64_H bodies_only \\\n  NOT isVSpaceFlushLabel isPageFlushLabel\n\nend (* context AARCH64 *)\nend", "property": "Retype Objects: Allow the kernel to retype objects, changing their type and purpose, while maintaining the integrity and consistency of the system's object model and architecture.", "title": "./spec/design/skel/AARCH64/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewFrameCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        when (\\<not>dev) $\n          mapM_x (\\<lambda>addr. doMachineOp $\n                            cleanCacheRange_RAM addr\n                                                (addr + mask (pageBitsForSize pSize))\n                                                (addrFromPPtr addr)) addrs;\n        return $ map (\\<lambda>n. FrameCap  (PPtr (fromPPtr n)) VMReadWrite pSize dev Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects ptType objectProto cap initialiseMappings \\<equiv> (do\n      tableBits \\<leftarrow> return (ptBits ptType);\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      modify (\\<lambda>ks. ks \\<lparr>ksArchState :=\n                         ksArchState ks \\<lparr>gsPTTypes := (\\<lambda>addr.\n                                           if addr `~elem~` map fromPPtr addrs then Just ptType\n                                           else gsPTTypes (ksArchState ks) addr)\\<rparr>\\<rparr>);\n      initialiseMappings pts;\n      mapM_x (\\<lambda>addr. doMachineOp $\n                       cleanCacheRange_PoU addr (addr + mask tableBits) (addrFromPPtr addr)) addrs;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev 0 ARMSmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev (ptTranslationBits NormalPT_T) ARMLargePage\n        | HugePageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev (2 * ptTranslationBits NormalPT_T) ARMHugePage\n        | VSpaceObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects VSRootPT_T (makeObject::pte)\n              (\\<lambda>base addr. PageTableCap base VSRootPT_T addr)\n              (\\<lambda>pts. return ())\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects NormalPT_T (makeObject::pte)\n              (\\<lambda>base addr. PageTableCap base NormalPT_T addr)\n              (\\<lambda>pts. return ())\n        | VCPUObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject :: vcpu)) 0;\n            return $ map (\\<lambda>addr. VCPUCap addr) addrs\n            od)\n        )\"\n\nend\nend\n\nend", "property": "Create New Capability Objects: Create new capability objects for various object types, including frames, page tables, and VCPUs, with specific attributes and mappings, ensuring proper initialization and caching. \n\nSubproperties:\n- Create Frame Capability Objects: Create new frame capability objects with specified region base, number of objects, device type, and page size, and initialize their mappings and caching.\n- Create Page Table Capability Objects: Create new page table capability objects with specified region base, number of objects, page table type, and object prototype, and initialize their mappings and caching.\n- Create VCPU Capability Objects: Create new VCPU capability objects with specified region base and number of objects, and return their corresponding capabilities.", "title": "./spec/design/skel/AARCH64/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/AARCH64.hs CONTEXT AARCH64_H Arch=MachineOps ArchReg=MachineTypes bodies_only\n\nend (* context AARCH64 *)\n\nend", "property": "Thread Management: Provides the fundamental definitions and structures for managing threads in the kernel, including the integration of architecture-specific thread handling.", "title": "./spec/design/skel/AARCH64/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/API/Invocation/AARCH64.hs CONTEXT AARCH64_H \\\n  ONLY isVSpaceFlushLabel isPageFlushLabel\n\nend\nend", "property": "Arch-specific Invocation Label Checks: Identify if an invocation label corresponds to a VSpace flush or a page flush operation.", "title": "./spec/design/skel/AARCH64/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": "\n  Arch-specific functions on invocation labels\n"}
{"spec": "(*\n  Hypervisor function definitions for AARCH64\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  FaultHandlerDecls_H\n  InterruptDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/VCPU/AARCH64.hs CONTEXT AARCH64_H decls_only \\\n  ONLY countTrailingZeros irqVPPIEventIndex\n#INCLUDE_HASKELL SEL4/Object/VCPU/AARCH64.hs CONTEXT AARCH64_H bodies_only \\\n  ONLY countTrailingZeros irqVPPIEventIndex\n#INCLUDE_HASKELL SEL4/Object/VCPU/AARCH64.hs CONTEXT AARCH64_H ArchInv=Arch \\\n  ONLY vcpuUpdate vgicUpdate vgicUpdateLR vcpuSaveReg vcpuRestoreReg \\\n    vcpuSaveRegRange vcpuRestoreRegRange vcpuWriteReg vcpuReadReg saveVirtTimer \\\n    restoreVirtTimer vcpuDisable vcpuEnable vcpuRestore armvVCPUSave \\\n    vcpuSave vcpuSwitch vcpuInvalidateActive vcpuCleanInvalidateActive \\\n    virqType virqSetEOIIRQEN vgicMaintenance vppiEvent curVCPUActive\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/AARCH64.hs Arch= CONTEXT AARCH64_H decls_only ArchInv= ArchLabels=\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/AARCH64.hs Arch= CONTEXT AARCH64_H bodies_only ArchInv= ArchLabels=\n\nend\nend", "property": "Hypervisor Functionality for AARCH64: Provides definitions for various hypervisor functions, including virtual CPU (VCPU) management, interrupt handling, and virtual timer operations, to facilitate efficient and secure virtualization on AARCH64 architecture.", "title": "./spec/design/skel/AARCH64/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/AARCH64.hs CONTEXT AARCH64_H decls_only ArchInv= Arch=MachineOps NOT plic_complete_claim\n\nend (* context AARCH64 *)\n\nend", "property": "Arch Interrupt Management: Provides definitions and functions for managing interrupts on the AARCH64 architecture, ensuring proper handling and routing of interrupts within the system.", "title": "./spec/design/skel/AARCH64/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs Platform=Platform.AARCH64 CONTEXT AARCH64_H \\\n  NOT PT_Type plic_complete_claim getMemoryRegions getDeviceRegions getKernelDevices \\\n  loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt \\\n  configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory \\\n  clearMemoryVM initMemory freeMemory setHardwareASID wordFromPDE wordFromPTE \\\n  VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize toPAddr \\\n  addrFromPPtr ptrFromPAddr sfence physBase paddrBase pptrBase pptrBaseOffset \\\n  pptrUserTop kernelELFBase kernelELFBaseOffset kernelELFPAddrBase \\\n  addrFromKPPtr ptTranslationBits vmFaultTypeFSR setVSpaceRoot \\\n  setIRQTrigger \\\n  config_ARM_PA_SIZE_BITS_40 fpuThreadDeleteOp isFpuEnable \\\n  hcrVCPU hcrNative sctlrDefault vgicHCREN gicVCPUMaxNumLR sctlrEL1VM \\\n  get_gic_vcpu_ctrl_hcr set_gic_vcpu_ctrl_hcr get_gic_vcpu_ctrl_vmcr \\\n  set_gic_vcpu_ctrl_vmcr get_gic_vcpu_ctrl_apr set_gic_vcpu_ctrl_apr \\\n  get_gic_vcpu_ctrl_vtr get_gic_vcpu_ctrl_eisr0 get_gic_vcpu_ctrl_eisr1 \\\n  get_gic_vcpu_ctrl_misr get_gic_vcpu_ctrl_lr set_gic_vcpu_ctrl_lr read_cntpct \\\n  check_export_arch_timer \\\n  isb dsb dmb \\\n  invalidateTranslationASID invalidateTranslationSingle \\\n  cleanByVA_PoU cleanInvalidateCacheRange_RAM cleanCacheRange_RAM cleanCacheRange_PoU \\\n  invalidateCacheRange_RAM invalidateCacheRange_I branchFlushRange \\\n  enableFpuEL01 \\\n  getFAR getDFSR getIFSR getHSR setHCR getESR  getSCTLR setSCTLR \\\n  addressTranslateS1 \\\n  readVCPUHardwareReg writeVCPUHardwareReg vcpuBits\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64_H instanceproofs NOT plic_complete_claim HardwareASID VMFaultType VMPageSize VMPageEntry HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64_H ONLY wordFromPTE", "property": "Hardware Abstraction: Provides an abstract interface to the underlying hardware, allowing the kernel to interact with the hardware in a platform-agnostic manner. This includes operations for memory management, interrupt handling, timer configuration, and other hardware-specific functions.\n\nSubproperties:\n- Memory Management: Provides functions for managing memory, including loading and storing words, clearing memory, and initializing memory regions.\n- Interrupt Handling: Provides functions for handling interrupts, including getting and acknowledging active IRQs, and masking interrupts.\n- Timer Configuration: Provides functions for configuring and resetting timers.\n- Hardware-Specific Functions: Provides functions for performing hardware-specific operations, such as debug printing, getting and setting the restart PC, and setting the next PC.", "title": "./spec/design/skel/AARCH64/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ \\<equiv> Kernel_Config.maxIRQ\"\n\nend (* context AARCH64 *)\n\nend", "property": "IRQ Configuration: Define the maximum IRQ value based on the Kernel_Config.", "title": "./spec/design/skel/AARCH64/Hardware_H.thy", "chapter": "", "section": "", "comment": " Kernel_Config provides a generic numeral, Haskell expects type irq "}
{"spec": "chapter \"VCPU\"\n\ntheory VCPU_H\nimports\n  Hardware_H\n  Structures_H\n  Invocations_H\n  TCB_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT ARM_HYP_H\n#INCLUDE_HASKELL SEL4/Object/VCPU/ARM.lhs CONTEXT ARM_HYP_H ArchInv=Arch NOT vcpuUpdate vgicUpdate vgicUpdateLR vcpuSaveReg vcpuRestoreReg vcpuSaveRegRange vcpuRestoreRegRange vcpuWriteReg vcpuReadReg saveVirtTimer restoreVirtTimer vcpuDisable vcpuEnable vcpuRestore vcpuSave vcpuSwitch vcpuInvalidateActive vcpuCleanInvalidateActive countTrailingZeros virqSetEOIIRQEN vgicMaintenance vppiEvent irqVPPIEventIndex armvVCPUSave\n\nend\nend", "property": "VCPU Management: Provides functions for managing Virtual CPUs (VCPU), including saving and restoring VCPU state, updating VCPU registers, handling virtual interrupts, and managing VCPU execution.", "title": "./spec/design/skel/ARM_HYP/VCPU_H.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/ARM.hs\n\nend (* context Arch *)\n\nend", "property": "Arch-Specific Ghost Update Functions: Provide functions for updating the ghost state of physical memory, specific to the ARM architecture.", "title": "./spec/design/skel/ARM_HYP/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/ARM.lhs CONTEXT Arch decls_only\n\nend\nend", "property": "Function Declarations for Threads: Provide function declarations for thread-related operations, importing necessary structures, fault monads, and kernel initialization monads, and establishing the context for architecture-specific thread declarations.", "title": "./spec/design/skel/ARM_HYP/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify ARM_HYP_H (in Arch)\ninstantiation ARM_HYP_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [PageDirectoryObject,\n      SmallPageObject,\n      LargePageObject,\n      SectionObject,\n      SuperSectionObject,\n      PageTableObject,\n      VCPUObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation ARM_HYP_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation ARM_HYP_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Define an enumeration of object types, including API object types and architecture-specific object types such as page directories, page tables, and VCPU objects, to facilitate proofs and reasoning about object types in the system.\n\nSubproperties:\n- Enum Class Definition: Define an enumeration class for object types, allowing for the definition of enumeration functions and predicates.\n- Enumeration Functions: Define functions for enumerating all object types and checking the existence of an object type satisfying a given predicate.\n- Distinctness and Completeness: Ensure that the enumeration is distinct and complete, covering all possible object types in the system.", "title": "./spec/design/skel/ARM_HYP/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/ARM.lhs CONTEXT ARM_HYP_H NOT ArmVSpaceRegionUse\n\nend\n\nend", "property": "Architecture Specific Kernel State: Defines the architecture-specific kernel state and monads, providing the necessary structures and types for the kernel's operation on a specific architecture.", "title": "./spec/design/skel/ARM_HYP/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_HYP_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_HYP_H bodies_only\n\n\nend\nend", "property": "No properties can be extracted from the given code as it appears to be a header or import section, and does not contain any specific functionality or logic that can be summarized as a property.", "title": "./spec/design/skel/ARM_HYP/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation ARM_HYP_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pde updateObject_pde\n  loadObject_pte updateObject_pte\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Object Management: Create, load, and update ASID pool objects with a fixed-size array of 2^32 entries, initialized with null values, ensuring efficient management of address space identifiers.", "title": "./spec/design/skel/ARM_HYP/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Main Setup_Locale\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/ARM.lhs CONTEXT ARM_HYP_H ONLY ArmVSpaceRegionUse\n\nend\nend", "property": "Architecture-Specific Data Types: Define data types specific to a particular architecture, such as ARM, to be shared by specification and abstraction.", "title": "./spec/design/skel/ARM_HYP/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/ARM.lhs CONTEXT ARM_HYP_H bodies_only ArchInv=ArchRetypeDecls_H.ARM_HYP ArchLabels=ArchInvocationLabels_H.ARM_HYP NOT checkPDAt checkPTAt checkPDASIDMapMembership checkValidMappingSize vptrFromPPtr\n\ndefs checkValidMappingSize_def:\n  \"checkValidMappingSize sz \\<equiv> stateAssert\n    (\\<lambda>s. 2 ^ pageBitsForSize sz <= gsMaxObjectSize s) []\"\n\nend\nend", "property": "Valid Mapping Size: Ensure that the mapping size is valid by checking if the page size corresponding to the given size is less than or equal to the maximum object size in the current state.", "title": "./spec/design/skel/ARM_HYP/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/ARM.lhs RegisterSet= CONTEXT ARM_HYP_H\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\n\nend\nend", "property": "TCB Register Management: Provide functions to get and set the register set of a thread, specifically for the ARM architecture.", "title": "./spec/design/skel/ARM_HYP/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "consts'\npageBase :: \"('a :: len word) \\<Rightarrow> vmpage_size \\<Rightarrow> 'a word\"\n\nend\nend", "property": "Page Base Calculation: Calculate the base address of a page given a word address and a page size.", "title": "./spec/design/skel/ARM_HYP/ArchVSpaceDecls_H.thy", "chapter": "", "section": "", "comment": " no \"wordlike\" class with a direct translation available, use more constrained spec "}
{"spec": "definition\n  canonicalAddressAssert :: \"machine_word => bool\" where\n  canonicalAddressAssert_def[simp]:\n  \"canonicalAddressAssert p = True\"\n\nend", "property": "Canonical Address Assertion: Ensure that a given machine word represents a canonical address.", "title": "./spec/design/skel/ARM_HYP/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "definition\n  canonicalAddressAssert :: \"machine_word => bool\" where\n  canonicalAddressAssert_def[simp]:\n  \"canonicalAddressAssert p = True\"\n\nend", "property": "Canonical Address Assertion: Always returns true, indicating that the address is canonical, regardless of the architecture.", "title": "./spec/design/skel/ARM_HYP/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/ARM.lhs CONTEXT ARM_HYP_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Define a set of labels for architecture-specific system calls.", "title": "./spec/design/skel/ARM_HYP/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/ARM.lhs CONTEXT ARM_HYP_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch Invocation Label Requalification: Requalify arch invocation labels for the ARM architecture to ensure correct instance proofs.", "title": "./spec/design/skel/ARM_HYP/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext ((K 0) aLU initContext)\"\n\nend\nend", "property": "Initial Register State: The register set is initialized with a new user context where all registers are set to zero.", "title": "./spec/design/skel/ARM_HYP/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/ARM.lhs\n\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs bodies_only\n\nend\n\n\nend", "property": "Fault Handler Management: Define the architecture-specific fault handlers for the ARM architecture, providing the necessary functions and data structures to manage faults and exceptions in the system.", "title": "./spec/design/skel/ARM_HYP/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP_H decls_only NOT VPPIEventIRQ VirtTimer\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP_H instanceproofs NOT VPPIEventIRQ VirtTimer\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP_H bodies_only NOT makeVCPUObject", "property": "Architectural Structures: Define the structures and settings for the ARM architecture, including ASID pools and architectural TCBs, to provide a foundation for the kernel's hardware interactions and management.", "title": "./spec/design/skel/ARM_HYP/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "defs makeVCPUObject_def:\n\"makeVCPUObject \\<equiv>\n    VCPUObj_ \\<lparr>\n          vcpuTCBPtr= Nothing\n        , vcpuVGIC= VGICInterface_ \\<lparr>\n                          vgicHCR= vgicHCREN\n                        , vgicVMCR= 0\n                        , vgicAPR= 0\n                        , vgicLR= (\\<lambda>_. 0)\n                        \\<rparr>\n        , vcpuRegs= funArray (const 0)  aLU  [(VCPURegSCTLR, sctlrDefault)\n                                             ,(VCPURegACTLR, actlrDefault)]\n        , vcpuVPPIMasked= (\\<lambda>_. False)\n        , vcpuVTimer= VirtTimer 0\n        \\<rparr>\"\n\ndatatype arch_kernel_object_type =\n    PDET\n  | PTET\n  | VCPUT\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPDE e) = PDET\"\n| \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOVCPU e) = VCPUT\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend", "property": "VCPU Object Creation: Creates a new VCPU object with default settings, including a VGIC interface, registers, and a virtual timer, ensuring a consistent initial state for VCPU objects.\n\nArchitectural Object Type Identification: Identifies the type of an architectural kernel object, categorizing it as a page directory entry table, page table entry table, VCPU, or ASID pool, allowing for proper management and handling of different object types.", "title": "./spec/design/skel/ARM_HYP/ArchStructures_H.thy", "chapter": "", "section": "", "comment": " we define makeVCPUObject_def manually because we want a total function vgicLR "}
{"spec": "arch_requalify_types (H)\n  vcpu\n\nend", "property": "Requalification of VCPU Type: Requalify the VCPU type for specific architectures, as it is not possible to do so generically due to architecture-specific variations.", "title": "./spec/design/skel/ARM_HYP/ArchStructures_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, as some arches don't have vcpu "}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=ARM_HYP CONTEXT ARM_HYP_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Memory and Pointer Management: Define basic operations and types for working with memory and pointers in the system, including conversions between physical pointers and machine words, and definitions for null pointers.", "title": "./spec/design/skel/ARM_HYP/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs Arch= CONTEXT ARM_HYP_H bodies_only ArchInv= NOT initInterruptController\n\ndefinition initInterruptController :: \"unit kernel\"\n  where \"initInterruptController \\<equiv> (do\n    setIRQState IRQReserved $ irqVGICMaintenance;\n    return ()\nod)\"\n\nend\nend", "property": "Interrupt Controller Initialization: Initialize the interrupt controller by setting the IRQ state of the VGIC maintenance interrupt to reserved.", "title": "./spec/design/skel/ARM_HYP/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  VCPU_H\n  KI_Decls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/ARM.lhs CONTEXT ARM_HYP_H Arch.Types= ArchInv= bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/ARM.lhs bodies_only CONTEXT ARM_HYP_H NOT isPDFlushLabel isPageFlushLabel\n\nend\nend", "property": "Retype Objects: Allow the kernel to retype objects, modifying their type and properties while maintaining the integrity and consistency of the system's object model.", "title": "./spec/design/skel/ARM_HYP/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewPageCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        when (\\<not>dev) $\n          mapM_x (\\<lambda>addr. doMachineOp $\n                            cleanCacheRange_RAM addr\n                                                (addr + mask (pageBitsForSize pSize))\n                                                (addrFromPPtr addr)) addrs;\n        return $ map (\\<lambda>n. PageCap dev (PPtr (fromPPtr n)) VMReadWrite pSize Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects tableBits objectProto cap initialiseMappings \\<equiv> (do\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      initialiseMappings pts;\n      mapM_x (\\<lambda>addr. doMachineOp $\n                       cleanCacheRange_PoU addr (addr + mask tableBits) (addrFromPPtr addr)) addrs;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 0 ARMSmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 4 ARMLargePage\n        | SectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 9 ARMSection\n        | SuperSectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 13 ARMSuperSection\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects ptBits (makeObject::pte) PageTableCap\n              (\\<lambda>pts. return ())\n        | PageDirectoryObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pdBits (makeObject::pde) PageDirectoryCap\n              (\\<lambda>pds. do objSize \\<leftarrow> return (((1::nat) `~shiftL~` pdBits));\n                        mapM_x copyGlobalMappings pds\n                     od)\n        | VCPUObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject :: vcpu)) 0;\n            return $ map (\\<lambda>addr. VCPUCap addr) addrs\n            od)\n        )\"\n\nend\nend\n\nend", "property": "Create New Capability Objects: Supports the creation of various capability objects (e.g., page, table, VCPU) with specified attributes (e.g., device, size, access rights) in a given memory region, ensuring proper initialization and caching. \n\nSubproperties:\n- Create Page Objects: Creates new page capability objects with specified properties (device, size, access rights) in a given memory region, handling caching and initialization.\n- Create Table Objects: Creates new table capability objects (e.g., page tables, page directories) with specified properties (size, mappings) in a given memory region, handling caching and initialization.\n- Create VCPU Objects: Creates new VCPU capability objects in a given memory region, ensuring proper initialization.", "title": "./spec/design/skel/ARM_HYP/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/ARM.lhs CONTEXT ARM_HYP_H ARMHardware=ARM_HYP bodies_only\n\nend\nend", "property": "No specific property can be summarized from the given code snippet as it appears to be a header or import section, and does not contain any specific functionality or behavior that can be described as a property.", "title": "./spec/design/skel/ARM_HYP/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/API/Invocation/ARM.lhs CONTEXT ARM_HYP_H ONLY isPDFlushLabel isPageFlushLabel\n\nend\nend", "property": "Arch-Specific Invocation Label Checks: Identify specific invocation labels (e.g., page directory flush, page flush) for architecture-specific handling.", "title": "./spec/design/skel/ARM_HYP/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": "\n  Arch-specific functions on invocation labels\n"}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  FaultHandlerDecls_H\n  InterruptDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/VCPU/ARM.lhs CONTEXT ARM_HYP_H decls_only ONLY countTrailingZeros irqVPPIEventIndex\n#INCLUDE_HASKELL SEL4/Object/VCPU/ARM.lhs CONTEXT ARM_HYP_H bodies_only ONLY countTrailingZeros irqVPPIEventIndex\n\n#INCLUDE_HASKELL SEL4/Object/VCPU/ARM.lhs CONTEXT ARM_HYP_H ArchInv=Arch ONLY vcpuUpdate vgicUpdate vgicUpdateLR vcpuSaveReg vcpuRestoreReg vcpuSaveRegRange vcpuRestoreRegRange vcpuWriteReg vcpuReadReg saveVirtTimer restoreVirtTimer vcpuDisable vcpuEnable vcpuRestore armvVCPUSave vcpuSave vcpuSwitch vcpuInvalidateActive vcpuCleanInvalidateActive virqSetEOIIRQEN vgicMaintenance vppiEvent\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_HYP_H decls_only\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_HYP_H bodies_only\n\nend\nend", "property": "Hypervisor Management: Provides functions for managing virtual CPUs (VCPUs) and virtual interrupt controllers (VGICs), including updating, saving, and restoring VCPU state, as well as handling virtual interrupts and timer events.", "title": "./spec/design/skel/ARM_HYP/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs CONTEXT Arch decls_only ArchInv=\n\nend\n\nend", "property": "No property can be extracted from this code snippet as it appears to be a header or import declaration and does not contain any specific functionality or behavior that can be summarized as a property.", "title": "./spec/design/skel/ARM_HYP/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs Platform=Platform.ARM_HYP CONTEXT ARM_HYP_H NOT getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory writeTTBR0 setGlobalPD  setTTBCR setHardwareASID invalidateLocalTLB invalidateLocalTLB_ASID invalidateLocalTLB_VAASID cleanByVA cleanByVA_PoU invalidateByVA invalidateByVA_I invalidate_I_PoU cleanInvalByVA branchFlush clean_D_PoU cleanInvalidate_D_PoC cleanInvalidate_D_PoU cleanInvalidateL2Range invalidateL2Range cleanL2Range isb dsb dmb getIFSR getDFSR getFAR HardwareASID wordFromPDE wordFromPTE VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize toPAddr paddrBase pptrBase pptrTop paddrTop kernelELFPAddrBase kernelELFBase kernelELFBaseOffset pptrBaseOffset cacheLineBits cacheLine lineStart cacheRangeOp cleanCacheRange_PoC cleanInvalidateCacheRange_RAM cleanCacheRange_RAM cleanCacheRange_PoU invalidateCacheRange_RAM invalidateCacheRange_I branchFlushRange cleanCaches_PoU cleanInvalidateL1Caches addrFromPPtr ptrFromPAddr addrFromKPPtr initIRQController MachineData hapFromVMRights wordsFromPDE wordsFromPTE writeContextIDAndPD hcrVCPU hcrNative vgicHCREN sctlrDefault actlrDefault gicVCPUMaxNumLR getHSR setHCR getHDFAR addressTranslateS1 getSCTLR setSCTLR getACTLR setACTLR get_gic_vcpu_ctrl_hcr set_gic_vcpu_ctrl_hcr get_gic_vcpu_ctrl_vmcr set_gic_vcpu_ctrl_vmcr get_gic_vcpu_ctrl_apr set_gic_vcpu_ctrl_apr get_gic_vcpu_ctrl_vtr get_gic_vcpu_ctrl_eisr0 get_gic_vcpu_ctrl_eisr1 get_gic_vcpu_ctrl_misr get_gic_vcpu_ctrl_lr set_gic_vcpu_ctrl_lr setCurrentPDPL2 readVCPUHardwareReg setIRQTrigger writeVCPUHardwareReg getTPIDRURO setTPIDRURO get_cntv_cval_64 set_cntv_cval_64 set_cntv_off_64 get_cntv_off_64 read_cntpct\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP_H instanceproofs NOT HardwareASID VMFaultType HypFaultType VMPageSize\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP_H ONLY hapFromVMRights wordsFromPDE wordsFromPTE", "property": "Hardware Abstraction: Provides a hardware abstraction layer for the ARM architecture, encapsulating various low-level operations and hardware-specific details, such as memory management, interrupt handling, timer configuration, and cache operations.\n\nSubproperties:\n- Memory Management: Offers functions for managing memory, including loading and storing words, clearing memory, and initializing memory regions.\n- Interrupt Handling: Provides functions for handling interrupts, including getting and acknowledging interrupts, masking interrupts, and resetting timers.\n- Timer Configuration: Supports configuring timers, including setting the next PC and resetting timers.\n- Cache Operations: Offers functions for managing caches, including cleaning and invalidating cache ranges, and flushing branches.\n- Hardware-Specific Operations: Encapsulates hardware-specific operations, such as getting and setting hardware registers, and performing hardware-specific actions.", "title": "./spec/design/skel/ARM_HYP/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ \\<equiv> Kernel_Config.maxIRQ\"", "property": "IRQ Range Limitation: The maximum IRQ value is defined as a generic numeral in Kernel_Config and is denoted as maxIRQ.", "title": "./spec/design/skel/ARM_HYP/Hardware_H.thy", "chapter": "", "section": "", "comment": " Kernel_Config provides a generic numeral, Haskell expects type irq "}
{"spec": "abbreviation (input) initIRQController where\n  \"initIRQController \\<equiv> ARM_HYP.initIRQController\"\n\nend\nend", "property": "Initialization of IRQ Controller: Provides the initialization operation for the IRQ controller on ARM/ARM_HYP machines.", "title": "./spec/design/skel/ARM_HYP/Hardware_H.thy", "chapter": "", "section": "", "comment": " provide ARM/ARM_HYP machine op in _H global_prefix for arch-split "}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM decls_only NOT UserContext UserMonad Word getRegister setRegister newContext", "property": "Machine State Management: Provides access to and modification of the ARM machine's register set, allowing for the retrieval and update of specific registers within the machine state.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM instanceproofs", "property": "Machine State Requalification: Requalify the machine state for ARM architecture, ensuring that the register set is correctly defined and validated.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM bodies_only NOT getRegister setRegister newContext", "property": "ARM Machine State Management: Manage the state of the ARM machine, including the register set, to ensure correct execution and interaction with the kernel.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest", "property": "Existence of Machine State: The machine state exists and can be interacted with through interface functions, but its internal workings and transformations are left underspecified.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym exclusive_monitors = \"(word32 \\<Rightarrow> bool) list \\<times> (word32 \\<times> nat \\<Rightarrow> bool)\"", "property": "Exclusive Monitors State: The state of exclusive monitors is observable in user mode, represented as a pair of a list of boolean functions mapping 32-bit words and a boolean function mapping 32-bit words and natural numbers.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The exclusive monitors state is observable in user mode.\n  The type for this is the type used in the Cambridge HOL4 ARM model.\n"}
{"spec": "end\n\nqualify ARM (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"ARM.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"word32 \\<Rightarrow> word8\"\n  device_state :: \"word32 \\<Rightarrow> word8 option\"\n  exclusive_state :: ARM.exclusive_monitors\n  machine_state_rest :: ARM.machine_state_rest\n\naxiomatization\n  irq_oracle :: \"nat \\<Rightarrow> ARM.irq\"\nwhere\n  irq_oracle_max_irq: \"\\<forall> n. irq_oracle n <= Kernel_Config.maxIRQ\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State: The machine state consists of the interrupt controller state (IRQ masks and IRQ state), memory (underlying memory, device state, and exclusive state), and underspecified rest. The interrupt controller state tracks which IRQs are masked, while the memory components reflect the state of kernel and user memory.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The full machine state is the state observable by the kernel plus\n  the underspecified rest above. The observable parts are the\n  interrupt controller (which IRQs are masked) and the memory of the\n  machine. The latter is shadow state: kernel memory is kept in a\n  separate, more abstract datatype; user memory is reflected down\n  to the underlying memory of the machine.\n"}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c ARM.machine_monad\" <= (type) \"(ARM.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine State Operations: Define a machine monad for nondeterministic operations on the machine state, encapsulating the state's interaction with the ARM architecture.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masks Initialization: All IRQs are masked after kernel initialization.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"word32 \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized with all contents set to 0.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "consts' default_exclusive_state :: exclusive_monitors", "property": "Initial Exclusive State: The initial exclusive state is set to a constant default value, ensuring consistent and predictable behavior of the exclusive monitors.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The initial exclusive state is the same constant\n  that clearExMonitor defaults it to.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         exclusive_state = default_exclusive_state,\n                         machine_state_rest = undefined \\<rparr>\"", "property": "Machine State Initialization: The machine state is initialized with default values for IRQ masks, IRQ state, underlying memory, device state, and exclusive state, while leaving the underspecified rest of the machine state undefined.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM ONLY HardwareASID VMFaultType VMPageSize HypFaultType pageBits pageBitsForSize\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM instanceproofs ONLY HardwareASID VMFaultType VMPageSize HypFaultType\n\nend\nend", "property": "ARM Machine State Properties: Defines the hardware-specific properties for ARM machine types, including hardware ASID, VM fault type, VM page size, and Hyp fault type, ensuring correct hardware configuration and management.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": " Machine/Hardware/ARM.lhs - hardware_asid, vmfault_type and vmpage_size "}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/X64.lhs CONTEXT X64 decls_only NOT UserContext UserMonad Word getRegister setRegister newContext", "property": "Machine State Management: Provides functions to manage the machine state, including getting and setting register values, and creating a new context for the x86-64bit machine type.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register gdtslot\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/X64.lhs CONTEXT X64 instanceproofs", "property": "Machine State Requalification: Requalify the types of machine state for x86-64bit architecture, ensuring that the register and GDT slot types are correctly defined and globally named within the X64 context.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/X64.lhs CONTEXT X64 bodies_only NOT getRegister setRegister newContext", "property": "Machine State Management: Manage the state of the x86-64bit machine, including the register set. \n\nGet and Set Registers: Allow getting and setting the values of specific registers within the register set. \n\nCreate New Context: Create a new context for the machine, which includes initializing the register set.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest\n\nend\n\nqualify X64 (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"X64.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"word64 \\<Rightarrow> word8\"\n  device_state :: \"word64 \\<Rightarrow> word8 option\"\n  machine_state_rest :: X64.machine_state_rest\n\nconsts irq_oracle :: \"nat \\<Rightarrow> word8\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State Structure: The machine state is comprised of several components, including interrupt masks, interrupt state, underlying memory, device state, and additional underspecified state.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c X64.machine_monad\" <= (type) \"(X64.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine State Operations: Define a machine monad for nondeterministic operations on the machine state, encapsulating the state and its transformations.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masks Initialization: All IRQs are masked after kernel initialization.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"word64 \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized with all contents set to 0.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         machine_state_rest = undefined \\<rparr>\"\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs CONTEXT X64 ONLY VMFaultType HypFaultType VMPageSize VMMapType pageBits ptTranslationBits pageBitsForSize\n\nend\n\narch_requalify_types vmpage_size vmmap_type\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs CONTEXT X64 instanceproofs ONLY VMFaultType HypFaultType VMPageSize VMMapType\n\nend\nend", "property": "Machine State Initialization: The machine state is initialized with default values for IRQ masks, IRQ state, underlying memory, and device state, while leaving the underspecified rest of the machine state undefined.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/RISCV64.hs CONTEXT RISCV64 decls_only NOT UserContext UserMonad Word getRegister setRegister newContext", "property": "Machine State Management: Provides access to and modification of the RISCV 64-bit machine's register set, allowing for the retrieval and update of register values, as well as the creation of new machine contexts.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/RISCV64.hs CONTEXT RISCV64 instanceproofs", "property": "Machine State Requalification: Requalify the machine state for RISCV 64-bit architecture, ensuring that the register set is correctly defined and validated.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/RISCV64.hs CONTEXT RISCV64 bodies_only NOT getRegister setRegister newContext", "property": "RISCV 64-bit Machine State: Defines the machine state for RISCV 64-bit architecture, including the register set and context management functions. \n\nRegister Set Management: Provides functions to get and set registers, and create a new context for the RISCV 64-bit architecture.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest\n\nend\n\nqualify RISCV64 (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"RISCV64.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"machine_word \\<Rightarrow> word8\"\n  device_state :: \"machine_word \\<Rightarrow> word8 option\"\n  machine_state_rest :: RISCV64.machine_state_rest\n\naxiomatization\n  irq_oracle :: \"nat \\<Rightarrow> RISCV64.irq\"\nwhere\n  irq_oracle_max_irq: \"\\<forall>n. irq_oracle n <= RISCV64.maxIRQ\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State Structure: The machine state consists of interrupt masks, interrupt state, underlying memory, device state, and underspecified machine state rest.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c RISCV64.machine_monad\" <= (type) \"(RISCV64.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine State Monad: Defines a non-deterministic monad for operations on the machine state, encapsulating the state and its transformations.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masks Initialization: All IRQs are masked after kernel initialization.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"machine_word \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized with all contents set to 0.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         machine_state_rest = undefined \\<rparr>\"\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64 ONLY VMFaultType HypFaultType vmFaultTypeFSR VMPageSize pageBits ptTranslationBits pageBitsForSize\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64 instanceproofs ONLY VMFaultType HypFaultType VMPageSize\n\nend\nend", "property": "Machine State Initialization: The machine state is initialized with default values for IRQ masks, IRQ state, underlying memory, and device state, while leaving the underspecified rest of the machine state undefined.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/AARCH64.hs CONTEXT AARCH64 decls_only NOT UserContext UserMonad Word getRegister setRegister newContext FPUState newFPUState\n\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64 ONLY VPPIEventIRQ VirtTimer", "property": "Machine State Management: Manage the state of the AARCH64 machine, including accessing and modifying register sets, creating new user contexts, and handling FPU state. \n\n Register Set Management: Access and modify the AARCH64 register set, including getting and setting register values.\n\n User Context Management: Create new user contexts for the AARCH64 machine.\n\n FPU State Management: Create new FPU states for the AARCH64 machine.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register vcpureg vppievent_irq virt_timer\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/AARCH64.hs CONTEXT AARCH64 instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64 instanceproofs ONLY VPPIEventIRQ VirtTimer", "property": "Machine State Requalification: Requalify AARCH64 machine types to ensure correct representation of machine state, including registers, virtual CPU registers, VPP events, and virtual timers.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/AARCH64.hs CONTEXT AARCH64 bodies_only NOT getRegister setRegister newContext newFPUState", "property": "AARCH64 Machine State Management: Define the AARCH64 machine state, including the register set, to manage and manipulate the machine's state effectively.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest\n\nend\n\nqualify AARCH64 (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"AARCH64.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"machine_word \\<Rightarrow> word8\"\n  device_state :: \"machine_word \\<Rightarrow> word8 option\"\n  machine_state_rest :: AARCH64.machine_state_rest\n\naxiomatization\n  irq_oracle :: \"nat \\<Rightarrow> AARCH64.irq\"\nwhere\n  irq_oracle_max_irq: \"\\<forall>n. irq_oracle n <= Kernel_Config.maxIRQ\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State Structure: The machine state consists of interrupt masks, interrupt state, underlying memory, device state, and additional underspecified machine state.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c AARCH64.machine_monad\" <= (type) \"(AARCH64.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine State Operations: Define a machine monad for nondeterministic operations on the AARCH64 machine state.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masks Initialization: All IRQs are masked after kernel initialization.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"machine_word \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized with all contents set to 0.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         machine_state_rest = undefined \\<rparr>\"\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64 ONLY \\\n  PT_Type \\\n  VMFaultType HypFaultType vmFaultTypeFSR VMPageSize pageBits ptTranslationBits \\\n  pageBitsForSize \\\n  hcrCommon hcrTWE hcrTWI \\\n  hcrVCPU hcrNative vgicHCREN sctlrDefault sctlrEL1VM actlrDefault gicVCPUMaxNumLR \\\n  vcpuBits\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64 instanceproofs ONLY VMFaultType HypFaultType VMPageSize\n\nend\nend", "property": "Machine State Initialization: The machine state is initialized with defined values for IRQ masks, IRQ state, underlying memory, and device state, while leaving the underspecified rest of the machine state undefined.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM_HYP decls_only NOT UserContext UserMonad Word getRegister setRegister newContext\n\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP ONLY VPPIEventIRQ VirtTimer", "property": "Machine State Management: Provides access to and manipulation of the ARM_HYP machine's register set, including getting and setting register values, and creating new contexts. Additionally, defines structures for VPPIEventIRQ and VirtTimer objects.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register vcpureg vppievent_irq virt_timer\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM_HYP instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP instanceproofs ONLY VPPIEventIRQ VirtTimer", "property": "Machine State Requalification: Requalify ARM_HYP machine types to ensure correct state management, including register, virtual CPU, VPP event IRQ, and virtual timer requalification.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM_HYP bodies_only NOT getRegister setRegister newContext", "property": "Machine State Management: Manage the state of the ARM_HYP machine, including register sets, to ensure correct execution and context switching. \n\nRegister Set Management: Provide functions to get and set registers, as well as create a new context for the ARM_HYP machine.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest", "property": "Existence of Machine State: The machine state exists and can be interacted with through interface functions, but its internal workings and transformations are left underspecified.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym exclusive_monitors = \"(word32 \\<Rightarrow> bool) list \\<times> (word32 \\<times> nat \\<Rightarrow> bool)\"", "property": "Exclusive Monitors State: The state of exclusive monitors is observable in user mode, represented as a pair of a list of boolean functions mapping 32-bit words to booleans and a boolean function mapping 32-bit words and natural numbers to booleans.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The exclusive monitors state is observable in user mode.\n  The type for this is the type used in the Cambridge HOL4 ARM model.\n"}
{"spec": "end\n\nqualify ARM_HYP (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"ARM_HYP.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"word32 \\<Rightarrow> word8\"\n  device_state :: \"word32 \\<Rightarrow> word8 option\"\n  exclusive_state :: ARM_HYP.exclusive_monitors\n  machine_state_rest :: ARM_HYP.machine_state_rest\n\naxiomatization\n  irq_oracle :: \"nat \\<Rightarrow> ARM_HYP.irq\"\nwhere\n  irq_oracle_max_irq: \"\\<forall> n. irq_oracle n <= Kernel_Config.maxIRQ\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State: The machine state consists of the interrupt controller state (IRQ masks and IRQ state), memory (underlying memory, device state, and exclusive state), and additional underspecified state (machine state rest). The interrupt controller state determines which IRQs are masked, while the memory state reflects the kernel's abstract view of memory and the underlying machine's memory.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The full machine state is the state observable by the kernel plus\n  the underspecified rest above. The observable parts are the\n  interrupt controller (which IRQs are masked) and the memory of the\n  machine. The latter is shadow state: kernel memory is kept in a\n  separate, more abstract datatype; user memory is reflected down\n  to the underlying memory of the machine.\n"}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c ARM_HYP.machine_monad\" <= (type) \"(ARM_HYP.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine State Management: Define the machine monad for operations on the machine state, encapsulating nondeterministic state transformations.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masking: All IRQs are masked after kernel initialization.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"word32 \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized with all contents set to 0.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "consts' default_exclusive_state :: exclusive_monitors", "property": "Initial Exclusive State: The initial exclusive state is set to a constant value, which is the same as the default value used by clearExMonitor.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The initial exclusive state is the same constant\n  that clearExMonitor defaults it to.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         exclusive_state = default_exclusive_state,\n                         machine_state_rest = undefined \\<rparr>\"", "property": "Machine State Initialization: The machine state is initialized with default values for IRQ masks, IRQ state, underlying memory, device state, and exclusive state, while leaving the rest of the machine state underspecified. \n\nSubproperties:\n- IRQ Masks Initialization: IRQ masks are initialized to their default values.\n- IRQ State Initialization: The IRQ state is initialized to 0.\n- Underlying Memory Initialization: The underlying memory is initialized to its default state.\n- Device State Initialization: The device state is initialized as an empty map.\n- Exclusive State Initialization: The exclusive state is initialized to its default value.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP ONLY HardwareASID VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize hcrCommon hcrTWE hcrTWI hcrVCPU hcrNative vgicHCREN sctlrDefault actlrDefault gicVCPUMaxNumLR\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP instanceproofs ONLY HardwareASID VMFaultType HypFaultType VMPageSize\n\nend\nend", "property": "Machine State Properties: Define the hardware-specific machine state for ARM_HYP, including hardware ASID, VM fault types, and VM page sizes, ensuring correct hardware configuration and virtualization support. \n\nHardware Configuration: Specify the hardware control register (HCR) settings, including common, TWE, TWI, VCPU, and native configurations, as well as the system control register (SCTLR) and auxiliary control register (ACTLR) defaults, to ensure proper hardware setup and virtualization functionality.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": " Machine/Hardware/ARM.lhs - hardware_asid, vmfault_type and vmpage_size "}
{"spec": "theory Decode_D\nimports\n  Asid_D\n  CNode_D\n  Interrupt_D\n  PageTable_D\n  Tcb_D\n  Untyped_D\nbegin\n\ndefinition\n  get_cnode_intent :: \"cdl_intent \\<Rightarrow> cdl_cnode_intent option\"\nwhere\n  \"get_cnode_intent intent \\<equiv>\n    case intent of\n        CNodeIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_tcb_intent :: \"cdl_intent \\<Rightarrow> cdl_tcb_intent option\"\nwhere\n  \"get_tcb_intent intent \\<equiv>\n    case intent of\n        TcbIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_irq_control_intent :: \"cdl_intent \\<Rightarrow> cdl_irq_control_intent option\"\nwhere\n  \"get_irq_control_intent intent \\<equiv>\n    case intent of\n        IrqControlIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_irq_handler_intent :: \"cdl_intent \\<Rightarrow> cdl_irq_handler_intent option\"\nwhere\n  \"get_irq_handler_intent intent \\<equiv>\n    case intent of\n        IrqHandlerIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_asid_pool_intent :: \"cdl_intent \\<Rightarrow> cdl_asid_pool_intent option\"\nwhere\n  \"get_asid_pool_intent intent \\<equiv>\n    case intent of\n        AsidPoolIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\n\ndefinition\n  get_asid_control_intent :: \"cdl_intent \\<Rightarrow> cdl_asid_control_intent option\"\nwhere\n  \"get_asid_control_intent intent \\<equiv>\n    case intent of\n        AsidControlIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_page_intent :: \"cdl_intent \\<Rightarrow> cdl_page_intent option\"\nwhere\n  \"get_page_intent intent \\<equiv>\n    case intent of\n        PageIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_page_table_intent :: \"cdl_intent \\<Rightarrow> cdl_page_table_intent option\"\nwhere\n  \"get_page_table_intent intent \\<equiv>\n    case intent of\n        PageTableIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_page_directory_intent :: \"cdl_intent \\<Rightarrow> cdl_page_directory_intent option\"\nwhere\n  \"get_page_directory_intent intent \\<equiv>\n    case intent of\n        PageDirectoryIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_untyped_intent :: \"cdl_intent \\<Rightarrow> cdl_untyped_intent option\"\nwhere\n  \"get_untyped_intent intent \\<equiv>\n    case intent of\n        UntypedIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_domain_intent :: \"cdl_intent \\<Rightarrow> cdl_domain_intent option\"\nwhere\n  \"get_domain_intent intent \\<equiv>\n     case intent of\n         DomainIntent x \\<Rightarrow> Some x\n       | _ \\<Rightarrow> None\"", "property": "Intent Extraction: Extract specific intent information from a given CDL intent, returning an option containing the corresponding intent data if the intent matches the desired type, or None otherwise. \n\nSubproperties:\n- CNode Intent Extraction: Extract CNode intent information.\n- TCB Intent Extraction: Extract TCB intent information.\n- IRQ Control Intent Extraction: Extract IRQ control intent information.\n- IRQ Handler Intent Extraction: Extract IRQ handler intent information.\n- ASID Pool Intent Extraction: Extract ASID pool intent information.\n- ASID Control Intent Extraction: Extract ASID control intent information.\n- Page Intent Extraction: Extract page intent information.\n- Page Table Intent Extraction: Extract page table intent information.\n- Page Directory Intent Extraction: Extract page directory intent information.\n- Untyped Intent Extraction: Extract untyped intent information.\n- Domain Intent Extraction: Extract domain intent information.", "title": "./spec/capDL/Decode_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  decode_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow> cdl_intent \\<Rightarrow> cdl_invocation except_monad\"\nwhere\n  \"decode_invocation invoked_cap invoked_cap_ref caps intent \\<equiv>\n    case invoked_cap of\n       \\<comment> \\<open>For endpoint-like caps, we always perform an operation,\n          regardless of the user's actual intent.\\<close>\n         EndpointCap o_id badge rights \\<Rightarrow>\n           (if Write \\<in> rights then\n             returnOk $ InvokeEndpoint (SyncMessage badge (Grant \\<in> rights) (GrantReply \\<in> rights) o_id)\n           else\n             throw)\n       | NotificationCap o_id badge rights \\<Rightarrow>\n           (if Write \\<in> rights then\n             returnOk $ InvokeNotification (Signal badge o_id)\n           else\n             throw)\n       | ReplyCap o_id rights \\<Rightarrow>\n           returnOk $ InvokeReply (ReplyMessage o_id invoked_cap_ref (Grant \\<in> rights))\n\n       \\<comment> \\<open>\n         For other operations, we only perform the user's intent\n         if it matches up with the cap.\n        \n         Note that this does not currently match the current\n         implementation: instead, the user's message will be\n         decoded into a new (undefined) intent for what the\n         cap happened to be. I propose modifying labels used to\n         avoid overlaps between different items so that we can\n         recognise when the user is invoking the wrong item.\n       \\<close>\n       | CNodeCap _ _ _ _ \\<Rightarrow>\n           doE\n             cnode_intent \\<leftarrow> throw_opt undefined $ get_cnode_intent intent;\n             liftME InvokeCNode $ decode_cnode_invocation invoked_cap invoked_cap_ref caps cnode_intent\n           odE\n       | TcbCap _ \\<Rightarrow>\n           doE\n             tcb_intent \\<leftarrow> throw_opt undefined $ get_tcb_intent intent;\n             liftME InvokeTcb $ decode_tcb_invocation invoked_cap invoked_cap_ref caps tcb_intent\n           odE\n       | IrqControlCap \\<Rightarrow>\n           doE\n             irq_control_intent \\<leftarrow> throw_opt undefined $ get_irq_control_intent intent;\n             liftME InvokeIrqControl $ decode_irq_control_invocation\n                 invoked_cap invoked_cap_ref caps irq_control_intent\n           odE\n       | IrqHandlerCap _ \\<Rightarrow>\n           doE\n             irq_handler_intent \\<leftarrow> throw_opt undefined $ get_irq_handler_intent intent;\n             liftME InvokeIrqHandler $ decode_irq_handler_invocation\n                 invoked_cap invoked_cap_ref caps irq_handler_intent\n           odE\n       | AsidPoolCap _ _\\<Rightarrow>\n           doE\n             asid_pool_intent \\<leftarrow> throw_opt undefined $ get_asid_pool_intent intent;\n             liftME InvokeAsidPool $ decode_asid_pool_invocation\n                 invoked_cap invoked_cap_ref caps asid_pool_intent\n           odE\n       | AsidControlCap \\<Rightarrow>\n           doE\n             asid_control_intent \\<leftarrow> throw_opt undefined $ get_asid_control_intent intent;\n             liftME InvokeAsidControl $ decode_asid_control_invocation\n                 invoked_cap invoked_cap_ref caps asid_control_intent\n           odE\n       | UntypedCap _ _ _ \\<Rightarrow>\n           doE\n             untyped_intent \\<leftarrow> throw_opt undefined $ get_untyped_intent intent;\n             liftME InvokeUntyped $ decode_untyped_invocation\n                 invoked_cap invoked_cap_ref caps untyped_intent\n           odE\n       | FrameCap _ _ _ _ _ _ \\<Rightarrow>\n           doE\n             page_intent \\<leftarrow> throw_opt undefined $ get_page_intent intent;\n             liftME InvokePage $ decode_page_invocation\n                 invoked_cap invoked_cap_ref caps page_intent\n           odE\n       | PageTableCap _ _ _ \\<Rightarrow>\n           doE\n             page_table_intent \\<leftarrow> throw_opt undefined $ get_page_table_intent intent;\n             liftME InvokePageTable $ decode_page_table_invocation\n                 invoked_cap invoked_cap_ref caps page_table_intent\n           odE\n       | PageDirectoryCap _ _ _ \\<Rightarrow>\n          doE\n             page_directory_intent \\<leftarrow> throw_opt undefined $ get_page_directory_intent intent;\n             liftME InvokePageDirectory $ decode_page_directory_invocation\n                 invoked_cap invoked_cap_ref caps page_directory_intent\n           odE\n       | DomainCap \\<Rightarrow>\n          doE\n            domain_intent \\<leftarrow> throw_opt undefined $ get_domain_intent intent;\n            liftME InvokeDomain $ decode_domain_invocation caps domain_intent\n          odE\n\n       \\<comment> \\<open>Don't support operations on other types of caps.\\<close>\n       | _ \\<Rightarrow> throw\"\n\nend", "property": "Decode and Validate Invocation: Transform the given intent into a validated invocation based on the type of capability, ensuring that the operation matches the capability's rights and intent. \n\nSubproperties:\n- Endpoint Capabilities: Always perform an operation (send a message) if the capability has write rights.\n- Notification Capabilities: Always perform an operation (send a signal) if the capability has write rights.\n- Reply Capabilities: Always perform an operation (send a reply message).\n- Other Capabilities: Perform the user's intent only if it matches the capability type and rights.", "title": "./spec/capDL/Decode_D.thy", "chapter": "", "section": "", "comment": "\n * Decode and validate the given intent, turning it into an\n * invocation.\n "}
{"spec": "(*\n * Operations on page table objects and frames.\n *)\n\ntheory Asid_D\nimports\n  Invocations_D\n  CSpace_D\n  Untyped_D\nbegin\n\ndefinition\n  decode_asid_control_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_asid_control_intent \\<Rightarrow> cdl_asid_control_invocation except_monad\"\nwhere\n  \"decode_asid_control_invocation target target_ref caps intent \\<equiv> case intent of\n     AsidControlMakePoolIntent index depth \\<Rightarrow>\n       doE\n         base \\<leftarrow> liftE $ select {x. x < 2 ^ asid_high_bits};\n\n         \\<comment> \\<open>Fetch the untyped item, and ensure it is valid.\\<close>\n         (untyped_cap, untyped_cap_ref) \\<leftarrow> throw_on_none $ get_index caps 0;\n         (case untyped_cap of\n             UntypedCap _ s _ \\<Rightarrow> returnOk ()\n           | _ \\<Rightarrow> throw);\n         ensure_no_children untyped_cap_ref;\n\n         \\<comment> \\<open>Fetch the slot we plan to put the generated cap into.\\<close>\n         (cspace_cap, _) \\<leftarrow> throw_on_none $ get_index caps 1;\n         target_slot \\<leftarrow> lookup_slot_for_cnode_op cspace_cap index (unat depth);\n         ensure_empty target_slot;\n\n         returnOk $ MakePool (set_available_range untyped_cap {}) untyped_cap_ref\n           (cap_objects untyped_cap) target_slot base\n       odE \\<sqinter> throw\"\n\ndefinition\n  decode_asid_pool_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_asid_pool_intent \\<Rightarrow> cdl_asid_pool_invocation except_monad\"\nwhere\n  \"decode_asid_pool_invocation target target_ref caps intent \\<equiv> case intent of\n     AsidPoolAssignIntent \\<Rightarrow>\n       doE\n         (pd_cap, pd_cap_ref) \\<leftarrow> throw_on_none $ get_index caps 0;\n         (case pd_cap of\n             PageDirectoryCap _ _ _ \\<Rightarrow> returnOk ()\n           | _ \\<Rightarrow> throw);\n\n         base \\<leftarrow> (case target of\n             AsidPoolCap p base \\<Rightarrow> returnOk $ base\n           | _ \\<Rightarrow> throw);\n         offset \\<leftarrow> liftE $ select {x. x < 2 ^ asid_low_bits};\n         returnOk $ Assign (base, offset) pd_cap_ref (cap_object target, offset)\n       odE \\<sqinter> throw\"\n\ndefinition\n  invoke_asid_control :: \"cdl_asid_control_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_asid_control params \\<equiv>\n    case params of\n        MakePool untyped_cap untyped_cap_ref untyped_covers target_slot base \\<Rightarrow>\n          do\n            \\<comment> \\<open>Untype the region. A choice may be made about whether to detype\n               objects with Untyped addresses.\\<close>\n            modify (detype untyped_covers);\n            set_cap untyped_cap_ref untyped_cap;\n            targets \\<leftarrow> generate_object_ids 1 AsidPoolType untyped_covers;\n\n            \\<comment> \\<open>Retype the region.\\<close>\n            retype_region 0 AsidPoolType targets;\n            assert (targets \\<noteq> []);\n\n            \\<comment> \\<open>Insert the cap.\\<close>\n            frame \\<leftarrow> return $ pick (hd targets);\n            insert_cap_child (AsidPoolCap frame base) untyped_cap_ref target_slot;\n\n            \\<comment> \\<open>Update the asid table.\\<close>\n            asid_table \\<leftarrow> gets cdl_asid_table;\n            asid_table' \\<leftarrow> return $ asid_table (base \\<mapsto> AsidPoolCap frame 0);\n            modify (\\<lambda>s. s \\<lparr>cdl_asid_table := asid_table'\\<rparr>)\n\n          od\"\n\ndefinition\n  invoke_asid_pool :: \"cdl_asid_pool_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_asid_pool params \\<equiv>\n     case params of\n       Assign asid pd_cap_ref ap_target_slot \\<Rightarrow> do\n         pd_cap \\<leftarrow> get_cap pd_cap_ref;\n         case pd_cap of\n           PageDirectoryCap pd_id _ _ \\<Rightarrow> do\n             set_cap pd_cap_ref (PageDirectoryCap pd_id Real (Some asid));\n             set_cap ap_target_slot (PageDirectoryCap pd_id Fake None)\n           od\n         | _ \\<Rightarrow> fail\n       od\"\n\nend", "property": "ASID Control and Pool Management: \n- ASID Control Invocation: Decodes and performs ASID control invocations, including making a new ASID pool from an untyped capability, ensuring the untyped item is valid, and inserting the generated cap into the target slot.\n- ASID Pool Invocation: Decodes and performs ASID pool invocations, including assigning a page directory to an ASID pool, updating the page directory capability, and setting the ASID pool capability.\n- ASID Control and Pool Operations: Invokes ASID control and pool operations, including untyping and retyping regions, inserting capabilities, and updating the ASID table.", "title": "./spec/capDL/Asid_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n * Operations on untyped memory objects.\n *)\n\ntheory Untyped_D\nimports Invocations_D CSpace_D\nbegin\n\ndefinition\n  decode_untyped_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_untyped_intent \\<Rightarrow> cdl_untyped_invocation except_monad\"\nwhere\n  \"decode_untyped_invocation untyped_cap untyped_ref caps intent \\<equiv> case intent of\n     UntypedRetypeIntent type size_bits node_index node_depth node_offset node_window \\<Rightarrow>\n       doE\n         (root_cap, root_slot) \\<leftarrow> throw_on_none $ get_index caps 0;\n\n         \\<comment> \\<open>Lookup the destination slots.\\<close>\n         target_node \\<leftarrow> if node_depth = 0 then\n             returnOk root_cap\n           else\n             doE\n               target_slot \\<leftarrow> lookup_slot_for_cnode_op root_cap node_index (unat node_depth);\n               liftE $ get_cap target_slot\n             odE;\n\n         \\<comment> \\<open>Ensure it is a CNode cap.\\<close>\n         unlessE (is_cnode_cap target_node) throw;\n\n         \\<comment> \\<open>Find our target slots.\\<close>\n         slots \\<leftarrow> returnOk $ map (\\<lambda>n. (cap_object target_node, n))\n               [unat node_offset ..< unat node_offset + unat node_window];\n         mapME_x ensure_empty slots;\n\n         \\<comment> \\<open>Work out what names are available. If we haven't haven't already been typed into something we can reuse our names.\\<close>\n         s \\<leftarrow> liftE $ get;\n         has_kids \\<leftarrow> returnOk $ has_children untyped_ref s;\n\n         returnOk $ Retype untyped_ref type (unat size_bits) slots has_kids (unat node_window)\n       odE \\<sqinter> throw\"", "property": "Decode Untyped Invocation: Validate and decode an untyped invocation, ensuring the target node is a CNode cap, the destination slots are empty, and determining the available names for the retype operation. \n\nSubproperties:\n- Target Node Validation: Verify the target node is a valid CNode cap.\n- Slot Validation: Ensure the destination slots are empty.\n- Name Availability: Determine the available names for the retype operation based on whether the untyped reference has children.", "title": "./spec/capDL/Untyped_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  detype :: \"cdl_object_id set \\<Rightarrow> cdl_state \\<Rightarrow> cdl_state\"\nwhere\n  \"detype detype_set s \\<equiv>\n     (s\\<lparr> cdl_objects :=\n         (\\<lambda>x. if x \\<in> detype_set then\n           Some Untyped\n         else cdl_objects s x)\\<rparr>)\"", "property": "Detype Function: Zero out a set of addresses by replacing the corresponding objects in the state with Untyped objects, effectively removing their type information.", "title": "./spec/capDL/Untyped_D.thy", "chapter": "", "section": "", "comment": " Zero out a set of addresses. "}
{"spec": "definition\n  generate_object_ids :: \"nat \\<Rightarrow> cdl_object_type \\<Rightarrow> cdl_object_id set \\<Rightarrow>  ((cdl_object_id set) list) k_monad\"\n  where \"generate_object_ids num_objects type object_range\n  \\<equiv> do\n    s \\<leftarrow> get;\n    available_names \\<leftarrow> return $ (cdl_objects s) -` {Some Untyped};\n    setlist \\<leftarrow> select {x. distinct  x \\<and> (\\<forall>a\\<in> set x. \\<forall>b \\<in> set x. a \\<noteq> b \\<longrightarrow> a \\<inter> b = {})\n           \\<and> (\\<forall>y \\<in> set x. y \\<noteq> {} \\<and> y \\<subseteq> object_range \\<inter> available_names)\n           \\<and> (num_objects = (size x)) };\n    if (type \\<noteq> UntypedType) then (return $ map (\\<lambda>x. {pick x}) setlist)\n    else return setlist\n    od\"\n\ndefinition create_objects :: \"(cdl_object_id set) list \\<Rightarrow> cdl_object option \\<Rightarrow> unit k_monad\"\nwhere\n  \"create_objects target_object_ids object \\<equiv>\n    (modify (\\<lambda>s. s\\<lparr>cdl_objects := (\\<lambda>x.\n     if {x} \\<in> set target_object_ids then\n      object\n     else\n      cdl_objects s x)\\<rparr>))\"", "property": "Object Creation: Create new objects of a specified type within a given object range, ensuring distinct and non-overlapping object IDs. \n\nObject ID Generation: Generate a list of sets of unique object IDs within a specified range, excluding existing untyped objects. If the object type is not untyped, return a list of singleton sets containing the generated IDs.", "title": "./spec/capDL/Untyped_D.thy", "chapter": "", "section": "", "comment": "\n * Retype the given untyped object into a new object type,\n * and return a list of pointers to the newly constructed items.\n "}
{"spec": "definition\n  create_cap :: \"cdl_object_type \\<Rightarrow> nat \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool \\<Rightarrow> (cdl_cap_ref \\<times> cdl_object_id set) \\<Rightarrow> unit k_monad\"\nwhere\n  \"create_cap new_type sz parent_slot dev \\<equiv> \\<lambda>(dest_slot, obj_refs).\n  do\n    old_cap \\<leftarrow> get_cap dest_slot;\n    assert (old_cap = NullCap);\n    set_cap dest_slot (default_cap new_type obj_refs sz dev);\n    set_parent dest_slot parent_slot\n  od\"\n\n\ndefinition\n  update_available_range :: \"(cdl_object_id set) => (cdl_object_id list) \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> unit k_monad\"\nwhere \"update_available_range orange newids cap_ref cap \\<equiv>\n  do\n     new_range  \\<leftarrow> select {x. x \\<subseteq> orange - set newids};\n     set_cap cap_ref $ set_available_range cap new_range\n  od\"\n\n\ndefinition\n  retype_region :: \"nat \\<Rightarrow> cdl_object_type \\<Rightarrow> (cdl_object_id set list)\n  \\<Rightarrow> ((cdl_object_id set) list) k_monad\"\nwhere\n  \"retype_region target_bits target_type target_object_ids \\<equiv>\n    do\n      \\<comment> \\<open>Get a list of target locations. We are happy with any unused name\n         within the target range.\\<close>\n\n      if (target_type \\<noteq> UntypedType) then\n       do\n         current_domain \\<leftarrow> gets cdl_current_domain;\n         create_objects target_object_ids (default_object target_type target_bits current_domain)\n       od\n      else return ();\n\n      \\<comment> \\<open>Get a list of target locations. We are happy with any unused name\n         within the target range.\\<close>\n      return target_object_ids\n    od\"\n\nprimrec (nonexhaustive)\n  untyped_is_device :: \"cdl_cap \\<Rightarrow> bool\"\nwhere\n    \"untyped_is_device (UntypedCap d _ _) = d\"\n\ndefinition\n  reset_untyped_cap :: \"cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"reset_untyped_cap cref \\<equiv> doE\n    cap \\<leftarrow> liftE $ get_cap cref;\n    whenE (available_range cap \\<noteq> cap_objects cap) $ doE\n      liftE $ modify (detype (cap_objects cap));\n      new_rans \\<leftarrow> liftE $ select {xs. (\\<forall>S \\<in> set xs.\n              S \\<subseteq> cap_objects cap \\<and> available_range cap \\<subset> S)\n          \\<and> xs \\<noteq> [] \\<and> List.last xs = cap_objects cap};\n      mapME_x (\\<lambda>r. doE\n        liftE $ set_cap cref $ set_available_range cap r;\n        returnOk () \\<sqinter> throw\n      odE) new_rans\n    odE\n  odE\"\n\ndefinition\n  invoke_untyped :: \"cdl_untyped_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"invoke_untyped params \\<equiv> case params of\n     Retype untyped_ref new_type type_size target_slots has_kids num_objects \\<Rightarrow>\n   doE\n     unlessE has_kids $ reset_untyped_cap untyped_ref;\n       liftE $ do\n         untyped_cap \\<leftarrow> get_cap untyped_ref;\n\n         new_range \\<leftarrow> return $ available_range untyped_cap;\n         new_obj_refs \\<leftarrow> generate_object_ids num_objects new_type new_range;\n\n         update_available_range new_range (map (\\<lambda>s. pick s) new_obj_refs) untyped_ref untyped_cap;\n\n         \\<comment> \\<open>Construct new objects within the covered range.\\<close>\n         retype_region type_size new_type new_obj_refs;\n\n         \\<comment> \\<open>Construct caps for the new objects.\\<close>\n         mapM_x (create_cap new_type type_size untyped_ref (untyped_is_device untyped_cap)) (zip target_slots new_obj_refs);\n\n         \\<comment> \\<open>Ideally, we should return back to the user how many\n            objects were created.\\<close>\n\n         return ()\n       od\n    odE\"\n\nend", "property": "Untyped Invocation: Allows retype of an untyped capability, creating new objects and capabilities, while ensuring the integrity of the available range and the objects within it.\n\nSubproperties:\n- Reset Untyped Capability: Resets the available range of an untyped capability, detyping the objects within the original range and setting a new available range.\n- Update Available Range: Updates the available range of an untyped capability, ensuring that the new range is a subset of the original range.\n- Retype Region: Creates new objects within a specified range, either by generating new object IDs or using existing ones.\n- Create Capability: Creates a new capability for an object, setting its parent and available range accordingly.", "title": "./spec/capDL/Untyped_D.thy", "chapter": "", "section": "", "comment": " Insert a cap for a new object in the given location. "}
{"spec": "(*\n * This file contains user \"intents\".\n *\n * Such intents attempt to capture the semantics of an operation the\n * user is attempting to perform, without having to worry about how the\n * operation is actually encoded within their message registers.\n *\n * There is a one-to-one mapping between the following intents and the\n * invocations made available to userspace. There is not quite\n * a one-to-one mapping between these intents and the invocations listed\n * in Invocations_D, as some of these intents are multiplexed onto\n * a single invocation when being validated.\n *\n * Caps required by the intents are not stored in the intent themselves,\n * but passed seperately in when required. In some sense, the Intent\n * is the \"data\" part of an invocation, but not the \"caps\" part of it.\n *)\n\ntheory Intents_D\nimports\n  \"ASpec.CapRights_A\"\n  ExecSpec.Platform\nbegin\n\ncontext begin interpretation Arch .\nrequalify_types irq\nend", "property": "User Intents: Capture the semantics of user operations without considering the encoding in message registers, providing a one-to-one mapping with userspace invocations.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym cdl_right = rights", "property": "Entity Rights: Entities in seL4 have specific rights to kernel objects, determining how they can interact with those objects.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": "\n * Entities in seL4 have particular rights to kernel objects, which\n * affects how entities can interact with those particular objects.\n "}
{"spec": "type_synonym cdl_cptr = word32\n\nabbreviation (input) Read ::rights\n  where \"Read \\<equiv> AllowRead\"\n\nabbreviation (input) Write::rights\n  where \"Write \\<equiv> AllowWrite\"\n\nabbreviation (input) Grant::rights\n  where \"Grant \\<equiv> AllowGrant\"\n\nabbreviation (input) GrantReply::rights\n  where \"GrantReply \\<equiv> AllowGrantReply\"", "property": "User Capability Pointer: A 32-bit word representing a capability pointer for user-level access, associated with rights such as Read, Write, Grant, and GrantReply.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " A user cap pointer. "}
{"spec": "type_synonym cdl_raw_capdata = word32", "property": "Capability Data Representation: Represents capability data, including guard information, as a 32-bit word.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Capability data, such as guard information. "}
{"spec": "type_synonym cdl_raw_vmattrs = word32", "property": "VM Attributes Representation: Represent VM attributes, such as page cache attributes, as a 32-bit word.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " VM Attributes, such as page cache attributes. "}
{"spec": "type_synonym cdl_raw_usercontext = \"word32 list\"", "property": "TCB Context: Represent the user context of a thread as a list of 32-bit words for operations such as writing to a thread's registers.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " TCB context, for operations such as write to a thread's registers. "}
{"spec": "datatype cdl_object_type =\n    EndpointType\n  | NotificationType\n  | TcbType\n  | CNodeType\n  | IRQNodeType\n  | UntypedType\n  | AsidPoolType\n  | PageTableType\n  | PageDirectoryType\n  | FrameType nat (* size in bits of desired page *)\n\ndatatype cdl_cnode_intent =", "property": "Kernel Object Types: Defines the various types of kernel objects, including endpoints, notifications, threads, capability nodes, IRQ nodes, untyped objects, ASID pools, page tables, page directories, and frames of varying sizes.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Kernel objects types. "}
{"spec": "CNodeCopyIntent word32 word32 word32 word32 \"cdl_right set\"", "property": "Copy Capability: Copy a capability from a source root to a destination root, specifying the source and destination indices, depths, and rights.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Copy: (target), dest_index, dest_depth, (src_root), src_index, src_depth, rights "}
{"spec": "|  CNodeMintIntent word32 word32 word32 word32 \"cdl_right set\" cdl_raw_capdata", "property": "CNode Minting: Create a new capability in the destination CNode by copying and modifying an existing capability from the source CNode, with updated rights and badge.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Mint: (target), dest_index, dest_depth, (src_root), src_index, src_depth, rights, badge "}
{"spec": "|  CNodeMoveIntent word32 word32 word32 word32", "property": "Move Capability: Move a capability from a source location to a destination location within a capability node, specified by indices and depths.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Move: (target), dest_index, dest_depth, (src_root), src_index, src_depth "}
{"spec": "|  CNodeMutateIntent word32 word32 word32 word32 cdl_raw_capdata", "property": "Mutate Capability: Modify a capability in a CNode by specifying the target CNode, destination index, destination depth, source root, source index, source depth, and badge.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Mutate: (target), dest_index, dest_depth, (src_root), src_index, src_depth, badge "}
{"spec": "|  CNodeRevokeIntent word32 word32", "property": "Revoke Capability: Revoke a capability from a CNode, specifying the target CNode, index, and depth.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Revoke: (target), index, depth "}
{"spec": "|  CNodeDeleteIntent word32 word32", "property": "Delete Capability: Remove a capability from a CNode, specified by the target CNode, capability index, and depth.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Delete: (target), index, depth "}
{"spec": "|  CNodeSaveCallerIntent word32 word32", "property": "Save Caller Intent: Save the caller's intent for a specific target, including its index and depth.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SaveCaller: (target), index, depth "}
{"spec": "|  CNodeCancelBadgedSendsIntent word32 word32", "property": "Cancel Badged Sends: Cancel badged sends targeting a specific capability in a CNode, specified by an index and depth.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " CancelBadgedSends: (target), index, depth "}
{"spec": "|  CNodeRotateIntent word32 word32 word32 word32 cdl_raw_capdata word32 word32 cdl_raw_capdata\n\ndatatype cdl_tcb_intent =", "property": "Rotate Capability: Rotate a capability between two source and destination locations, updating the capability graph. The rotation involves a pivot node, and the source and destination locations are specified by their indices and depths, with corresponding badges.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Rotate: (target), dest_index, dest_depth, (pivot_root), pivot_index, pivot_depth, pivot_badge, (src_root), src_index, src_depth, src_badge "}
{"spec": "TcbReadRegistersIntent bool word8 word32", "property": "Read Registers: Read the register values from a target thread, with options to suspend the source thread and specify architecture-specific flags, and retrieve a specified count of register values.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " ReadRegisters: (target), suspend_source, arch_flags, count "}
{"spec": "|  TcbWriteRegistersIntent bool word8 word32 cdl_raw_usercontext", "property": "Write Registers: Write the specified registers of a target thread with new values, potentially resuming the target thread and handling architecture-specific flags.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " WriteRegisters: (target), resume_target, arch_flags, count, regs "}
{"spec": "|  TcbCopyRegistersIntent bool bool bool bool word8", "property": "Copy Registers: Copy the register values from a source thread to a target thread, with options to suspend the source thread, resume the target thread, transfer frame and integer registers, and consider architecture-specific flags.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " CopyRegisters: (target), (source), suspend_source, resume_target, transfer_frame, transfer_integer, arch_flags "}
{"spec": "|  TcbSuspendIntent", "property": "Suspend Thread: Allow a thread to be suspended, temporarily stopping its execution.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Suspend: (target) "}
{"spec": "|  TcbResumeIntent", "property": "Resume Action: Allows a thread to resume another thread, reactivating its execution.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Resume: (target) "}
{"spec": "|  TcbConfigureIntent cdl_cptr cdl_raw_capdata cdl_raw_capdata word32", "property": "TCB Configuration: Configure various settings for a target thread, including its fault endpoint, capability space root, virtual space root, and IPC buffer, along with their associated data.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Configure: (target), fault_ep, (cspace_root), cspace_root_data, (vspace_root), vspace_root_data, buffer, (bufferFrame) "}
{"spec": "|  TcbSetMCPriorityIntent word8", "property": "Set Master Control Priority: Set the master control priority of a thread to a specified value.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetMCPriority: (target), mcp "}
{"spec": "|  TcbSetPriorityIntent word8", "property": "Set Priority: Set the priority of a target thread to a specified value.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetPriority: (target), priority "}
{"spec": "|  TcbSetSchedParamsIntent word8 word8", "property": "Set Scheduling Parameters: Set the scheduling parameters for a thread, including the maximum controlled priority (MCP) and priority.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetSchedParams: (target), mcp, priority "}
{"spec": "|  TcbSetIPCBufferIntent word32", "property": "Set IPC Buffer: Set the IPC buffer for a target thread, specifying the buffer address and optionally a buffer frame.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetIPCBuffer: (target), buffer, (bufferFrame) "}
{"spec": "|  TcbSetSpaceIntent word32 cdl_raw_capdata cdl_raw_capdata", "property": "TCB Set Space Intent: Set the address space intent for a thread, including the target, fault endpoint, CSpace root, CSpace root data, VSpace root, and VSpace root data.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetSpace: (target), fault_ep, (cspace_root), cspace_root_data, (vspace_root), vspace_root_data "}
{"spec": "|  TcbBindNTFNIntent", "property": "Bind Notification: Associate a notification with a target, ensuring the target is informed of the notification's occurrence.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " BindNTFN: (target), (ntfn) "}
{"spec": "|  TcbUnbindNTFNIntent", "property": "Notification Unbinding: Unbind a notification from a target thread.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " UnbindNTFN: (target) "}
{"spec": "|  TcbSetTLSBaseIntent\n\ndatatype cdl_untyped_intent =", "property": "Set TLS Base: Set the TLS base register for a target thread.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetTLSBase: (target) "}
{"spec": "UntypedRetypeIntent cdl_object_type word32 word32 word32 word32 word32\n\ndatatype cdl_irq_handler_intent =", "property": "Untyped Retype Intent: Specify the intent to retype an untyped capability, including the target object, reset flag, object type, size, root node, node index, node depth, node offset, node window, and whether the node has children.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Retype: (target), (do_reset), type, size_bits, (root), node_index, node_depth, node_offset, node_window, has_children "}
{"spec": "IrqHandlerAckIntent", "property": "Acknowledge Interrupt: Allow a thread to acknowledge an interrupt, indicating that it has begun processing the interrupt request.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Ack: (target) "}
{"spec": "|  IrqHandlerSetEndpointIntent", "property": "Set Endpoint: Set the endpoint for a target, allowing it to receive interrupts.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetEndpoint: (target), (endpoint) "}
{"spec": "|  IrqHandlerClearIntent\n\ndatatype cdl_arch_irq_control_intent =", "property": "Clear IRQ Handler Intent: Clear the intent to handle an IRQ for a target.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Clear: (target) "}
{"spec": "ARMIrqControlIssueIrqHandlerIntent irq word32 word32\n\ndatatype cdl_irq_control_intent =", "property": "Issue IRQ Handler Intent: Specify the intent to issue an IRQ handler for a specific IRQ, including the target, root, index, and depth.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " ArchIssueIrqHandler: (target), irq, (root), index, depth "}
{"spec": "IrqControlIssueIrqHandlerIntent irq word32 word32", "property": "Issue IRQ Handler Intent: Specify the intent to issue an IRQ handler for a specific IRQ, with a target, root, index, and depth.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " IssueIrqHandler: (target), irq, (root), index, depth "}
{"spec": "|  ArchIrqControlIssueIrqHandlerIntent cdl_arch_irq_control_intent\n\ndatatype cdl_page_table_intent =", "property": "Interrupt Control: Manage interrupt-related operations, including issuing IRQ handler intents for specific architectures.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " InterruptControl "}
{"spec": "PageTableMapIntent word32 cdl_raw_vmattrs\n |  PageTableUnmapIntent\n\ndatatype cdl_page_intent =", "property": "Page Table Intent: Specify the intent to map or unmap a page table, defining the target, page directory, virtual address, and attributes for the mapping operation. \n\nMapping Intent: Define the intent to map a page, specifying the target, page directory, virtual address, and attributes. \nUnmapping Intent: Define the intent to unmap a page.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Map: (target), (pd), vaddr, attr "}
{"spec": "PageMapIntent word32 \"cdl_right set\" cdl_raw_vmattrs", "property": "Page Mapping Intent: Specify the intent to map a page to a target address space, defining the virtual address, access rights, and attributes for the mapping. \n\nSubproperties: \n- Target Address Space: Identify the address space where the page will be mapped.\n- Virtual Address: Specify the virtual address where the page will be mapped.\n- Access Rights: Define the access rights (read, write, execute) for the mapped page.\n- Attributes: Specify additional attributes (e.g., caching, alignment) for the mapped page.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Map: (target), (pd), vaddr, rights, attr "}
{"spec": "|  PageUnmapIntent", "property": "Page Unmapping: Allows a page to be unmapped from a target address space, ensuring that the page is no longer accessible through that mapping.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Unmap: (target) "}
{"spec": "|  PageFlushCachesIntent", "property": "Flush Caches: Ensure cache coherence by flushing the caches of a target, maintaining data consistency across the system.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " FlushCaches: (target) "}
{"spec": "| PageGetAddressIntent\n\n\ndatatype cdl_page_directory_intent =\n   PageDirectoryFlushIntent\n | PageDirectoryNothingIntent\n\ndatatype cdl_asid_control_intent =", "property": "Get Address Intent: Retrieve the address associated with a page or other memory-related entity.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " GetAddress "}
{"spec": "AsidControlMakePoolIntent word32 word32\n\ndatatype cdl_asid_pool_intent =", "property": "ASID Pool Creation: Create a new ASID pool with the specified target, untyped capability, root, index, and depth.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " MakePool: (target), (untyped), (root), index, depth "}
{"spec": "AsidPoolAssignIntent\n\ndatatype cdl_notification_intent =\n    SendSignalIntent word32", "property": "Notification Intent: Specify the intent to send a signal to a specific target, including the target and virtual root (vroot) information. \n\nSubproperties:\n- Target Assignment: Assign the target for the notification intent.\n- VRoot Assignment: Assign the virtual root (vroot) for the notification intent.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Assign: (target), (vroot) "}
{"spec": "datatype cdl_endpoint_intent =\n    SendMessageIntent \"cdl_cptr list\"\n\ndatatype cdl_domain_intent = DomainSetIntent word8\n\ndatatype cdl_intent =\n    CNodeIntent cdl_cnode_intent\n  | TcbIntent cdl_tcb_intent\n  | UntypedIntent cdl_untyped_intent\n  | IrqHandlerIntent cdl_irq_handler_intent\n  | IrqControlIntent cdl_irq_control_intent\n  | PageTableIntent cdl_page_table_intent\n  | PageIntent cdl_page_intent\n  | PageDirectoryIntent cdl_page_directory_intent\n  | AsidControlIntent cdl_asid_control_intent\n  | AsidPoolIntent cdl_asid_pool_intent\n  | NotificationIntent cdl_notification_intent\n  | EndpointIntent cdl_endpoint_intent\n  | DomainIntent cdl_domain_intent\n\nrecord cdl_full_intent =\n  cdl_intent_op        :: \"cdl_intent option\"\n  cdl_intent_error     :: bool\n  cdl_intent_cap       :: cdl_cptr\n  cdl_intent_extras    :: \"cdl_cptr list\"\n  cdl_intent_recv_slot :: \"(cdl_cptr \\<times> word32 \\<times> nat) option\"\n\nend", "property": "CDL Intent Structure: Represents the intent behind an operation in the CDL (Capability Definition Language) model, capturing the type of intent, potential errors, capability pointers, extra capability pointers, and receive slot information. This structure facilitates the definition and management of capabilities in the system.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Also used with reply caps "}
{"spec": "(*\n * Operations on thread control blocks.\n *)\n\ntheory Tcb_D\nimports Invocations_D CSpace_D\nbegin\n\ndefinition cdl_update_cnode_cap_data :: \"cdl_cap \\<Rightarrow> word32 \\<Rightarrow> cdl_cap\"\nwhere \"cdl_update_cnode_cap_data cap data  \\<equiv>\n  case cap of cdl_cap.CNodeCap oid _ _ sz \\<Rightarrow> if data\\<noteq>0 then\n    (let reserved_bits = 3; guard_bits = 18; guard_size_bits = 5; new_guard_size = unat ((data >> reserved_bits) && mask guard_size_bits);\n        new_guard =\n          (data >> reserved_bits + guard_size_bits) && mask (min (unat ((data >> reserved_bits) && mask guard_size_bits)) guard_bits)\n    in CNodeCap oid new_guard new_guard_size sz)\n    else cap\n  | _ \\<Rightarrow> cap\"\n\ndefinition cdl_same_arch_obj_as :: \"cdl_cap \\<Rightarrow> cdl_cap \\<Rightarrow> bool\"\nwhere \"cdl_same_arch_obj_as capa capb \\<equiv>\n  case capa of AsidPoolCap x _ \\<Rightarrow> (\n        case capb of AsidPoolCap y _ \\<Rightarrow>  y = x\n        | _ \\<Rightarrow> False)\n  | AsidControlCap \\<Rightarrow> (\n       case capb of AsidControlCap \\<Rightarrow> True\n        | _ \\<Rightarrow> False)\n  | FrameCap dev ra _ sa _ _ \\<Rightarrow> (\n       case capb of FrameCap dev' rb _ sb _ _ \\<Rightarrow> rb = ra \\<and> sb = sa \\<and> dev = dev'\n        | _ \\<Rightarrow> False)\n  | cdl_cap.PageTableCap a _ _ \\<Rightarrow> (\n       case capb of cdl_cap.PageTableCap b _ _ \\<Rightarrow> b = a\n        | _ \\<Rightarrow> False)\n  | cdl_cap.PageDirectoryCap a _ _ \\<Rightarrow> (\n       case capb of cdl_cap.PageDirectoryCap b _ _ \\<Rightarrow> b = a\n        | _ \\<Rightarrow> False)\n  | _ \\<Rightarrow> False\"\n\ndefinition\n  decode_tcb_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_tcb_intent \\<Rightarrow> cdl_tcb_invocation except_monad\"\nwhere\n  \"decode_tcb_invocation target slot caps intent \\<equiv> case intent of\n       \\<comment> \\<open>Read another thread's registers.\\<close>\n       TcbReadRegistersIntent suspend flags count \\<Rightarrow>\n         returnOk (ReadRegisters (cap_object target) suspend 0 0) \\<sqinter> throw\n\n       \\<comment> \\<open>Write another thread's registers.\\<close>\n     | TcbWriteRegistersIntent resume flags count regs \\<Rightarrow>\n         returnOk (WriteRegisters (cap_object target) resume [0] 0) \\<sqinter> throw\n\n       \\<comment> \\<open>Copy registers from one thread to another.\\<close>\n     | TcbCopyRegistersIntent suspend_source resume_target f1 f2 f3 \\<Rightarrow>\n         doE\n           (source_cap, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           source_tcb \\<leftarrow> (\n              case source_cap of\n                  TcbCap x \\<Rightarrow> returnOk x\n                | _ \\<Rightarrow> throw);\n           target_tcb \\<leftarrow> returnOk $ cap_object target;\n           returnOk (CopyRegisters target_tcb source_tcb suspend_source resume_target f1 f2 0)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Suspend the target thread.\\<close>\n     | TcbSuspendIntent \\<Rightarrow>\n         returnOk (Suspend (cap_object target)) \\<sqinter> throw\n\n       \\<comment> \\<open>Resume the target thread.\\<close>\n     | TcbResumeIntent \\<Rightarrow>\n         returnOk (Resume (cap_object target)) \\<sqinter> throw\n\n       \\<comment> \\<open>Configure: target, fault_ep, mcp, priority, cspace_root_data, vspace_root_data, buffer\\<close>\n     | TcbConfigureIntent fault_ep cspace_root_data vspace_root_data buffer \\<Rightarrow>\n         doE\n           cspace_root \\<leftarrow> throw_on_none $ get_index caps 0;\n           vspace_root \\<leftarrow> throw_on_none $ get_index caps 1;\n           buffer_frame \\<leftarrow> throw_on_none $ get_index caps 2;\n           cspace_root_cap_ref \\<leftarrow> returnOk $ (cdl_update_cnode_cap_data (fst cspace_root) cspace_root_data,snd cspace_root);\n           vspace_root_cap_ref \\<leftarrow> returnOk $ vspace_root;\n           buffer_frame_opt \\<leftarrow> returnOk $ (if (buffer \\<noteq> 0) then Some (reset_mem_mapping (fst buffer_frame), snd buffer_frame) else None);\n           returnOk (ThreadControl (cap_object target) slot (Some fault_ep)\n               (Some cspace_root_cap_ref) (Some vspace_root_cap_ref) (buffer_frame_opt))\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Modify a thread's maximum control priority.\\<close>\n     | TcbSetMCPriorityIntent mcp \\<Rightarrow>\n         doE\n           auth_cap \\<leftarrow> throw_on_none $ get_index caps 0;\n           returnOk (ThreadControl (cap_object target) slot None None None None)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Modify a thread's priority.\\<close>\n     | TcbSetPriorityIntent priority \\<Rightarrow>\n         doE\n           auth_cap \\<leftarrow> throw_on_none $ get_index caps 0;\n           returnOk (ThreadControl (cap_object target) slot None None None None)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Modify a thread's mcp and priority at the same time.\\<close>\n     | TcbSetSchedParamsIntent mcp priority \\<Rightarrow>\n         doE\n           auth_cap \\<leftarrow> throw_on_none $ get_index caps 0;\n           returnOk (ThreadControl (cap_object target) slot None None None None)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Modify a thread's IPC buffer.\\<close>\n     | TcbSetIPCBufferIntent buffer \\<Rightarrow>\n         doE\n           buffer_frame \\<leftarrow> throw_on_none $ get_index caps 0;\n           buffer_frame_opt \\<leftarrow> returnOk $ (if (buffer \\<noteq> 0) then Some (reset_mem_mapping (fst buffer_frame), snd buffer_frame) else None);\n           returnOk (ThreadControl (cap_object target) slot None None None buffer_frame_opt)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Update the various spaces (CSpace/VSpace) of a thread.\\<close>\n     | TcbSetSpaceIntent fault_ep cspace_root_data vspace_root_data \\<Rightarrow>\n         doE\n           cspace_root \\<leftarrow> throw_on_none $ get_index caps 0;\n           vspace_root \\<leftarrow> throw_on_none $ get_index caps 1;\n           cspace_root_cap_ref \\<leftarrow> returnOk $ (cdl_update_cnode_cap_data (fst cspace_root) cspace_root_data,snd cspace_root);\n           vspace_root_cap_ref \\<leftarrow> returnOk $ vspace_root;\n           returnOk (ThreadControl (cap_object target) slot (Some fault_ep)\n               (Some cspace_root_cap_ref) (Some vspace_root_cap_ref) None)\n        odE \\<sqinter> throw\n     | TcbBindNTFNIntent \\<Rightarrow> doE\n           (ntfn_cap, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           returnOk (NotificationControl (cap_object target) (Some (cap_object ntfn_cap)))\n         odE \\<sqinter> throw\n     | TcbUnbindNTFNIntent \\<Rightarrow> returnOk (NotificationControl (cap_object target) None) \\<sqinter> throw\n     | TCBSetTLSBaseIntent \\<Rightarrow> returnOk (SetTLSBase (cap_object target)) \\<sqinter> throw\n  \"", "property": "TCB Invocation Decoding: Decodes the intent of a TCB invocation, determining the specific action to be performed on a thread, such as reading or writing registers, copying registers, suspending or resuming, configuring thread settings, modifying priorities, updating spaces, binding or unbinding notifications, or setting the TLS base.\n\nSubproperties:\n- TCB Read Registers: Reads the registers of another thread.\n- TCB Write Registers: Writes to the registers of another thread.\n- TCB Copy Registers: Copies registers from one thread to another.\n- TCB Suspend: Suspends the target thread.\n- TCB Resume: Resumes the target thread.\n- TCB Configure: Configures various thread settings, including fault endpoints, capability roots, and IPC buffers.\n- TCB Set Priority: Modifies a thread's priority.\n- TCB Set MCPriority: Modifies a thread's maximum control priority.\n- TCB Set Sched Params: Modifies a thread's scheduling parameters (MCP and priority).\n- TCB Set IPC Buffer: Modifies a thread's IPC buffer.\n- TCB Set Space: Updates the various spaces (CSpace/VSpace) of a thread.\n- TCB Bind Notification: Binds a notification to a thread.\n- TCB Unbind Notification: Unbinds a notification from a thread.\n- TCB Set TLS Base: Sets the TLS base for a thread.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  tcb_empty_thread_slot :: \"cdl_object_id \\<Rightarrow> cdl_cnode_index \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_empty_thread_slot target_tcb target_slot \\<equiv> doE\n    cap \\<leftarrow> liftE $ get_cap (target_tcb,target_slot);\n    whenE (cap \\<noteq> NullCap) $\n      delete_cap  (target_tcb, target_slot)\n  odE\"", "property": "TCB Slot Deletion: Delete the capability in the specified slot of a TCB, ensuring the slot is empty.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Delete the given slot of a TCB. "}
{"spec": "definition\n  tcb_update_thread_slot :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cnode_index \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_thread_slot target_tcb tcb_cap_slot target_slot pcap \\<equiv>\n         liftE (do\n           thread_cap \\<leftarrow> get_cap tcb_cap_slot;\n           when (thread_cap = TcbCap target_tcb)\n           (insert_cap_child (fst pcap) (snd pcap) (target_tcb, target_slot)\n            \\<sqinter> insert_cap_sibling (fst pcap) (snd pcap) (target_tcb,target_slot))\n         od)\"", "property": "TCB Slot Update: Update a slot of a TCB with a new capability, deleting the previous capability in the slot, ensuring the TCB's capability is updated correctly.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update the given slot of a TCB with a new cap, delete the previous\n * capability that was in the slot. "}
{"spec": "definition\n  tcb_update_cspace_root :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap \\<times> cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_cspace_root target_tcb tcb_cap_ref croot \\<equiv>\n  doE\n     tcb_empty_thread_slot target_tcb tcb_cspace_slot;\n     src_cap \\<leftarrow> liftE $ get_cap (snd croot);\n     whenE (is_cnode_cap src_cap \\<and> (cap_object src_cap = cap_object (fst croot)))\n       $ tcb_update_thread_slot target_tcb tcb_cap_ref tcb_cspace_slot croot\n  odE\"", "property": "Update Thread's CSpace Root: Update a thread's CSpace root by emptying the thread's CSpace slot, retrieving the source capability, and updating the thread slot if the source capability is a CNode capability with a matching object.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update a thread's CSpace root. "}
{"spec": "definition\n  tcb_update_vspace_root :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_vspace_root target_tcb tcb_cap_ref vroot \\<equiv>\n  doE\n     tcb_empty_thread_slot target_tcb tcb_vspace_slot;\n     src_cap \\<leftarrow> liftE $ get_cap (snd vroot);\n     whenE (cdl_same_arch_obj_as (fst vroot) src_cap)\n       $ tcb_update_thread_slot target_tcb tcb_cap_ref tcb_vspace_slot vroot\n  odE\"", "property": "Update Thread's VSpace Root: Update a thread's virtual space root by emptying the current thread slot, retrieving the source capability, and updating the thread slot with the new virtual space root if the architectures match. \n\nSubproperties:\n- Empty the current thread slot for the VSpace root.\n- Retrieve the source capability for the new VSpace root.\n- Update the thread slot with the new VSpace root if the architectures match.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update a thread's VSpace root. "}
{"spec": "definition\n  mark_tcb_intent_error :: \"cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"mark_tcb_intent_error target_tcb has_error \\<equiv>\n      update_thread target_tcb (\\<lambda>t. (t\\<lparr>cdl_tcb_intent := (cdl_tcb_intent t)\\<lparr>cdl_intent_error := has_error\\<rparr>\\<rparr>))\"", "property": "TCB Intent Error Update: Modify the TCB's intent to indicate whether an error occurred during decode.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Modify the TCB's intent to indicate an error during decode. "}
{"spec": "definition\n  tcb_update_ipc_buffer :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_ipc_buffer target_tcb tcb_cap_ref ipc_buffer \\<equiv>\n     doE\n       tcb_empty_thread_slot target_tcb tcb_ipcbuffer_slot;\n       liftE $ corrupt_tcb_intent target_tcb;\n       src_cap \\<leftarrow> liftE $ get_cap (snd ipc_buffer);\n       whenE (cdl_same_arch_obj_as (fst ipc_buffer) src_cap)\n         $ tcb_update_thread_slot target_tcb tcb_cap_ref tcb_ipcbuffer_slot ipc_buffer\n     odE\n\"", "property": "Thread IPC Buffer Update: Update a thread's IPC buffer by emptying the current buffer slot, corrupting the thread's intent, and then updating the buffer slot with the new IPC buffer if the architectures match.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update a thread's IPC buffer. "}
{"spec": "definition\n  restart :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"restart target_tcb \\<equiv>\n  do\n     cap \\<leftarrow> KHeap_D.get_cap (target_tcb,tcb_pending_op_slot);\n     when (cap \\<noteq> RestartCap \\<and> cap\\<noteq> RunningCap)\n     (do\n       CSpace_D.cancel_ipc target_tcb;\n       KHeap_D.set_cap (target_tcb,tcb_replycap_slot) (cdl_cap.MasterReplyCap target_tcb);\n       KHeap_D.set_cap (target_tcb,tcb_pending_op_slot) (cdl_cap.RestartCap)\n      od)\n  od\"", "property": "Thread Restart: Resume a thread, aborting any pending operation and revoking any incoming reply capabilities, ensuring the thread is properly reinitialized for execution.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Resume a thread, aborting any pending operation, and revoking\n * any incoming reply caps. "}
{"spec": "definition\n  suspend :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"suspend target_tcb \\<equiv> CSpace_D.cancel_ipc target_tcb >>= K (KHeap_D.set_cap (target_tcb,tcb_pending_op_slot) cdl_cap.NullCap)\"\n\ndefinition\n  bind_notification :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"bind_notification tcb_id ntfn_id \\<equiv> set_cap (tcb_id, tcb_boundntfn_slot) (BoundNotificationCap ntfn_id)\"\n\ndefinition\n  invoke_tcb :: \"cdl_tcb_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"invoke_tcb params \\<equiv> case params of\n    \\<comment> \\<open>Modify a thread's registers.\\<close>\n      WriteRegisters target_tcb resume _ _ \\<Rightarrow>\n        liftE $\n        do\n          corrupt_tcb_intent target_tcb;\n          when resume $ restart target_tcb\n        od\n\n    \\<comment> \\<open>Read a thread's registers.\\<close>\n    | ReadRegisters src_tcb _ _ _ \\<Rightarrow>\n        liftE $ suspend src_tcb \\<sqinter> return ()\n\n    \\<comment> \\<open>Copy registers from one thread to another\\<close>\n    | CopyRegisters target_tcb source_tcb _ _ _ _ _ \\<Rightarrow>\n        liftE $\n        do\n          suspend source_tcb \\<sqinter> return ();\n          restart target_tcb \\<sqinter> return ();\n          corrupt_tcb_intent target_tcb\n       od\n\n    \\<comment> \\<open>Suspend this thread.\\<close>\n    | Suspend target_tcb \\<Rightarrow>\n        liftE $ suspend target_tcb \\<sqinter> return ()\n\n    \\<comment> \\<open>Resume this thread.\\<close>\n    | Resume target_tcb \\<Rightarrow>\n        liftE $ restart target_tcb\n\n    \\<comment> \\<open>Update a thread's options.\\<close>\n    | ThreadControl target_tcb tcb_cap_slot faultep croot vroot ipc_buffer \\<Rightarrow>\n        doE\n          case faultep of\n              Some x \\<Rightarrow> liftE $ update_thread target_tcb (\\<lambda>tcb. tcb\\<lparr>cdl_tcb_fault_endpoint := x\\<rparr>)\n            | None \\<Rightarrow> returnOk ();\n\n          \\<comment> \\<open>Possibly update CSpace\\<close>\n          case croot of\n              Some x \\<Rightarrow> tcb_update_cspace_root target_tcb tcb_cap_slot x\n            | None \\<Rightarrow> returnOk ();\n\n          \\<comment> \\<open>Possibly update VSpace\\<close>\n          case vroot of\n              Some x \\<Rightarrow> tcb_update_vspace_root target_tcb tcb_cap_slot x\n            | None \\<Rightarrow> returnOk ();\n\n          \\<comment> \\<open>Possibly update Ipc Buffer\\<close>\n          case ipc_buffer of\n              Some x \\<Rightarrow> tcb_update_ipc_buffer target_tcb tcb_cap_slot x\n            | None \\<Rightarrow> (returnOk () \\<sqinter> (doE tcb_empty_thread_slot target_tcb tcb_ipcbuffer_slot;\n                 liftE $ corrupt_tcb_intent target_tcb odE))\n        odE\n    | NotificationControl tcb ntfn \\<Rightarrow>\n          liftE $ (case ntfn of\n             Some ntfn_id \\<Rightarrow> bind_notification tcb ntfn_id\n           | None \\<Rightarrow> unbind_notification tcb)\n    | SetTLSBase tcb \\<Rightarrow> liftE $ corrupt_tcb_intent tcb\"\n\n\ndefinition\n  decode_domain_invocation :: \"(cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow> cdl_domain_intent \\<Rightarrow> cdl_domain_invocation except_monad\"\nwhere\n  \"decode_domain_invocation caps intent \\<equiv> case intent of\n     DomainSetIntent d \\<Rightarrow> returnOk (SetDomain (cap_object (fst (hd caps))) d) \\<sqinter> throw\"\n\ndefinition\n  set_domain :: \"cdl_object_id \\<Rightarrow> word8 \\<Rightarrow> unit k_monad\"\nwhere\n  \"set_domain tcb d \\<equiv> update_thread tcb (\\<lambda>t. (t\\<lparr>cdl_tcb_domain := d \\<rparr>))\"\n\ndefinition\n  invoke_domain :: \"cdl_domain_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"invoke_domain params \\<equiv> case params of\n     SetDomain tcb d \\<Rightarrow> liftE $ set_domain tcb d\"\n\n\nend", "property": "TCB Invocation Actions: Allows threads to perform actions such as suspending and resuming other threads, controlling various thread settings (fault endpoints, capability roots, IPC buffers), copying registers between threads, reading and writing thread registers, controlling notifications (binding and unbinding), and setting the TLS base, while ensuring the integrity and performance of the kernel.\n\nSubproperties:\n- Suspend Thread: Abort any pending operation and revoke incoming reply caps.\n- Resume Thread: Restart a suspended thread.\n- Update Thread Options: Update a thread's fault endpoint, capability roots, IPC buffer, and other settings.\n- Copy Registers: Copy registers from one thread to another.\n- Read Registers: Read a thread's registers while suspending the thread.\n- Write Registers: Modify a thread's registers.\n- Notification Control: Bind or unbind notifications to a thread.\n- Set TLS Base: Set the TLS base for a thread.\n\nDomain Management: Set the scheduling domain for a thread, ensuring correct dequeuing, domain updating, and re-enqueuing if runnable.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Suspend a thread, aborting any pending operation, and revoking\n * any incoming reply caps. "}
{"spec": "(*\n * Operations on endpoints.\n *)\n\ntheory Endpoint_D\nimports Invocations_D CSpace_D Tcb_D\nbegin", "property": "Endpoint Operations: Manage endpoint-related activities, ensuring the proper creation, modification, and deletion of endpoints, as well as the sending and receiving of messages through them, maintaining the integrity of inter-process communication within the system.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  inject_reply_cap :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"inject_reply_cap src_tcb_id dst_tcb_id can_grant \\<equiv> do\n     set_cap (src_tcb_id, tcb_pending_op_slot) $\n         cdl_cap.PendingSyncRecvCap src_tcb_id True False;\n     insert_cap_child (ReplyCap src_tcb_id (if can_grant then {Grant, Write} else {Write}))\n                      (src_tcb_id, tcb_replycap_slot)\n                      (dst_tcb_id, tcb_caller_slot);\n     return ()\n  od\"", "property": "Inject Reply Capability: Insert a reply capability into the target TCB, enabling it to receive replies from the source TCB, with optional grant rights.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " Inject the reply cap into the target TCB "}
{"spec": "definition\n  get_receive_slot :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref option k_monad\"\nwhere\n  \"get_receive_slot thread \\<equiv>\n    do\n      tcb \\<leftarrow> get_thread thread;\n      recv_slot \\<leftarrow> (case (cdl_tcb_caps tcb tcb_ipcbuffer_slot) of (Some (FrameCap _ _ rights _ _ _)) \\<Rightarrow>\n        if (Read \\<in> rights \\<and> Write \\<in> rights)\n          then return (cdl_intent_recv_slot (cdl_tcb_intent tcb))\n        else\n          return None\n      | _ \\<Rightarrow> return None);\n      case ( recv_slot ) of\n          None \\<Rightarrow>\n            return None\n        | Some (croot, index, depth) \\<Rightarrow>\n            doE\n              \\<comment> \\<open>Lookup the slot.\\<close>\n              cspace_root \\<leftarrow> unify_failure $ lookup_cap thread croot;\n              result \\<leftarrow> unify_failure $ lookup_slot_for_cnode_op cspace_root index depth;\n\n              \\<comment> \\<open>Ensure nothing is already in it.\\<close>\n              cap \\<leftarrow> liftE $ get_cap result;\n              whenE (cap \\<noteq> NullCap) throw;\n\n              returnOk $ Some result\n            odE <catch> (\\<lambda>_. return None)\n    od\n  \"", "property": "Get Receive Slot: Determine the slot where an incoming capability should be placed for a particular thread, ensuring the slot is empty and the thread has the necessary read and write rights to its IPC buffer. \n\nSlot Lookup: Perform a lookup to find the slot, handling potential failures and ensuring the slot is empty before returning it.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Get the slot where we should place an incoming cap for a\n * particular thread.\n "}
{"spec": "definition\n  get_send_slots :: \"cdl_object_id \\<Rightarrow> cdl_cptr list k_monad\"\nwhere\n  \"get_send_slots thread \\<equiv>\n    do\n      tcb \\<leftarrow> get_thread thread;\n      return $ cdl_intent_extras (cdl_tcb_intent tcb)\n    od\n  \"\n\ndefinition\n  get_ipc_buffer :: \"cdl_object_id \\<Rightarrow> bool \\<Rightarrow> cdl_object_id option k_monad\"\nwhere\n  \"get_ipc_buffer oid in_receive \\<equiv> do\n    frame_cap \\<leftarrow> get_cap (oid,tcb_ipcbuffer_slot);\n    (case frame_cap of\n        Types_D.FrameCap _ a rights _ _ _ \\<Rightarrow> if (Write \\<in> rights \\<and> Read \\<in> rights) \\<or> (Read\\<in> rights \\<and> \\<not> in_receive)\n          then return (Some a)\n          else return None\n        | _ \\<Rightarrow> return None)\n   od\"\n\ndefinition\n  corrupt_ipc_buffer :: \"cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\n  where\n  \"corrupt_ipc_buffer oid in_receive \\<equiv> do\n    buffer \\<leftarrow> get_ipc_buffer oid in_receive;\n    (case buffer of\n        Some a \\<Rightarrow> corrupt_frame a\n      | None \\<Rightarrow> corrupt_tcb_intent oid)\n  od\"", "property": "Thread IPC Management: Get the capability pointers that a thread wishes to transfer, retrieve the IPC buffer for a thread, and corrupt the IPC buffer or the thread's intent if necessary. \n\nGet Send Slots: Retrieve the capability pointers that a thread wishes to transfer.\nGet IPC Buffer: Retrieve the IPC buffer for a thread based on its ID and receive status, ensuring the buffer has the necessary read and write rights.\nCorrupt IPC Buffer: Corrupt the IPC buffer or the thread's intent if the buffer is invalid or does not have the necessary rights.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " Get the cptr's that the given thread wishes to transfer. "}
{"spec": "fun\n  transfer_caps_loop :: \"cdl_object_id option \\<Rightarrow> cdl_object_id \\<Rightarrow>\n                         (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow> cdl_cap_ref option\n                         \\<Rightarrow> unit k_monad\"\nwhere\n  \"transfer_caps_loop ep receiver [] dest = return ()\"\n| \"transfer_caps_loop ep receiver ((cap,slot)#caps) dest =\n      \\<comment> \\<open>Transfer badge, transfer cap, or abort early if more than\n         one cap to transfer\\<close>\n      (if is_ep_cap cap \\<and> ep = Some (cap_object cap)\n      then do\n        \\<comment> \\<open>transfer badge\\<close>\n        corrupt_ipc_buffer receiver True;\n        \\<comment> \\<open>transfer rest of badges or cap\\<close>\n        transfer_caps_loop ep receiver caps dest\n      od\n      else if dest \\<noteq> None then doE\n        new_cap \\<leftarrow> returnOk (update_cap_rights (cap_rights cap - {Write}) cap) \\<sqinter>\n                  returnOk cap;\n\n        \\<comment> \\<open>Target cap is derived. This may abort transfer early.\\<close>\n        target_cap \\<leftarrow> derive_cap slot new_cap;\n        whenE (target_cap = NullCap) throw;\n\n        \\<comment> \\<open>Copy the cap across as either a child or sibling.\\<close>\n        liftE (insert_cap_child target_cap slot (the dest)\n               \\<sqinter> insert_cap_sibling target_cap slot (the dest));\n\n        \\<comment> \\<open>Transfer rest of badges\\<close>\n        liftE $ transfer_caps_loop ep receiver caps None\n      odE <catch> (\\<lambda>_. return ())\n      else\n        return ())\"", "property": "Transfer Caps: Transfer at most one capability and multiple endpoint badges from a sender to a receiver, ensuring that the capability rights are updated and the target capability is derived correctly. If the capability to be transferred is to the endpoint used in the transfer, transfer the badges instead.\n\n Subproperties:\n- Badge Transfer: If the capability to be transferred is to the endpoint used in the transfer, transfer the badges.\n- Capability Transfer: Transfer at most one capability, updating its rights and deriving the target capability.\n- Abort Early: Abort the transfer early if more than one capability is to be transferred or if the target capability is null.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Transfers at most one cap in addition to a number of endpoint badges.\n *\n * Endpoint badges are transferred if the cap to be transferred is to\n * the endpoint used in the transfer.\n "}
{"spec": "definition\n  transfer_caps :: \"cdl_object_id option \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n                    cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"transfer_caps ep caps sender receiver \\<equiv>\n    do\n      dest_slot \\<leftarrow> get_receive_slot receiver \\<sqinter> return None;\n      transfer_caps_loop ep receiver caps dest_slot\n    od\"", "property": "Transfer Caps: Transfer capabilities from the sender to the receiver, using a list of capabilities to send and a list of capability slots to receive them, while handling various kernel implementation intricacies and nondeterminism. \n\nSubproperties:\n- Capability Transfer Nondeterminism: The actual transfer of capabilities is subject to various kernel implementation intricacies, including caps not sending, receive slots being 'burned', and cap sending stopping halfway.\n- Capability Slot Management: The transfer process uses a single destination capability slot, and the new capability may be either a sibling or child of the source capability, depending on the CDT location of the source capability.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Transfer caps from src to dest.\n *\n * In theory, the source thread specifies a list of caps to send, and\n * the destination thread specifies a list of cap slots to put them in.\n *\n * In the true spirit of L4 Pistachio, what _actually_ occurs during the\n * IPC transfer is hard to determine without knowing intricate details\n * of the kernel's implementation. In particular:\n *\n *   - Caps often just won't send, but still 'burn' the receive slot\n *     (ZombieCaps, ReplyCaps, IrqControlCap);\n *\n *   - Caps may not send, but still allow later caps to\n *     use the receive slot (Unwrapped endpoints);\n *\n *   - Cap sending may stop half way (cap lookup faults);\n *\n *   - The new cap may either be a sibling or child of source cap,\n *     depending on where in the CDT the source cap is.\n *\n *   - In reality, no more than one cap will ever be sent, because only\n *     one destination cap slot is supported elsewhere in the code.\n *\n * We remove some of the details, replacing them with nondeterminism.\n "}
{"spec": "definition\n  get_waiting_ntfn_recv_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_waiting_ntfn_recv_threads target state \\<equiv>\n     {x. \\<exists>a. (cdl_objects state) x = Some (Tcb a) \\<and>\n         (((cdl_tcb_caps a) tcb_pending_op_slot) = Some (PendingNtfnRecvCap target)) }\"", "property": "Notification Waiting Threads: Identify the set of threads waiting to receive on a specific notification by checking the pending operations of all threads in the system. \n\nThreads with Pending Receive Operations: A thread is considered waiting if it has a pending receive operation on the specified notification, as indicated by the presence of a PendingNtfnRecvCap capability in its pending operation slot.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Get the set of threads waiting to receive on the given notification.\n "}
{"spec": "definition\n  get_waiting_sync_recv_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_waiting_sync_recv_threads target state \\<equiv>\n     {x. \\<exists>a. (cdl_objects state) x = Some (Tcb a) \\<and>\n         (\\<exists>can_grant. (cdl_tcb_caps a) tcb_pending_op_slot = Some (PendingSyncRecvCap target False can_grant)) }\"", "property": "Get Waiting Sync Receive Threads: Retrieves the set of threads waiting to receive on a given synchronization endpoint, identifying threads with a pending sync receive capability for that endpoint.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " Get the set of threads waiting to receive on the given sync endpoint. "}
{"spec": "definition\n  get_waiting_sync_send_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_waiting_sync_send_threads target state \\<equiv>\n     {t. \\<exists>fault a b. (cdl_objects state) t = Some (Tcb a) \\<and>\n         (\\<exists>call can_grant can_grant_reply. (cdl_tcb_caps a) tcb_pending_op_slot =\n                    Some (PendingSyncSendCap target b call can_grant can_grant_reply fault)) }\"", "property": "Get Waiting Sync Send Threads: Retrieves the set of threads waiting to send to a specific sync endpoint, identifying threads with a pending sync send capability to that endpoint.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Get the set of threads waiting to send to the given sync endpoint.\n "}
{"spec": "definition\n  get_waiting_sync_bound_ntfn_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_waiting_sync_bound_ntfn_threads ntfn_id state \\<equiv>\n     {x. \\<exists>a ep_id. (cdl_objects state) x = Some (Tcb a) \\<and>\n         (\\<exists>can_grant. (cdl_tcb_caps a) tcb_pending_op_slot = Some (PendingSyncRecvCap ep_id False can_grant)) \\<and>\n         ((cdl_tcb_caps a) tcb_boundntfn_slot = Some (BoundNotificationCap ntfn_id))}\"", "property": "Get Waiting Sync Bound Notification Threads: Retrieves the set of threads bound to a given notification and waiting on synchronous IPC. \n\nThreads Waiting on Sync IPC: The threads are in a waiting state for synchronous IPC, with a pending receive operation on an endpoint. \n\nBound to Notification: The threads are bound to the specified notification, with a BoundNotificationCap in their tcb_boundntfn_slot.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Get the set of threads which are bound to the given ntfn, but are\n * also waiting on sync IPC\n "}
{"spec": "definition\n  block_thread_on_ipc :: \"cdl_object_id \\<Rightarrow> cdl_cap \\<Rightarrow> unit k_monad\"\nwhere\n  \"block_thread_on_ipc tcb cap \\<equiv> set_cap (tcb, tcb_pending_op_slot) cap\" (* Might need to do some check here *)\n\ndefinition\n  lookup_extra_caps :: \"cdl_object_id \\<Rightarrow> cdl_cptr list \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list fault_monad\"\nwhere\n  \"lookup_extra_caps thread cptrs \\<equiv>\n     mapME (\\<lambda>cptr. lookup_cap_and_slot thread cptr) cptrs\"", "property": "Thread IPC Blocking: Mark a thread as blocked on IPC, granting it an implicit \"send once\" or \"receive once\" capability to ensure the transfer can proceed even if the original capability is revoked.\n\nLookup Extra Caps: Retrieve the extra capabilities associated with a thread by looking up the capability pointers in the thread's capability space.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Mark a thread blocked on IPC.\n *\n * Theads get a new implicit \"send once\" or \"receive once\" capability\n * when they block on an IPC. This is because if the capability they\n * used to start the send/receive is revoked, the transfer will still be\n * allowed to proceed (even if it is at a much later point in time).\n "}
{"spec": "definition\n  do_ipc_transfer :: \"cdl_object_id option \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"do_ipc_transfer ep_id sender_id receiver_id can_grant \\<equiv> do\n      \\<comment> \\<open>look up cap transfer\\<close>\n      src_slots \\<leftarrow> get_send_slots sender_id;\n      do \\<comment> \\<open>do normal transfer\\<close>\n        caps \\<leftarrow> if can_grant then\n                lookup_extra_caps sender_id src_slots <catch> (\\<lambda>_. return [])\n              else\n                return [];\n        \\<comment> \\<open>copy registers, transfer message or fault\\<close>\n        corrupt_ipc_buffer receiver_id True;\n        \\<comment> \\<open>transfer caps if no fault occured\\<close>\n        transfer_caps ep_id caps sender_id receiver_id\n      od  \\<sqinter>  \\<comment> \\<open>fault transfer\\<close>\n      corrupt_ipc_buffer receiver_id True;\n      \\<comment> \\<open>set message info\\<close>\n      corrupt_tcb_intent receiver_id\n  od\"", "property": "IPC Transfer: Transfer a message from the sender to the receiver, potentially copying capabilities, while handling pending faults in the receiver by sending the fault instead. \n\nSubproperties:\n- Capability Transfer: Copy capabilities from the sender to the receiver if allowed by the can_grant permission.\n- Fault Handling: If a fault is pending in the receiver, send the fault instead of the original message.\n- Register Copying: Copy registers from the sender to the receiver as part of the transfer process.\n- Message Info Update: Update the message information for the receiver.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Transfer a message from \"sender\" to \"receiver\", possibly copying caps\n * over in the process. If a fault is pending in receiver, send fault instead.\n "}
{"spec": "definition\n  do_reply_transfer :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"do_reply_transfer sender_id receiver_id reply_cap_slot can_grant \\<equiv>\n    do\n      has_fault \\<leftarrow> get_thread_fault receiver_id;\n      when (\\<not> has_fault) $ do_ipc_transfer None sender_id receiver_id can_grant;\n      \\<comment> \\<open>Clear out any pending operation caps.\\<close>\n      delete_cap_simple reply_cap_slot;\n      when (has_fault) $ (do corrupt_tcb_intent receiver_id;\n        update_thread_fault receiver_id (\\<lambda>_. False) od );\n      if ( \\<not> has_fault) then set_cap (receiver_id, tcb_pending_op_slot) RunningCap\n      else\n         (set_cap (receiver_id,tcb_pending_op_slot) NullCap\n        \\<sqinter> set_cap (receiver_id,tcb_pending_op_slot) RestartCap)\n    od\"", "property": "Message Transfer with Reply Capability: Transfer a message from the sender to the receiver using a reply capability, handling pending faults and updating the receiver's thread state accordingly.\n\nSubproperties:\n- Fault Transfer: If a fault is pending in the receiver, transfer the fault and update the receiver's thread fault state.\n- Capability Grant: The sender may have the right to grant capabilities over the channel.\n- Reply Capability Management: Clear out any pending operation capabilities and update the receiver's pending operation slot with the appropriate capability (RunningCap, NullCap, or RestartCap) based on the presence of a fault.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Transfer a message from \"sender\" to \"receiver\" using a reply capability.\n *\n * The sender may have the right to grant caps over the channel.\n *\n * If a fault is pending in the receiver, the fault is transferred.\n "}
{"spec": "definition\n  do_notification_transfer :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"do_notification_transfer receiver_id \\<equiv> do\n      set_cap (receiver_id,tcb_pending_op_slot) RunningCap;\n      corrupt_tcb_intent receiver_id\n   od\"", "property": "Notification Transfer: Wake up a thread waiting on a notification by setting its pending operation to running and corrupting its TCB intent.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " Wake-up a thread waiting on an notification. "}
{"spec": "definition\n  send_signal_bound :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"send_signal_bound ntfn_id \\<equiv> do\n      bound_tcbs \\<leftarrow> gets $ get_waiting_sync_bound_ntfn_threads ntfn_id;\n      if (bound_tcbs \\<noteq> {}) then do\n          t \\<leftarrow> select bound_tcbs;\n          set_cap (t, tcb_pending_op_slot) NullCap;\n          do_notification_transfer t\n        od\n      else return ()\n    od\"\n\ndefinition\n  send_signal :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"send_signal ep_id \\<equiv>\n    (do waiters \\<leftarrow> gets $ get_waiting_ntfn_recv_threads ep_id;\n          t \\<leftarrow> option_select waiters;\n          case t of\n              None \\<Rightarrow> return ()\n            | Some receiver \\<Rightarrow> do_notification_transfer receiver\n     od)\n            \\<sqinter> send_signal_bound ep_id\"", "property": "Notification Signaling: Send a signal to a notification object, waking up any threads blocked on it. If threads are waiting on the notification, one is selected and a notification transfer is performed. If no threads are waiting, the operation has no effect. \n\nBound Notification Signaling: If threads are bound to the notification, one is selected, its pending operation is cleared, and a notification transfer is performed. If no threads are bound, the operation has no effect.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Signal on a notification.\n *\n * If someone is blocked on the notifications, we wake them up. Otherwise,\n * this is a no-(.)\n "}
{"spec": "definition\n  recv_signal :: \"cdl_object_id \\<Rightarrow> cdl_cap \\<Rightarrow> unit k_monad\"\nwhere\n  \"recv_signal tcb_id_receiver ep_cap  \\<equiv> do\n     ep_id \\<leftarrow> return $ cap_object ep_cap;\n     block_thread_on_ipc tcb_id_receiver (PendingNtfnRecvCap ep_id) \\<sqinter> corrupt_tcb_intent tcb_id_receiver\n   od\"", "property": "Signal Reception: Receive a signal from a notification, either retrieving data or blocking the thread to wait for the signal. \n\nSubproperties: \n- Retrieve the endpoint ID from the capability.\n- Block the thread on the IPC endpoint for receiving the signal.\n- Handle potential corruption of the thread's intent.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Receive a signal (receive from a notification).\n *\n * We will either receive data or block waiting.\n "}
{"spec": "definition\n  send_ipc :: \"bool \\<Rightarrow> bool \\<Rightarrow> cdl_badge \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"send_ipc block call badge can_grant can_grant_reply tcb_id_sender ep_id \\<equiv>\n    do\n      waiters \\<leftarrow> gets $ get_waiting_sync_recv_threads ep_id;\n      t \\<leftarrow> option_select waiters;\n      case t of\n          None \\<Rightarrow>\n            if block then\n              block_thread_on_ipc tcb_id_sender\n                  (PendingSyncSendCap ep_id badge call can_grant can_grant_reply False)\n            else\n              return ()\n        | Some tcb_id_receiver \\<Rightarrow> do\n             \\<comment> \\<open>liftM instead of bind+return avoids early unfolding in send_ipc_corres\\<close>\n             recv_state \\<leftarrow> liftM (\\<lambda>tcb. the (cdl_tcb_caps tcb tcb_pending_op_slot)) $\n                              get_thread tcb_id_receiver;\n             reply_can_grant \\<leftarrow>\n               (case recv_state of\n                    PendingSyncRecvCap target False receiver_grant \\<Rightarrow> do\n                      do_ipc_transfer (Some ep_id) tcb_id_sender tcb_id_receiver can_grant;\n                      return receiver_grant od\n                  | _ \\<Rightarrow> fail);\n             set_cap (tcb_id_receiver,tcb_pending_op_slot) RunningCap;\n             (when (can_grant \\<or> can_grant_reply) $\n                  (inject_reply_cap tcb_id_sender tcb_id_receiver reply_can_grant))\n               \\<sqinter> set_cap (tcb_id_sender,tcb_pending_op_slot) NullCap \\<sqinter> return ()\n          od\n    od\"", "property": "Send IPC: Deliver an IPC to the specified endpoint, waking up a waiting receiver if present, or putting the sender to sleep if no receiver is waiting and blocking is enabled.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Send an IPC to the given endpoint. If someone is waiting, we wake\n * them up. Otherwise, we put the sender to sleep.\n "}
{"spec": "definition\n  receive_sync :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"receive_sync thread ep_id receiver_can_grant \\<equiv> do\n    waiters \\<leftarrow> gets $ get_waiting_sync_send_threads ep_id;\n      waiter \\<leftarrow> option_select waiters;\n      (case waiter of\n          None \\<Rightarrow>\n            block_thread_on_ipc thread (PendingSyncRecvCap ep_id False receiver_can_grant)\n             \\<sqinter> corrupt_tcb_intent thread\n        | Some tcb_id_sender \\<Rightarrow> (do\n            tcb \\<leftarrow> get_thread tcb_id_sender;\n            case ((cdl_tcb_caps tcb) tcb_pending_op_slot) of\n              Some (PendingSyncSendCap target _ call can_grant can_grant_reply fault) \\<Rightarrow> (do\n                 do_ipc_transfer (Some ep_id) tcb_id_sender thread can_grant;\n                 (when (can_grant \\<or> can_grant_reply) $\n                    (inject_reply_cap tcb_id_sender thread receiver_can_grant)) \\<sqinter>\n                 set_cap (tcb_id_sender, tcb_pending_op_slot) RunningCap \\<sqinter>\n                 set_cap (tcb_id_sender, tcb_pending_op_slot) NullCap\n              od)\n        od)\n      )\n    od\"", "property": "Synchronous IPC Receive: Receive an IPC from the given endpoint, waking up a waiting sender thread if present, or putting the receiver thread to sleep if no sender is waiting. Ensure that the receiver thread's intent is not corrupted and that the sender thread's pending operation is correctly updated. If the sender can grant or grant reply, inject a reply capability to the receiver thread.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Receive an IPC from the given endpoint. If someone is waiting, we\n * wake them up. Otherwise, we put the receiver to sleep.\n "}
{"spec": "definition\n  receive_ipc :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"receive_ipc thread ep_id can_grant \\<equiv> corrupt_tcb_intent thread \\<sqinter> receive_sync thread ep_id can_grant\"\n\ndefinition\n  invoke_endpoint :: \"bool \\<Rightarrow> bool \\<Rightarrow> cdl_endpoint_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_endpoint is_call can_block params \\<equiv> case params of\n    SyncMessage badge can_grant can_grant_reply ep_id \\<Rightarrow> do\n      thread \\<leftarrow> gets_the cdl_current_thread;\n      send_ipc can_block is_call badge can_grant can_grant_reply thread ep_id\n    od\"\n\ndefinition\n  invoke_notification :: \"cdl_notification_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_notification params \\<equiv> case params of\n    Signal badge ep_id \\<Rightarrow>\n      send_signal ep_id\"\n\ndefinition\n  invoke_reply :: \"cdl_reply_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_reply params \\<equiv> case params of\n    ReplyMessage recv reply_cap_ref rights \\<Rightarrow> do\n      send \\<leftarrow> gets_the cdl_current_thread;\n      do_reply_transfer send recv reply_cap_ref rights\n    od\"", "property": "IPC Invocation: Handle various types of IPC (Inter-Process Communication) invocations, including endpoint invocations, notification invocations, and reply invocations. These invocations allow for synchronous and asynchronous communication between threads, facilitating data transfer and capability exchange.\n\nEndpoint Invocation: Handle endpoint invocations, which involve sending IPC messages to endpoints, potentially blocking the current thread and granting capabilities.\n\nNotification Invocation: Handle notification invocations, which involve sending signals to notifications.\n\nReply Invocation: Handle reply invocations, which involve transferring data and capabilities between threads in response to a previous IPC message.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " This is more nonderministic than is really required, but\n   it makes the refinement proofs much easier "}
{"spec": "definition\n  send_fault_ipc :: \"cdl_object_id \\<Rightarrow> unit fault_monad\"\n  where\n  \"send_fault_ipc tcb_id \\<equiv>\n    doE\n      \\<comment> \\<open>Lookup where we should send the fault IPC to.\\<close>\n      tcb \\<leftarrow> liftE $ get_thread tcb_id;\n      target_ep_cptr \\<leftarrow> returnOk $ cdl_tcb_fault_endpoint tcb;\n      handler_cap \\<leftarrow> lookup_cap tcb_id target_ep_cptr;\n      (case handler_cap of\n          EndpointCap ref badge rights \\<Rightarrow>\n            if Write \\<in> rights \\<and> (Grant \\<in> rights \\<or> GrantReply \\<in> rights) then\n              liftE $ do\n                update_thread_fault tcb_id (\\<lambda>_. True);\n                send_ipc True True badge (Grant \\<in> rights) True tcb_id ref\n              od\n            else\n               throw\n        | _ \\<Rightarrow> throw)\n    odE\"", "property": "Send Fault IPC: Send a fault IPC to the given thread's fault handler, ensuring the handler has the necessary rights to receive the IPC and updating the thread's fault status accordingly. \n\nSubproperties:\n- Lookup the target endpoint capability for the fault handler.\n- Check the handler capability has the required rights (Write and either Grant or GrantReply).\n- Update the thread's fault status and send the IPC to the handler if the rights are valid.\n- Throw an exception if the handler capability is invalid or lacks the required rights.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Send a fault IPC to the given thread's fault handler.\n "}
{"spec": "definition\n  handle_fault :: \"unit k_monad\"\nwhere\n  \"handle_fault \\<equiv> do\n    tcb_id \\<leftarrow> gets_the cdl_current_thread;\n    (send_fault_ipc tcb_id\n      <catch> (\\<lambda>_. KHeap_D.set_cap (tcb_id,tcb_pending_op_slot) cdl_cap.NullCap))\n  od\"\n\nend", "property": "Fault Handling: Handle a fault caused by the current thread by sending a fault IPC to the thread, and if that fails, set the pending operation slot of the thread to a null capability.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Handle a fault caused by the current thread.\n *\n * The abstract spec adds two additional parameters:\n *\n *    1. The fault type (which we abstract away);\n *\n *    2. The thread causing the fault (which always turns out\n *       to be the current thread).\n "}
{"spec": "(*\n * Operations on CNodes.\n *)\n\ntheory CNode_D\nimports Invocations_D CSpace_D\nbegin\n\ndefinition\n  has_cancel_send_rights :: \"cdl_cap \\<Rightarrow> bool\" where\n  \"has_cancel_send_rights cap \\<equiv> case cap of\n   EndpointCap _ _ R \\<Rightarrow> R = UNIV\n   | _ \\<Rightarrow> False\"\n\ndefinition\n  decode_cnode_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_cnode_intent \\<Rightarrow> cdl_cnode_invocation except_monad\"\nwhere\n  \"decode_cnode_invocation target target_ref caps intent \\<equiv> case intent of\n       \\<comment> \\<open>Copy a cap to anther capslot, without modifying the cap.\\<close>\n       CNodeCopyIntent dest_index dest_depth src_index src_depth rights \\<Rightarrow>\n         doE\n           (src_root, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op target dest_index (unat dest_depth);\n           ensure_empty dest_slot;\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n           new_cap \\<leftarrow> returnOk $ update_cap_rights (cap_rights src_cap \\<inter> rights) src_cap;\n           cap \\<leftarrow> derive_cap src_slot new_cap;\n           whenE (cap = cdl_cap.NullCap) throw;\n\n           returnOk $ InsertCall cap src_slot dest_slot\n         odE\n\n     \\<comment> \\<open>Copy a cap to another capslot, possibly modifying the cap.\\<close>\n     | CNodeMintIntent dest_index dest_depth src_index src_depth rights badge \\<Rightarrow>\n         doE\n           (src_root, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op target dest_index (unat dest_depth);\n           ensure_empty dest_slot;\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n\n           \\<comment> \\<open>Munge the caps rights/data.\\<close>\n           new_cap \\<leftarrow> returnOk $ update_cap_rights (cap_rights src_cap \\<inter> rights) src_cap;\n           new_cap' \\<leftarrow> liftE $ update_cap_data False badge new_cap;\n\n           cap \\<leftarrow> derive_cap src_slot new_cap';\n           whenE (cap = cdl_cap.NullCap) throw;\n\n           returnOk $ InsertCall cap src_slot dest_slot\n         odE\n\n     \\<comment> \\<open>Move a cap to another capslot, without modifying the cap.\\<close>\n     | CNodeMoveIntent dest_index dest_depth src_index src_depth \\<Rightarrow>\n         doE\n           (src_root, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op target dest_index (unat dest_depth);\n           ensure_empty dest_slot;\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n           whenE (src_cap = NullCap) throw;\n           returnOk $ MoveCall src_cap src_slot dest_slot\n         odE\n\n     \\<comment> \\<open>Move a cap to another capslot, possibly modifying the cap.\\<close>\n     | CNodeMutateIntent dest_index dest_depth src_index src_depth badge \\<Rightarrow>\n         doE\n           (src_root, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op target dest_index (unat dest_depth);\n           ensure_empty dest_slot;\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n\n           \\<comment> \\<open>Munge the caps rights/data.\\<close>\n           cap \\<leftarrow> liftE $ update_cap_data True badge src_cap;\n           whenE (cap = NullCap) throw;\n\n           returnOk $ MoveCall cap src_slot dest_slot\n         odE\n\n     \\<comment> \\<open>Revoke all CDT children of the given cap.\\<close>\n     | CNodeRevokeIntent index depth \\<Rightarrow>\n         doE\n           target_slot \\<leftarrow> lookup_slot_for_cnode_op target index (unat depth);\n           returnOk $ RevokeCall target_slot\n         odE\n\n     \\<comment> \\<open>Delete the given cap, but not its children.\\<close>\n     | CNodeDeleteIntent index depth \\<Rightarrow>\n         doE\n           target_slot \\<leftarrow> lookup_slot_for_cnode_op target index (unat depth);\n           returnOk $ DeleteCall target_slot\n         odE\n\n     \\<comment> \\<open>Save the current thread's reply cap into the target slot.\\<close>\n     | CNodeSaveCallerIntent index depth \\<Rightarrow>\n         doE\n           target_slot \\<leftarrow> lookup_slot_for_cnode_op target index (unat depth);\n           ensure_empty target_slot;\n           returnOk $ SaveCall target_slot\n         odE\n\n     \\<comment> \\<open>Recycle the target cap.\\<close>\n     | CNodeCancelBadgedSendsIntent index depth \\<Rightarrow>\n         doE\n           target_slot \\<leftarrow> lookup_slot_for_cnode_op target index (unat depth);\n           cap \\<leftarrow> liftE $ get_cap target_slot;\n           unlessE (has_cancel_send_rights cap) throw;\n           returnOk $ CancelBadgedSendsCall cap\n         odE\n\n     \\<comment> \\<open>Atomically move several caps.\\<close>\n     | CNodeRotateIntent dest_index dest_depth pivot_index pivot_depth pivot_badge src_index src_depth src_badge \\<Rightarrow>\n         doE\n           pivot_root \\<leftarrow> throw_on_none $ get_index caps 0;\n           src_root \\<leftarrow> throw_on_none $ get_index caps 1;\n\n           dest_root \\<leftarrow> returnOk $ target;\n           pivot_root \\<leftarrow> returnOk $ fst pivot_root;\n           src_root \\<leftarrow> returnOk $ fst src_root;\n\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op dest_root dest_index (unat dest_depth);\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           pivot_slot \\<leftarrow> lookup_slot_for_cnode_op pivot_root pivot_index (unat pivot_depth);\n\n           whenE (pivot_slot = src_slot \\<or> pivot_slot = dest_slot) throw;\n\n           unlessE (src_slot = dest_slot) $ ensure_empty dest_slot;\n\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n           whenE (src_cap = NullCap) throw;\n\n           pivot_cap \\<leftarrow> liftE $ get_cap pivot_slot;\n           whenE (pivot_cap = NullCap) throw;\n\n           \\<comment> \\<open>Munge caps.\\<close>\n           new_src \\<leftarrow> liftE $ update_cap_data True src_badge src_cap;\n           new_pivot \\<leftarrow> liftE $ update_cap_data True pivot_badge pivot_cap;\n\n           whenE (new_src = NullCap) throw;\n           whenE (new_pivot = NullCap) throw;\n\n           returnOk $ RotateCall new_src new_pivot src_slot pivot_slot dest_slot\n         odE\n   \"\n\ndefinition\n  invoke_cnode :: \"cdl_cnode_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"invoke_cnode params \\<equiv> case params of\n    \\<comment> \\<open>Insert a new cap.\\<close>\n      InsertCall cap src_slot dest_slot \\<Rightarrow>\n        liftE $\n          insert_cap_sibling cap src_slot dest_slot\n          \\<sqinter>\n          insert_cap_child cap src_slot dest_slot\n\n    \\<comment> \\<open>Move a cap, possibly modifying it in the process.\\<close>\n    | MoveCall cap src_slot dest_slot \\<Rightarrow>\n        liftE $ move_cap cap src_slot dest_slot\n\n    \\<comment> \\<open>Revoke a cap.\\<close>\n    | RevokeCall src_slot \\<Rightarrow>\n        revoke_cap src_slot\n\n    \\<comment> \\<open>Delete a cap.\\<close>\n    | DeleteCall src_slot \\<Rightarrow>\n        delete_cap src_slot\n\n    \\<comment> \\<open>Atomically move two capabilities.\\<close>\n    | RotateCall cap1 cap2 slot1 slot2 slot3 \\<Rightarrow>\n        liftE $ if slot1 = slot3 then\n          swap_cap cap1 slot1 cap2 slot2\n        else\n          do\n            move_cap cap2 slot2 slot3;\n            move_cap cap1 slot1 slot2\n          od\n\n    \\<comment> \\<open>Save a reply cap from the caller's TCB into this CNode.\\<close>\n    | SaveCall dest_slot \\<Rightarrow>\n        liftE $ do\n          current \\<leftarrow> gets_the cdl_current_thread;\n          replycap \\<leftarrow> get_cap (current, tcb_caller_slot);\n          when (replycap \\<noteq> NullCap)\n            $ move_cap replycap (current, tcb_caller_slot) dest_slot\n        od\n\n    \\<comment> \\<open>Reset an object into its original state.\\<close>\n    | CancelBadgedSendsCall (EndpointCap ep b _) \\<Rightarrow> liftE $ when (b \\<noteq> 0) $ cancel_badged_sends ep b\n    | CancelBadgedSendsCall _ \\<Rightarrow> fail\n  \"\n\nend", "property": "CNode Invocation Actions: Perform various operations on CNodes, including copying and moving capabilities, revoking and deleting capabilities, saving reply capabilities, recycling capabilities, and rotating capabilities. These actions ensure that capabilities are managed correctly and efficiently within the CNode.\n\nSubproperties:\n- Capability Copy and Move: Copy or move capabilities between slots, possibly modifying the capability in the process.\n- Capability Revoke and Delete: Revoke or delete capabilities, ensuring that the capability is removed from the system.\n- Reply Capability Save: Save a reply capability from the caller's TCB into a CNode slot.\n- Capability Recycling: Recycle capabilities, resetting objects to their original state.\n- Capability Rotation: Rotate capabilities between slots, ensuring that capabilities are moved atomically.", "title": "./spec/capDL/CNode_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n * Operations on page table objects and frames.\n *)\n\ntheory PageTable_D\nimports Invocations_D CSpace_D\nbegin", "property": "Page Table Operations: Manage page table objects and frames, ensuring correct mapping and access control.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  free_pd_slots :: \"cdl_object \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\"\nwhere\n  \"free_pd_slots pd pd_id state \\<equiv> {(pd_id, y). (object_slots pd) y = Some NullCap}\"", "property": "Free Page Directory Slots: Returns the set of free slots in a given page directory, identified by the page directory ID and object, within the current system state. \n\nFree Slots Identification: The free slots are those with a Null capability.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Return the set of free PD slots in the given PD. "}
{"spec": "definition\n  all_pd_pt_slots :: \"cdl_object \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\"\nwhere\n  \"all_pd_pt_slots pd pd_id state \\<equiv> {(pd_id, y). y \\<in> dom (object_slots pd)}\n     \\<union> {(x, y). \\<exists> a b c. (object_slots pd) a = Some (PageTableCap x b c) \\<and> x \\<in> dom (cdl_objects state)}\"\n\ndefinition\n  \"cdl_get_pt_mapped_addr cap \\<equiv>\n    case cap of PageTableCap pid ctype maddr \\<Rightarrow>  maddr\n    | _ \\<Rightarrow> None\"", "property": "PD/PT Slot Retrieval: Returns the set of all PD/PT slots in a given PD, including direct slots and indirect slots from page tables referenced by the PD.\n\nSubproperties:\n- Direct Slot Retrieval: Retrieves all direct slots within the given PD.\n- Indirect Slot Retrieval: Retrieves all indirect slots from page tables referenced by the PD.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Return the set of all PD/PT slots in the given PD. "}
{"spec": "definition\n  decode_page_table_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_page_table_intent \\<Rightarrow> cdl_page_table_invocation except_monad\"\nwhere\n  \"decode_page_table_invocation target target_ref caps intent \\<equiv> case intent of\n    \\<comment> \\<open>\n      Map the given PageTable into the given PageDirectory at the given\n      virtual address.\n\n      The concrete implementation only allows a PageTable to be mapped\n      once at any point in time, but we don't enforce that here.\n     \\<close>\n    PageTableMapIntent vaddr attr \\<Rightarrow>\n      doE\n        case cdl_get_pt_mapped_addr target of Some a \\<Rightarrow> throw\n        | None \\<Rightarrow> returnOk ();\n        \\<comment> \\<open>Ensure that a PD was passed in.\\<close>\n        pd \\<leftarrow> throw_on_none $ get_index caps 0;\n        (pd_object_id, asid) \\<leftarrow>\n          case (fst pd) of\n              PageDirectoryCap x _ (Some asid) \\<Rightarrow> returnOk (x, asid)\n            | _ \\<Rightarrow> throw;\n\n        target_slot \\<leftarrow> returnOk $ cdl_lookup_pd_slot pd_object_id vaddr;\n\n        returnOk $ PageTableMap (PageTableCap (cap_object target) Real (Some (asid,vaddr && ~~ mask 20)))\n          (PageTableCap (cap_object target) Fake None) target_ref target_slot\n      odE \\<sqinter> throw\n    \\<comment> \\<open>Unmap this PageTable.\\<close>\n    | PageTableUnmapIntent \\<Rightarrow> (\n        case target of PageTableCap pid ctype maddr \\<Rightarrow>\n        (returnOk $ PageTableUnmap maddr pid target_ref)\n        | _ \\<Rightarrow> throw\n      ) \\<sqinter> throw\n  \"", "property": "Page Table Invocation Decoding: Decodes a page table intent into a specific invocation, handling two types of intents: mapping a page table into a page directory at a given virtual address with specific attributes, and unmapping a page table. Ensures that the page table is not already mapped and that a valid page directory is provided for mapping.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Decode a page table intent into an invocation. "}
{"spec": "definition\n  decode_page_directory_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_page_directory_intent \\<Rightarrow> cdl_page_directory_invocation except_monad\"\nwhere\n  \"decode_page_directory_invocation target target_ref caps intent \\<equiv>\n      (returnOk $ PageDirectoryNothing) \\<sqinter>\n      (returnOk $ PageDirectoryFlush Unify)  \\<sqinter>  (returnOk $ PageDirectoryFlush Clean)  \\<sqinter>\n      (returnOk $ PageDirectoryFlush CleanInvalidate )  \\<sqinter> (returnOk $ PageDirectoryFlush Invalidate)\n      \\<sqinter> throw \"", "property": "Page Directory Invocation Decoding: Decode a page directory intent into a specific invocation, which can result in either no action (PageDirectoryNothing) or various flushing operations (Unify, Clean, CleanInvalidate, Invalidate) on the page directory.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Decode a page table intent into an invocation. "}
{"spec": "definition\n  decode_page_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_page_intent \\<Rightarrow> cdl_page_invocation except_monad\"\nwhere\n  \"decode_page_invocation target target_ref caps intent \\<equiv> case intent of\n      \\<comment> \\<open>\n        Map the given Page into the given PageDirectory or PageTable at\n        the given virtual address.\n\n        The concrete implementation only allows a Page to be mapped\n        once at any point in time, but we don't enforce that here.\n       \\<close>\n      PageMapIntent vaddr rights attr \\<Rightarrow>\n        doE\n          \\<comment> \\<open>Ensure that a PD was passed in.\\<close>\n          pd \\<leftarrow> throw_on_none $ get_index caps 0;\n          (pd_object_id, asid) \\<leftarrow>\n            case (fst pd) of\n                PageDirectoryCap x _ (Some asid) \\<Rightarrow> returnOk (x, asid)\n              | _ \\<Rightarrow> throw;\n\n          \\<comment> \\<open>Collect mapping from target cap.\\<close>\n          (frame,sz,dev) \\<leftarrow> returnOk $ (case target of FrameCap dev p R sz m mp \\<Rightarrow> (p,sz,dev));\n\n          target_slots \\<leftarrow> cdl_page_mapping_entries vaddr sz pd_object_id;\n\n          \\<comment> \\<open>Calculate rights.\\<close>\n          new_rights \\<leftarrow> returnOk $ validate_vm_rights $ cap_rights target \\<inter> rights;\n\n          \\<comment> \\<open>Return the map intent.\\<close>\n          returnOk $ PageMap (FrameCap dev frame (cap_rights target) sz Real (Some (asid,vaddr)))\n            (FrameCap False frame new_rights sz Fake None) target_ref target_slots\n        odE \\<sqinter> throw\n\n    \\<comment> \\<open>Unmap this PageTable.\\<close>\n    | PageUnmapIntent \\<Rightarrow> doE\n        (frame, asid, sz) \\<leftarrow> (case target of\n           FrameCap _ p R sz m mp \\<Rightarrow> returnOk (p, mp , sz)\n        | _ \\<Rightarrow> throw);\n      (returnOk $ PageUnmap asid frame target_ref sz) \\<sqinter> throw\n      odE\n\n    \\<comment> \\<open>Flush the caches associated with this page.\\<close>\n    | PageFlushCachesIntent \\<Rightarrow>\n       (returnOk $ PageFlushCaches Unify)  \\<sqinter>  (returnOk $ PageFlushCaches Clean)  \\<sqinter>\n      (returnOk $ PageFlushCaches CleanInvalidate )  \\<sqinter> (returnOk $ PageFlushCaches Invalidate)\n      \\<sqinter> throw\n\n    | PageGetAddressIntent \\<Rightarrow> returnOk PageGetAddress\n\n  \"", "property": "Page Invocation Decoding: Decode a page intent into a specific invocation, handling various page-related operations such as mapping a page into a page directory or page table at a given virtual address, unmapping a page table, flushing caches associated with a page, or retrieving a page's address. \n\nPage Mapping: Ensure a page directory is provided, collect mapping information from the target capability, calculate the new rights, and return the map intent.\n\nPage Unmapping: Extract the frame, address space identifier, and size from the target capability and return the unmap intent.\n\nPage Cache Flushing: Return the flush caches intent with various cache flushing options (Unify, Clean, CleanInvalidate, Invalidate).\n\nPage Address Retrieval: Return the page get address intent.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Decode a page intent into an invocation. "}
{"spec": "definition\n  invoke_page_directory :: \"cdl_page_directory_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_page_directory params \\<equiv> case params of\n      PageDirectoryFlush flush  => return ()\n    | PageDirectoryNothing => return ()\n  \"\n\ndefinition \"option_exec f \\<equiv> \\<lambda>x. case x of Some a \\<Rightarrow> f a | None \\<Rightarrow> return ()\"", "property": "Page Table Invocation: Allows invoking a page table with specific parameters, currently supporting flush and no-operation actions. \n\nFlush Action: Does nothing when invoked with a flush parameter.\nNo-Operation Action: Does nothing when invoked with no parameters.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Invoke a page table. "}
{"spec": "definition\n  invoke_page_table :: \"cdl_page_table_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_page_table params \\<equiv> case params of\n      PageTableMap real_pt_cap pt_cap pt_cap_ref pd_target_slot \\<Rightarrow>\n        do set_cap pt_cap_ref real_pt_cap;\n           \\<comment> \\<open>\n             We install the Page Table into the Page Directory.  The\n             concrete kernel uses hardware-defined PDEs (Page Directory\n             Entries). Our abstract spec just uses caps.\n            \\<close>\n           insert_cap_orphan pt_cap pd_target_slot\n        od\n    | PageTableUnmap mapped_addr pt_id pt_cap_ref \\<Rightarrow> do\n        (case mapped_addr of Some maddr \\<Rightarrow> do\n                 unmap_page_table maddr pt_id;\n                 clear_object_caps pt_id \\<sqinter> return ()\n               od\n          | _ \\<Rightarrow> return ());\n        cap \\<leftarrow> get_cap pt_cap_ref;\n        set_cap pt_cap_ref (reset_mem_mapping cap)\n        od\n\n  \"", "property": "Page Table Invocation: Allows for the invocation of a page table, enabling mapping and unmapping operations. Mapping involves setting a capability and installing a page table into a page directory, while unmapping entails clearing object capabilities, unmapping the page table, and resetting the memory mapping capability.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Invoke a page table. "}
{"spec": "definition\n  invoke_page :: \"cdl_page_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_page params \\<equiv> case params of\n      PageMap frame_cap pseudo_frame_cap frame_cap_ref target_slots \\<Rightarrow>\n          \\<comment> \\<open>Clear out the target slots.\\<close>\n        do\n          set_cap frame_cap_ref frame_cap;\n          mapM_x (swp set_cap pseudo_frame_cap) target_slots\n        od\n\n    | PageUnmap mapped_addr frame_id frame_cap_ref pgsz \\<Rightarrow> do\n        (case mapped_addr of\n          Some maddr \\<Rightarrow> unmap_page maddr frame_id pgsz\n        | _ \\<Rightarrow> return ());\n        cap \\<leftarrow> get_cap frame_cap_ref;\n        set_cap frame_cap_ref (reset_mem_mapping cap)\n      od\n\n    | PageFlushCaches flush \\<Rightarrow> return ()\n\n    | PageGetAddress \\<Rightarrow> return ()\n\n  \"\n\nend", "property": "Page Invocation Actions: Allows invoking page operations such as mapping a page to multiple slots, unmapping a page from a specific address, flushing caches, and getting page addresses. These actions ensure that pages can be effectively managed and accessed within the system. \n\nPage Mapping: Maps a page to multiple target slots, ensuring that the page is correctly referenced and accessible.\n\nPage Unmapping: Unmaps a page from a specific address, resetting the memory mapping and ensuring that the page is no longer accessible at that address.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Invoke a page. "}
{"spec": "(*\n * System calls\n *)\n\ntheory Syscall_D\nimports\n  Schedule_D\n  Decode_D\n  \"ExecSpec.Event_H\"\nbegin", "property": "System Call Management: Provides the foundation for handling system calls, including scheduling and decoding, to facilitate controlled interactions between user-level applications and the kernel.", "title": "./spec/capDL/Syscall_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\nsyscall :: \"\n  ('a fault_monad) \\<Rightarrow> (unit k_monad) \\<Rightarrow>\n  ('a \\<Rightarrow> 'b except_monad) \\<Rightarrow> (unit k_monad) \\<Rightarrow>\n  ('b \\<Rightarrow> unit preempt_monad) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"syscall\n      cap_decoder_fn decode_error_handler_fn\n      arg_decode_fn arg_error_handler_fn\n      perform_syscall_fn \\<equiv>\n    cap_decoder_fn\n    <handle>\n      (\\<lambda> _. liftE $ decode_error_handler_fn)\n    <else>\n      (\\<lambda> a. ((arg_decode_fn a)\n        <handle>\n          (\\<lambda> _. liftE $ arg_error_handler_fn)\n        <else>\n          perform_syscall_fn))\n  \"\n\nfun\n  perform_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> cdl_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n    \"perform_invocation is_call can_block (InvokeUntyped untyped_params) = (invoke_untyped untyped_params)\"\n  | \"perform_invocation is_call can_block (InvokeEndpoint endpoint_params) = liftE (invoke_endpoint is_call can_block endpoint_params)\"\n  | \"perform_invocation is_call can_block (InvokeNotification ntfn_params) = liftE (invoke_notification ntfn_params)\"\n  | \"perform_invocation is_call can_block (InvokeReply reply_params) = liftE (invoke_reply reply_params)\"\n  | \"perform_invocation is_call can_block (InvokeTcb tcb_params) = (invoke_tcb tcb_params)\"\n  | \"perform_invocation is_call can_block (InvokeDomain domain_params) = (invoke_domain domain_params)\"\n  | \"perform_invocation is_call can_block (InvokeCNode cnode_params) = invoke_cnode cnode_params\"\n  | \"perform_invocation is_call can_block (InvokeIrqControl irq_params) = liftE (invoke_irq_control irq_params)\"\n  | \"perform_invocation is_call can_block (InvokeIrqHandler handler_params) = liftE (invoke_irq_handler handler_params)\"\n  | \"perform_invocation is_call can_block (InvokePageTable page_table_params) = liftE (invoke_page_table page_table_params)\"\n  | \"perform_invocation is_call can_block (InvokePage page_params) = liftE (invoke_page page_params)\"\n  | \"perform_invocation is_call can_block (InvokeAsidControl asid_control_params) = liftE (invoke_asid_control asid_control_params)\"\n  | \"perform_invocation is_call can_block (InvokeAsidPool asid_pool_params) = liftE (invoke_asid_pool asid_pool_params)\"\n  | \"perform_invocation is_call can_block (InvokePageDirectory page_dir_params) = liftE (invoke_page_directory page_dir_params) \"\n\ndefinition ep_related_cap :: \"cdl_cap \\<Rightarrow> bool\"\nwhere \"ep_related_cap cap \\<equiv> case cap of\n cdl_cap.EndpointCap o_id badge rights \\<Rightarrow> True\n| cdl_cap.NotificationCap o_id badge rights \\<Rightarrow> True\n| cdl_cap.ReplyCap o_id rights \\<Rightarrow> True\n| _ \\<Rightarrow> False\"\n\ndefinition \"has_restart_cap \\<equiv> \\<lambda>tcb_id. do\n  t \\<leftarrow> get_thread tcb_id;\n  return ((cdl_tcb_caps t) tcb_pending_op_slot = Some cdl_cap.RestartCap)\n  od\"\n\ndefinition\n  handle_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"handle_invocation is_call can_block \\<equiv>\n    doE\n      thread_ptr \\<leftarrow> liftE $ gets_the cdl_current_thread;\n      thread \\<leftarrow> liftE $ get_thread thread_ptr;\n      full_intent \\<leftarrow> returnOk $ cdl_tcb_intent thread;\n\n      intent \\<leftarrow> returnOk $ cdl_intent_op full_intent;\n      invoked_cptr \\<leftarrow> returnOk $ cdl_intent_cap full_intent;\n      extra_cap_cptrs \\<leftarrow> returnOk $ cdl_intent_extras full_intent;\n\n      syscall\n        \\<comment> \\<open>Lookup all caps presented.\\<close>\n        (doE\n          (cap, cap_ref) \\<leftarrow> lookup_cap_and_slot thread_ptr invoked_cptr;\n          extra_caps \\<leftarrow> lookup_extra_caps thread_ptr extra_cap_cptrs;\n          returnOk (cap, cap_ref, extra_caps)\n        odE)\n        \\<comment> \\<open>If that failed, send off a fault IPC (if we did a blocking operation).\\<close>\n        (when can_block $ handle_fault)\n\n        \\<comment> \\<open>Decode the user's intent.\\<close>\n        (\\<lambda> (cap, cap_ref, extra_caps).\n          case intent of\n              None \\<Rightarrow> (if ep_related_cap cap then\n                decode_invocation cap cap_ref extra_caps undefined\n                else throw)\n            | Some intent' \\<Rightarrow>\n                decode_invocation cap cap_ref extra_caps intent')\n\n        \\<comment> \\<open>If that stuffed up, we do nothing more than corrupt the frames.\\<close>\n        (do corrupt_ipc_buffer thread_ptr True;\n            when is_call (mark_tcb_intent_error thread_ptr True)\n         od)\n\n        \\<comment> \\<open>Invoke the system call.\\<close>\n        (\\<lambda> inv. doE\n            liftE $ set_cap (thread_ptr,tcb_pending_op_slot) RestartCap;\n            perform_invocation is_call can_block inv;\n            restart \\<leftarrow> liftE $ has_restart_cap thread_ptr;\n            whenE restart $ liftE (do\n                       corrupt_ipc_buffer thread_ptr True;\n                       when (is_call) (mark_tcb_intent_error thread_ptr False);\n                       set_cap (thread_ptr,tcb_pending_op_slot) RunningCap\n            od)\n            odE)\n  odE\n  \"\n\ndefinition\n  handle_recv :: \"unit k_monad\"\nwhere\n  \"handle_recv \\<equiv>\n    do\n      \\<comment> \\<open>Get the current thread.\\<close>\n      tcb_id \\<leftarrow> gets_the cdl_current_thread;\n      tcb \\<leftarrow> get_thread tcb_id;\n      \\<comment> \\<open>Get the endpoint it is trying to receive from.\\<close>\n      (doE\n        ep_cptr \\<leftarrow> returnOk $ cdl_intent_cap (cdl_tcb_intent tcb);\n        ep_cap \\<leftarrow> lookup_cap tcb_id ep_cptr;\n        (case ep_cap of\n          EndpointCap o_id badge rights \\<Rightarrow>\n            if Read \\<in> rights then\n              (liftE $ do\n                   delete_cap_simple (tcb_id, tcb_caller_slot);\n                   receive_ipc tcb_id (cap_object ep_cap) (Grant \\<in> rights)\n                od) \\<sqinter> throw\n            else\n              throw\n        | NotificationCap o_id badge rights \\<Rightarrow>\n            if Read \\<in> rights then\n              (liftE $ recv_signal tcb_id ep_cap) \\<sqinter> throw\n            else\n              throw\n        | _ \\<Rightarrow>\n            throw)\n      odE)\n      <catch>\n        (\\<lambda> _. handle_fault)\n    od\n  \"\n\ndefinition\n  handle_reply :: \"unit k_monad\"\nwhere\n  \"handle_reply \\<equiv>\n    do\n      tcb_id \\<leftarrow> gets_the cdl_current_thread;\n      caller_cap \\<leftarrow> get_cap (tcb_id, tcb_caller_slot);\n\n      case caller_cap of\n          ReplyCap target rights \\<Rightarrow> do_reply_transfer tcb_id target (tcb_id, tcb_caller_slot) (Grant \\<in> rights)\n        | NullCap \\<Rightarrow> return ()\n        | _ \\<Rightarrow> fail\n    od\n  \"\n\ndefinition handle_hypervisor_fault :: \"unit k_monad\"\nwhere \"handle_hypervisor_fault \\<equiv> return ()\"\n\ndefinition\n  handle_syscall :: \"syscall \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"handle_syscall sys \\<equiv>\n    case sys of\n      SysSend  \\<Rightarrow> handle_invocation False True\n    | SysNBSend \\<Rightarrow> handle_invocation False False\n    | SysCall \\<Rightarrow> handle_invocation True True\n    | SysRecv \\<Rightarrow> liftE $ handle_recv\n    | SysYield \\<Rightarrow> returnOk ()\n    | SysReply \\<Rightarrow> liftE $ handle_reply\n    | SysReplyRecv \\<Rightarrow> liftE $ do\n        handle_reply;\n        handle_recv\n      od\n    | SysNBRecv \\<Rightarrow> liftE $ handle_recv\"\n\ndefinition\n  handle_event :: \"event \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"handle_event ev \\<equiv> case ev of\n      SyscallEvent sys \\<Rightarrow> handle_syscall sys\n    | UnknownSyscall n \\<Rightarrow> liftE $ handle_fault\n    | UserLevelFault a b \\<Rightarrow> liftE $ handle_fault\n    | VMFaultEvent c \\<Rightarrow> liftE $ handle_fault\n    | Interrupt \\<Rightarrow> liftE $ handle_pending_interrupts\n    | HypervisorEvent w \\<Rightarrow> liftE $ handle_hypervisor_fault\n    \"\n\ndefinition\n  call_kernel :: \"event \\<Rightarrow> unit k_monad\"\nwhere\n  \"call_kernel ev \\<equiv>\n    do\n      \\<comment> \\<open>Deal with the event.\\<close>\n      handle_event ev\n        <handle> (\\<lambda> _. liftE handle_pending_interrupts);\n      schedule;\n      t \\<leftarrow> gets cdl_current_thread;\n      case t of Some thread \\<Rightarrow> do\n       restart \\<leftarrow> has_restart_cap thread;\n       when restart $ set_cap (thread, tcb_pending_op_slot) RunningCap\n      od | None \\<Rightarrow> return ()\n    od\"\n\nend", "property": "System Call Handling: Ensures that system calls are handled correctly by performing cap validation, argument validation, and syscall execution, while also managing faults, interrupts, and restarts. This guarantees the integrity and security of the kernel.\n\nSubproperties:\n- Cap Validation: Verifies that all caps passed into the system call are valid.\n- Argument Validation: Ensures that the requested operation is valid and permitted.\n- Syscall Execution: Carries out the actual operation.\n- Fault Handling: Manages faults by sending off a fault IPC if a blocking operation failed.\n- Interrupt Handling: Handles pending interrupts.\n- Restart Management: Manages restarts by setting the restart cap and marking the tcb intent error.", "title": "./spec/capDL/Syscall_D.thy", "chapter": "", "section": "", "comment": "\n * Perform system calls.\n *\n * Each system call is broken into three stages:\n *\n *   (1) Cap validation, where we ensure that all caps passed\n *       into the system call are valid;\n *\n *   (2) Argument validation, where we ensure that the requested\n *       operation is valid and permitted; and\n *\n *   (3) Syscall execution, where we carry out the actual\n *       operation.\n *\n * For this function, the user passes us in 5 functions:\n *\n *   (1, 2) A cap validation function, and an error handler;\n *   (3, 4) A argument validation function, and an error handler;\n *   (5)    A syscall execution function.\n *\n * This function returns an item of type \"'c\", and may also\n * return an exception if operation (3) above was preempted\n * by an interrupt.\n "}
{"spec": "(*\n * Unmapping pages and page tables and what is needed for it:\n * short cut delete, revoke and finale of caps, ipc cancelling.\n *)\n\ntheory PageTableUnmap_D\nimports\n  Invocations_D\n  KHeap_D\nbegin\n\n\\<comment> \\<open>Return all slots in the system containing a cap with the given property.\\<close>\ndefinition\n  slots_with :: \"(cdl_cap \\<Rightarrow> bool) \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\"\nwhere\n  \"slots_with P s \\<equiv> {(obj, slot). \\<exists>x c. cdl_objects s obj = Some x \\<and>\n                                        has_slots x \\<and>\n                                        object_slots x slot = Some c \\<and> P c}\"\n\n\n\\<comment> \\<open>Remove a pending operation from the given TCB.\\<close>\ndefinition\n  remove_pending_operation :: \"cdl_tcb \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_tcb\"\nwhere\n  \"remove_pending_operation t cap \\<equiv> t\\<lparr>cdl_tcb_caps := (cdl_tcb_caps t)(tcb_pending_op_slot \\<mapsto> cap)\\<rparr>\"\n\n\n\\<comment> \\<open>Is the given thread pending on the given endpoint?\\<close>\ndefinition\n  is_thread_blocked_on_endpoint :: \"cdl_tcb \\<Rightarrow> cdl_object_id \\<Rightarrow> bool\"\nwhere\n  \"is_thread_blocked_on_endpoint t ep \\<equiv>\n    case (cdl_tcb_caps t tcb_pending_op_slot) of\n        Some (PendingSyncSendCap p _ _ _ _ _) \\<Rightarrow> p = ep\n      | Some (PendingSyncRecvCap p is_reply _) \\<Rightarrow> p = ep \\<and> \\<not> is_reply\n      | Some (PendingNtfnRecvCap p) \\<Rightarrow> p = ep\n      | _ \\<Rightarrow> False\"\n\n\n\\<comment> \\<open>Cancel all pending IPCs currently blocked on this endpoint.\\<close>\ndefinition\n  cancel_all_ipc :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"cancel_all_ipc ep \\<equiv>\n    modify (\\<lambda>s. s\\<lparr>cdl_objects :=  map_option\n        (\\<lambda>obj. case obj of\n            Tcb t \\<Rightarrow>\n              if (is_thread_blocked_on_endpoint t ep) then\n                Tcb (remove_pending_operation t RestartCap)\n              else\n                Tcb t\n           | _ \\<Rightarrow> obj)\n          \\<circ> (cdl_objects s)\\<rparr>)\"\n\n\\<comment> \\<open>Is the given thread bound to the given ntfn?\\<close>\ndefinition\n  is_thread_bound_to_ntfn :: \"cdl_tcb \\<Rightarrow> cdl_object_id \\<Rightarrow> bool\"\nwhere\n  \"is_thread_bound_to_ntfn t ntfn \\<equiv>\n    case (cdl_tcb_caps t tcb_boundntfn_slot) of\n        Some (BoundNotificationCap a) \\<Rightarrow> a = ntfn\n      | _ \\<Rightarrow> False\"\n\n\\<comment> \\<open>find all tcbs that are bound to a given ntfn\\<close>\ndefinition\n  get_bound_notification_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_bound_notification_threads ntfn_id state \\<equiv>\n     {x. \\<exists>a. (cdl_objects state) x = Some (Tcb a) \\<and>\n         (((cdl_tcb_caps a) tcb_boundntfn_slot) = Some (BoundNotificationCap ntfn_id))}\"\n\ndefinition\n  modify_bound_ntfn :: \"cdl_tcb \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_tcb\"\nwhere\n  \"modify_bound_ntfn t cap \\<equiv> t \\<lparr> cdl_tcb_caps := (cdl_tcb_caps t)(tcb_boundntfn_slot \\<mapsto> cap)\\<rparr>\"\n\n\nabbreviation\n  do_unbind_notification :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"do_unbind_notification tcb \\<equiv> set_cap (tcb, tcb_boundntfn_slot) NullCap\"\n\ndefinition\n  unbind_notification :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"unbind_notification tcb \\<equiv> do\n     cap \\<leftarrow> KHeap_D.get_cap (tcb, tcb_boundntfn_slot);\n     (case cap of\n      BoundNotificationCap _ \\<Rightarrow> do_unbind_notification tcb\n    | _ \\<Rightarrow> return ())\n   od\"\n\ndefinition\n  unbind_maybe_notification :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"unbind_maybe_notification ntfn_id \\<equiv> do\n     bound_tcbs \\<leftarrow> gets $ get_bound_notification_threads ntfn_id;\n     t \\<leftarrow> option_select bound_tcbs;\n     (case t of\n       None \\<Rightarrow> return ()\n     | Some tcb \\<Rightarrow> do_unbind_notification tcb)\n  od\"\n\ndefinition\n  can_fast_finalise :: \"cdl_cap \\<Rightarrow> bool\" where\n \"can_fast_finalise cap \\<equiv> case cap of ReplyCap r R \\<Rightarrow> True\n                       | MasterReplyCap r \\<Rightarrow> True\n                       | EndpointCap r b R \\<Rightarrow> True\n                       | NotificationCap r b R \\<Rightarrow> True\n                       | NullCap \\<Rightarrow> True\n                       | RestartCap \\<Rightarrow> True\n                       | RunningCap \\<Rightarrow> True\n                       | PendingSyncSendCap r _ _ _ _ _ \\<Rightarrow> True\n                       | PendingSyncRecvCap r _ _ \\<Rightarrow> True\n                       | PendingNtfnRecvCap r \\<Rightarrow> True\n                       | DomainCap \\<Rightarrow> True\n                       | PageDirectoryCap _ x _ \\<Rightarrow> \\<not>(x = Real)\n                       | PageTableCap _ x _ \\<Rightarrow> \\<not>(x = Real)\n                       | FrameCap _ _ _ _ x _ \\<Rightarrow> \\<not>(x = Real)\n                       | _ \\<Rightarrow> False\"\n\ncontext\nnotes [[function_internals =true]]\nbegin\n\nfun\n  fast_finalise :: \"cdl_cap \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"fast_finalise NullCap                  final = return ()\"\n| \"fast_finalise (RestartCap)             final = return ()\"\n| \"fast_finalise (RunningCap)             final = return ()\"\n| \"fast_finalise (ReplyCap r R)           final = return ()\"\n| \"fast_finalise (MasterReplyCap r)       final = return ()\"\n| \"fast_finalise (EndpointCap r b R)      final =\n      (when final $ cancel_all_ipc r)\"\n| \"fast_finalise (NotificationCap r b R) final =\n      (when final $ do\n            unbind_maybe_notification r;\n            cancel_all_ipc r\n          od)\"\n| \"fast_finalise (PendingSyncSendCap r _ _ _ _ _) final = return()\"\n| \"fast_finalise (PendingSyncRecvCap r _ _) final = return()\"\n| \"fast_finalise  (PendingNtfnRecvCap r) final = return()\"\n| \"fast_finalise DomainCap final = return ()\"\n| \"fast_finalise (PageDirectoryCap _ x _) _ = (if x = Real then fail else return())\"\n| \"fast_finalise (PageTableCap _ x _) _ = (if x = Real then fail else return())\"\n| \"fast_finalise (FrameCap _ _ _ _ x _) _ = (if x = Real then fail else return())\"\n| \"fast_finalise _ _ = fail\"\n\nend\n\n\\<comment> \\<open>These caps don't count when determining if an entity should be deleted or not\\<close>\ndefinition\n  cap_counts :: \"cdl_cap \\<Rightarrow> bool\" where\n \"cap_counts cap \\<equiv> (case cap of\n    cdl_cap.NullCap \\<Rightarrow> False\n  | UntypedCap _ _ _ \\<Rightarrow> False\n  | ReplyCap _ _ \\<Rightarrow> False\n  | MasterReplyCap _ \\<Rightarrow> False\n  | RestartCap \\<Rightarrow> False\n  | RunningCap \\<Rightarrow> False\n  | PendingSyncSendCap _ _ _ _ _ _ \\<Rightarrow> False\n  | PendingSyncRecvCap _ _ _ \\<Rightarrow> False\n  | PendingNtfnRecvCap _ \\<Rightarrow> False\n  | DomainCap \\<Rightarrow> False\n  | BoundNotificationCap _ \\<Rightarrow> False\n  | IrqControlCap  \\<Rightarrow> False\n  | AsidControlCap \\<Rightarrow> False\n  | IOSpaceMasterCap \\<Rightarrow> False\n  | FrameCap _ _ _ _ c _ \\<Rightarrow> c = Real\n  | PageTableCap _ c _ \\<Rightarrow> c = Real\n  | PageDirectoryCap _ c _ \\<Rightarrow> c = Real\n  | _ \\<Rightarrow> True)\"\n\ndefinition\n  cdl_cap_irq :: \"cdl_cap \\<Rightarrow> cdl_irq option\" where\n \"cdl_cap_irq cap \\<equiv> (case cap of IrqHandlerCap irq \\<Rightarrow> Some irq | _ \\<Rightarrow> None)\"\n\n\\<comment> \\<open>Some caps don't count when determining if an entity should be deleted or not\\<close>\ndefinition\n  is_final_cap' :: \"cdl_cap \\<Rightarrow> cdl_state \\<Rightarrow> bool\" where\n \"is_final_cap' cap s \\<equiv> ((cap_counts cap) \\<and>\n  (\\<exists>cref. {cref. \\<exists>cap'. opt_cap cref s = Some cap'\n                       \\<and> (cap_object cap = cap_object cap'\n                             \\<and> cdl_cap_irq cap = cdl_cap_irq cap')\n                       \\<and> cap_counts cap'}\n         = {cref}))\"\n\n\ndefinition\n  is_final_cap :: \"cdl_cap \\<Rightarrow> bool k_monad\" where\n  \"is_final_cap cap \\<equiv> gets (is_final_cap' cap)\"\n\n\ndefinition\n  always_empty_slot :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n \"always_empty_slot slot = do\n    remove_parent slot;\n    set_cap slot NullCap\n  od\"\n\ndefinition\n  empty_slot :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n \"empty_slot slot = do\n  cap \\<leftarrow> get_cap slot;\n  if cap = NullCap then\n    return ()\n  else do\n    remove_parent slot;\n    set_cap slot NullCap\n    od\n  od\"", "property": "Page Table Unmapping: Ensure that page tables and pages are correctly unmapped, including shortcut deletion, revocation, and finalization of capabilities, as well as cancellation of IPC operations.\n\nSubproperties:\n- Capability Management: Remove pending operations, cancel IPCs, and unbind notifications to ensure correct capability handling.\n- Page Table and Page Finalization: Finalize page directories, page tables, and frames, considering whether they are real or not.\n- Entity Deletion: Determine whether an entity should be deleted based on capability counts and finalization status.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  delete_cap_simple :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"delete_cap_simple cap_ref \\<equiv> do\n    cap \\<leftarrow> get_cap cap_ref;\n    unless (cap = NullCap) $ do\n      final \\<leftarrow> is_final_cap cap;\n      fast_finalise cap final;\n      always_empty_slot cap_ref\n    od\n  od\"", "property": "Non-Preemptable Capability Deletion: Delete a capability without preemption, assuming the deletion is guaranteed not to preempt and the capability exists only at the CapDL level. \n\n Simple Capability Deletion: The capability is retrieved, checked for finality, and then finalised before its slot is emptied.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": "\n Non-premptable delete.\n\n Should only be used on deletes guaranteed not to preempt\n (and you are happy to prove this). In particular, it is\n useful for deleting caps that exist at the CapDL level\n but not at lower levels.\n"}
{"spec": "function\n  revoke_cap_simple :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"revoke_cap_simple victim s = (do\n    descendants \\<leftarrow> gets $ KHeap_D.descendants_of victim;\n    assert (finite descendants);\n    non_null \\<leftarrow> gets (\\<lambda>s. {slot. opt_cap slot s \\<noteq> Some NullCap \\<and> opt_cap slot s \\<noteq> None});\n    non_null_descendants \\<leftarrow> return (descendants \\<inter> non_null);\n    if (non_null_descendants \\<noteq> {}) then do\n      a \\<leftarrow> select non_null_descendants;\n      delete_cap_simple a;\n      revoke_cap_simple victim\n    od else return ()\n  od) s\"\n  by auto\n\n\ndefinition cdl_get_pde :: \"(word32 \\<times> nat)\\<Rightarrow> cdl_cap k_monad\"\nwhere \"cdl_get_pde ptr \\<equiv>\n  KHeap_D.get_cap ptr\"\n\ndefinition cdl_lookup_pd_slot :: \"word32 \\<Rightarrow> word32 \\<Rightarrow> word32 \\<times> nat \"\n  where \"cdl_lookup_pd_slot pd vptr \\<equiv> (pd, unat (vptr >> 20))\"\n\ndefinition cdl_lookup_pt_slot :: \"word32 \\<Rightarrow> word32 \\<Rightarrow> (word32 \\<times> nat) except_monad\"\n  where \"cdl_lookup_pt_slot pd vptr \\<equiv>\n    doE pd_slot \\<leftarrow> returnOk (cdl_lookup_pd_slot pd vptr);\n        pdcap \\<leftarrow> liftE $ cdl_get_pde pd_slot;\n        (case pdcap of cdl_cap.PageTableCap ref Fake None\n         \\<Rightarrow> ( doE pt \\<leftarrow> returnOk ref;\n              pt_index \\<leftarrow> returnOk ((vptr >> 12) && 0xFF);\n              returnOk (pt,unat pt_index)\n         odE)\n        | _ \\<Rightarrow> Monads_D.throw)\n    odE\"\n\ndefinition\n  cdl_find_pd_for_asid :: \"cdl_mapped_addr \\<Rightarrow> cdl_object_id except_monad\"\nwhere\n  \"cdl_find_pd_for_asid maddr \\<equiv> doE\n     asid_table \\<leftarrow> liftE $ gets cdl_asid_table;\n     asid_pool \\<leftarrow> returnOk $ asid_table (fst (fst maddr));\n     pd_cap_ref \\<leftarrow> (case asid_pool of Some (AsidPoolCap ptr _) \\<Rightarrow> returnOk (ptr, (snd \\<circ> fst) maddr)\n              | _ \\<Rightarrow> throw );\n     pd_cap \\<leftarrow> liftE $ get_cap pd_cap_ref;\n     case pd_cap of (PageDirectoryCap pd _ _) \\<Rightarrow> returnOk pd\n     | _ \\<Rightarrow> throw\n   odE \"\n\ndefinition cdl_page_mapping_entries :: \"32 word \\<Rightarrow> nat \\<Rightarrow> 32 word\n                                       \\<Rightarrow> ((32 word \\<times> nat) list) except_monad\"\n  where \"cdl_page_mapping_entries vptr pgsz pd \\<equiv>\n  if pgsz = 12 then doE\n    p \\<leftarrow> cdl_lookup_pt_slot pd vptr;\n         returnOk [p]\n    odE\n\n  else if pgsz = 16 then doE\n    p \\<leftarrow> cdl_lookup_pt_slot pd vptr;\n         returnOk [p]\n    odE\n  else if pgsz = 20 then doE\n    p \\<leftarrow> returnOk $ (cdl_lookup_pd_slot pd vptr);\n         returnOk [p]\n    odE\n  else if pgsz = 24 then doE\n    p \\<leftarrow> returnOk $ (cdl_lookup_pd_slot pd vptr);\n         returnOk [p]\n    odE\n  else throw\"\n\ndefinition\n  cdl_page_table_mapped :: \"cdl_mapped_addr \\<Rightarrow> cdl_object_id \\<Rightarrow> (cdl_cap_ref option) k_monad\"\nwhere\n  \"cdl_page_table_mapped maddr pt_id \\<equiv> doE\n     pd \\<leftarrow> cdl_find_pd_for_asid maddr;\n     pd_slot \\<leftarrow> returnOk (cdl_lookup_pd_slot pd (snd maddr));\n     pdcap \\<leftarrow> liftE $ cdl_get_pde pd_slot;\n     (case pdcap of\n       cdl_cap.PageTableCap ref Fake None \\<Rightarrow>\n         (returnOk $ if ref = pt_id then Some pd_slot else None)\n     | _ \\<Rightarrow> returnOk None )\n   odE <catch> (K (return None))\"", "property": "Non-Preemptable Revoke: Ensures that a revoke operation is executed without preemption, allowing for the atomic removal of capabilities and their descendants, maintaining the integrity of the capability hierarchy.\n\nDescendant Revocation: Revokes all non-null descendants of a capability, ensuring that all dependent capabilities are removed.\n\nCapability Revocation: Revokes a capability, removing it and its non-null descendants from the system, maintaining the consistency of the capability hierarchy.\n\nPage Table Mapping: Finds the page table mapped to a specific address and page table ID, returning the capability reference of the page table if found.\n\nPage Mapping Entries: Retrieves the page mapping entries for a given virtual pointer, page size, and page directory, returning a list of page mapping entries.\n\nPage Directory Lookup: Finds the page directory for a given address space ID, returning the object ID of the page directory.\n\nPage Table Lookup: Finds the page table for a given page directory and virtual pointer, returning the page table reference and index.\n\nCapability Retrieval: Retrieves a capability from a given capability reference, returning the capability if found.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": "\n  Non-preemptable revoke.\n\n  Should only be used on bounded revokes.\n   * PageTableUnmap pt_cap_ref\n   * PageUnmap frame_cap_ref \\<Rightarrow>\n   * revoke_cap_simple (target_tcb, tcb_replycap_slot)\n"}
{"spec": "definition\n \"might_throw \\<equiv> (returnOk ()) \\<sqinter> throw\"\n\ndefinition\n  unmap_page :: \"cdl_mapped_addr  \\<Rightarrow> cdl_object_id \\<Rightarrow> nat \\<Rightarrow> unit k_monad\"\nwhere\n  \"unmap_page maddr frame_id pgsz \\<equiv>\n    doE\n      pd \\<leftarrow> cdl_find_pd_for_asid maddr;\n      pslots \\<leftarrow> cdl_page_mapping_entries (snd maddr) pgsz pd;\n      might_throw;\n      liftE $ mapM_x delete_cap_simple pslots;\n      returnOk ()\n    odE <catch> (K $ return ())\"", "property": "Unmap Page: Unmap a frame from the page table, removing its mappings and deleting associated capabilities. \n\nSubproperties:\n- Find the page directory for the given address space identifier.\n- Get the page mapping entries for the specified page size.\n- Remove the page mappings and delete associated capabilities.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": "\n  Unmap a frame.\n"}
{"spec": "definition\n  unmap_page_table  :: \"cdl_mapped_addr \\<Rightarrow> cdl_object_id  \\<Rightarrow> unit k_monad\"\nwhere\n  \"unmap_page_table maddr pt_id\\<equiv>\n    do\n      pt_slot \\<leftarrow> cdl_page_table_mapped maddr pt_id;\n      case pt_slot of (Some slot) \\<Rightarrow> delete_cap_simple slot\n      | None \\<Rightarrow> return ()\n    od\"\n\n\nend", "property": "Unmap Page Table: Unmaps a page table from a given mapped address, deleting the corresponding capability if it exists.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": "\n  Unmap a page table.\n\n  This hits the same problems as 'unmap_page', so we also\n  non-deterministically choose a bunch of page-tables to unmap.\n"}
{"spec": "(*\n * CapDL Types\n *\n * This file introduces many of the high-level types used in this\n * specification.\n *)\n\ntheory Types_D\nimports\n  \"ASpec.VMRights_A\"\n  Intents_D\n  \"Lib.Lib\"\n  \"Lib.SplitRule\"\n  \"HOL-Combinatorics.Transposition\" (* for Fun.swap *)\nbegin", "property": "High-Level Type Definitions: Introduces various high-level types used throughout the specification, providing foundational elements for the CapDL design.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym cdl_irq = irq", "property": "IRQ Representation: A hardware IRQ number is represented as a distinct type, ensuring clarity and type safety in IRQ-related operations.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A hardware IRQ number. "}
{"spec": "type_synonym cdl_object_id = word32\n\ntype_synonym cdl_object_set = \"(cdl_object_id set)\"", "property": "Object Naming: Objects within the kernel are uniquely identified by 32-bit words, which may correspond to their memory addresses.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * How objects are named within the kernel.\n *\n * Objects are named by 32 bit words.\n * This name may correspond to the memory address of the object.\n "}
{"spec": "type_synonym cdl_badge = word32", "property": "Endpoint Badge: A 32-bit word representing the badge of an endpoint.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The badge of an endpoint "}
{"spec": "type_synonym cdl_cap_guard = word32\ntype_synonym cdl_cap_guard_size = nat", "property": "CNode Cap Guard Property: The guard of a CNode capability is represented by a 32-bit word, and the size of the guard is specified by a natural number.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The guard of a CNode cap, and the number of bits the guard uses. "}
{"spec": "type_synonym cdl_size_bits = nat", "property": "Object Size Representation: Represent object sizes using a natural number type, denoted as cdl_size_bits.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The type we use to represent object sizes. "}
{"spec": "type_synonym cdl_io_port = nat", "property": "IO Port Representation: Represents a single IA32 IO port using a natural number.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A single IA32 IO port. "}
{"spec": "type_synonym cdl_io_pagetable_level = nat", "property": "Pagetable Depth: The depth of an IA32 pagetable is a natural number.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The depth of a particular IA32 pagetable. "}
{"spec": "type_synonym cdl_cnode_index = nat", "property": "CDL CNode Index: Represents an index into a kernel object (such as a CNode or TCB) that contains capabilities.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " An index into a CNode, TCB, or other kernel object that contains caps. "}
{"spec": "type_synonym cdl_cap_ref = \"cdl_object_id \\<times> cdl_cnode_index\"", "property": "Capability Reference: A unique identifier for a capability slot, consisting of an object ID and a cnode index, allowing for precise referencing and management of capabilities within the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A reference to a capability slot. "}
{"spec": "type_synonym cdl_asid = \"cdl_cnode_index \\<times> cdl_cnode_index\"", "property": "Virtual ASID Structure: A virtual ASID is represented as a pair of CNode indices.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A virtual ASID. "}
{"spec": "type_synonym cdl_mapped_addr = \"(cdl_asid \\<times> word32)\"", "property": "Mapped Address Representation: A mapped address is represented as a pair of an ASID (Address Space Identifier) and a 32-bit word.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " mapped address  "}
{"spec": "definition\n  badge_bits :: nat\nwhere\n  \"badge_bits \\<equiv> 28\"", "property": "Badge Bits Limitation: The number of bits available for a badge is limited to 28.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Number of bits of a badge we can use. "}
{"spec": "datatype cdl_frame_cap_type = Real | Fake", "property": "Frame Capability Types: Distinguish between \"real\" and \"fake\" capabilities for frames, page tables, and page directories, where real capabilities are installed in CNodes and fake capabilities represent page table mappings.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " FrameCaps, PageTableCaps and PageDirectoryCaps can either be\n * \"real\" cap or \"fake\" cap. Real caps are installed in CNodes,\n * and fake caps represent a page table mapping.\n "}
{"spec": "datatype cdl_cap =\n    NullCap", "property": "Kernel Capability Structure: Defines the structure and attributes of kernel capabilities, including the object they point to, the rights they grant to the holder, and the allowed interactions with the target object.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * Kernel capabilities.\n *\n * Such capabilities (or \"caps\") give the holder particular rights to\n * a kernel object or system hardware.\n *\n * Caps have attributes such as the object they point to, the rights\n * they give the holder, or how the holder is allowed to interact with\n * the target object.\n "}
{"spec": "| UntypedCap bool cdl_object_set cdl_object_set\n  | EndpointCap cdl_object_id cdl_badge \"cdl_right set\"\n  | NotificationCap cdl_object_id cdl_badge \"cdl_right set\"\n  | ReplyCap cdl_object_id \"cdl_right set\" (* The id of the tcb of the target thread *)\n  | MasterReplyCap cdl_object_id\n  | CNodeCap cdl_object_id cdl_cap_guard cdl_cap_guard_size cdl_size_bits\n  | TcbCap cdl_object_id\n  | DomainCap", "property": "Kernel Object Capabilities: Define the capabilities for kernel objects, including untyped, endpoint, notification, reply, master reply, CNode, TCB, and domain capabilities, each with specific attributes and properties. \n\n Untyped Capability: Represents an untyped capability with a boolean flag and two sets of object references.\n Endpoint Capability: Represents an endpoint capability with an object ID, badge, and a set of rights.\n Notification Capability: Represents a notification capability with an object ID, badge, and a set of rights.\n Reply Capability: Represents a reply capability with an object ID and a set of rights.\n Master Reply Capability: Represents a master reply capability with an object ID.\n CNode Capability: Represents a CNode capability with an object ID, guard, guard size, and size bits.\n TCB Capability: Represents a TCB capability with an object ID.\n Domain Capability: Represents a domain capability.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Kernel object capabilities "}
{"spec": "| PendingSyncSendCap cdl_object_id cdl_badge bool bool bool bool", "property": "Pending Sync Send Capability: Tracks the state of a pending synchronous send capability, including the target object ID, badge, and flags indicating whether it's a call, can grant capabilities, can grant reply capabilities, and whether it's a fault IPC.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " thread, badge, is call, can grant, can grant reply, is fault ipc "}
{"spec": "| PendingSyncRecvCap cdl_object_id bool bool\n  | PendingNtfnRecvCap cdl_object_id", "property": "Thread State: A thread can be in a pending state, waiting for a reply, and has the ability to grant capabilities. Specifically, it can be in a pending synchronous receive capability state or a pending notification receive capability state.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " thread, is waiting for reply, can grant "}
{"spec": "| RestartCap\n  | RunningCap", "property": "Thread State Indication: Indicate that the thread is ready for rescheduling, specifically through restart or running capabilities.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Indicate that the thread is ready for Reschedule "}
{"spec": "| IrqControlCap\n  | IrqHandlerCap cdl_irq", "property": "Interrupt Capability Management: Provides capabilities for controlling and handling interrupts, ensuring that the system can manage and respond to interrupts effectively. \n\nSubproperties:\n- Interrupt Control Capability: Allows for control over interrupt settings and configurations.\n- Interrupt Handler Capability: Enables the handling and processing of interrupts by specifying the interrupt handler.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Interrupt capabilities "}
{"spec": "| FrameCap bool cdl_object_id \"cdl_right set\" nat cdl_frame_cap_type \"cdl_mapped_addr option\"\n  | PageTableCap cdl_object_id cdl_frame_cap_type \"cdl_mapped_addr option\"\n  | PageDirectoryCap cdl_object_id cdl_frame_cap_type \"cdl_asid option\"\n  | AsidControlCap\n  | AsidPoolCap cdl_object_id \"cdl_cnode_index\"", "property": "Virtual Memory Capabilities: Define the capabilities for managing virtual memory, including frame, page table, page directory, ASID control, and ASID pool capabilities, each with specific attributes and options for memory mapping and access control. \n\nSubproperties:\n- Frame Capability: Represents a frame of memory with specific rights, size, and mapping attributes.\n- Page Table Capability: Manages page tables with specific mapping attributes.\n- Page Directory Capability: Controls page directories with specific mapping attributes and optional ASID.\n- ASID Control Capability: Regulates the allocation and management of ASIDs.\n- ASID Pool Capability: Manages pools of ASIDs with specific indexing.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Virtual memory capabilties "}
{"spec": "| IOPortsCap cdl_object_id \"cdl_io_port set\"\n  | IOSpaceMasterCap\n  | IOSpaceCap cdl_object_id\n  | IOPageTableCap cdl_object_id", "property": "X86-Specific Capabilities: Provide capabilities for managing x86-specific resources, including I/O ports, I/O spaces, and I/O page tables. \n\nSubproperties:\n- I/O Port Management: Manage access to specific I/O ports.\n- I/O Space Management: Control I/O spaces, including master and specific I/O space capabilities.\n- I/O Page Table Management: Manage I/O page tables for efficient memory management.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " x86-specific capabilities "}
{"spec": "| ZombieCap cdl_object_id", "property": "Zombie Capability: Represents an object that is in the process of being deleted, ensuring that the object is not accessed or used while it is being removed from the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Zombie caps (representing objects mid-deletion) "}
{"spec": "| BoundNotificationCap cdl_object_id", "property": "Notification Binding: A TCB is bound to a notification, signified by a Bound NTFN capability.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Bound NTFN caps signifying when a tcb is bound to an NTFN "}
{"spec": "type_synonym cdl_cap_map = \"cdl_cnode_index \\<Rightarrow> cdl_cap option\"", "property": "Capability Mapping: Maps capability identifiers to their corresponding capabilities, allowing for efficient lookup and management of capabilities within the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A mapping from capability identifiers to capabilities. "}
{"spec": "type_synonym cdl_cdt = \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref option\"\n\ntranslations\n  (type) \"cdl_cap_map\" <=(type) \"nat \\<Rightarrow> cdl_cap option\"\n  (type) \"cdl_cap_ref\" <=(type) \"cdl_object_id \\<times> nat\"\n  (type) \"cdl_cap_ref\" <=(type) \"word32 \\<times> nat\"\n  (type) \"cdl_cdt\"     <=(type) \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref option\"", "property": "Cap Derivation Tree (CDT): Records the derivation relationships between capabilities, enabling the revocation of capabilities and their children.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * The cap derivation tree (CDT).\n *\n * This tree records how certain caps are derived from others. This\n * information is important because it affects how caps are revoked; if an\n * entity revokes a particular cap, all of the cap's children (as\n * recorded in the CDT) are also revoked.\n *\n * At this point in time, we leave the definition of the CDT quite\n * abstract. This may be made more concrete in the future allowing us to\n * reason about revocation.\n "}
{"spec": "record cdl_tcb =\n  cdl_tcb_caps           :: cdl_cap_map\n  cdl_tcb_fault_endpoint :: cdl_cptr\n  cdl_tcb_intent         :: cdl_full_intent\n  cdl_tcb_has_fault      :: bool\n  cdl_tcb_domain         :: word8\n\nrecord cdl_cnode =\n  cdl_cnode_caps :: cdl_cap_map\n  cdl_cnode_size_bits :: cdl_size_bits\n\nrecord cdl_asid_pool =\n  cdl_asid_pool_caps :: cdl_cap_map\n\nrecord cdl_page_table =\n  cdl_page_table_caps :: cdl_cap_map\n\nrecord cdl_page_directory =\n  cdl_page_directory_caps :: cdl_cap_map\n\nrecord cdl_frame =\n  cdl_frame_size_bits :: cdl_size_bits\n\nrecord cdl_irq_node =\n  cdl_irq_node_caps :: cdl_cap_map", "property": "Kernel Object Structures: Define the structures of various kernel objects, including TCBs (threads), CNodes (capability nodes), ASID pools, page tables, page directories, frames, and IRQ nodes, each containing specific fields that describe their properties and capabilities. \n\nSubproperties:\n- TCB Structure: A TCB object contains fields for capability mapping, fault endpoint, intent, fault status, and domain.\n- CNode Structure: A CNode object contains fields for capability mapping and size bits.\n- ASID Pool Structure: An ASID pool object contains a field for capability mapping.\n- Page Table Structure: A page table object contains a field for capability mapping.\n- Page Directory Structure: A page directory object contains a field for capability mapping.\n- Frame Structure: A frame object contains a field for size bits.\n- IRQ Node Structure: An IRQ node object contains a field for capability mapping.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Kernel objects "}
{"spec": "datatype cdl_object =\n    Endpoint\n  | Notification\n  | Tcb cdl_tcb\n  | CNode cdl_cnode\n  | AsidPool cdl_asid_pool\n  | PageTable cdl_page_table\n  | PageDirectory cdl_page_directory\n  | Frame cdl_frame\n  | Untyped\n  | IRQNode cdl_irq_node", "property": "Kernel Object Types: Defines the various types of kernel objects that can be created or deleted by users during system execution, including endpoints, notifications, threads, capability nodes, address space identifier pools, page tables, page directories, frames, untyped objects, and interrupt request nodes.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * Kernel objects.\n *\n * These are in-memory objects that may, over the course of the system\n * execution, be created or deleted by users.\n "}
{"spec": "datatype cdl_arch = IA32 | ARM11", "property": "System Architecture: The system supports two architectures, IA32 and ARM11, allowing for diverse hardware configurations and ensuring compatibility with different processor types.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The architecture that we are modelling. "}
{"spec": "type_synonym cdl_heap = \"cdl_object_id \\<Rightarrow> cdl_object option\"\n\ntranslations\n  (type) \"cdl_heap\" <=(type) \"32 word \\<Rightarrow> cdl_object option\"", "property": "System Object Map: A mapping of object identifiers to their corresponding objects in the system, representing the current state of the system's objects.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The map of objects that are in the system. "}
{"spec": "record cdl_state =\n  cdl_arch           :: cdl_arch\n  cdl_objects        :: cdl_heap\n  cdl_cdt            :: cdl_cdt\n  cdl_current_thread :: \"cdl_object_id option\"\n  cdl_irq_node       :: \"cdl_irq \\<Rightarrow> cdl_object_id\"\n  cdl_asid_table     :: cdl_cap_map\n  cdl_current_domain :: word8", "property": "System State: The system state record contains essential information about the system's architecture, existing objects, capability derivation tree, current thread, IRQ mappings, ASID table, and current domain. \n\nSubproperties:\n- System Architecture: The system's architecture is defined and remains constant at runtime.\n- Object Existence: The system maintains a record of currently existing objects.\n- Capability Derivation Tree: The system's capability derivation tree is tracked.\n- Current Thread: The system identifies the currently running thread, on whose behalf operations are performed.\n- IRQ Mappings: The system maps IRQs to notifications.\n- ASID Table: The system maintains the first level of the ASID table, containing capabilities to ASIDPools.\n- Current Domain: The system identifies the currently running domain.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * The current state of the system.\n *\n * The state record contains the following primary pieces of information:\n *\n * arch:\n *   The architecture of the system. This affects what capabilities and\n *   kernel objects could possibly be present. In the current kernel\n *   arch will not change at runtime.\n *\n * objects:\n *   The objects that currently exist in the system.\n *\n * cdt:\n *   The cap derivation tree of the system.\n *\n * current_thread:\n *   The currently running thread. Operations will always be performed\n *   on behalf of this thread.\n *\n * irq_node:\n *   Which IRQs are mapped to which notifications.\n *\n * asid_table:\n *   The first level of the asid table, containing capabilities to all\n *   of the ASIDPools.\n *\n * current_domain:\n *   The currently running domain.\n "}
{"spec": "definition\n  object_type :: \"cdl_object \\<Rightarrow> cdl_object_type\"\nwhere\n  \"object_type x \\<equiv>\n    case x of\n        Untyped \\<Rightarrow> UntypedType\n      | Endpoint \\<Rightarrow> EndpointType\n      | Notification \\<Rightarrow> NotificationType\n      | Tcb _ \\<Rightarrow> TcbType\n      | CNode _ \\<Rightarrow> CNodeType\n      | IRQNode _ \\<Rightarrow> IRQNodeType\n      | AsidPool _ \\<Rightarrow> AsidPoolType\n      | PageTable _ \\<Rightarrow> PageTableType\n      | PageDirectory _ \\<Rightarrow> PageDirectoryType\n      | Frame f \\<Rightarrow> FrameType (cdl_frame_size_bits f)\"\n\nlemmas object_type_simps = object_type_def[split_simps cdl_object.split]\n\ndefinition\n  asid_high_bits :: nat where\n  \"asid_high_bits \\<equiv> 7\"\ndefinition\n  asid_low_bits :: nat where\n  \"asid_low_bits \\<equiv> 10 :: nat\"\ndefinition\n  asid_bits :: nat where\n  \"asid_bits \\<equiv> 17 :: nat\"", "property": "Object Type Identification: Determine the type of a given object, categorizing it into one of the defined types (Untyped, Endpoint, Notification, TCB, CNode, IRQNode, AsidPool, PageTable, PageDirectory, or Frame).", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Return the type of an object. "}
{"spec": "definition \"tcb_cspace_slot     = (0 :: cdl_cnode_index)\"\ndefinition \"tcb_vspace_slot     = (1 :: cdl_cnode_index)\"\ndefinition \"tcb_replycap_slot   = (2 :: cdl_cnode_index)\"\ndefinition \"tcb_caller_slot     = (3 :: cdl_cnode_index)\"\ndefinition \"tcb_ipcbuffer_slot  = (4 :: cdl_cnode_index)\"\ndefinition \"tcb_pending_op_slot = (5 :: cdl_cnode_index)\"\ndefinition \"tcb_boundntfn_slot  = (8 :: cdl_cnode_index)\"\n\ndefinition \"tcb_slots_list \\<equiv> [0..<tcb_pending_op_slot + 1] @ [tcb_boundntfn_slot]\"\nabbreviation \"tcb_slots \\<equiv> set tcb_slots_list\"\nlemmas tcb_slots_def = tcb_slots_list_def\n\nlemmas tcb_slot_defs =\n  tcb_cspace_slot_def\n  tcb_vspace_slot_def\n  tcb_replycap_slot_def\n  tcb_caller_slot_def\n  tcb_ipcbuffer_slot_def\n  tcb_pending_op_slot_def\n  tcb_boundntfn_slot_def\n  tcb_slots_list_def", "property": "TCB Capability Slot Purposes: Define the purpose of each capability slot within a TCB, including cspace, vspace, reply capability, caller, IPC buffer, pending operation, and bound notification slots.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * Each TCB contains a number of cap slots, each with a specific\n * purpose. These constants define the purpose of each slot.\n *\n * The specific list of slots is chosen to be consistent with the output\n * of the CapDL-tool.\n "}
{"spec": "primrec (nonexhaustive)\n  cap_objects :: \"cdl_cap \\<Rightarrow> cdl_object_id set\"\nwhere\n    \"cap_objects (IOPageTableCap x) = {x}\"\n  | \"cap_objects (IOSpaceCap x) = {x}\"\n  | \"cap_objects (IOPortsCap x _) = {x}\"\n  | \"cap_objects (AsidPoolCap x _) = {x}\"\n  | \"cap_objects (PageDirectoryCap x _ _) = {x}\"\n  | \"cap_objects (PageTableCap x _ _) = {x}\"\n  | \"cap_objects (FrameCap _ x _ _ _ _) = {x}\"\n  | \"cap_objects (TcbCap x) = {x}\"\n  | \"cap_objects (CNodeCap x _ _ _) = {x}\"\n  | \"cap_objects (MasterReplyCap x) = {x}\"\n  | \"cap_objects (ReplyCap x _) = {x}\"\n  | \"cap_objects (NotificationCap x _ _) = {x}\"\n  | \"cap_objects (EndpointCap x _ _) = {x}\"\n  | \"cap_objects (UntypedCap _ x a) = x\"\n  | \"cap_objects (ZombieCap x) = {x}\"\n  | \"cap_objects (PendingSyncSendCap x _ _ _ _ _) = {x}\"\n  | \"cap_objects (PendingSyncRecvCap x _ _) = {x}\"\n  | \"cap_objects (PendingNtfnRecvCap x) = {x}\"\n  | \"cap_objects (BoundNotificationCap x) = {x}\"\n\ndefinition\n  cap_has_object :: \"cdl_cap \\<Rightarrow> bool\"\nwhere\n  \"cap_has_object cap \\<equiv> case cap of\n     NullCap          \\<Rightarrow> False\n  | IrqControlCap    \\<Rightarrow> False\n  | IrqHandlerCap _  \\<Rightarrow> False\n  | AsidControlCap   \\<Rightarrow> False\n  | IOSpaceMasterCap \\<Rightarrow> False\n  | RestartCap       \\<Rightarrow> False\n  | RunningCap       \\<Rightarrow> False\n  | DomainCap        \\<Rightarrow> False\n  | _                \\<Rightarrow> True\"\n\ndefinition\n  cap_object :: \"cdl_cap \\<Rightarrow> cdl_object_id\"\nwhere\n  \"cap_object cap \\<equiv>\n     if cap_has_object cap\n     then (THE c. c \\<in> cap_objects cap)\n     else undefined\"\n\nlemma cap_object_simps[simp]:\n  \"cap_object (IOPageTableCap x) = x\"\n  \"cap_object (IOSpaceCap x) = x\"\n  \"cap_object (IOPortsCap x a) = x\"\n  \"cap_object (AsidPoolCap x b) = x\"\n  \"cap_object (PageDirectoryCap x c d) = x\"\n  \"cap_object (PageTableCap x e f) = x\"\n  \"cap_object (FrameCap dev x g h i j) = x\"\n  \"cap_object (TcbCap x) = x\"\n  \"cap_object (CNodeCap x k l sz) = x\"\n  \"cap_object (MasterReplyCap x) = x\"\n  \"cap_object (ReplyCap x q) = x\"\n  \"cap_object (NotificationCap x m n) = x\"\n  \"cap_object (EndpointCap x p q) = x\"\n  \"cap_object (ZombieCap x) = x\"\n  \"cap_object (PendingSyncSendCap x s t u v w) = x\"\n  \"cap_object (PendingSyncRecvCap x t u) = x\"\n  \"cap_object (PendingNtfnRecvCap x) = x\"\n  \"cap_object (BoundNotificationCap x) = x\"\n  by (simp_all add:cap_object_def Nitpick.The_psimp cap_has_object_def)\n\nprimrec (nonexhaustive) cap_badge :: \"cdl_cap \\<Rightarrow> cdl_badge\"\nwhere\n    \"cap_badge (NotificationCap _ x _) = x\"\n  | \"cap_badge (EndpointCap _ x _) = x\"\n\ndefinition\n  update_cap_badge :: \"cdl_badge \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"update_cap_badge x c \\<equiv> case c of\n      NotificationCap f1 _ f3 \\<Rightarrow> NotificationCap f1 x f3\n    | EndpointCap f1 _ f3      \\<Rightarrow> EndpointCap f1 x f3\n    | _ \\<Rightarrow> c\"\n\ndefinition all_cdl_rights :: \"cdl_right set\" where\n  \"all_cdl_rights = {Read, Write, Grant, GrantReply}\"\n\ndefinition\n  cap_rights :: \"cdl_cap \\<Rightarrow> cdl_right set\"\nwhere\n  \"cap_rights c \\<equiv> case c of\n      FrameCap _ _ x _ _ _ \\<Rightarrow> x\n    | NotificationCap _ _ x \\<Rightarrow> x\n    | EndpointCap _ _ x \\<Rightarrow> x\n    | ReplyCap _ x \\<Rightarrow> x\n    | _ \\<Rightarrow> all_cdl_rights\"\n\ndefinition\n  update_cap_rights :: \"cdl_right set \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"update_cap_rights r c \\<equiv> case c of\n      FrameCap dev f1 _ f2 f3 f4 \\<Rightarrow> FrameCap dev f1 (validate_vm_rights r) f2 f3 f4\n    | NotificationCap f1 f2 _ \\<Rightarrow> NotificationCap f1 f2 (r - {Grant, GrantReply})\n    | EndpointCap f1 f2 _ \\<Rightarrow> EndpointCap f1 f2 r\n    | ReplyCap f1 _ \\<Rightarrow> ReplyCap f1 (r - {Read, GrantReply} \\<union> {Write})\n    | _ \\<Rightarrow> c\"\n\ndefinition\n  update_mapping_cap_status :: \"cdl_frame_cap_type \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n \"update_mapping_cap_status r c \\<equiv> case c of\n      FrameCap dev f1 f2 f3 _ f4 \\<Rightarrow> FrameCap dev f1 f2 f3 r f4\n    | PageTableCap pt1 _ pt2 \\<Rightarrow> PageTableCap pt1 r pt2\n    | _ \\<Rightarrow> c\"\n\nprimrec (nonexhaustive) cap_guard :: \"cdl_cap \\<Rightarrow> cdl_cap_guard\"\nwhere\n  \"cap_guard (CNodeCap _ x _ _) = x\"\n\ndefinition\n  update_cap_guard :: \"cdl_cap_guard \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"update_cap_guard x c \\<equiv> case c of\n      CNodeCap f1 _ f3 f4 \\<Rightarrow> CNodeCap f1 x f3 f4\n    | _ \\<Rightarrow> c\"\n\nprimrec (nonexhaustive) cap_guard_size :: \"cdl_cap \\<Rightarrow> cdl_cap_guard_size\"\nwhere\n  \"cap_guard_size (CNodeCap _ _ x _ ) = x\"\n\ndefinition\n  cnode_cap_size :: \"cdl_cap \\<Rightarrow> cdl_size_bits\"\nwhere\n  \"cnode_cap_size cap \\<equiv> case cap of\n      CNodeCap _ _ _ x \\<Rightarrow> x\n    | _ \\<Rightarrow> 0\"\n\ndefinition\n  update_cap_guard_size :: \"cdl_cap_guard_size \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"update_cap_guard_size x c \\<equiv> case c of\n      CNodeCap f1 f2 _ f3 \\<Rightarrow> CNodeCap f1 f2 x f3\n    | _ \\<Rightarrow> c\"", "property": "Capability Getters and Setters: Provide functions to extract and modify various properties of capabilities, including the object ID, badge, rights, mapping status, guard, and guard size. These functions enable the management of capabilities and their associated attributes, ensuring that capabilities are correctly configured and updated.\n\nSubproperties:\n- Capability Object ID: Extract the object ID associated with a capability.\n- Capability Badge: Get or update the badge of a capability, specifically for NotificationCap and EndpointCap.\n- Capability Rights: Extract or update the rights associated with a capability, including Read, Write, Grant, and GrantReply.\n- Mapping Status: Update the mapping status of a frame capability or a page table capability.\n- Capability Guard: Get or update the guard of a CNode capability.\n- Capability Guard Size: Get or update the guard size of a CNode capability.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Capability getters / setters "}
{"spec": "definition\n  object_slots :: \"cdl_object \\<Rightarrow> cdl_cap_map\"\nwhere\n  \"object_slots obj \\<equiv> case obj of\n    PageDirectory x \\<Rightarrow> cdl_page_directory_caps x\n  | PageTable x \\<Rightarrow> cdl_page_table_caps x\n  | AsidPool x \\<Rightarrow> cdl_asid_pool_caps x\n  | CNode x \\<Rightarrow> cdl_cnode_caps x\n  | Tcb x \\<Rightarrow> cdl_tcb_caps x\n  | IRQNode x \\<Rightarrow> cdl_irq_node_caps x\n  | _ \\<Rightarrow> Map.empty\"\n\ndefinition\n  update_slots :: \"cdl_cap_map \\<Rightarrow> cdl_object \\<Rightarrow> cdl_object\"\nwhere\n  \"update_slots new_val obj \\<equiv> case obj of\n    PageDirectory x \\<Rightarrow> PageDirectory (x\\<lparr>cdl_page_directory_caps := new_val\\<rparr>)\n  | PageTable x \\<Rightarrow> PageTable (x\\<lparr>cdl_page_table_caps := new_val\\<rparr>)\n  | AsidPool x \\<Rightarrow> AsidPool (x\\<lparr>cdl_asid_pool_caps := new_val\\<rparr>)\n  | CNode x \\<Rightarrow> CNode (x\\<lparr>cdl_cnode_caps := new_val\\<rparr>)\n  | Tcb x \\<Rightarrow> Tcb (x\\<lparr>cdl_tcb_caps := new_val\\<rparr>)\n  | IRQNode x \\<Rightarrow> IRQNode (x\\<lparr>cdl_irq_node_caps := new_val\\<rparr>)\n  | _ \\<Rightarrow> obj\"\n\ndefinition\n  has_slots :: \"cdl_object \\<Rightarrow> bool\"\nwhere\n  \"has_slots obj \\<equiv> case obj of\n    PageDirectory _ \\<Rightarrow> True\n  | PageTable _ \\<Rightarrow> True\n  | AsidPool _ \\<Rightarrow> True\n  | CNode _ \\<Rightarrow> True\n  | Tcb _ \\<Rightarrow> True\n  | IRQNode _ \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"\n\n\ndefinition\n  cap_free_ids :: \"cdl_cap \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"cap_free_ids cap \\<equiv> (case cap of\n     UntypedCap _ _ free_ids \\<Rightarrow> free_ids\n   | _ \\<Rightarrow> {})\"\n\ndefinition\n  remove_free_ids :: \"cdl_cap \\<Rightarrow> cdl_object_id set \\<Rightarrow> cdl_cap\"\nwhere\n  \"remove_free_ids cap obj_ids \\<equiv> case cap of\n     UntypedCap dev c a \\<Rightarrow> UntypedCap dev c (a - obj_ids)\n   | _ \\<Rightarrow> cap\"\n\ndefinition cap_irq :: \"cdl_cap \\<Rightarrow> cdl_irq\"\nwhere\n  \"cap_irq cap \\<equiv> case cap of\n      IrqHandlerCap x \\<Rightarrow> x\n    | _ \\<Rightarrow> undefined\"", "property": "Kernel Object Getters and Setters: Provide functions to access and modify the slots of various kernel objects, including page directories, page tables, ASID pools, CNodes, TCBs, and IRQ nodes. Additionally, functions are provided to check if an object has slots, retrieve the free IDs of an untyped capability, remove free IDs from an untyped capability, and get the IRQ of an IRQ handler capability. \n\nSubproperties:\n- Object Slots: Retrieve the capability map of an object based on its type.\n- Update Slots: Update the capability map of an object.\n- Has Slots: Check if an object has slots.\n- Capability Free IDs: Get the free IDs of an untyped capability.\n- Remove Free IDs: Remove free IDs from an untyped capability.\n- Capability IRQ: Get the IRQ of an IRQ handler capability.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Kernel object getters / setters "}
{"spec": "definition cap_type :: \"cdl_cap \\<Rightarrow> cdl_object_type option\"\nwhere\n  \"cap_type x \\<equiv> case x of\n    UntypedCap _ _ _         \\<Rightarrow> Some UntypedType\n  | EndpointCap _ _ _      \\<Rightarrow> Some EndpointType\n  | NotificationCap _ _ _ \\<Rightarrow> Some NotificationType\n  | TcbCap _               \\<Rightarrow> Some TcbType\n  | CNodeCap _ _ _ _       \\<Rightarrow> Some CNodeType\n  | AsidPoolCap _ _        \\<Rightarrow> Some AsidPoolType\n  | PageTableCap _ _ _     \\<Rightarrow> Some PageTableType\n  | PageDirectoryCap _ _ _ \\<Rightarrow> Some PageDirectoryType\n  | FrameCap _ _ _ f _ _     \\<Rightarrow> Some (FrameType f)\n  | IrqHandlerCap _        \\<Rightarrow> Some IRQNodeType\n  | _                      \\<Rightarrow> None \"\n\nabbreviation \"is_untyped_cap cap    \\<equiv> (cap_type cap = Some UntypedType)\"\nabbreviation \"is_ep_cap cap         \\<equiv> (cap_type cap = Some EndpointType)\"\nabbreviation \"is_ntfn_cap cap        \\<equiv> (cap_type cap = Some NotificationType)\"\nabbreviation \"is_tcb_cap cap        \\<equiv> (cap_type cap = Some TcbType)\"\nabbreviation \"is_cnode_cap cap      \\<equiv> (cap_type cap = Some CNodeType)\"\nabbreviation \"is_asidpool_cap cap   \\<equiv> (cap_type cap = Some AsidPoolType)\"\nabbreviation \"is_pt_cap cap         \\<equiv> (cap_type cap = Some PageTableType)\"\nabbreviation \"is_pd_cap cap         \\<equiv> (cap_type cap = Some PageDirectoryType)\"\nabbreviation \"is_frame_cap cap      \\<equiv> (\\<exists>sz. cap_type cap = Some (FrameType sz))\"\nabbreviation \"is_irqhandler_cap cap \\<equiv> (cap_type cap = Some IRQNodeType)\"\ndefinition   \"is_irqcontrol_cap cap \\<equiv> (cap = IrqControlCap)\"\n\nlemma cap_type_simps [simp]:\n  \"is_untyped_cap    (UntypedCap dev a a')\"\n  \"is_ep_cap         (EndpointCap b c d)\"\n  \"is_ntfn_cap        (NotificationCap e f g)\"\n  \"is_tcb_cap        (TcbCap h)\"\n  \"is_cnode_cap      (CNodeCap j k l m)\"\n  \"is_asidpool_cap   (AsidPoolCap n p)\"\n  \"is_pd_cap         (PageDirectoryCap r s t)\"\n  \"is_pt_cap         (PageTableCap u v w)\"\n  \"is_frame_cap      (FrameCap dev a1 a2 a3 a4 a5)\"\n  \"is_irqhandler_cap (IrqHandlerCap a6)\"\n  \"cap_type (FrameCap dev obj_id rights sz rs asid) = Some (FrameType sz)\"\n  by (clarsimp simp: cap_type_def)+\n\nabbreviation \"cap_has_type cap \\<equiv> (\\<exists>type. cap_type cap = Some type)\"\n\nlemma cap_type_update_cap_badge [simp]:\n  \"cap_type (update_cap_badge x cap) = cap_type cap\"\n  by (clarsimp simp: update_cap_badge_def cap_type_def split: cdl_cap.splits)\n\nlemma cap_type_update_cap_rights [simp]:\n  \"cap_type (update_cap_rights x cap) = cap_type cap\"\n  by (clarsimp simp: update_cap_rights_def cap_type_def split: cdl_cap.splits)\n\nlemma cap_type_update_mapping_cap_status [simp]:\n  \"cap_type (update_mapping_cap_status x cap) = cap_type cap\"\n  by (clarsimp simp: update_mapping_cap_status_def cap_type_def split: cdl_cap.splits)\n\nlemma cap_type_update_cap_guard [simp]:\n  \"cap_type (update_cap_guard x cap) = cap_type cap\"\n  by (clarsimp simp: update_cap_guard_def cap_type_def split: cdl_cap.splits)\n\nlemma update_cap_guard_size [simp]:\n  \"cap_type (update_cap_guard_size x cap) = cap_type cap\"\n  by (clarsimp simp: update_cap_guard_size_def cap_type_def split: cdl_cap.splits)\n\n\n\ndefinition is_pending_cap :: \"cdl_cap \\<Rightarrow> bool\"\nwhere \"is_pending_cap c \\<equiv> case c of\n  PendingSyncRecvCap _ _ _ \\<Rightarrow> True\n  | PendingNtfnRecvCap _ \\<Rightarrow> True\n  | PendingSyncSendCap _ _ _ _ _ _ \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"", "property": "Cap Type Identification: Determine the type of a capability, such as untyped, endpoint, notification, TCB, CNode, ASID pool, page table, page directory, frame, IRQ handler, or IRQ control, based on its structure.\n\nSubproperties:\n- Untyped Capabilities: Identify untyped capabilities.\n- Endpoint Capabilities: Identify endpoint capabilities.\n- Notification Capabilities: Identify notification capabilities.\n- TCB Capabilities: Identify TCB capabilities.\n- CNode Capabilities: Identify CNode capabilities.\n- ASID Pool Capabilities: Identify ASID pool capabilities.\n- Page Table Capabilities: Identify page table capabilities.\n- Page Directory Capabilities: Identify page directory capabilities.\n- Frame Capabilities: Identify frame capabilities with specific sizes.\n- IRQ Handler Capabilities: Identify IRQ handler capabilities.\n- IRQ Control Capabilities: Identify IRQ control capabilities.\n- Pending Capabilities: Identify pending capabilities for synchronous receive, notification receive, and synchronous send.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "************\n * Cap types *\n ************"}
{"spec": "definition\n  empty_cap_map :: \"nat \\<Rightarrow> cdl_cap_map\"\nwhere\n  \"empty_cap_map sz \\<equiv> (\\<lambda>a. if a < 2^sz then (Some NullCap) else None)\"", "property": "Empty Capability Map Creation: Creates a capability map of a specified size, initialized with no capabilities, where all slots within the map's bounds contain a NullCap and all slots outside the bounds are empty.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Create a capability map that contains no caps. "}
{"spec": "definition\n  empty_cnode :: \"nat \\<Rightarrow> cdl_cnode\"\nwhere\n  \"empty_cnode sz = \\<lparr> cdl_cnode_caps = empty_cap_map sz, cdl_cnode_size_bits = sz \\<rparr>\"\n\ndefinition\n  empty_irq_node :: cdl_irq_node\nwhere\n  \"empty_irq_node \\<equiv> \\<lparr> cdl_irq_node_caps = empty_cap_map 0 \\<rparr>\"", "property": "Create Empty CNode and IRQ Node: Create an empty CNode with a specified size and an empty IRQ node, initializing their capability maps and size bits accordingly. \n\nSubproperties:\n- Empty CNode Creation: Create a new CNode with an empty capability map and specified size bits.\n- Empty IRQ Node Creation: Create a new IRQ node with an empty capability map and size bits set to 0.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Create an empty CNode. "}
{"spec": "definition\n  default_tcb :: \"word8 \\<Rightarrow> cdl_tcb\"\nwhere\n  \"default_tcb current_domain = \\<lparr>\n    cdl_tcb_caps = \\<lambda>n. if n \\<in> tcb_slots then Some NullCap else None,\n    cdl_tcb_fault_endpoint = 0,\n    cdl_tcb_intent = \\<lparr>\n      cdl_intent_op = None,\n      cdl_intent_error = False,\n      cdl_intent_cap = 0,\n      cdl_intent_extras = [],\n      cdl_intent_recv_slot = None\n      \\<rparr>,\n    cdl_tcb_has_fault = False,\n    cdl_tcb_domain = current_domain\n    \\<rparr>\"", "property": "Default TCB Object: A standard empty TCB object is defined with default attributes, including empty capability slots, a null fault endpoint, an empty intent, no fault, and a specified domain.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Standard empty TCB object. "}
{"spec": "definition\n  default_object :: \"cdl_object_type \\<Rightarrow> nat \\<Rightarrow> word8 \\<Rightarrow> cdl_object option\"\nwhere\n  \"default_object x y current_domain \\<equiv>\n    case x of\n        UntypedType \\<Rightarrow> Some Untyped\n      | EndpointType \\<Rightarrow> Some Endpoint\n      | NotificationType \\<Rightarrow> Some Notification\n      | TcbType \\<Rightarrow> Some (Tcb (default_tcb current_domain))\n      | CNodeType \\<Rightarrow> Some (CNode (empty_cnode y))\n      | AsidPoolType \\<Rightarrow> Some (AsidPool \\<lparr> cdl_asid_pool_caps = empty_cap_map asid_low_bits \\<rparr>)\n      | PageTableType \\<Rightarrow> Some (PageTable \\<lparr> cdl_page_table_caps = empty_cap_map 8 \\<rparr>)\n      | PageDirectoryType \\<Rightarrow> Some (PageDirectory \\<lparr> cdl_page_directory_caps = empty_cap_map 12 \\<rparr>)\n      | FrameType sz \\<Rightarrow> Some (Frame \\<lparr> cdl_frame_size_bits = sz \\<rparr>)\n      | IRQNodeType \\<Rightarrow> Some (IRQNode empty_irq_node)\"\n\nabbreviation \"pick a \\<equiv> SOME x. x\\<in> a\"", "property": "Default Object Construction: Return a newly constructed object of the given type, with default attributes and settings, for various object types such as Untyped, Endpoint, Notification, TCB, CNode, AsidPool, PageTable, PageDirectory, Frame, and IRQNode. \n\nSubproperties:\n- Untyped objects are created with no specific attributes.\n- Endpoint and Notification objects are created with default settings.\n- TCB objects are created with default tcb settings for the given current domain.\n- CNode objects are created with an empty cnode of a specified size.\n- AsidPool objects are created with an empty cap map of a specified size.\n- PageTable and PageDirectory objects are created with empty cap maps of specified sizes.\n- Frame objects are created with a specified size.\n- IRQNode objects are created with an empty irq node.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Return a newly constructed object of the given type. "}
{"spec": "definition\n  default_cap :: \"cdl_object_type \\<Rightarrow> cdl_object_id set \\<Rightarrow> cdl_size_bits \\<Rightarrow> bool \\<Rightarrow> cdl_cap\"\nwhere\n  \"default_cap t id_set sz dev \\<equiv>\n    case t of\n        EndpointType \\<Rightarrow> EndpointCap (pick id_set) 0 UNIV\n      | NotificationType \\<Rightarrow> NotificationCap (THE i. i \\<in> id_set) 0 {Read,Write}\n      | TcbType \\<Rightarrow> TcbCap (pick id_set)\n      | CNodeType \\<Rightarrow> CNodeCap (pick id_set) 0 0 sz\n      | IRQNodeType \\<Rightarrow> IrqHandlerCap undefined\n      | UntypedType \\<Rightarrow> UntypedCap dev id_set id_set\n      | AsidPoolType \\<Rightarrow> AsidPoolCap (pick id_set) 0\n      | PageTableType \\<Rightarrow> PageTableCap (pick id_set) Real None\n      | PageDirectoryType \\<Rightarrow> PageDirectoryCap (pick id_set) Real None\n      | FrameType frame_size \\<Rightarrow> FrameCap dev (pick id_set) {Read, Write} frame_size Real None\"\n\nend", "property": "Default Capability Construction: Construct a default capability for a new object based on its type, ID set, size, and device status, ensuring that the capability is correctly initialized with the required attributes and permissions.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Construct a cap for a new object. "}
{"spec": "definition\n  all_active_tcbs :: \"cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"all_active_tcbs state \\<equiv> {x \\<in> dom (cdl_objects state).\n      \\<exists> a. (cdl_objects state) x = Some (Tcb a)\n          \\<and> ( ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RunningCap) \\<or> ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RestartCap))}\"\n\ndefinition\n  active_tcbs_in_domain :: \"word8 \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"active_tcbs_in_domain domain state  = {x \\<in> dom (cdl_objects state).\n      \\<exists> a. (cdl_objects state) x = Some (Tcb a)\n          \\<and> ( ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RunningCap) \\<or> ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RestartCap))\n          \\<and> cdl_tcb_domain a = domain }\"", "property": "Runnable Threads Collection: Collect the set of runnable threads in the system, including threads with RunningCap or RestartCap in their pending operation slot. \nRunnable Threads in Domain: Collect the set of runnable threads within a specific domain, including threads with RunningCap or RestartCap in their pending operation slot and matching the specified domain.", "title": "./spec/capDL/Schedule_D.thy", "chapter": "", "section": "", "comment": "\n * Collect the set of runnable threads in the system.\n "}
{"spec": "definition\n  switch_to_thread :: \"cdl_object_id option \\<Rightarrow> unit k_monad\"\nwhere\n  \"switch_to_thread target \\<equiv>\n     modify (\\<lambda> t. t\\<lparr> cdl_current_thread := target \\<rparr>)\"\n\ndefinition\n  change_current_domain :: \"unit k_monad\"\nwhere\n  \"change_current_domain = do\n     next_domain \\<leftarrow> select UNIV;\n     modify      (\\<lambda>s. s\\<lparr> cdl_current_domain := next_domain \\<rparr>)\n   od\"", "property": "Thread Switching: Update the current thread to a new target thread by modifying the current thread state.\nDomain Switching: Change the current domain to a new domain, selecting from all possible domains and updating the current domain state.", "title": "./spec/capDL/Schedule_D.thy", "chapter": "", "section": "", "comment": "\n * Switch to a new thread.\n "}
{"spec": "definition\n  schedule :: \"unit k_monad\"\nwhere\n  \"schedule \\<equiv> do\n     change_current_domain;\n     next_domain \\<leftarrow> gets cdl_current_domain;\n     threads     \\<leftarrow> gets (active_tcbs_in_domain next_domain);\n     next_thread \\<leftarrow> select threads;\n     switch_to_thread (Some next_thread)\n   od \\<sqinter> do\n     change_current_domain;\n     switch_to_thread None\n   od\"\n\n\nend", "property": "Scheduling Nondeterminism: The scheduling process is fully nondeterministic, allowing for flexible and unpredictable selection of the next thread to execute within a domain.\n\nSubproperties:\n- Domain Selection: The current domain is updated before selecting the next thread.\n- Thread Selection: The next thread is chosen from the active threads within the selected domain.\n- Optional Idle Transition: The system can transition to an idle state instead of switching to a specific thread.", "title": "./spec/capDL/Schedule_D.thy", "chapter": "", "section": "", "comment": "\n * Scheduling is fully nondeterministic at this level.\n "}
{"spec": "(*\n * Operations on CSpace\n *)\n\ntheory CSpace_D\nimports\n  PageTableUnmap_D\nbegin", "property": "Operations on CSpace: Provide functionality for managing and manipulating the capability space, ensuring the integrity and security of capability-based memory management.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  has_children :: \"cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> bool\"\nwhere\n  \"has_children parent s = (\\<exists>child. is_cdt_parent s parent child)\"", "property": "Check Capability Children Existence: Determine if a given capability has any child capabilities in the current state.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Does the given cap have any children? "}
{"spec": "definition\n  ensure_no_children :: \"cdl_cap_ref \\<Rightarrow> unit except_monad\"\nwhere\n  \"ensure_no_children x \\<equiv> doE\n     c \\<leftarrow> liftE $ gets (has_children x);\n     whenE c $ throw\n   odE\"", "property": "Capability Validation: Ensure that a given capability does not have any child capabilities in the Capability Derivation Tree (CDT).", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Ensure that the given cap does not contain any children\n * in the CDT.\n "}
{"spec": "definition\n  ensure_empty :: \"cdl_cap_ref \\<Rightarrow> unit except_monad\"\nwhere\n  \"ensure_empty cap_ref \\<equiv> doE\n     cap \\<leftarrow> liftE $ get_cap cap_ref;\n     unlessE (cap = NullCap) $ throw\n  odE\"", "property": "Ensure Empty Capability Slot: Verify that a given capability slot is empty by checking if it contains a NullCap. If the slot is not empty, an exception is thrown.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Ensure that the given cap slot is empty. "}
{"spec": "definition\n  insert_cap_orphan :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"insert_cap_orphan new_cap dest_slot \\<equiv> do\n     old_cap \\<leftarrow> get_cap dest_slot;\n     assert (old_cap = NullCap);\n     set_cap dest_slot new_cap\n   od\"\n\n\n\nprimrec (nonexhaustive)\n  available_range :: \"cdl_cap \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"available_range (UntypedCap _ r available) = available\"\n\ndefinition\n  set_available_range :: \"cdl_cap \\<Rightarrow> cdl_object_id set \\<Rightarrow> cdl_cap\"\nwhere\n  \"set_available_range cap nrange \\<equiv>\n    case cap of UntypedCap d r available \\<Rightarrow> UntypedCap d r nrange | _ \\<Rightarrow> cap\"\n\nlemmas set_avaiable_range_simps[simp] = set_available_range_def[split_simps cdl_cap.split]\n\ndefinition\n  set_untyped_cap_as_full :: \"cdl_cap \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"set_untyped_cap_as_full src_cap new_cap src_slot \\<equiv>\n  if (is_untyped_cap src_cap \\<and> is_untyped_cap new_cap\n     \\<and> cap_objects src_cap = cap_objects new_cap) then\n     (set_cap src_slot (set_available_range src_cap {}))\n     else return ()\"", "property": "Insert Cap Orphan: Insert a new capability into an object without a parent, ensuring the destination slot is empty.\n\nSet Untyped Cap As Full: Update an untyped capability's available range to empty in its original slot, if the new capability has the same objects and is also untyped.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Insert a new cap into an object. The cap will have no parent. "}
{"spec": "definition\n  insert_cap_sibling :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"insert_cap_sibling new_cap src_slot dest_slot \\<equiv> do\n    src_cap \\<leftarrow> get_cap src_slot;\n    old_cap \\<leftarrow> get_cap dest_slot;\n    assert (old_cap = NullCap);\n    set_untyped_cap_as_full src_cap new_cap src_slot;\n    set_cap dest_slot new_cap;\n    p \\<leftarrow> gets $ opt_parent src_slot;\n    case p of\n      None \\<Rightarrow> return ()\n    | Some parent \\<Rightarrow> set_parent dest_slot parent\n  od\"", "property": "Insert Capability Sibling: Insert a new capability as a sibling into an object, ensuring the destination slot is empty and updating the parent-child relationships accordingly. \n\nSubproperties:\n- Destination Slot Validation: The destination slot must be empty (i.e., contain a NullCap).\n- Source Capability Update: The source capability is updated to reflect the new capability.\n- Parent-Child Relationship Update: The parent of the new capability is set to the parent of the source slot, if it exists.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Insert a new cap into an object. The cap will be a sibling. "}
{"spec": "definition\n  insert_cap_child :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"insert_cap_child new_cap src_slot dest_slot \\<equiv> do\n    src_cap \\<leftarrow> get_cap src_slot;\n    old_cap \\<leftarrow> get_cap dest_slot;\n    assert (old_cap = NullCap);\n    set_untyped_cap_as_full src_cap new_cap src_slot;\n    set_cap dest_slot new_cap;\n    set_parent dest_slot src_slot\n  od\"", "property": "Insert Capability as Child: Insert a new capability into an object, ensuring it is a child capability. The destination slot must be empty, and the new capability's parent is set to the source slot. \n\nSubproperties:\n- Destination Slot Empty: The destination slot must be empty (i.e., contain a NullCap) before inserting the new capability.\n- Set New Capability: The new capability is set in the destination slot.\n- Update Parent Relationship: The parent of the new capability is set to the source slot.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Insert a new cap into an object. The cap will be a child. "}
{"spec": "definition\n  delete_asid_pool :: \"cdl_cnode_index \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"delete_asid_pool base ptr \\<equiv> do\n    asid_table \\<leftarrow> gets cdl_asid_table;\n    asid_table' \\<leftarrow> return $ asid_table (base \\<mapsto> NullCap);\n    modify (\\<lambda>s. s \\<lparr>cdl_asid_table := asid_table'\\<rparr>)\n  od \\<sqinter> return ()\"", "property": "ASID Pool Deletion: Delete an ASID pool by updating the ASID table to map the specified base to a NullCap.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Delete an ASID pool.\n "}
{"spec": "definition\n  delete_asid :: \"cdl_asid \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"delete_asid asid pd \\<equiv> do\n    asid_table \\<leftarrow> gets cdl_asid_table;\n    case asid_table (fst asid) of\n       Some NullCap \\<Rightarrow> return ()\n     | Some (AsidPoolCap p _) \\<Rightarrow> set_cap (p, (snd asid)) NullCap\n     | _ \\<Rightarrow> fail\n  od \\<sqinter> return ()\"\n\ndefinition\n  get_irq_slot :: \"cdl_irq \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref\"\nwhere\n  \"get_irq_slot irq s \\<equiv> (cdl_irq_node s irq, 0)\"", "property": "ASID Deletion: Delete a specific ASID, deactivating the associated page directory in the process. \n\nIRQ Slot Retrieval: Get the slot corresponding to a specific IRQ in the IRQ node.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Delete a particular ASID, decactivating the PD using it\n * in the process.\n "}
{"spec": "definition\n  deleting_irq_handler :: \"cdl_irq \\<Rightarrow> unit k_monad\"\nwhere\n \"deleting_irq_handler irq \\<equiv>\n    gets (get_irq_slot irq) >>= delete_cap_simple\"\n\ndefinition\n  cancel_ipc ::\"cdl_object_id \\<Rightarrow> unit k_monad\"\n  where \"cancel_ipc ptr \\<equiv>\n  do cap \\<leftarrow> KHeap_D.get_cap (ptr,tcb_pending_op_slot);\n   (case cap of\n    PendingSyncRecvCap _ is_reply _ \\<Rightarrow> ( do\n     when is_reply $ update_thread_fault ptr (\\<lambda>x. False);\n     revoke_cap_simple (ptr,tcb_replycap_slot);\n     when (\\<not> is_reply) $ set_cap (ptr,tcb_pending_op_slot) NullCap\n     od )\n   | PendingSyncSendCap _ _ _ _ _ _ \\<Rightarrow> (do\n     revoke_cap_simple (ptr,tcb_replycap_slot);\n     set_cap (ptr,tcb_pending_op_slot) NullCap\n     od)\n   | PendingNtfnRecvCap _ \\<Rightarrow> (do\n     revoke_cap_simple (ptr,tcb_replycap_slot);\n     set_cap (ptr, tcb_pending_op_slot) NullCap\n     od)\n   | _ \\<Rightarrow> return ())\n  od\"\n\ndefinition\n  prepare_thread_delete ::\"cdl_object_id \\<Rightarrow> unit k_monad\"\n  where \"prepare_thread_delete ptr \\<equiv> return ()\" (* for ARM it does nothing *)", "property": "IRQ Handler Deletion: After deleting an IRQ Handler capability, the corresponding IRQ slot is deleted.\n\nSubproperties:\n- Cancel IPC: When canceling an IPC, the pending operation slot is updated based on the type of pending capability (sync recv, sync send, or notification recv), which may involve revoking the reply capability slot and setting the pending operation slot to null.\n- Prepare Thread Delete: Prepare a thread for deletion, which currently does nothing for ARM architecture.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "Actions to be taken after deleting an IRQ Handler capability."}
{"spec": "fun\n  finalise_cap :: \"cdl_cap \\<Rightarrow> bool \\<Rightarrow> (cdl_cap \\<times> cdl_cap) k_monad\"\nwhere\n  \"finalise_cap NullCap                  final = return (NullCap, NullCap)\"\n| \"finalise_cap RestartCap               final = return (NullCap, NullCap)\"\n| \"finalise_cap (UntypedCap dev r a)           final = return (NullCap, NullCap)\"\n| \"finalise_cap (EndpointCap r b R)      final =\n      (liftM (K (NullCap, NullCap)) $ when  final $ cancel_all_ipc r)\"\n| \"finalise_cap (NotificationCap r b R) final =\n      (liftM (K (NullCap, NullCap)) $ when  final $\n       do\n         unbind_maybe_notification r;\n         cancel_all_ipc r\n       od)\"\n| \"finalise_cap (ReplyCap r R)           final = return (NullCap, NullCap)\"\n| \"finalise_cap (MasterReplyCap r)       final = return (NullCap, NullCap)\"\n| \"finalise_cap (CNodeCap r bits g sz)   final =\n      (return (if final then ZombieCap r else NullCap, NullCap))\"\n| \"finalise_cap (TcbCap r)               final =\n      (do\n         when final $ (do unbind_notification r;\n         cancel_ipc r;\n         KHeap_D.set_cap (r, tcb_pending_op_slot) cdl_cap.NullCap;\n         prepare_thread_delete r od);\n         return (if final then (ZombieCap r) else NullCap, NullCap)\n       od)\"\n| \"finalise_cap (PendingSyncSendCap r _ _ _ _ _) final = return (NullCap, NullCap)\"\n| \"finalise_cap (PendingSyncRecvCap r _ _) final = return (NullCap, NullCap)\"\n| \"finalise_cap (PendingNtfnRecvCap r)  final = return (NullCap, NullCap)\"\n| \"finalise_cap IrqControlCap            final = return (NullCap, NullCap)\"\n| \"finalise_cap (IrqHandlerCap irq)      final = (\n       if final then do\n         deleting_irq_handler irq;\n         return (NullCap, (IrqHandlerCap irq))\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (ZombieCap r)            final =\n      (do assert final; return (ZombieCap r, NullCap) od)\"\n| \"finalise_cap (AsidPoolCap ptr asid)        final = (\n       if final then do\n         delete_asid_pool asid ptr;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap AsidControlCap           final = return (NullCap,NullCap)\"\n| \"finalise_cap (PageDirectoryCap ptr x (Some asid))   final = (\n       if final \\<and> x = Real then do\n         delete_asid asid ptr;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (PageTableCap ptr x (Some asid))     final = (\n       if (final \\<and> x = Real) then do\n         unmap_page_table asid ptr;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (FrameCap dev ptr _ s x (Some asid))       final = (\n       if x = Real then do\n         unmap_page asid ptr s;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap _ final = return (NullCap, NullCap)\"", "property": "Capability Deletion Actions: Ensure that when a capability is deleted, necessary actions are taken to maintain system integrity, such as canceling IPC, unbinding notifications, and updating kernel data structures. If deletion requires a long-running operation, a Zombie capability is returned, and a possible IRQ is cleared.\n\nSubproperties:\n- Cancel IPC and unbind notifications for Endpoint and Notification capabilities.\n- Update kernel data structures for CNode and Tcb capabilities.\n- Clear possible IRQ for IrqHandler capabilities.\n- Delete AsidPool, PageDirectory, PageTable, and Frame capabilities when finalising.\n- Return Zombie capability if deletion requires a long-running operation.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "Actions that must be taken when a capability is deleted. Returns a\nZombie capability if deletion requires a long-running operation and also a\npossible IRQ to be cleared."}
{"spec": "lemma fast_finalise_def2:\n  \"fast_finalise cap final = do\n     assert (can_fast_finalise cap);\n     result \\<leftarrow> finalise_cap cap final;\n     assert (result = (NullCap, NullCap))\n   od\"\n  unfolding can_fast_finalise_def\n  by (rule finalise_cap.cases[of \"(cap,final)\"]; simp add: assert_def liftM_def)", "property": "Fast Finalise Capability: Delete a capability quickly when a long-running operation is impossible, ensuring the capability is finalised and resulting in a null capability. \n\nSubproperties:\n- Can Fast Finalise: Check if a capability can be fast finalised.\n- Finalise Capability: Finalise the capability, ensuring it is deleted and resulting in a null capability.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "The fast_finalise operation is used to delete a capability when it is\nknown that a long-running operation is impossible. It is equivalent to calling\nthe regular finalise operation. It cannot be defined in that way as doing so\nwould create a circular definition."}
{"spec": "definition\n  swap_cap :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"swap_cap cap1 slot1 cap2 slot2 \\<equiv> do\n     set_cap slot1 cap2;\n     set_cap slot2 cap1;\n     swap_parents slot1 slot2\n  od\"", "property": "Atomic Capability Swap: Swap two capabilities atomically, ensuring that the swap is executed as a single, uninterruptible operation. \n\nSwap Operation: The swap operation involves setting the first capability to the second slot and the second capability to the first slot, and then updating the parent-child relationships between the slots.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Atomically swap the two given caps.\n "}
{"spec": "definition\n  move_cap :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"move_cap cap src_slot dest_slot \\<equiv> do\n     insert_cap_orphan cap dest_slot;\n     set_cap src_slot NullCap;\n     swap_parents src_slot dest_slot\n  od\"\n\ndefinition\n  monadic_rel_optionation_form :: \"('a \\<Rightarrow> ('s, 'b) nondet_monad)\n      \\<Rightarrow> (('a \\<times> 's) option \\<times> ('b \\<times> 's) option) set\"\nwhere\n \"monadic_rel_optionation_form f =\n    {(x, y). (x \\<noteq> None \\<and> y \\<noteq> None \\<and> the y \\<in> fst (case_prod f (the x)))\n           \\<or> (x \\<noteq> None \\<and> y = None \\<and> snd (case_prod f (the x)))\n           \\<or> (x = None \\<and> y = None)}\"\n\ndefinition\n  monadic_option_dest :: \"('a \\<times> 's) option set \\<Rightarrow> (('a \\<times> 's) set \\<times> bool)\"\nwhere\n \"monadic_option_dest S = (Some -` S, None \\<in> S)\"\n\nlemma use_option_form:\n  \"f x = (\\<lambda>s. monadic_option_dest  (monadic_rel_optionation_form f `` {Some (x, s)}))\"\n  by (simp add: monadic_rel_optionation_form_def monadic_option_dest_def)\n\nlemma ex_option: \" (\\<exists>x. P x) = ((\\<exists>y. P (Some y)) \\<or> P None)\"\n  apply safe\n  apply (case_tac x, auto)\n  done\n\nlemma use_option_form_bind:\n  \"f x >>= g = (\\<lambda>s. monadic_option_dest\n       ((monadic_rel_optionation_form f O monadic_rel_optionation_form g) `` {Some (x, s)}))\"\n  apply (rule ext)\n  apply (simp add: monadic_rel_optionation_form_def monadic_option_dest_def\n                   bind_def split_def)\n  apply (simp add: relcomp_unfold ex_option image_def prod_eq_iff Bex_def)\n  apply fastforce\n  done\n\ndefinition\n  monadic_trancl :: \"('a \\<Rightarrow> ('s, 'a) nondet_monad)\n       \\<Rightarrow> 'a \\<Rightarrow> ('s, 'a) nondet_monad\"\nwhere\n \"monadic_trancl f x = (\\<lambda>s. monadic_option_dest ((monadic_rel_optionation_form f)\\<^sup>* `` {Some (x, s)}))\"\n\ndefinition\n  monadic_trancl_preemptible ::\n     \"('a \\<Rightarrow> ('s, 'e + 'a) nondet_monad)\n         \\<Rightarrow> ('a \\<Rightarrow> ('s, 'e + 'a) nondet_monad)\"\nwhere\n \"monadic_trancl_preemptible f x\n    = monadic_trancl (lift f) (Inr x)\"\n\ndefinition\n  cap_removeable :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> bool\"\nwhere\n \"cap_removeable cap slot s =\n   (cap = NullCap\n      \\<or> (\\<exists>p. cap = ZombieCap p \\<and> swp opt_cap s ` (({p} \\<times> UNIV) - {slot})\n              \\<subseteq> {Some NullCap, None}))\"\n\ndefinition\n  finalise_slot_inner1 :: \"cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> bool) k_monad\"\nwhere\n \"finalise_slot_inner1 victim = do\n    cap \\<leftarrow> get_cap victim;\n    final \\<leftarrow> is_final_cap cap;\n    (cap', irqopt) \\<leftarrow> finalise_cap cap final;\n    removeable \\<leftarrow> gets $ cap_removeable cap' victim;\n    when (\\<not> removeable) (set_cap victim cap')\n        \\<sqinter> set_cap victim cap';\n    return (cap', removeable)\n  od\"\n\ndefinition\n  get_zombie_range :: \"cdl_cap \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\"\nwhere\n \"get_zombie_range cap =\n    (\\<lambda>s. case cap of ZombieCap p \\<Rightarrow> dom (swp opt_cap s) \\<inter> ({p} \\<times> UNIV)\n               | _ \\<Rightarrow> {})\"\n\ndefinition\n  swap_for_delete :: \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n \"swap_for_delete ptr1 ptr2 = do\n    cap1 \\<leftarrow> get_cap ptr1;\n    cap2 \\<leftarrow> get_cap ptr2;\n    swap_cap cap1 ptr1 cap2 ptr2\n  od\"\n\ndefinition\n \"finalise_slot_inner2 =\n      (\\<lambda>(region, finalised).\n        liftE (do (victim', remove) \\<leftarrow> select region;\n          (cap', removeable) \\<leftarrow> finalise_slot_inner1 victim';\n          region' \\<leftarrow> gets $ get_zombie_range cap';\n          return (region \\<union> (region' \\<times> {True}), if removeable then {(victim', remove)} else {})\n        od) \\<sqinter>\n        liftE (do (slot, slot') \\<leftarrow> select {(x, y). (x, True) \\<in> region \\<and> (y, True) \\<in> region \\<and> x \\<noteq> y};\n          swap_for_delete slot slot';\n          return (region, {})\n        od) \\<sqinter>\n        liftE (do victim' \\<leftarrow> select {x. (x, True) \\<in> finalised};\n          empty_slot victim';\n          return (region, {})\n        od) \\<sqinter>\n        throw\n      )\"\n\ndefinition\n  finalise_slot :: \"cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n \"finalise_slot victim = doE\n    (region, finalised) \\<leftarrow>\n      monadic_trancl_preemptible finalise_slot_inner2\n        ({(victim, False)}, {});\n    whenE (victim \\<notin> fst ` finalised) throw\n  odE\"\n\ndefinition\n  delete_cap :: \"cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n \"delete_cap victim = doE\n    finalise_slot victim;\n    liftE $ empty_slot victim\n  odE\"", "property": "Cap Management: Move, finalise, and delete capabilities while maintaining system integrity, ensuring that capability removal and deletion are handled correctly and securely.\n\nSubproperties:\n- Capability Movement: Move a capability from one location to another, possibly modifying it in the process.\n- Capability Finalisation: Finalise a capability, handling its removal and ensuring system integrity.\n- Capability Deletion: Delete a capability, securely removing it from the system.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Move the given cap from one location to another,\n * possibly modifying it along the way.\n "}
{"spec": "definition\n  revoke_cap :: \"cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"revoke_cap victim = doE\n     fin \\<leftarrow> monadic_trancl_preemptible (K (doE\n          S \\<leftarrow> liftE $ gets $ descendants_of victim;\n          if S = {} then returnOk True\n          else doE\n            child \\<leftarrow> liftE $ select S;\n            cap \\<leftarrow> liftE $ get_cap child;\n            assertE (cap \\<noteq> NullCap);\n            delete_cap child;\n            Monads_D.throw \\<sqinter> returnOk False\n          odE\n       odE)) False;\n     unlessE fin throw\n   odE\"", "property": "Revoke Capability: Revoke all descendants of a given capability, deleting them if the Capability Derivation Tree (CDT) is being modeled, and handling potential recursive deletion of capabilities containing the cap being revoked.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Revoke all the descendants of the given cap.\n *\n * If the CDT is being modelled, this will delete all the\n * descendants of the given cap. Wonderful things happen\n * if we happen to, in this process, delete something\n * that contains the cap we are trying to revoke.\n "}
{"spec": "definition\n  get_tcb_ep_badge :: \"cdl_tcb \\<Rightarrow> cdl_badge option\"\nwhere\n  \"get_tcb_ep_badge t \\<equiv>\n    case (cdl_tcb_caps t tcb_pending_op_slot) of\n      Some (PendingSyncSendCap _ badge _ _ _ _) \\<Rightarrow> Some badge\n    | _ \\<Rightarrow> None\"", "property": "Get IPC Send Badge: Retrieve the badge used by a thread for its IPC send operation, if it exists.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Get the badge the given thread object is using to\n * perform its IPC send operation.\n "}
{"spec": "definition\n  cancel_badged_sends :: \"cdl_object_id \\<Rightarrow> cdl_badge \\<Rightarrow> unit k_monad\"\nwhere\n  \"cancel_badged_sends ep badge \\<equiv>\n    modify (\\<lambda>s. s\\<lparr>cdl_objects := map_option\n        (\\<lambda>obj. case obj of\n            Tcb t \\<Rightarrow>\n              if (is_thread_blocked_on_endpoint t ep\n                  \\<and> get_tcb_ep_badge t = Some badge) then\n                    Tcb (remove_pending_operation t cdl_cap.RestartCap)\n              else\n                Tcb t\n          | _ \\<Rightarrow> obj) \\<circ> (cdl_objects s)\\<rparr>)\"", "property": "Cancel Badged Sends: Cancel all pending send operations to a specific endpoint that are associated with a given badge, ensuring that blocked threads are properly updated.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Cancel all pending send operations to the given endpoint\n * that are using the given badge.\n "}
{"spec": "definition\n  clear_object_caps :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n \"clear_object_caps ptr = do\n    ptrs \\<leftarrow> gets (\\<lambda>s. {cptr. fst cptr = ptr \\<and> opt_cap cptr s \\<noteq> None});\n    ptrlist \\<leftarrow> select {xs. set xs = ptrs \\<and> distinct xs};\n    mapM_x empty_slot ptrlist\n  od\"\n\ndefinition cdl_default_tcb :: \"cdl_object\"\nwhere \"cdl_default_tcb \\<equiv>  Tcb \\<lparr>cdl_tcb_caps =\n           [tcb_cspace_slot \\<mapsto> cdl_cap.NullCap, tcb_vspace_slot \\<mapsto> cdl_cap.NullCap, tcb_replycap_slot \\<mapsto>\n            cdl_cap.NullCap, tcb_caller_slot \\<mapsto> cdl_cap.NullCap, tcb_ipcbuffer_slot \\<mapsto> cdl_cap.NullCap,\n            tcb_pending_op_slot \\<mapsto> cdl_cap.NullCap, tcb_boundntfn_slot \\<mapsto> cdl_cap.NullCap],\n           cdl_tcb_fault_endpoint = 0,\n           cdl_tcb_intent =\n             \\<lparr>cdl_intent_op = None, cdl_intent_error = False,cdl_intent_cap = 0, cdl_intent_extras = [],\n                cdl_intent_recv_slot = None\\<rparr>, cdl_tcb_has_fault = False, cdl_tcb_domain = minBound\\<rparr>\"\n\ndefinition obj_tcb :: \"cdl_object \\<Rightarrow> cdl_tcb\"\nwhere \"obj_tcb obj \\<equiv> case obj of Tcb tcb \\<Rightarrow> tcb\"\n\ndefinition tcb_caps_merge :: \"cdl_tcb \\<Rightarrow> cdl_tcb \\<Rightarrow> cdl_tcb\"\n  where \"tcb_caps_merge regtcb captcb \\<equiv> regtcb\\<lparr>cdl_tcb_caps\n  := (cdl_tcb_caps captcb)(tcb_pending_op_slot \\<mapsto> the (cdl_tcb_caps regtcb tcb_pending_op_slot), tcb_boundntfn_slot \\<mapsto> the (cdl_tcb_caps regtcb tcb_boundntfn_slot))\\<rparr>\"\n\ndefinition merge_with_dft_tcb :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere \"merge_with_dft_tcb o_id \\<equiv>\n do\n  new_intent \\<leftarrow> select UNIV;\n  KHeap_D.update_thread o_id (cdl_tcb_intent_update (\\<lambda>x. new_intent) \\<circ> (tcb_caps_merge (obj_tcb cdl_default_tcb)))\n od\"\n\nfun\n  reset_mem_mapping :: \"cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"reset_mem_mapping (FrameCap dev p rts sz b mp) = FrameCap dev p rts sz b None\"\n| \"reset_mem_mapping (PageTableCap ptr b mp) = PageTableCap ptr b None\"\n| \"reset_mem_mapping (PageDirectoryCap ptr b ma) = PageDirectoryCap ptr b None\"\n| \"reset_mem_mapping cap = cap\"", "property": "Object Regeneration: Regenerate the target object by revoking its children, resetting it to its original state, and reinitializing its properties. This involves clearing the object's capabilities, resetting its memory mappings, and merging its attributes with default values.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Regenerate the target object.\n *\n * Any children of the cap are first revoked. The object\n * is then reset into its original (as-if just created)\n * state. But maybe not. It's complex.\n *\n * In the C implementation, attempting to recycle a\n * non-master cap may do something that is not\n * a recycle. (Should be perhaps return an error?)\n "}
{"spec": "function\n  resolve_address_bits ::\n  \"cdl_cap \\<Rightarrow> cdl_cptr \\<Rightarrow> nat \\<Rightarrow> (cdl_cap_ref \\<times> nat) fault_monad\"\nwhere\n  \"resolve_address_bits cnode_cap cap_ptr remaining_size = doE\n    unlessE (is_cnode_cap cnode_cap) $ throw;\n\n    \\<comment> \\<open>Fetch the next level CNode.\\<close>\n    cnode \\<leftarrow> liftE $ get_cnode $ cap_object cnode_cap;\n    radix_size \\<leftarrow> returnOk $ cdl_cnode_size_bits cnode;\n    guard_size \\<leftarrow> returnOk $ cap_guard_size cnode_cap;\n    cap_guard  \\<leftarrow> returnOk $ cap_guard cnode_cap;\n    level_size \\<leftarrow> returnOk (radix_size + guard_size);\n    assertE (level_size \\<noteq> 0);\n\n    \\<comment> \\<open>Ensure the guard matches up.\\<close>\n    guard \\<leftarrow> returnOk $ (cap_ptr >> (remaining_size-guard_size)) && (mask guard_size);\n    unlessE (guard_size \\<le> remaining_size \\<and> guard = cap_guard) $ throw;\n\n    \\<comment> \\<open>Ensure we still enough unresolved bits left in our CPTR.\\<close>\n    whenE (level_size > remaining_size) $ throw;\n\n    \\<comment> \\<open>Find the next slot.\\<close>\n    offset \\<leftarrow> returnOk $ (cap_ptr >> (remaining_size-level_size)) && (mask radix_size);\n    slot \\<leftarrow> returnOk (cap_object cnode_cap, unat offset);\n    size_left \\<leftarrow> returnOk (remaining_size - level_size);\n    if (size_left = 0) then\n      returnOk (slot, 0)\n    else\n      doE\n        next_cap \\<leftarrow> liftE $ get_cap (slot);\n        if is_cnode_cap next_cap then\n          resolve_address_bits next_cap cap_ptr size_left\n        else\n          returnOk (slot, size_left)\n      odE\n  odE\"\n  by fastforce+\n\ntermination resolve_address_bits\n  apply (relation \"measure (\\<lambda>(a,b,c). c)\")\n  apply (auto simp: in_monad)\n  done\n\ndefinition\n  lookup_slot :: \"cdl_object_id \\<Rightarrow> cdl_cptr \\<Rightarrow> cdl_cap_ref fault_monad\"\nwhere\n  \"lookup_slot thread cptr \\<equiv>\n    doE\n      cspace_root \\<leftarrow> liftE $ get_cap (thread, tcb_cspace_slot);\n      (slot, _) \\<leftarrow> resolve_address_bits cspace_root cptr word_bits;\n      returnOk slot\n    odE\"\n\ndefinition\n  lookup_cap :: \"cdl_object_id \\<Rightarrow> cdl_cptr \\<Rightarrow> cdl_cap fault_monad\"\nwhere\n  \"lookup_cap thread cptr \\<equiv>\n    doE\n      slot \\<leftarrow> lookup_slot thread cptr;\n      liftE $ get_cap slot\n    odE\"\n\ndefinition\n  lookup_cap_and_slot :: \"cdl_object_id \\<Rightarrow> cdl_cptr \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) fault_monad\"\nwhere\n  \"lookup_cap_and_slot thread cptr \\<equiv>\n    doE\n      slot \\<leftarrow> lookup_slot thread cptr;\n      cap \\<leftarrow> liftE $ get_cap slot;\n      returnOk (cap, slot)\n    odE\"\n\ndefinition\n  lookup_slot_for_cnode_op :: \"cdl_cap \\<Rightarrow> cdl_cptr \\<Rightarrow> nat \\<Rightarrow> cdl_cap_ref except_monad\"\nwhere\n  \"lookup_slot_for_cnode_op croot cptr depth \\<equiv>\n    doE\n      whenE (depth < 1 \\<or> depth > word_bits) throw;\n      (slot, rem) \\<leftarrow> fault_to_except $ resolve_address_bits croot cptr depth;\n      if rem = 0 then returnOk slot else throw\n    odE\"", "property": "Resolve Address Bits: Walk a user's CSpace to convert a user's CPTR into a cap slot by recursively resolving address bits, ensuring guard matches, and finding the next slot until all bits are resolved.\n\nLookup Operations: Perform various lookup operations (slot, cap, cap and slot) in a user's CSpace by starting from the cspace root and resolving address bits to find the target slot and/or capability.\n\nLookup Slot for CNode Op: Find the slot for a CNode operation by resolving address bits to the specified depth, ensuring all bits are resolved, and returning the resulting slot.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Walk a user's CSpace to convert a user's CPTR into a cap slot.\n "}
{"spec": "definition\n  badge_update :: \"word32 \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"badge_update data cap \\<equiv> update_cap_badge (data && mask badge_bits) cap\"", "property": "Badge Update: Update the badge of a capability by masking off bits that cannot be stored due to implementation limitations.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Update the badge of a cap, masking off bits the lower specs are unable\n * to store for implementation reasons.\n "}
{"spec": "definition\n  update_cap_data :: \"bool \\<Rightarrow> word32 \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap k_monad\"\nwhere\n  \"update_cap_data preserve data cap \\<equiv>\n    return $ case cap of\n        EndpointCap _ b _ \\<Rightarrow>\n          if b = 0 \\<and> \\<not> preserve then\n            badge_update data cap\n          else\n            NullCap\n      | NotificationCap _ b _ \\<Rightarrow>\n          if b = 0 \\<and> \\<not> preserve then\n            badge_update data cap\n          else\n            NullCap\n      | CNodeCap object guard guard_size sz \\<Rightarrow>\n          let\n            reserved_bits = 3;\n            guard_bits = 18;\n            guard_size_bits = 5;\n\n            new_guard_size = unat ((data >> reserved_bits) && mask guard_size_bits);\n            new_guard = (data >> (reserved_bits + guard_size_bits)) && mask (min (unat ((data >> reserved_bits) && mask guard_size_bits)) guard_bits)\n          in\n            if new_guard_size + sz > word_bits then NullCap else\n            (CNodeCap object new_guard new_guard_size sz)\n      | _ \\<Rightarrow> cap\"", "property": "Capability Update: Transform a capability based on a user request, interpreting the \"data\" word differently for various capability types, and return a set of possible capabilities to accommodate non-deterministic implementations.\n\nSubproperties:\n- Endpoint and Notification Capabilities: Update the badge of the capability if the current badge is zero and the preserve flag is not set; otherwise, return a Null Capability.\n- CNode Capability: Update the guard size and guard of the capability based on the provided data, ensuring that the new guard size does not exceed the word size limit; otherwise, return a Null Capability.\n- Other Capability Types: Return the original capability unchanged.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Transform a capability based on a request from the user.\n *\n * The \"data\" word is interpreted differently for different cap types.\n *\n * We return a set of possible caps to allow for non-deterministic\n * implementations, to avoid messy implementation details of the CDT\n * in lower-level models.\n "}
{"spec": "definition\n  derive_cap :: \"cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap except_monad\"\nwhere\n  \"derive_cap slot cap \\<equiv> case cap of\n     UntypedCap _ _ _ \\<Rightarrow> doE ensure_no_children slot; returnOk cap odE\n   | ReplyCap _ _ \\<Rightarrow> returnOk NullCap\n   | MasterReplyCap oref \\<Rightarrow> returnOk NullCap\n   | IrqControlCap \\<Rightarrow> returnOk NullCap\n   | ZombieCap _ \\<Rightarrow> returnOk NullCap\n   | FrameCap dev p r sz b x \\<Rightarrow> returnOk (FrameCap dev p r sz b None)\n   | PageTableCap _ _ _ \\<Rightarrow> throw \\<sqinter> returnOk cap\n   | PageDirectoryCap _ _ _ \\<Rightarrow> throw \\<sqinter> returnOk cap\n   | _ \\<Rightarrow> returnOk cap\"", "property": "Derive Capability: Derive a new capability from an existing one, handling cases where the capability cannot be copied or minted, and returning NullCap or throwing an exception as necessary. \n\nSubproperties:\n- Untyped capabilities require ensuring no children exist.\n- Reply, Master Reply, IrqControl, and Zombie capabilities return NullCap.\n- Frame capabilities are derived with the executable flag set to None.\n- PageTable and PageDirectory capabilities may either throw an exception or return the original capability, modeling nondeterminism. \n- All other capabilities are returned unchanged.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Some caps may not be copied/minted. In this case the following function\n * returns NullCap or throws.\n *\n * PageTable and PageDirectory caps may not be copied if already mapped. This is\n * left out here and modelled by nondeterminism.\n "}
{"spec": "definition\n  corrupt_tcb_intent :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"corrupt_tcb_intent target_tcb \\<equiv>\n    do\n      new_intent \\<leftarrow> select UNIV;\n      update_thread target_tcb (\\<lambda>t. t\\<lparr>cdl_tcb_intent := new_intent\\<rparr>)\n    od\"\n\nend", "property": "TCB Corruption: Arbitrarily modify a TCB's intent, allowing for changes to its IPC buffer or registers.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Modify the TCB's IpcBuffer or Registers in an arbitrary fashion. "}
{"spec": "(*\n * The basic monads used in capDL\n *)\n\ntheory Monads_D\nimports\n  Types_D\n  Monads.Nondet_In_Monad\n  Monads.Nondet_VCG\nbegin", "property": "No specific property can be summarized from the given code as it only contains imports and no actual specification or implementation details.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym 'a k_monad = \"(cdl_state, 'a) nondet_monad\"\n\ndatatype cdl_except_error = ExceptError\ndatatype cdl_preempt_error = PreemptError\ndatatype cdl_fault_error = FaultError", "property": "Kernel State Management: The kernel state is managed through a non-deterministic monad, allowing for handling of exceptions, preemptions, and faults in a controlled manner. \n\nSubproperties:\n- Exception Handling: The kernel state monad allows for the handling of exceptions through the ExceptError type.\n- Preemption Handling: The kernel state monad allows for the handling of preemptions through the PreemptError type.\n- Fault Handling: The kernel state monad allows for the handling of faults through the FaultError type.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Kernel state monad "}
{"spec": "type_synonym 'a except_monad = \"(cdl_state, cdl_except_error + 'a) nondet_monad\"", "property": "Exception Handling: The system uses an exception monad to handle errors, where no further exception information is provided.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Exception monad, no further exception information "}
{"spec": "type_synonym 'a preempt_monad = \"(cdl_state, cdl_preempt_error + 'a) nondet_monad\"", "property": "Preemption Monad: Represents a non-deterministic monad that handles preemption errors, providing a way to manage exceptions in a preemptive environment.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Exception monad, no further exception information "}
{"spec": "type_synonym 'a fault_monad =  \"(cdl_state, cdl_fault_error + 'a) nondet_monad\"\n\nabbreviation\n  throw :: \"(cdl_state, 'a + 'b) nondet_monad\" where\n  \"throw == throwError undefined\"", "property": "Fault Monad: Provides a way to handle exceptions in a non-deterministic manner, allowing for the propagation of errors without additional information.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Exception monad, no further exception information "}
{"spec": "definition\n  preemption_point :: \"unit preempt_monad\" where\n \"preemption_point \\<equiv> throw \\<sqinter> returnOk ()\"", "property": "Allow Preemption: Permit the kernel to preempt the current thread at this point, potentially yielding control to another thread.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": "Allow preemption at this point."}
{"spec": "definition\n  unify_failure :: \"('f + 'a) k_monad \\<Rightarrow> (unit + 'a) k_monad\" where\n \"unify_failure m \\<equiv> handleE' m (\\<lambda>x. throwError ())\"", "property": "Unify Failure: Convert an exception monad with an arbitrary type into a new exception monad with a unit type, handling failures by throwing a unit error.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": "\n * Convert an exception monad with aribtrary type into a\n * new exception monad with unit type.\n "}
{"spec": "definition\n  fault_to_except :: \"'a fault_monad \\<Rightarrow> 'a except_monad\"\nwhere\n  \"fault_to_except m \\<equiv> handleE' m (\\<lambda>x. throw)\"", "property": "Fault Handling: Convert a fault monad into an exception monad by handling faults and re-throwing them as exceptions.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": "\n  Convert a fault monad into an exception monad.\n"}
{"spec": "definition\n  option_select :: \"'a set \\<Rightarrow> ('s, 'a option) nondet_monad\"\nwhere\n  \"option_select S \\<equiv>\n    if S = {} then\n      return None\n    else\n      select S >>= (\\<lambda>a. return (Some a))\"", "property": "Non-Deterministic Selection: Select an item non-deterministically from a given set, returning None if the set is empty.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": "\n * Non-deterministically select an item from the given set.\n * If the set if empty, return 'None'.\n "}
{"spec": "definition\n  throw_on_none :: \"'a option \\<Rightarrow> ('e + 'a) k_monad\"\nwhere\n  \"throw_on_none x \\<equiv>\n    case x of\n        None \\<Rightarrow> throw\n      | Some y \\<Rightarrow> returnOk y\"\n\n\nend", "property": "Return Non-Null Object: Returns the given object if it exists, otherwise throws an error.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Return the given object, throwing an error if it is 'None'. "}
{"spec": "theory Invocations_D\nimports Types_D\nbegin\n\ndatatype cdl_cnode_invocation =\n    InsertCall cdl_cap cdl_cap_ref cdl_cap_ref\n  | MoveCall cdl_cap cdl_cap_ref cdl_cap_ref\n  | RevokeCall cdl_cap_ref\n  | DeleteCall cdl_cap_ref\n  | RotateCall cdl_cap cdl_cap cdl_cap_ref cdl_cap_ref cdl_cap_ref\n  | SaveCall cdl_cap_ref\n  | CancelBadgedSendsCall cdl_cap\n\ndatatype cdl_untyped_invocation =\n    Retype cdl_cap_ref\n        cdl_object_type cdl_size_bits \"cdl_cap_ref list\" bool nat\n\ndatatype cdl_tcb_invocation =\n    WriteRegisters cdl_object_id bool \"word32 list\" nat\n  | ReadRegisters cdl_object_id bool word32 nat\n  | CopyRegisters cdl_object_id cdl_object_id bool bool bool bool nat\n  | ThreadControl cdl_object_id cdl_cap_ref\n        \"cdl_cptr option\"\n        \"(cdl_cap \\<times> cdl_cap_ref) option\"\n        \"(cdl_cap \\<times> cdl_cap_ref) option\"\n        \"(cdl_cap \\<times> cdl_cap_ref) option\"\n  | Suspend cdl_object_id\n  | Resume cdl_object_id\n  | NotificationControl cdl_object_id \"cdl_object_id option\"\n  | SetTLSBase cdl_object_id\n\ndatatype arch_cdl_irq_control_invocation =\n    ARMIssueIrqHandler cdl_irq cdl_cap_ref cdl_cap_ref bool\n\ndatatype cdl_irq_control_invocation =\n    IssueIrqHandler cdl_irq cdl_cap_ref cdl_cap_ref\n  | ArchIssueIrqHandler arch_cdl_irq_control_invocation\n\ndatatype cdl_irq_handler_invocation =\n    AckIrq cdl_irq\n  | SetIrqHandler cdl_irq cdl_cap cdl_cap_ref\n  | ClearIrqHandler cdl_irq\n\ndatatype cdl_endpoint_invocation =", "property": "Invocation Types: Define various invocation types for different objects in the system, including cdl_cnode_invocation, cdl_untyped_invocation, cdl_tcb_invocation, arch_cdl_irq_control_invocation, cdl_irq_control_invocation, cdl_irq_handler_invocation, and cdl_endpoint_invocation. Each invocation type specifies the actions that can be performed on the corresponding object, such as inserting or deleting capabilities, controlling threads, handling interrupts, and managing endpoints.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "SyncMessage cdl_badge bool bool cdl_object_id\n\ndatatype cdl_notification_invocation =", "property": "Synchronous Message Properties: Define the structure of synchronous messages, including a badge, grant, grant reply, and endpoint (cdl_object_id), to facilitate capability-based communication between threads.\n\nNotification Invocation Properties: Specify the invocation structure for notifications, enabling threads to interact with each other through notification mechanisms.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": " badge, grant, grant reply, ep "}
{"spec": "Signal cdl_badge cdl_object_id\n\ndatatype cdl_reply_invocation =\n    ReplyMessage cdl_object_id cdl_cap_ref bool (* can grant *)\n\ndatatype cdl_page_table_invocation =", "property": "Signal Notification: Send a signal to a notification object with a specific badge. \n\nNo subproperties are necessary for this simple property.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": " badge (notification word) and notification object "}
{"spec": "PageTableMap cdl_cap cdl_cap cdl_cap_ref cdl_cap_ref", "property": "Map Page Table: Map a page table into a page directory, creating a new capability for the mapped page table.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": " PageTableMap <real_pt_cap> <pt_cap> <pt_cap_ref> <pd_target_slot> "}
{"spec": "| PageTableUnmap \"cdl_mapped_addr option\"  cdl_object_id cdl_cap_ref\n\ndatatype cdl_asid_control_invocation =\n    MakePool cdl_cap cdl_cap_ref \"cdl_object_id set\" cdl_cap_ref nat\n\ndatatype cdl_asid_pool_invocation =\n    Assign cdl_asid cdl_cap_ref cdl_cap_ref\n\ndatatype flush =\n   Clean | Invalidate | CleanInvalidate | Unify\n\ndatatype cdl_page_invocation =\n    PageMap cdl_cap cdl_cap cdl_cap_ref \"cdl_cap_ref list\"\n  | PageUnmap \"cdl_mapped_addr option\" cdl_object_id \"cdl_cap_ref\" nat\n  | PageFlushCaches flush\n  | PageGetAddress\n\n\ndatatype cdl_page_directory_invocation =\n   PageDirectoryFlush  flush\n | PageDirectoryNothing\n\n\ndatatype cdl_domain_invocation =\n  SetDomain cdl_object_id word8\n\ndatatype cdl_invocation =\n    InvokeUntyped cdl_untyped_invocation\n  | InvokeEndpoint cdl_endpoint_invocation\n  | InvokeNotification cdl_notification_invocation\n  | InvokeReply cdl_reply_invocation\n  | InvokeTcb cdl_tcb_invocation\n  | InvokeDomain cdl_domain_invocation\n  | InvokeCNode cdl_cnode_invocation\n  | InvokeIrqControl cdl_irq_control_invocation\n  | InvokeIrqHandler cdl_irq_handler_invocation\n  | InvokePageTable cdl_page_table_invocation\n  | InvokePage cdl_page_invocation\n  | InvokePageDirectory cdl_page_directory_invocation\n  | InvokeAsidControl cdl_asid_control_invocation\n  | InvokeAsidPool cdl_asid_pool_invocation\n\nend", "property": "Page Table Unmap: Allows unmapping a page table from a specific address space, specified by the mapped address, page table object ID, and capability reference. \n\nPage Management: Provides various page-related operations, including mapping pages, unmapping pages, flushing caches, and retrieving page addresses. These operations ensure that pages are correctly managed within the system, maintaining memory integrity and performance.\n\nASID Control: Manages the creation and assignment of address space identifiers (ASIDs) to pools, ensuring that ASIDs are correctly allocated and deallocated.\n\nASID Pool Management: Assigns ASIDs to pools, ensuring that ASIDs are correctly managed within the system.\n\nDomain Management: Sets the domain for a specific object, ensuring that objects are correctly managed within their domains.\n\nInvocation Management: Provides a range of invocation types for various system objects, including untyped, endpoint, notification, reply, TCB, domain, CNode, IRQ control, IRQ handler, page table, page, page directory, ASID control, and ASID pool invocations. These invocations ensure that system objects are correctly managed and interact with each other efficiently.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": " PageTableUnmap <mapped_addr option> <pt_obj_id> <pt_cap_ref> "}
{"spec": "(*\n * Accessor functions for objects and caps.\n *)\n\ntheory KHeap_D\nimports Monads_D\nbegin", "property": "No properties can be extracted from this code snippet as it does not contain any specific functionality or behavior. It appears to be a header or import statement for a theory in a formal verification framework.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation\n  get_object :: \"cdl_object_id \\<Rightarrow> cdl_object k_monad\"\nwhere\n  \"get_object p \\<equiv> gets_the (\\<lambda>s. cdl_objects s p)\"", "property": "Get Object: Return an object from the heap given its identifier, failing if the object does not exist.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Return an item from the heap. Fail if no such object exists. "}
{"spec": "definition\n  set_object :: \"cdl_object_id \\<Rightarrow> cdl_object \\<Rightarrow> unit k_monad\"\nwhere\n  \"set_object p obj \\<equiv>\n    modify (\\<lambda>s. s \\<lparr> cdl_objects := (cdl_objects s) (p \\<mapsto> obj) \\<rparr> )\"", "property": "Set Object: Set an item on the heap to the given object, updating the state's object mapping.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Set an item on the heap to the given object. "}
{"spec": "definition\n  get_thread :: \"cdl_object_id \\<Rightarrow> cdl_tcb k_monad\"\nwhere\n  \"get_thread p \\<equiv>\n    do\n      t \\<leftarrow> get_object p;\n      case t of\n          Tcb tcb \\<Rightarrow> return tcb\n        | _ \\<Rightarrow> fail\n    od\"", "property": "Thread Retrieval: Get a thread from a given pointer, returning the thread's TCB (Thread Control Block) if the pointer is valid, or failing if the pointer is invalid.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Get a thread from the given pointer. "}
{"spec": "definition\n  get_thread_fault :: \"cdl_object_id \\<Rightarrow> bool k_monad\"\nwhere\n  \"get_thread_fault p \\<equiv>\n    do\n      t \\<leftarrow> get_object p;\n      case t of\n          Tcb tcb \\<Rightarrow> return (cdl_tcb_has_fault tcb)\n        | _ \\<Rightarrow> fail\n    od\"", "property": "Thread Retrieval: Get a thread from a given pointer and check if it has a fault, failing if the object is not a thread.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Get a thread from the given pointer. "}
{"spec": "definition\n  update_thread :: \"cdl_object_id \\<Rightarrow> (cdl_tcb \\<Rightarrow> cdl_tcb) \\<Rightarrow> unit k_monad\"\nwhere\n  \"update_thread p f \\<equiv>\n     do\n       t \\<leftarrow> get_object p;\n       case t of\n          Tcb tcb \\<Rightarrow> set_object p (Tcb (f tcb))\n       | _ \\<Rightarrow> fail\n     od\"", "property": "Thread Update: Modify a thread's state on the heap by applying a transformation function to the thread's control block (TCB). \n\nSubproperty: \n- The update operation retrieves the thread object from the heap.\n- If the retrieved object is a TCB, it applies the transformation function to the TCB and updates the heap with the modified TCB.\n- If the retrieved object is not a TCB, the update operation fails.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Update a thread on the heap. "}
{"spec": "definition\n  update_thread_fault :: \"cdl_object_id \\<Rightarrow> (bool\\<Rightarrow>bool) \\<Rightarrow> unit k_monad\"\nwhere\n  \"update_thread_fault p f \\<equiv>\n     do\n       t \\<leftarrow> get_object p;\n       case t of\n          Tcb tcb \\<Rightarrow> set_object p (Tcb (tcb\\<lparr>cdl_tcb_has_fault := f (cdl_tcb_has_fault tcb)\\<rparr>))\n       | _ \\<Rightarrow> fail\n     od\"", "property": "Thread Update: Modify a thread's fault status on the heap by applying a given function to the current fault status and updating the thread object accordingly. \n\nSubproperties: \n- Retrieve the thread object from the heap.\n- Check if the object is a TCB (Thread Control Block).\n- Update the fault status of the TCB by applying the given function.\n- Fail if the object is not a TCB.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Update a thread on the heap. "}
{"spec": "definition\n  get_cnode :: \"cdl_object_id \\<Rightarrow> cdl_cnode k_monad\"\nwhere\n  \"get_cnode p \\<equiv>\n    do\n      t \\<leftarrow> get_object p;\n      case t of\n          CNode cnode \\<Rightarrow> return cnode\n        | _ \\<Rightarrow> fail\n    od\"", "property": "Get CNode: Retrieve a CNode from a given pointer, returning the CNode if it exists and failing otherwise.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Get a CNode from the given pointer. "}
{"spec": "definition\n  get_index :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a option\"\nwhere\n  \"get_index a b \\<equiv>\n     if b < length a then\n       Some (a ! b)\n     else\n       None\"", "property": "List Index Retrieval: Retrieve an element at a specified index from a list, returning None if the index is out of bounds. \n\nList Bounds Checking: Check if the given index is within the bounds of the list.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": "\n * Get the index out of the given list, returning None if it\n * doesn't exist.\n "}
{"spec": "definition\n  slots_of :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_map\"\nwhere\n  \"slots_of obj_id \\<equiv> \\<lambda>s.\n  case cdl_objects s obj_id of\n    None \\<Rightarrow> Map.empty\n  | Some obj \\<Rightarrow> object_slots obj\"", "property": "Object Slot Retrieval: Returns a map of capability slots for a given object ID in the current state. If the object does not exist or does not have capabilities, an empty map is returned.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " The slots of an object, returns an empty map for non-existing objects\n   or objects that do not have caps "}
{"spec": "definition\n  opt_cap :: \"cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap option\"\nwhere\n  \"opt_cap \\<equiv> \\<lambda>(obj_id, slot) s. slots_of obj_id s slot\"", "property": "Retrieve Capability: Get the capability at a specific capability reference, returning None if the object or capability does not exist.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " The cap at the given cap_ref. None if object or cap does not exist "}
{"spec": "abbreviation\n  get_cap :: \"cdl_cap_ref \\<Rightarrow> cdl_cap k_monad\" where\n  \"get_cap p \\<equiv> gets_the (opt_cap p)\"", "property": "Get Capability: Retrieve a capability from the capability space, returning the capability associated with the given capability reference if it exists.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " monad version of opt_cap "}
{"spec": "definition\n  set_cap :: \"cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> unit k_monad\"\nwhere\n  \"set_cap \\<equiv> \\<lambda>(obj_id, slot) cap. do\n    obj \\<leftarrow> get_object obj_id;\n    assert (has_slots obj);\n    slots \\<leftarrow> return $ object_slots obj;\n    obj' \\<leftarrow> return $ update_slots (slots (slot \\<mapsto> cap)) obj;\n    obj'' \\<leftarrow> case obj' of\n              Tcb t \\<Rightarrow> if slot = tcb_ipcbuffer_slot \\<and> slots slot \\<noteq> Some cap then do\n                   intent' \\<leftarrow> select UNIV;\n                   return $ Tcb (t \\<lparr> cdl_tcb_intent := intent' \\<rparr>)\n                 od\n                 else return obj'\n             | _ \\<Rightarrow> return obj';\n    set_object obj_id obj''\n  od\"", "property": "Set Capability: Set a capability at a specific capability reference, ensuring the object exists and has capability slots. \n\nUpdate Object Slots: Update the object's slots with the new capability, handling the special case of updating the IPC buffer slot of a TCB object.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Setting a cap at specific cap_ref. Object must exist and have cap slots. "}
{"spec": "definition\n  opt_parent :: \"cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref option\" where\n  \"opt_parent p \\<equiv> \\<lambda>s. cdl_cdt s p\"\n\nabbreviation\n  get_parent :: \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref k_monad\" where\n  \"get_parent p \\<equiv> gets_the (opt_parent p)\"", "property": "Parent Capability Lookup: Retrieve the parent capability of a given capability reference from the Capability Derivation Tree (CDT). \n\nGet Parent Capability: Fetch the parent capability reference of a specified capability reference, returning the result as a kernel monad.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " looking up the parent of a cap in the cdt "}
{"spec": "definition\n  set_parent :: \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\" where\n  \"set_parent child parent \\<equiv> do\n    cdt \\<leftarrow> gets cdl_cdt;\n    assert (cdt child = None);\n    modify (\\<lambda>s. s \\<lparr> cdl_cdt := (cdl_cdt s) (child \\<mapsto> parent) \\<rparr> )\n   od\"", "property": "Set Cap Derivation: Establish a parent-child relationship between two capability references in the capability derivation tree (CDT), ensuring the child reference has no existing parent.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " setting a cap derivation of a specific cap_ref  "}
{"spec": "definition\n  remove_parent :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\" where\n  \"remove_parent parent \\<equiv>\n   modify (\\<lambda>s. s \\<lparr>cdl_cdt := (\\<lambda> x. if x = parent\n                                 then None\n                                 else (if cdl_cdt s x = Some parent\n                                     then cdl_cdt s parent\n                                     else cdl_cdt s x )) \\<rparr>)\"", "property": "Remove Parent Capability: Removes a capability slot from the Capability Derivation Tree (CDT) and updates the children to point to their grandparent, effectively removing the parent-child relationship.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Removes a cap slot from the cdt, and points all its children to their grandparent "}
{"spec": "definition\n  swap_parents :: \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\" where\n  \"swap_parents p p' = modify (cdl_cdt_update\n     (\\<lambda>cd. Fun.swap p p'\n          (\\<lambda>x. if cd x = Some p then Some p' else\n              if cd x = Some p' then Some p else cd x)))\"\n\ndefinition\n  is_cdt_parent :: \"cdl_state \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool\" where\n  \"is_cdt_parent s p c \\<equiv> cdl_cdt s c = Some p\"\n\ndefinition\n  cdt_parent_rel :: \"cdl_state \\<Rightarrow> (cdl_cap_ref \\<times> cdl_cap_ref) set\" where\n  \"cdt_parent_rel \\<equiv> \\<lambda>s. {(p,c). is_cdt_parent s p c}\"\n\nabbreviation\n  parent_of :: \"cdl_state \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> p cdt_parent_of c \\<equiv> (p,c) \\<in> cdt_parent_rel s\"\n\nabbreviation\n  parent_of_trancl :: \"cdl_state \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of\\<^sup>+ _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x cdt_parent_of\\<^sup>+ y \\<equiv> (x, y) \\<in> (cdt_parent_rel s)\\<^sup>+\"\n\nabbreviation\n  parent_of_rtrancl :: \"cdl_state \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of\\<^sup>* _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x cdt_parent_of\\<^sup>* y \\<equiv> (x, y) \\<in> (cdt_parent_rel s)\\<^sup>*\"\n\n\\<comment> \\<open>descendants of a slot\\<close>\ndefinition\n  descendants_of :: \"cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\" where\n  \"descendants_of p s \\<equiv> {q. (p,q) \\<in> (cdt_parent_rel s)\\<^sup>+}\"\n\n\n\ndefinition\n  tcb_ipcframe_id :: \"cdl_tcb \\<Rightarrow> cdl_object_id option\"\nwhere\n  \"tcb_ipcframe_id tcb \\<equiv> case (cdl_tcb_caps tcb tcb_ipcbuffer_slot) of\n                              Some (FrameCap _ oid _ _ _ _) \\<Rightarrow> Some oid\n                              | _                       \\<Rightarrow> None\"", "property": "Swap Parents: Swap the parents of two capability references in the Capability Derivation Tree (CDT). \n\nParent-Child Relationship: Define the parent-child relationship between capability references in the CDT, including direct parent, ancestor, and descendant relationships. \n\nCapability Frame ID: Retrieve the object ID of the IPC frame capability associated with a TCB, if it exists.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Swaps the parents of two cap_refs "}
{"spec": "definition\n  corrupt_intents ::\"(word32 \\<Rightarrow> cdl_full_intent) \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_state\"\nwhere\n  \"corrupt_intents f bufp s \\<equiv>\n  let changed = (\\<lambda>ptr. case cdl_objects s ptr of\n    Some (Tcb tcb)\n      \\<Rightarrow> if tcb_ipcframe_id tcb = Some bufp then Some (Tcb (tcb\\<lparr> cdl_tcb_intent := f ptr \\<rparr> ) ) else None\n  | _ \\<Rightarrow> None)\n  in\n  s\\<lparr>cdl_objects := cdl_objects s ++ changed\\<rparr>\"", "property": "Corrupt Intents: Update the intents of TCB objects in the system state that reference a specific IPC buffer, by applying a given function to the intent of each affected TCB.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": "\n * Dealing with writes to message registers or other locations that\n * may have an effect on how intents are interpreted.\n "}
{"spec": "definition\n  corrupt_frame :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\n  where\n  \"corrupt_frame bufp \\<equiv> do\n      f \\<leftarrow> select UNIV;\n      modify (corrupt_intents f bufp)\n    od\"\n\nend", "property": "Corrupt Frame Handling: When a memory frame is corrupted, update the intents of all TCBs whose IPC buffer is located within that frame to reflect the corruption.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " When a memory frame has been corrupted,\n * we need to change all the intents of tcbs\n * whose ipc_buffer is located within that frame\n "}
{"spec": "(*\n * Operations on interrupt objects.\n *)\n\ntheory Interrupt_D\nimports Endpoint_D \"ExecSpec.Platform\"\nbegin\n\ncontext begin interpretation Arch .\nrequalify_types\n  irq\nend", "property": "Interrupt Object Operations: Provide operations for managing interrupt objects, including handling and manipulating interrupt requests (IRQs).", "title": "./spec/capDL/Interrupt_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  get_active_irq :: \"(cdl_irq option) k_monad\"\nwhere\n  \"get_active_irq \\<equiv>\n    do\n      irq \\<leftarrow> select UNIV;\n      return $ Some irq\n    od \\<sqinter> (return None)\n  \"\n\ndefinition\n  arch_decode_irq_control_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_arch_irq_control_intent \\<Rightarrow> cdl_irq_control_invocation except_monad\"\nwhere\n  \"arch_decode_irq_control_invocation target target_ref caps intent \\<equiv> case intent of\n      ARMIrqControlIssueIrqHandlerIntent irq index depth \\<Rightarrow>\n        doE\n          root \\<leftarrow> throw_on_none $ get_index caps 0;\n          cnode_cap \\<leftarrow> returnOk $ fst root;\n          dest_slot_cap_ref \\<leftarrow> lookup_slot_for_cnode_op cnode_cap index (unat depth);\n          returnOk $ IssueIrqHandler irq target_ref dest_slot_cap_ref\n        odE \\<sqinter> throw\"\n\ndefinition\n  decode_irq_control_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_irq_control_intent \\<Rightarrow> cdl_irq_control_invocation except_monad\"\nwhere\n  \"decode_irq_control_invocation target target_ref caps intent \\<equiv> case intent of\n      \\<comment> \\<open>Create an IRQ handler cap for the given IRQ, placing it\n         in the specified CNode slot.\\<close>\n      IrqControlIssueIrqHandlerIntent irq index depth \\<Rightarrow>\n        doE\n          root \\<leftarrow> throw_on_none $ get_index caps 0;\n          cnode_cap \\<leftarrow> returnOk $ fst root;\n          dest_slot_cap_ref \\<leftarrow> lookup_slot_for_cnode_op cnode_cap index (unat depth);\n          returnOk $ IssueIrqHandler irq target_ref dest_slot_cap_ref\n        odE \\<sqinter> throw\n    | ArchIrqControlIssueIrqHandlerIntent arch_intent \\<Rightarrow> arch_decode_irq_control_invocation target target_ref caps arch_intent\"\n\ndefinition\n  decode_irq_handler_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_irq_handler_intent \\<Rightarrow> cdl_irq_handler_invocation except_monad\"\nwhere\n  \"decode_irq_handler_invocation target target_ref caps intent \\<equiv> case intent of\n    \\<comment> \\<open>Acknowledge an IRQ.\\<close>\n    IrqHandlerAckIntent \\<Rightarrow>\n      doE\n        irq \\<leftarrow> liftE $ assert_opt $ cdl_cap_irq target;\n        returnOk $ AckIrq irq\n      odE \\<sqinter> throw\n\n    \\<comment> \\<open>Modify the IRQ so that it no longer sends to an endpoint.\\<close>\n    | IrqHandlerClearIntent \\<Rightarrow>\n      doE\n        irq \\<leftarrow> liftE $ assert_opt $ cdl_cap_irq target;\n        returnOk $ ClearIrqHandler irq\n      odE \\<sqinter> throw\n\n    \\<comment> \\<open>Setup an IRQ to cause an endpoint to be sent to.\\<close>\n    | IrqHandlerSetEndpointIntent \\<Rightarrow>\n      doE\n        endpoint \\<leftarrow> throw_on_none $ get_index caps 0;\n        endpoint_cap \\<leftarrow> returnOk $ fst endpoint;\n        endpoint_cap_ref \\<leftarrow> returnOk $ snd endpoint;\n        irq \\<leftarrow> liftE $ assert_opt $ cdl_cap_irq target;\n        case endpoint_cap of\n              NotificationCap x _ _ \\<Rightarrow> returnOk ()\n              | _                    \\<Rightarrow> throw;\n        returnOk $ SetIrqHandler irq endpoint_cap endpoint_cap_ref\n      odE \\<sqinter> throw\n  \"\n\ndefinition\n  arch_invoke_irq_control :: \"arch_cdl_irq_control_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"arch_invoke_irq_control params \\<equiv> case params of\n      \\<comment> \\<open>Create a new IRQ handler cap.\\<close>\n      ARMIssueIrqHandler irq control_slot dest_slot trigger \\<Rightarrow>\n        insert_cap_child (IrqHandlerCap irq) control_slot dest_slot\n  \"\n\ndefinition\n  invoke_irq_control :: \"cdl_irq_control_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_irq_control params \\<equiv> case params of\n      \\<comment> \\<open>Create a new IRQ handler cap.\\<close>\n      IssueIrqHandler irq control_slot dest_slot \\<Rightarrow>\n        insert_cap_child (IrqHandlerCap irq) control_slot dest_slot\n    | ArchIssueIrqHandler arch_inv \\<Rightarrow>\n        arch_invoke_irq_control arch_inv\"\n\ndefinition\n  invoke_irq_handler :: \"cdl_irq_handler_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_irq_handler params \\<equiv> case params of\n      \\<comment> \\<open>Acknowledge and unmask an IRQ.\\<close>\n      AckIrq irq \\<Rightarrow> return ()\n\n      \\<comment> \\<open>Attach an IRQ handler to write to an endpoint.\\<close>\n    | SetIrqHandler irq cap slot \\<Rightarrow>\n        do\n          irqslot \\<leftarrow> gets (get_irq_slot irq);\n          delete_cap_simple irqslot;\n          insert_cap_child cap slot irqslot \\<sqinter> insert_cap_sibling cap slot irqslot\n        od\n\n      \\<comment> \\<open>Deassociate this handler with all endpoints.\\<close>\n    | ClearIrqHandler irq \\<Rightarrow>\n        do\n          irqslot \\<leftarrow> gets (get_irq_slot irq);\n          delete_cap_simple irqslot\n        od\n  \"", "property": "IRQ Management: Provides functionality for managing IRQs (Interrupt Requests), including acknowledging and unmasking IRQs, attaching IRQ handlers to endpoints, and deassociating handlers from endpoints.\n\nSubproperties:\n- IRQ Control: Create new IRQ handler capabilities and insert them into specified control slots.\n- IRQ Handler Invocation: Perform actions such as acknowledging and unmasking IRQs, attaching IRQ handlers to endpoints, and deassociating handlers from endpoints.\n- IRQ Slot Management: Delete and insert capabilities in IRQ slots.\n- IRQ State Management: Get the currently pending IRQ and update the IRQ state.", "title": "./spec/capDL/Interrupt_D.thy", "chapter": "", "section": "", "comment": " Return the currently pending IRQ. "}
{"spec": "definition\n  handle_interrupt :: \"cdl_irq \\<Rightarrow> unit k_monad\"\nwhere\n  \"handle_interrupt irq \\<equiv> if irq > maxIRQ then return () else\n    do\n      irq_slot \\<leftarrow> gets $ get_irq_slot irq;\n      c \\<leftarrow> gets $ opt_cap irq_slot;\n      case c of\n          None \\<Rightarrow> return ()\n        | Some cap \\<Rightarrow> (\n            case cap of\n              (NotificationCap obj _ rights) \\<Rightarrow>\n                  if (Write \\<in> rights) then send_signal obj else return ()\n              | _ \\<Rightarrow> return ()\n          )\n    od\n  \"\n\ndefinition\n  handle_pending_interrupts :: \"unit k_monad\"\nwhere\n  \"handle_pending_interrupts \\<equiv>\n    do\n      active \\<leftarrow> get_active_irq;\n      case active of\n          Some irq \\<Rightarrow> handle_interrupt irq\n        | None \\<Rightarrow> return ()\n    od\"\n\nend", "property": "Interrupt Handling: Handle interrupts by checking if the interrupt is valid, retrieving the corresponding capability, and sending a signal to the notification object if the capability has write rights.\n\nSubproperties:\n- Valid Interrupt Check: Verify that the interrupt is within the valid range (less than or equal to maxIRQ).\n- Capability Retrieval: Get the capability associated with the interrupt slot.\n- Signal Sending: Send a signal to the notification object if the capability has write rights.", "title": "./spec/capDL/Interrupt_D.thy", "chapter": "", "section": "", "comment": " Handle an interrupt. "}
{"spec": "translations\n  (type) \"cslot_ptr\" <= (type) \"word32 \\<times> bool list\"\n\ntype_synonym slot_ptr = \"cslot_ptr\"\ntype_synonym slot_region_t = \"nat \\<times> nat\"\ntype_synonym bi_dev_reg_t = \"paddr \\<times> word32 \\<times> slot_region_t\"", "property": "Parameter Types: Define types for parameters passed from the linker script, including cslot_ptr (a tuple of a 32-bit word and a list of booleans), slot_ptr (an alias for cslot_ptr), slot_region_t (a tuple of two natural numbers), and bi_dev_reg_t (a tuple of a physical address, a 32-bit word, and a slot region).", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Parameters passed in from linker script", "comment": ""}
{"spec": "definition\n  \"throw_select S ex \\<equiv> doE\n     whenE (S = {}) (throwError ex);\n     liftE (select S)\n   odE\"", "property": "Select From State: Select an element from a state set S, throwing an exception ex if the set is empty. \n\nThrow Exception When Empty: Throws an exception when the state set S is empty.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Parameters passed in from linker script", "comment": "Select from state S, throw ex if S is empty."}
{"spec": "consts\n  ki_boot_end :: paddr\n  arm_vector_table :: obj_ref\n  arm_kernel_stack :: obj_ref\n  idle_thread_start :: vspace_ref (* &idle_thread *)", "property": "Kernel Initialization State: Defines the initial state of the kernel, including the boot end address, ARM vector table, kernel stack, and idle thread start address.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel Init State", "comment": ""}
{"spec": "text \\<open>Ghost state representing the contents of the boot info frame\\<close>\nrecord bi_frame_data =\n  bi_f_node_id :: word32\n  bi_f_num_nodes :: word32\n  bi_f_num_iopt_levels :: word32\n  bi_f_ipcbuf_vptr :: vspace_ref\n  bi_f_null_caps :: slot_region_t\n  bi_f_sh_frame_caps :: slot_region_t\n  bi_f_ui_frame_caps :: slot_region_t\n  bi_f_ui_pt_caps :: slot_region_t\n  bi_f_ut_obj_caps :: slot_region_t\n  bi_f_ut_obj_paddr_list :: \"paddr list\"\n  bi_f_ut_obj_size_bits_list :: \"word8 list\"\n  bi_f_it_cnode_size_bits :: word8\n  bi_f_num_dev_regs :: word32\n  bi_f_dev_reg_list :: \"bi_dev_reg_t list\"\n\ntype_synonym (* XXX: natural numbers represent components of kernel objects, for those\n              objects that can be subdivided *)\n  component = \"bool list\"", "property": "Boot Info Frame Data: Represents the contents of the boot info frame, including node ID, number of nodes, number of I/O page table levels, IPC buffer virtual pointer, and various capability and object information.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel Init State", "comment": ""}
{"spec": "record ('z) ki_state =\n  ki_kernel_state    :: \"'z state\"\n  ki_free_mem        :: \"obj_ref set\" (* ndks_boot.freemem representative? *)\n  ki_available_mem   :: \"obj_ref set\" (* ghost state *)\n  ki_bootinfo        :: bi_frame_data (* ghost state *)\n  ki_components      :: \"paddr \\<Rightarrow> component set\"\n  ndks_boot_slot_pos_cur :: nat\n  ndks_boot_slot_pos_max :: nat\n  ndks_boot_bi_frame :: paddr", "property": "Kernel Initialization State: The kernel's initial state comprises the basic kernel state and additional information such as free memory, available memory, boot information, and component mappings. \n\nFree Memory Management: Tracks the memory that has not been allocated. \nAvailable Memory Management: Tracks the memory that has been allocated but not yet used (i.e., no objects have been created in it). \nComponent Mapping: Maps each physical address to the set of components that can be accessed within the corresponding object.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel Init State", "comment": "\n  For kernel initialisation, we need the basic kernel state plus some extra\n  information to keep track of, such as free memory.\n  At the concrete level, this is managed by region lists.\n\n  The ``available memory'' indicates memory that has been allocated (and thus\n  no longer free) but that has no objects in it, as it has not been retyped.\n  This is so we can state heap-consuming separation logic predicates which\n  assert that ``there's nothing here'', e.g. so-called untyped objects.\n\n  The components map should have the same domain as the abstract heap in the\n  kernel state, but indicate which components of the object we have permission\n  to access. The purpose is separation logic statements about heaps in which\n  objects can be split up, e.g. only one cap in a CNode.\n"}
{"spec": "text \\<open>\n  The kernel init monad can fail. The actual value of the failure is largely\n  irrelevant, just so long as we don't have assertion failures for no reason.\n\\<close>\n\ndatatype ki_failure = InitFailure\ntype_synonym ('a,'z) ki_monad = \"('z ki_state, ki_failure + 'a) nondet_monad\"\ntranslations\n  (type) \"'a ki_monad\" <=\n    (type) \"((ki_failure + 'a) \\<times> ki_state \\<Rightarrow> bool) \\<times> bool\"", "property": "Kernel Init Monad: Allows the kernel initialization process to handle potential failures in a controlled manner, ensuring that assertion failures do not occur unnecessarily.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init monad", "comment": ""}
{"spec": "definition\n  do_kernel_op :: \"('a,'z::state_ext) s_monad \\<Rightarrow> ('a,'z) ki_monad\" where\n \"do_kernel_op kop \\<equiv> liftE $ do\n    ms \\<leftarrow> gets ki_kernel_state;\n    (r, ms') \\<leftarrow> select_f (kop ms);\n    modify (\\<lambda>ks. ks \\<lparr> ki_kernel_state := ms' \\<rparr>);\n    return r\n  od\"", "property": "Kernel Initialization: Lifts kernel state monad operations to the kernel initialization monad, allowing kernel state operations to be executed within the kernel initialization context. \n\nKernel State Management: Ensures that kernel state operations are properly executed and the resulting state is updated in the kernel initialization context.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init monad", "comment": "Lift kernel state monad ops to the kernel init monad."}
{"spec": "definition \"MIN_NUM_4K_UNTYPED_OBJ \\<equiv> 12 :: nat\"\ndefinition \"MAX_NUM_FREEMEM_REG \\<equiv> 2 :: nat\"", "property": "Kernel Constants: Define the minimum number of 4K untyped objects and the maximum number of free memory regions. \n\nMinimum Untyped Objects: The minimum number of 4K untyped objects is 12.\nMaximum Free Memory Regions: The maximum number of free memory regions is 2.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel constants", "comment": ""}
{"spec": "definition \"BI_CAP_NULL         \\<equiv>  0 :: nat\"\ndefinition \"BI_CAP_IT_TCB       \\<equiv>  1 :: nat\"\ndefinition \"BI_CAP_IT_CNODE     \\<equiv>  2 :: nat\"\ndefinition \"BI_CAP_IT_PD        \\<equiv>  3 :: nat\"\ndefinition \"BI_CAP_IRQ_CTRL     \\<equiv>  4 :: nat\"\ndefinition \"BI_CAP_ASID_CTRL    \\<equiv>  5 :: nat\"\ndefinition \"BI_CAP_IT_ASID_POOL \\<equiv>  6 :: nat\"\ndefinition \"BI_CAP_IO_PORT      \\<equiv>  7 :: nat\"\ndefinition \"BI_CAP_IO_SPACE     \\<equiv>  8 :: nat\"\ndefinition \"BI_CAP_BI_FRAME     \\<equiv>  9 :: nat\"\ndefinition \"BI_CAP_IT_IPCBUF    \\<equiv> 10 :: nat\"\ndefinition \"BI_CAP_DYN_START    \\<equiv> 11 :: nat\"\n\ndefinition \"BI_FRAME_SIZE_BITS \\<equiv> pageBits\"\ndefinition \"ROOT_CNODE_SIZE_BITS \\<equiv> 12 :: nat\"", "property": "Kernel Constants: Define fixed capability positions in the root CNode and other kernel constants, such as frame size and root CNode size, to ensure consistent and efficient kernel operation.\n\n Capability Positions: Specify the fixed positions of various capabilities in the root CNode, including null, TCB, CNode, page directory, IRQ control, ASID control, ASID pool, I/O port, I/O space, bootinfo frame, and IPC buffer. \n\n Kernel Parameters: Define the size of a frame and the root CNode in terms of bits, determining the kernel's memory management and capability allocation.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel constants", "comment": "Fixed cap positions in root CNode (bootinfo.h)"}
{"spec": "definition \"PPTR_VECTOR_TABLE \\<equiv> 0xffff0000 :: word32\"\ndefinition \"PPTR_GLOBALS_PAGE \\<equiv> 0xffffc000 :: word32\"\ndefinition \"PPTR_KERNEL_STACK \\<equiv> 0xfffff000 :: word32\"\n\ndefinition \"IT_ASID     \\<equiv> 1 :: asid\" (* initial thread ASID *)\n\ndefinition \"WORD_SIZE_BITS \\<equiv> 2 :: nat\"\ndefinition \"ASID_POOL_BITS \\<equiv> asid_low_bits :: nat\"\ndefinition \"ASID_POOL_SIZE_BITS \\<equiv> ASID_POOL_BITS + WORD_SIZE_BITS\"\n\ndefinition \"CTE_SIZE_BITS \\<equiv> 4 :: nat\" (* from ARM structures.h *)", "property": "ARM Constants Definition: Define various ARM architecture-specific constants, including memory addresses for vector tables, global pages, and kernel stacks, as well as constants for ASID, word size, and CTE size. \n\nMemory Layout Constants: Define memory addresses for specific components, including the vector table, global page, and kernel stack.\n\nSystem Configuration Constants: Define system configuration parameters, including the initial thread ASID, word size, ASID pool size, and CTE size.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "ARM constants", "comment": ""}
{"spec": "definition \"PD_BITS \\<equiv> 12 :: nat\"\ndefinition \"PT_BITS \\<equiv> 8 :: nat\"\n\ndefinition \"PDE_SIZE_BITS \\<equiv> 2 :: nat\"\ndefinition \"PTE_SIZE_BITS \\<equiv> 2 :: nat\"", "property": "Page Table Constants: Define the size and layout of page tables and directories, specifying the number of bits used for page directory and table entries, as well as the size of these entries in bits. \n\nSubproperties:\n- Page Directory Bits: 12 bits are used for page directory entries.\n- Page Table Bits: 8 bits are used for page table entries.\n- Page Directory Entry Size Bits: 2 bits are used to represent the size of page directory entries.\n- Page Table Entry Size Bits: 2 bits are used to represent the size of page table entries.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "ARM constants", "comment": "in abstract, these do not have a direct equivalent"}
{"spec": "definition \"PD_SIZE_BITS \\<equiv> PD_BITS + PDE_SIZE_BITS\"\ndefinition \"PT_SIZE_BITS \\<equiv> PT_BITS + PTE_SIZE_BITS\"", "property": "Page Table Size Properties: Define the size of page directories (PD) and page tables (PT) in terms of their respective bit lengths and entry sizes. \n\n- Page Directory Size: The size of a page directory is determined by the sum of the page directory bits and the page directory entry size bits.\n- Page Table Size: The size of a page table is determined by the sum of the page table bits and the page table entry size bits.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "ARM constants", "comment": "in abstract, these are pd_bits and pt_bits respectively"}
{"spec": "definition \"irqInvalid       \\<equiv> 255 :: irq\"\ndefinition \"INTERRUPT_PMU    \\<equiv> 23 :: irq\"\ndefinition \"INTERRUPT_EPIT1  \\<equiv> 28 :: irq\"\ndefinition \"KERNEL_TIMER_IRQ \\<equiv> INTERRUPT_EPIT1\"", "property": "Platform Constants: Define specific interrupt request (IRQ) constants for the iMX31 platform, including invalid IRQ, and IRQs for the performance monitoring unit (PMU), EPIT1 timer, and kernel timer.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Platform constants (iMX31)", "comment": ""}
{"spec": "definition \"EPIT_PADDR \\<equiv> 0x53f94000 :: word32\"\ndefinition \"EPIT_PPTR  \\<equiv> 0xfff00000 :: word32\"\ndefinition \"AVIC_PADDR \\<equiv> 0x68000000 :: word32\"\ndefinition \"AVIC_PPTR  \\<equiv> 0xfff01000 :: word32\"\ndefinition \"L2CC_PADDR \\<equiv> 0x30000000 :: word32\"\ndefinition \"L2CC_PPTR  \\<equiv> 0xfff02000 :: word32\"\ndefinition \"UART_PADDR \\<equiv> 0x43f90000 :: word32\"\ndefinition \"UART_PPTR  \\<equiv> 0xfff03000 :: word32\"\n\ndefinition \"BASE_OFFSET = pptrBaseOffset\"", "property": "Platform Constants: Define the physical and virtual addresses of various kernel devices for the iMX31 platform, including EPIT, AVIC, L2CC, and UART, as well as the base offset for the platform.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Platform constants (iMX31)", "comment": "Kernel devices for imx31"}
{"spec": "text \\<open>\n  These shadow the normal functions, but do not force a well-formedness\n  check for the cnodes, as wellformed\\_cnode\\_sz is non-local with respect\n  to individual caps, and so get\\_cap and set\\_cap are also.\\<close>\n\ndefinition\n  get_cap_local :: \"cslot_ptr \\<Rightarrow> (cap,'z::state_ext) s_monad\"\nwhere\n  \"get_cap_local \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     caps \\<leftarrow> case obj of\n             CNode sz cnode \\<Rightarrow> return cnode\n           | TCB tcb     \\<Rightarrow> return (tcb_cnode_map tcb)\n           | _ \\<Rightarrow> fail;\n     assert_opt (caps cref)\n   od\"\n\ndefinition\n  set_cap_local :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_cap_local cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     obj' \\<leftarrow> case obj of\n               CNode sz cn \\<Rightarrow> if cref \\<in> dom cn\n                                then return $ CNode sz $ cn (cref \\<mapsto> cap)\n                                else fail\n             | TCB tcb \\<Rightarrow>\n                   if cref = tcb_cnode_index 0 then\n                       return $ TCB $ tcb \\<lparr> tcb_ctable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 1 then\n                       return $ TCB $ tcb \\<lparr> tcb_vtable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 2 then\n                       return $ TCB $ tcb \\<lparr> tcb_reply := cap \\<rparr>\n                   else if cref = tcb_cnode_index 3 then\n                       return $ TCB $ tcb \\<lparr> tcb_caller := cap \\<rparr>\n                   else if cref = tcb_cnode_index 4 then\n                       return $ TCB $ tcb \\<lparr> tcb_ipcframe := cap \\<rparr>\n                   else\n                       fail\n             | _ \\<Rightarrow> fail;\n     set_object oref obj'\n  od\"\n\ndefinition\n  set_untyped_cap_as_full_local :: \"cap \\<Rightarrow> cap \\<Rightarrow> word32 \\<times> bool list\\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_untyped_cap_as_full_local src_cap new_cap src_slot \\<equiv>\n   if (is_untyped_cap src_cap \\<and> is_untyped_cap new_cap\n       \\<and> obj_ref_of src_cap = obj_ref_of new_cap \\<and> cap_bits_untyped src_cap = cap_bits_untyped new_cap)\n       then set_cap_local (max_free_index_update src_cap) src_slot else return ()\"\n\ndefinition\n  cap_insert_local :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"cap_insert_local new_cap src_slot dest_slot \\<equiv> do\n    src_cap \\<leftarrow> get_cap_local src_slot;\n\n    dest_original \\<leftarrow> return (if is_ep_cap new_cap then\n                                cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n                             else if is_ntfn_cap new_cap then\n                                cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n                             else if \\<exists>irq. new_cap = IRQHandlerCap irq then\n                                src_cap = IRQControlCap\n                             else is_untyped_cap new_cap);\n    old_cap \\<leftarrow> get_cap_local dest_slot;\n    assert (old_cap = NullCap);\n    set_untyped_cap_as_full_local src_cap new_cap src_slot;\n    set_cap_local new_cap dest_slot;\n\n    is_original \\<leftarrow> gets is_original_cap;\n    src_parent \\<leftarrow> return $\n       should_be_parent_of src_cap (is_original src_slot) new_cap dest_original;\n    src_p \\<leftarrow> gets (\\<lambda>s. cdt s src_slot);\n    dest_p \\<leftarrow> gets (\\<lambda>s. cdt s dest_slot);\n    update_cdt (\\<lambda>cdt. cdt (dest_slot := if src_parent\n                                        then Some src_slot\n                                        else cdt src_slot));\n    do_extended_op (cap_insert_ext src_parent src_slot dest_slot src_p dest_p);\n    set_original dest_slot dest_original\n  od\"\n\ndefinition\n  \"setup_reply_master_local thread \\<equiv> do\n     old_cap <- get_cap_local (thread, tcb_cnode_index 2);\n     when (old_cap = NullCap) $ do\n         set_original (thread, tcb_cnode_index 2) True;\n         set_cap_local (ReplyCap thread True) (thread, tcb_cnode_index 2)\n     od\n  od\"", "property": "Capability Management: Provides functions for managing capabilities, including retrieving, setting, and inserting capabilities, while maintaining the integrity of the capability derivation tree (CDT) and ensuring that capabilities are correctly updated and tracked.\n\nSubproperties:\n- Get Capability: Retrieves a capability from a specified slot, handling different object types (CNode, TCB, etc.).\n- Set Capability: Sets a capability in a specified slot, ensuring that the object type and slot index are valid.\n- Insert Capability: Inserts a new capability into a destination slot, updating the CDT and performing necessary checks for untyped capabilities, endpoint badges, and notification badges.\n- Setup Reply Master: Sets up a reply master capability for a thread, ensuring that the reply capability is correctly set and marked as original.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Functions cloned and modified for separation logic to work", "comment": ""}
{"spec": "consts \n  sync_bootinfo_frame :: \"paddr \\<Rightarrow> (unit,'z::state_ext) ki_monad\"\n\ndefinition \n      returnOk pptr\n   odE\"\n\ndefinition\n  create_idle_thread :: \"(unit,'z::state_ext) ki_monad\" where\n  \"create_idle_thread \\<equiv> doE\n     pptr \\<leftarrow> create_objects (obj_bits $ TCB undefined)\n                           (obj_bits $ TCB undefined) TCBObject;\n     do_kernel_op $ do\n       modify (\\<lambda>s. s \\<lparr> idle_thread := pptr \\<rparr>);\n       configure_idle_thread pptr\n     od\n   odE\"\n\ndefinition\n  create_root_cnode :: \"(cap,'z::state_ext) ki_monad\" where\n  \"create_root_cnode \\<equiv>\n   let sz = (ROOT_CNODE_SIZE_BITS + CTE_SIZE_BITS) in\n   doE\n     liftE $ modify\n               (\\<lambda>s. s \\<lparr> ndks_boot_slot_pos_max := 2 ^ ROOT_CNODE_SIZE_BITS \\<rparr>);\n\n     pptr \\<leftarrow> create_objects sz sz CapTableObject;\n\n     let cap = CNodeCap pptr ROOT_CNODE_SIZE_BITS\n                             (replicate (32 - ROOT_CNODE_SIZE_BITS) False)\n     in (doE\n           do_kernel_op $ write_slot (cap_slot_pptr cap BI_CAP_IT_CNODE) cap;\n           returnOk cap\n         odE)\n   odE\"\n\ndefinition\n  create_irq_cnode :: \"(unit,'z::state_ext) ki_monad\" where\n  \"create_irq_cnode \\<equiv> doE", "property": "Kernel Initialization: Set up the kernel's initial state by creating essential objects, including the idle thread, root capability node, and interrupt request (IRQ) capability node, ensuring the kernel's fundamental structures are properly initialized for secure and efficient operation.\n\nSubproperties:\n- Idle Thread Creation: Create the idle thread, configuring its properties and setting it as the kernel's idle thread.\n- Root Capability Node Creation: Create the root capability node, initializing its properties and writing its capability to the appropriate slot.\n- IRQ Capability Node Creation: Create the IRQ capability node, ensuring proper interrupt handling and management.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": ""}
{"spec": "pptr \\<leftarrow> create_objects pageBits CTE_SIZE_BITS CapTableObject;", "property": "Kernel Initialization: Create a page of capability nodes (cnodes) with each node containing a single capability table entry (CTE), effectively initializing a capability table page.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " Make a page full of cnodes with one CTE each. At the C level\n        this is of course just an array of CTEs taking up the whole page. "}
{"spec": "do_kernel_op $ modify\n               (\\<lambda>s. s \\<lparr> interrupt_irq_node :=\n                        (\\<lambda>irq. pptr + ucast irq * of_nat CTE_SIZE_BITS) \\<rparr>)\n   odE\"\n\ndefinition\n  create_it_frame_cap :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> asid option \\<Rightarrow> bool \\<Rightarrow> (cap,'z::state_ext) ki_monad\"\n  where\n  \"create_it_frame_cap pptr vptr asid use_large \\<equiv>\n   let sz = if use_large then ARMLargePage else ARMSmallPage in\n     returnOk $ ArchObjectCap $ PageCap pptr {AllowRead,AllowWrite}\n                                        sz (map_option (\\<lambda>a. (a, vptr)) asid)\"\n\ndefinition\n  create_ipcbuf_frame :: \"cap \\<Rightarrow> (vspace_ref \\<times> vspace_ref)\n                          \\<Rightarrow> (cap \\<times> vspace_ref,'z::state_ext) ki_monad\" where\n  \"create_ipcbuf_frame root_cnode_cap ui_v_reg \\<equiv>\n   let vptr = snd ui_v_reg (* ui_v_reg.end *)\n   in\n   doE\n     pptr \\<leftarrow> alloc_region pageBits;\n     do_kernel_op $ do_machine_op $ clearMemory pptr pageBits;\n\n     cap \\<leftarrow> create_it_frame_cap pptr vptr (Some IT_ASID) False;\n\n     do_kernel_op $\n       write_slot (cap_slot_pptr root_cnode_cap BI_CAP_IT_IPCBUF) cap;\n\n     returnOk (cap, vptr)\n   odE\"\n\ndefinition\n  create_bi_frame :: \"cap \\<Rightarrow> (vspace_ref \\<times> vspace_ref) \\<Rightarrow> vspace_ref \\<Rightarrow> word32\n                      \\<Rightarrow> word32 \\<Rightarrow> (vspace_ref,'z::state_ext) ki_monad\" where\n  \"create_bi_frame root_cnode_cap ui_v_reg ipcbuf_vptr node_id num_nodes \\<equiv>\n   let vptr = ipcbuf_vptr + of_nat (2 ^ pageBits)\n   in\n   doE\n     pptr \\<leftarrow> alloc_region BI_FRAME_SIZE_BITS;", "property": "Kernel Initialization: Associate each interrupt request (IRQ) with a cnode and initialize the interrupt_irq_node mapping accordingly.\n\n Subproperties:\n- Create IT Frame Capability: Create a page capability for a given physical address, virtual address, and optional address space identifier (ASID), with specified access rights and page size.\n- Create IPC Buffer Frame: Allocate a new page for the IPC buffer, clear its memory, create a page capability for it, and write the capability to the specified slot in the root cnode.\n- Create Boot Info Frame: Allocate a new frame for boot information, with a specified size, and return its virtual address.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " Now associate each cnode with an irq "}
{"spec": "liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_node_id := node_id,\n       bi_f_num_nodes := num_nodes,\n       bi_f_num_iopt_levels := 0,\n       bi_f_ipcbuf_vptr := ipcbuf_vptr,\n       bi_f_it_cnode_size_bits := of_nat ROOT_CNODE_SIZE_BITS \\<rparr>\\<rparr>);", "property": "Boot Info Frame Update: Update the abstract representation of the boot info frame with the provided node ID, number of nodes, IPC buffer virtual pointer, and root CNode size bits.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " update in abstract representation of boot info frame "}
{"spec": "sync_bootinfo_frame pptr;\n\n     liftE $ modify (\\<lambda>s. s \\<lparr> ndks_boot_bi_frame := pptr,\n                             ndks_boot_slot_pos_cur := BI_CAP_DYN_START \\<rparr> );\n\n     cap \\<leftarrow> create_it_frame_cap pptr vptr (Some IT_ASID) False;\n     do_kernel_op $\n       write_slot (cap_slot_pptr root_cnode_cap BI_CAP_BI_FRAME) cap;\n\n     returnOk vptr\n   odE\"\n\ndefinition\n  create_it_asid_pool :: \"cap \\<Rightarrow> (cap,'z::state_ext) ki_monad\" where\n  \"create_it_asid_pool root_cnode_cap \\<equiv> doE", "property": "Kernel Initialization: Synchronize the abstract bootinfo with the boot info frame by updating the bootinfo frame pointer and slot position, creating an IT frame capability, and writing it to the corresponding slot in the root CNode. \n\n Bootinfo Frame Initialization: Update the bootinfo frame pointer and slot position in the kernel state. \n\n IT Frame Capability Creation: Create an IT frame capability with the given parameters (physical pointer, virtual pointer, ASID, and executable flag). \n\n Root CNode Update: Write the created IT frame capability to the corresponding slot in the root CNode.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " synchronise abstract bootinfo with boot info frame "}
{"spec": "ap_pptr \\<leftarrow> create_objects ASID_POOL_SIZE_BITS\n                              ASID_POOL_SIZE_BITS (ArchObject ASIDPoolObj);\n\n     ap_cap \\<leftarrow> returnOk $ ArchObjectCap $\n                 ASIDPoolCap ap_pptr (IT_ASID >> asid_low_bits);\n\n     do_kernel_op $ write_slot (cap_slot_pptr root_cnode_cap\n                                BI_CAP_IT_ASID_POOL) ap_cap;", "property": "Kernel Initialization: Create an ASID pool with the specified size and initialize its capability. The ASID pool capability is then written to the designated slot in the root CNode.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create ASID pool "}
{"spec": "do_kernel_op $ write_slot (cap_slot_pptr root_cnode_cap BI_CAP_ASID_CTRL)\n                               (ArchObjectCap ASIDControlCap);\n\n     returnOk ap_cap\n   odE\"\n\ndefinition\n  create_frames_of_region :: \"cap \\<Rightarrow> (paddr \\<times> paddr) \\<Rightarrow> bool \\<Rightarrow> word32\n                              \\<Rightarrow> (nat \\<times> nat,'z::state_ext) ki_monad\" where\n  \"create_frames_of_region root_cnode_cap reg do_map pv_offset \\<equiv> doE\n\n     slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n     (swp mapME)\n       [(fst reg),(fst reg + of_nat (2 ^ pageBits)) .e. (snd reg - 1)]\n       (\\<lambda>f. doE\n              frame_cap \\<leftarrow> (if do_map\n                           then create_it_frame_cap f\n                                  (f - BASE_OFFSET - pv_offset) (Some IT_ASID) False\n                           else create_it_frame_cap f 0 None False);\n              provide_cap root_cnode_cap frame_cap\n            odE);\n\n     slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n     returnOk (slot_pos_before, slot_pos_after)\n   odE\"\n\ndefinition\n  write_it_asid_pool :: \"cap \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"write_it_asid_pool it_ap_cap it_pd_cap \\<equiv>\n   let ap_ptr = obj_ref_of it_ap_cap;\n       pd_ptr = obj_ref_of it_pd_cap;\n       asid_idx = ucast (IT_ASID >> asid_low_bits)\n   in\n   do\n     ap \\<leftarrow> get_asid_pool ap_ptr;\n     ap' \\<leftarrow> return (ap (ucast IT_ASID \\<mapsto> pd_ptr));\n     set_asid_pool ap_ptr ap';\n\n     asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n     asid_table' \\<leftarrow> return (asid_table(asid_idx \\<mapsto> ap_ptr));\n     modify (\\<lambda>s. s \\<lparr> arch_state :=\n                      arch_state s \\<lparr> arm_asid_table := asid_table' \\<rparr>\\<rparr>)\n\n   od\"\n\ndefinition\n  map_it_pt_cap :: \"cap \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"map_it_pt_cap pd_cap pt_cap \\<equiv> do\n\n     pd \\<leftarrow> return $ obj_ref_of pd_cap; (* C uses specific PD version *)\n\n     (pt,vptr) \\<leftarrow> return $ case the_arch_cap pt_cap\n                            of PageTableCap ref (Some (_, vref)) \\<Rightarrow> (ref,vref);\n\n     slot \\<leftarrow> return $ vptr >> pageBitsForSize ARMSection;", "property": "Kernel Initialization: Create essential kernel data structures and mappings, including the ASID control capability, page frames, and page tables, to establish a functional kernel environment. \n\nSubproperties:\n- Create ASID Control Capability: Initialize the ASID control capability in the root capability node to manage address space identifiers.\n- Create Page Frames: Allocate and map page frames within a specified region to establish a usable memory space.\n- Map Page Tables: Map page tables to page directories to enable virtual memory translation and management.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create ASID control cap "}
{"spec": "pde \\<leftarrow> return $ PageTablePDE (addrFromPPtr pt) {ParityEnabled} 0;\n\n     pd_obj \\<leftarrow> get_object pd;\n     pd_obj' \\<leftarrow> return (case pd_obj\n                         of ArchObj (PageDirectory table)\n                            \\<Rightarrow> ArchObj (PageDirectory $ table(ucast slot := pde)\n                       ));\n     set_object pd pd_obj'\n   od\"\n\ndefinition\n  map_it_frame_cap :: \"cap \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"map_it_frame_cap pd_cap frame_cap \\<equiv> do\n\n     pd \\<leftarrow> return $ obj_ref_of pd_cap;\n\n     (frame, vptr) \\<leftarrow> return $ case the_arch_cap frame_cap\n                       of PageCap ref _ _ (Some (_, vptr)) \\<Rightarrow> (ref, vptr);\n\n     pd_obj \\<leftarrow> get_object pd;\n     pde \\<leftarrow> return $ case pd_obj\n                      of ArchObj (PageDirectory table)\n                         \\<Rightarrow> table (ucast (vptr >> pageBitsForSize ARMSection));\n\n     pt \\<leftarrow> return (case pde of PageTablePDE ref _ _ \\<Rightarrow> ptrFromPAddr ref);\n\n     slot \\<leftarrow> return $ (vptr && mask (pageBitsForSize ARMSection))\n                              >> pageBitsForSize ARMSmallPage;\n\n     pte \\<leftarrow> return $ SmallPagePTE (addrFromPPtr frame) {PageCacheable}\n                                 vm_read_write;\n     pt_obj \\<leftarrow> get_object pt;\n     pt_obj' \\<leftarrow> return (case pt_obj\n                         of ArchObj (PageTable table)\n                            \\<Rightarrow> ArchObj (PageTable $ table(ucast slot := pte)));\n     set_object pt pt_obj'\n   od\"\n\ndefinition\n  write_it_pd_pts :: \"cap \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"write_it_pd_pts root_cnode_cap it_pd_cap \\<equiv> doE\n\n     do_kernel_op $ copy_global_mappings $ obj_ref_of it_pd_cap;", "property": "Kernel Initialization Functions: Enable ECC by setting the ParityEnable bit, and map IT frame capabilities to page tables, ensuring correct memory access and caching. \n\nSubproperties:\n1. Parity Enable: Set the ParityEnable bit to enable ECC.\n2. Map IT Frame Capabilities: Map IT frame capabilities to page tables, ensuring correct memory access and caching. \n3. Write IT PD PTS: Write IT page directory and page table entries, ensuring correct memory mappings.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " C code sets ParityEnable bit, which is apparently to enable ECC "}
{"spec": "(start, end) \\<leftarrow> liftE $ gets (bi_f_ui_pt_caps \\<circ> ki_bootinfo);\n\n     do_kernel_op $\n       (swp mapM)\n          [start..<end]\n          (\\<lambda>pos. do\n                   cap \\<leftarrow> get_cap_local $ cap_slot_pptr root_cnode_cap pos;\n                   map_it_pt_cap it_pd_cap cap\n                 od);", "property": "Kernel Initialization: Map page tables into page directories. \n\n Map Page Tables: Iterate over a range of page table positions, retrieve the corresponding capability, and map it into the page directory using the provided page directory capability.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map PTs into PD "}
{"spec": "(start, end) \\<leftarrow> liftE $ gets (bi_f_ui_frame_caps \\<circ> ki_bootinfo);\n\n     do_kernel_op (do\n       (swp mapM)\n          [start..<end]\n          (\\<lambda>pos. do\n                   cap \\<leftarrow> get_cap_local $ cap_slot_pptr root_cnode_cap pos;\n                   map_it_frame_cap it_pd_cap cap\n                 od);\n\n       cap \\<leftarrow> get_cap_local $ cap_slot_pptr root_cnode_cap BI_CAP_IT_IPCBUF;\n       map_it_frame_cap it_pd_cap cap;\n       cap \\<leftarrow> get_cap_local $ cap_slot_pptr root_cnode_cap BI_CAP_BI_FRAME;\n       map_it_frame_cap it_pd_cap cap\n     od)\n   odE\"\n\ndefinition\n  bi_finalise :: \"(unit,'z::state_ext) ki_monad\" where\n  \"bi_finalise \\<equiv> doE\n     slot_pos_start \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n     slot_pos_end \\<leftarrow> liftE $ gets ndks_boot_slot_pos_max;\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_null_caps := (of_nat slot_pos_start, of_nat slot_pos_end) \\<rparr>\\<rparr>);\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame\n   odE\"\n\ndefinition\n  create_it_pd_pts :: \"cap \\<Rightarrow> (vspace_ref \\<times> vspace_ref) \\<Rightarrow> vspace_ref\n                       \\<Rightarrow> vspace_ref \\<Rightarrow> (cap,'z::state_ext) ki_monad\" where\n  \"create_it_pd_pts root_cnode_cap ui_v_reg ipcbuf_vptr bi_frame_vptr \\<equiv> doE", "property": "Kernel Initialization: Map frames into page tables (PTs) and finalize boot information. This involves mapping frames into PTs using the provided capability pointers, and updating the boot information with the final null capability positions and synchronizing the bootinfo frame.\n\nSubproperties:\n- Map Frames into PTs: Map frames into page tables using the provided capability pointers.\n- Finalize Boot Information: Update the boot information with the final null capability positions and synchronize the bootinfo frame.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map frames into PTs "}
{"spec": "pd_pptr \\<leftarrow> create_objects PD_SIZE_BITS PD_SIZE_BITS\n                              (ArchObject PageDirectoryObj);\n     pd_cap \\<leftarrow> returnOk $ ArchObjectCap $\n                           PageDirectoryCap pd_pptr (Some IT_ASID);\n     do_kernel_op $ write_slot (cap_slot_pptr root_cnode_cap BI_CAP_IT_PD)\n                               pd_cap;", "property": "Kernel Initialization: Create a Page Directory (PD) object and its corresponding capability, then write the PD capability to the designated slot in the root capability node.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create PD obj and cap "}
{"spec": "(ui_v_reg_start, ui_v_reg_end) \\<leftarrow>\n         returnOk (fst ui_v_reg, bi_frame_vptr + 2 ^ BI_FRAME_SIZE_BITS);", "property": "Userland Image Initialization: The kernel initializes the userland image by including the IPC buffer and bootinfo frames within a specific virtual address range.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " include IPC buffer and bootinfo frames in the userland image "}
{"spec": "slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n     start \\<leftarrow> returnOk $ round_down ui_v_reg_start (PD_BITS + pageBits);\n     next \\<leftarrow> returnOk $ start + (2 ^ (PT_BITS + pageBits));\n\n     (swp mapME) [start,next .e. ui_v_reg_end] (\\<lambda>pt_vptr. doE\n\n       pt_pptr \\<leftarrow> alloc_region PT_SIZE_BITS;\n       do_kernel_op $ retype_region pt_pptr 1 PT_SIZE_BITS\n                                            (ArchObject PageTableObj);\n\n       provide_cap root_cnode_cap $\n         ArchObjectCap $ PageTableCap pt_pptr (Some (IT_ASID, pt_vptr))\n     odE);\n\n     slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_ui_pt_caps := (of_nat slot_pos_before, of_nat slot_pos_after) \\<rparr>\\<rparr>);\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame;\n\n     returnOk pd_cap\n   odE\"\n\ndefinition\n  create_initial_thread :: \"cap \\<Rightarrow> cap \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref\n                            \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"create_initial_thread root_cnode_cap it_pd_cap ui_v_entry bi_frame_vptr\n                         ipcbuf_vptr ipcbuf_cap \\<equiv>\n   let tcb_bits = obj_bits $ TCB undefined\n   in\n   doE", "property": "Kernel Initialization: Create all page table objects and capabilities necessary to cover the userland image, and initialize the bootinfo frame with the slot positions of the page table capabilities. \n\nCreate Initial Thread: Set up the initial thread with the given capabilities, virtual space references, and IPC buffer information.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create all PT objs and caps necessary to cover userland image "}
{"spec": "tcb_pptr \\<leftarrow> create_objects tcb_bits tcb_bits TCBObject;", "property": "TCB Allocation: Allocate memory for a Thread Control Block (TCB) during kernel initialization, ensuring that the TCB is properly initialized and ready for use.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " allocate TCB "}
{"spec": "do_kernel_op $ (do\n     cap_insert_local root_cnode_cap (cap_slot_pptr root_cnode_cap BI_CAP_IT_CNODE)\n                               (tcb_pptr, tcb_cnode_index 0); (* tcbCTable *)\n     cap_insert_local root_cnode_cap (cap_slot_pptr root_cnode_cap BI_CAP_IT_PD)\n                               (tcb_pptr, tcb_cnode_index 1); (* tcbVTable *)\n     cap_insert_local root_cnode_cap (cap_slot_pptr root_cnode_cap BI_CAP_IT_IPCBUF)\n                               (tcb_pptr, tcb_cnode_index 4); (* tcbBuffer *)\n\n     tcb_obj \\<leftarrow> get_object tcb_pptr;\n     tcb_obj' \\<leftarrow> return $\n                case tcb_obj\n                  of TCB tcb \\<Rightarrow> TCB (tcb\\<lparr>tcb_ipc_buffer := ipcbuf_vptr\\<rparr>);\n     set_object tcb_pptr tcb_obj';\n\n     as_user tcb_pptr $ set_register CPSR 0x1f;\n     as_user tcb_pptr $ setNextPC ui_v_entry;", "property": "Kernel Initialization: Set up the initial kernel context by inserting required capabilities into the root CNode, configuring the TCB object, setting the IPC buffer, and initializing the CPU state for the first thread.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " Arch_initContext should be implicit in retype_region "}
{"spec": "setup_reply_master_local tcb_pptr;\n     set_thread_state tcb_pptr Running;", "property": "Kernel Initialization: Set up the initial state of a thread control block (TCB) by establishing the reply master and setting the thread state to running.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " TCB priority not in abstract spec "}
{"spec": "idle_thread \\<leftarrow> gets idle_thread;\n     modify (\\<lambda>s. s\\<lparr> cur_thread := idle_thread \\<rparr>);\n\n     switch_to_thread tcb_pptr;\n\n     cap \\<leftarrow> return $ ThreadCap tcb_pptr;\n     write_slot (cap_slot_pptr root_cnode_cap BI_CAP_IT_TCB) cap\n   od)\n   odE\"\n\ndefinition\n  create_device_frames :: \"cap \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"create_device_frames root_cnode_cap \\<equiv> doE\n     dev_regs \\<leftarrow> do_kernel_op $ do_machine_op getDeviceRegions;\n\n     (swp mapME) dev_regs (\\<lambda>(start,end). doE", "property": "Kernel Initialization: Set up the initial kernel state by switching to the idle thread, setting the current thread, and writing the thread capability to the root CNode. \n\nDevice Frame Creation: Create device frames by retrieving device regions and mapping each region to a device frame.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " scheduler action not in abstract spec "}
{"spec": "frame_size \\<leftarrow>\n         returnOk $ if (is_aligned start (pageBitsForSize ARMSection)\n                        \\<and> is_aligned end (pageBitsForSize ARMSection))\n                    then ARMSection\n                    else ARMSmallPage;\n\n       slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n       (swp mapME) [start,(start + 2^(pageBitsForSize frame_size))\n                       .e. (end - 1)]\n         (\\<lambda>f. doE\n                frame_cap \\<leftarrow> create_it_frame_cap f 0 None\n                                                (frame_size = ARMSection);\n                provide_cap root_cnode_cap frame_cap\n              odE);\n\n       slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n       bi_dev_reg \\<leftarrow> returnOk (addrFromPPtr start,\n                              of_nat (pageBitsForSize frame_size),\n                              (slot_pos_before, slot_pos_after));\n\n       liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n         bi_f_dev_reg_list := (bi_f_dev_reg_list $\n                                 ki_bootinfo s) @ [bi_dev_reg]\n         \\<rparr>\\<rparr>);\n\n       bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n       sync_bootinfo_frame bi_frame\n\n     odE);\n\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_num_dev_regs := of_nat $ length (bi_f_dev_reg_list $\n                                               ki_bootinfo s)\n       \\<rparr>\\<rparr>);\n\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame\n   odE\"\n\nfun (* for (ptr,bits)-style regions which don't straddle the end of memory *)\n  no_region_overlap :: \"(paddr \\<times> nat) \\<Rightarrow> (paddr \\<times> nat) \\<Rightarrow> bool\" where\n  \"no_region_overlap (ptr1,bits1) (ptr2,bits2) =\n     ({ptr1 .. ptr1 + 2 ^ bits1 - 1} \\<inter> {ptr2 .. ptr2 + 2 ^ bits2 - 1} = {})\"\n\ndefinition\n  freemem_regions :: \"obj_ref set \\<Rightarrow> ((paddr \\<times> nat) list,'z::state_ext) s_monad\" where\n  \"freemem_regions free \\<equiv> do\n     regs \\<leftarrow> select {lst. (\\<forall>(ptr,bits) \\<in> set lst. is_aligned ptr bits \\<and>\n                                           {ptr .. ptr + 2 ^ bits - 1} \\<subseteq> free)\n                         \\<and> distinct_prop no_region_overlap lst};\n     return regs\n   od\"\n\ndefinition\n  create_untyped_obj :: \"cap \\<Rightarrow> (paddr \\<times> paddr) \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"create_untyped_obj root_cnode_cap boot_mem_reuse_reg \\<equiv> doE\n\n     slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;", "property": "Kernel Initialization: \nUse the largest possible frame size (1M or 4K) for memory allocation based on alignment, and initialize the kernel by creating frames, providing capabilities, and updating boot information.\n\n Untyped Object Creation: \nCreate an untyped object in the kernel, which involves getting the current slot position, and preparing for the creation of the object.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " use 1M frames if possible, else 4K frames "}
{"spec": "(swp mapME) [fst boot_mem_reuse_reg,(fst boot_mem_reuse_reg + 2^pageBits)\n                   .e. (snd boot_mem_reuse_reg - 1)]\n                  (\\<lambda>i. provide_untyped_cap root_cnode_cap i pageBits\n                                           slot_pos_before);", "property": "Kernel Initialization: Reuse boot code and data frames by providing untyped capabilities for each frame in the boot memory reuse region, allowing the kernel to efficiently manage and allocate memory.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " re-use boot code/data frames "}
{"spec": "slot_pos_cur \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n     (swp mapME) [(slot_pos_cur - slot_pos_before)..<MIN_NUM_4K_UNTYPED_OBJ]\n       (\\<lambda>i. doE\n              pptr \\<leftarrow> alloc_region pageBits;\n              provide_untyped_cap root_cnode_cap pptr pageBits slot_pos_before\n            odE);", "property": "Kernel Initialization: Allocate and provide a minimum number of 4K untyped objects as requested during kernel initialization. \n\n Untyped Object Allocation: Allocate a region of memory of a specified size (pageBits) and provide an untyped capability for the allocated memory in the root CNode.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " allocate and provide the minimum number of 4K UT objects requested "}
{"spec": "freemem \\<leftarrow> liftE $ gets ki_free_mem;\n     freeregs \\<leftarrow> do_kernel_op $ freemem_regions freemem;\n\n     (swp mapME) (take MAX_NUM_FREEMEM_REG freeregs)\n       (\\<lambda>(start,bits). provide_untyped_cap root_cnode_cap start bits\n                                           slot_pos_before);\n\n     slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_ut_obj_caps := (slot_pos_before, slot_pos_after) \\<rparr>\\<rparr>);\n\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame\n   odE\"\n\ndefinition\n  map_kernel_frame :: \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vm_rights \\<Rightarrow> vm_attributes\n                       \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"map_kernel_frame paddr vaddr vm_rights attributes \\<equiv> do\n\n     idx \\<leftarrow> return $ (vaddr && mask (pageBitsForSize ARMSection))\n                    >> pageBitsForSize ARMSmallPage;\n\n     global_pt \\<leftarrow> get_arm_global_pt;\n\n     pte \\<leftarrow> return $ SmallPagePTE paddr attributes vm_rights;\n\n     store_pte (global_pt + (idx << PTE_SIZE_BITS)) pte\n   od\"\n\n\ndefinition (* from plat/imx31/machine/hardware.c *)\n  map_kernel_devices :: \"(unit,'z::state_ext) s_monad\" where\n  \"map_kernel_devices \\<equiv> do\n     map_kernel_frame EPIT_PADDR EPIT_PPTR vm_kernel_only\n                      {ParityEnabled,PageCacheable};\n     map_kernel_frame AVIC_PADDR AVIC_PPTR vm_kernel_only\n                      {ParityEnabled,PageCacheable};\n     map_kernel_frame L2CC_PADDR L2CC_PPTR vm_kernel_only\n                      {ParityEnabled,PageCacheable}\n   od\"\n\ndefinition\n  map_kernel_window :: \"(unit,'z::state_ext) s_monad\" where\n  \"map_kernel_window \\<equiv> do\n\n     global_pd \\<leftarrow> gets (arm_global_pd \\<circ> arch_state);", "property": "Kernel Initialization: \nMap kernel frames and devices, initialize the kernel window, and set up the bootinfo frame, ensuring that the kernel's memory layout and boot information are correctly established. \n\nSubproperties:\n- Map kernel frames to specific physical addresses with the correct virtual memory rights and attributes.\n- Map kernel devices (EPIT, AVIC, L2CC) to their respective physical addresses with kernel-only access and specific attributes.\n- Initialize the kernel window by retrieving the global page directory.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " using non-determinism to the max "}
{"spec": "idx \\<leftarrow> return $ kernel_base >> pageBitsForSize ARMSection;", "property": "Kernel Initialization: The kernel's base address is used to calculate an initial index into the page directory, ensuring it is aligned to a 16-byte boundary.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " initial index into the PD, guaranteed to be divisible by 16 "}
{"spec": "phys \\<leftarrow> return $ physBase;", "property": "Kernel Initialization: Establish the starting point for physical memory mapping by defining the first physical address.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " first physical address we'll map "}
{"spec": "iterations \\<leftarrow> return ((2^(PD_BITS) - idx) >> 4);\n\n     (swp mapM) [0 .e. iterations - 1] (\\<lambda>i. do\n         idx' \\<leftarrow> return $ idx + i * 16;\n         phys' \\<leftarrow> return $ phys + i * (2^(pageBitsForSize(ARMSuperSection)));\n\n         pde \\<leftarrow> return $ SuperSectionPDE phys' {ParityEnabled,PageCacheable}\n                                         vm_kernel_only;", "property": "Kernel Initialization: Map physical memory to kernel base address space in 16MB increments, configuring page directory entries for supersections with specific attributes.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map physBase at kernel_base 16M at a time, but not final supersection "}
{"spec": "mapM (\\<lambda>offs. store_pde (idx' + offs) pde) [0 .e. 15]\n       od);", "property": "Kernel Initialization: Write 16 section entries for a supersection by storing page directory entries (PDEs) at contiguous offsets.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " write 16 section entries for this supersection "}
{"spec": "idx \\<leftarrow> return $ idx + iterations * 16; (* should be 2^PD_BITS - 16 *)\n     phys \\<leftarrow> return $ phys + iterations * (2^pageBitsForSize(ARMSuperSection));", "property": "Kernel Initialization: Advance the index and physical address to match the exit of the C loop, ensuring proper alignment and incrementation of the index and physical address. \n\nIndex Incrementation: Increment the index by the product of iterations and 16.\nPhysical Address Incrementation: Increment the physical address by the product of iterations and the size of an ARMSuperSection page.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " advance idx and phys to match exit of C loop "}
{"spec": "(swp mapM) [0 .e. 14] (\\<lambda>i. do\n         phys' \\<leftarrow> return $ phys + i * (2^(pageBitsForSize(ARMSection)));\n         pde \\<leftarrow> return $ SectionPDE phys' {ParityEnabled,PageCacheable} 0\n                                   vm_kernel_only;\n         store_pde (idx + i) pde\n       od);", "property": "Kernel Initialization: Map the next 15MB of memory using 1MB frames, configuring the page directory entries (PDEs) for kernel-only access with specific attributes (ParityEnabled, PageCacheable).", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " next 15M mapped using 1M frames "}
{"spec": "idx \\<leftarrow> return $ idx + 15; (* should be 2^PD_BITS - 1 *)\n     phys \\<leftarrow> return $ phys + 15 * (2^pageBitsForSize(ARMSection));", "property": "Kernel Initialization: Advance the index and physical address to match the exit of the C loop, ensuring proper alignment and incrementation of the index and physical address. \n\nIndex Incrementation: Increment the index by a fixed value (15) to match the expected value (2^PD_BITS - 1) at the end of the C loop.\n\nPhysical Address Incrementation: Increment the physical address by a calculated value (15 * (2^pageBitsForSize(ARMSection))) to maintain proper alignment and addressing.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " advance idx and phys to match exit of C loop "}
{"spec": "global_pt \\<leftarrow> get_arm_global_pt;\n     pde \\<leftarrow> return $ PageTablePDE (addrFromPPtr global_pt) {ParityEnabled} 0;\n     store_pde idx pde;", "property": "Kernel Initialization: Map the global page table into the last slot of the global page directory. \n\nSubproperties: \n- Retrieve the global page table.\n- Create a page table PDE with the global page table address and parity enabled.\n- Store the PDE in the specified index.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " now map global PT into last slot in global PD  "}
{"spec": "retype_region global_pt 1 PT_SIZE_BITS\n                   (ArchObject PageTableObj);", "property": "Kernel Initialization: Initialize the page table by re-typing a region of memory as a page table object with a specified size.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " init the PT "}
{"spec": "map_kernel_frame (addrFromPPtr arm_vector_table) PPTR_VECTOR_TABLE\n                      vm_kernel_only {ParityEnabled,PageCacheable};", "property": "Map Kernel Vector Table: Map the kernel's vector table into the kernel's virtual address space with specific attributes (ParityEnabled and PageCacheable).", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map vector table "}
{"spec": "globals_frame \\<leftarrow> gets (arm_globals_frame \\<circ> arch_state);\n     map_kernel_frame (addrFromPPtr globals_frame) PPTR_GLOBALS_PAGE\n                      vm_read_only {ParityEnabled,PageCacheable};", "property": "Kernel Initialization: Map the globals frame to a specific address with read-only access and caching enabled.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map globals frame "}
{"spec": "map_kernel_frame (addrFromPPtr arm_kernel_stack) PPTR_KERNEL_STACK\n                      vm_kernel_only {ParityEnabled,PageCacheable};\n\n     map_kernel_devices\n   od\"\n\n\n\ndefinition\n  paddr_to_pptr_reg :: \"(paddr \\<times> paddr) \\<Rightarrow> (paddr \\<times> paddr)\" where\n  \"paddr_to_pptr_reg p_reg \\<equiv> (fst p_reg + pptrBaseOffset,\n                              snd p_reg + pptrBaseOffset)\"\n\ndefinition\n  init_kernel :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> word32 \\<Rightarrow> vspace_ref \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"init_kernel ui_p_reg_start ui_p_reg_end pv_offset v_entry \\<equiv>\n   let ui_v_reg_start = ui_p_reg_start - pv_offset;\n       ui_v_reg_end = ui_p_reg_end - pv_offset;\n       ui_v_reg = (ui_v_reg_start, ui_v_reg_end);\n       ui_reg = paddr_to_pptr_reg (ui_p_reg_start, ui_p_reg_end)\n   in\n   doE\n     do_kernel_op $ map_kernel_window;\n     do_kernel_op $ init_cpu;\n     do_kernel_op $ init_plat;\n     init_freemem ui_reg;\n     root_cnode_cap \\<leftarrow> create_root_cnode;\n     create_irq_cnode;\n     do_kernel_op $ init_irqs root_cnode_cap;", "property": "Kernel Initialization: Set up the kernel's memory layout, initialize the CPU and platform, create the root and IRQ nodes, and initialize the IRQs. Ensure the kernel's memory is properly mapped and the necessary data structures are created for efficient kernel operation.\n\nMemory Mapping: Map the kernel stack frame and devices into the kernel's virtual memory space, configuring the memory attributes for optimal performance and security.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map stack frame "}
{"spec": "ipcbuf_ret \\<leftarrow> create_ipcbuf_frame root_cnode_cap ui_v_reg;\n\n     bi_frame_vptr \\<leftarrow> create_bi_frame root_cnode_cap ui_v_reg\n                                     (snd ipcbuf_ret) 0 1;", "property": "Kernel Initialization: Create the initial thread's IPC buffer and bootinfo frame, ensuring the kernel's basic data structures are properly set up for execution. \n\nCreate IPC Buffer: Allocate and initialize the IPC buffer frame for the initial thread, providing a fundamental resource for inter-process communication.\n\nCreate Bootinfo Frame: Allocate and initialize the bootinfo frame, storing essential system information and ensuring the kernel's correct startup and operation.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create initial thread's ipc buffer "}
{"spec": "ui_fr_caps \\<leftarrow> create_frames_of_region root_cnode_cap ui_reg True pv_offset;\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_ui_frame_caps := ui_fr_caps \\<rparr>\\<rparr>);\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame;", "property": "Kernel Initialization: Create userland image frame objects and store their information in the bootinfo frame, ensuring that the kernel's boot process is properly initialized and configured. \n\nUserland Frame Creation: Create frames for the userland image in the specified region, with the correct offset and mapping. \n\nBootinfo Frame Update: Update the bootinfo frame with the newly created userland image frame capabilities. \n\nBootinfo Frame Synchronization: Synchronize the bootinfo frame to ensure consistency and accuracy during the boot process.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create userland image frame objs, store info in bootinfo frame "}
{"spec": "it_pd_cap \\<leftarrow> create_it_pd_pts root_cnode_cap ui_v_reg (snd ipcbuf_ret)\n                                   bi_frame_vptr;\n     write_it_pd_pts root_cnode_cap it_pd_cap;", "property": "Kernel Initialization: Create and initialize page directories (PDs) and page tables (PTs) for the userland image, setting up the memory management structures for user space. \n\nPage Directory and Table Initialization: Create and write the initial page directory and page table capabilities, establishing the memory mapping for the userland image.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create/init PDs and PTs for userland image "}
{"spec": "it_ap_cap \\<leftarrow> create_it_asid_pool root_cnode_cap;\n     do_kernel_op $ write_it_asid_pool it_ap_cap it_pd_cap;\n\n     create_idle_thread;", "property": "Kernel Initialization: Create and initialize the initial thread's ASID pool, and write it to the IT ASID pool. Additionally, create the idle thread to ensure the kernel's basic execution environment is set up correctly. \n\nSubproperties:\n- ASID Pool Creation: Create the initial thread's ASID pool using the root CNode capability.\n- ASID Pool Initialization: Write the created ASID pool to the IT ASID pool using the IT PD capability.\n- Idle Thread Creation: Create the idle thread to establish a foundational execution context for the kernel.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create/init initial thread's ASID pool "}
{"spec": "create_initial_thread root_cnode_cap it_pd_cap v_entry bi_frame_vptr\n                           (snd ipcbuf_ret) (fst ipcbuf_ret);", "property": "Create Initial Thread: Create the initial thread with the specified root capability node, initial thread page directory capability, virtual entry point, boot info frame virtual pointer, IPC buffer virtual address, and IPC buffer capability.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create_initial_thread "}
{"spec": "create_untyped_obj root_cnode_cap (kernel_base, ki_boot_end);", "property": "Kernel Initialization: Reclaim boot code and data by creating an untyped object.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create_untyped_obj (reclaim boot code/data) "}
{"spec": "create_device_frames root_cnode_cap;", "property": "Device Frame Initialization: Create device frames for the kernel during initialization.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create_device_frames "}
{"spec": "liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_sh_frame_caps := (0,0) \\<rparr>\\<rparr>);\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame;\n\n     bi_finalise;\n\n     do_kernel_op $ do_machine_op cleanCache\n   odE\n  \"\n\nend", "property": "Kernel Initialization: Ensure that shared frame capabilities are disabled and boot information is properly initialized and synchronized. The kernel's cache is also cleaned as part of the initialization process.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " no shared frame caps (ARM = no multikernel) "}
{"spec": "datatype cnode_invocation =\n    InsertCall cap cslot_ptr cslot_ptr\n  | MoveCall cap cslot_ptr cslot_ptr\n  | RevokeCall cslot_ptr\n  | DeleteCall cslot_ptr\n  | RotateCall cap cap cslot_ptr cslot_ptr cslot_ptr\n  | SaveCall cslot_ptr\n  | CancelBadgedSendsCall cap\n\ndatatype untyped_invocation =\n    Retype cslot_ptr bool obj_ref obj_ref apiobject_type nat \"cslot_ptr list\" bool\n\ndatatype tcb_invocation =\n    WriteRegisters machine_word bool \"machine_word list\" arch_copy_register_sets\n  | ReadRegisters machine_word bool machine_word arch_copy_register_sets\n  | CopyRegisters machine_word machine_word bool bool bool bool arch_copy_register_sets\n  | ThreadControl (tc_target: machine_word) (tc_slot: cslot_ptr)\n                  (tc_new_fault_ep: \"cap_ref option\")\n                  (tc_new_mcpriority: \"(word8 * obj_ref) option\")\n                  (tc_new_priority: \"(word8 * obj_ref) option\")\n                  (tc_new_croot: \"(cap * cslot_ptr) option\")\n                  (tc_new_vroot: \"(cap * cslot_ptr) option\")\n                  (tc_new_buffer: \"(vspace_ref * (cap * cslot_ptr) option) option\")\n  | Suspend \"obj_ref\"\n  | Resume \"obj_ref\"\n  | NotificationControl \"obj_ref\" \"obj_ref option\"\n  | SetTLSBase obj_ref machine_word\n\ndatatype irq_control_invocation =\n    IRQControl irq cslot_ptr cslot_ptr\n  | ArchIRQControl arch_irq_control_invocation\n\ndatatype irq_handler_invocation =\n    ACKIrq irq\n  | SetIRQHandler irq cap cslot_ptr\n  | ClearIRQHandler irq\n\ndatatype invocation =\n    InvokeUntyped untyped_invocation\n  | InvokeEndpoint obj_ref machine_word bool bool\n  | InvokeNotification obj_ref machine_word\n  | InvokeReply obj_ref cslot_ptr bool\n  | InvokeTCB tcb_invocation\n  | InvokeDomain obj_ref word8\n  | InvokeCNode cnode_invocation\n  | InvokeIRQControl irq_control_invocation\n  | InvokeIRQHandler irq_handler_invocation\n  | InvokeArchObject arch_invocation\n\nend", "property": "System Call Invocation Arguments: Define the data types for the arguments of various system calls, including capability management, thread control, interrupt handling, and other kernel operations. These data types ensure that system calls are properly parameterized and executed, maintaining the integrity and security of the kernel.\n\nSubproperties:\n- Capability Management: Define the data types for capability-related system calls, including capability insertion, movement, revocation, deletion, rotation, and saving.\n- Thread Control: Define the data types for thread-related system calls, including thread suspension, resumption, register management, and notification control.\n- Interrupt Handling: Define the data types for interrupt-related system calls, including interrupt control, acknowledgment, and handler management.\n- Kernel Operations: Define the data types for other kernel-related system calls, including domain management, untyped invocations, and architecture-specific operations.", "title": "./spec/abstract/Invocations_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the available system calls."}
{"spec": "text \\<open>\n Recall that a capability may reside in either a CNode, or inside a TCB;\nthe following definitions allow the kernel model to retrieve and update\ncapabilities in a uniform fashion.\\<close>\ndefinition\n  get_cap :: \"cslot_ptr \\<Rightarrow> (cap,'z::state_ext) s_monad\"\nwhere\n  \"get_cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     caps \\<leftarrow> case obj of\n             CNode sz cnode \\<Rightarrow> do\n                                assert (well_formed_cnode_n sz cnode);\n                                return cnode\n                              od\n           | TCB tcb     \\<Rightarrow> return (tcb_cnode_map tcb)\n           | _ \\<Rightarrow> fail;\n     assert_opt (caps cref)\n   od\"\n\ndefinition\n  set_cap :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_cap cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     obj' \\<leftarrow> case obj of\n               CNode sz cn \\<Rightarrow> if cref \\<in> dom cn \\<and> well_formed_cnode_n sz cn\n                                then return $ CNode sz $ cn (cref \\<mapsto> cap)\n                                else fail\n             | TCB tcb \\<Rightarrow>\n                   if cref = tcb_cnode_index 0 then\n                       return $ TCB $ tcb \\<lparr> tcb_ctable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 1 then\n                       return $ TCB $ tcb \\<lparr> tcb_vtable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 2 then\n                       return $ TCB $ tcb \\<lparr> tcb_reply := cap \\<rparr>\n                   else if cref = tcb_cnode_index 3 then\n                       return $ TCB $ tcb \\<lparr> tcb_caller := cap \\<rparr>\n                   else if cref = tcb_cnode_index 4 then\n                       return $ TCB $ tcb \\<lparr> tcb_ipcframe := cap \\<rparr>\n                   else\n                       fail\n             | _ \\<Rightarrow> fail;\n     set_object oref obj'\n  od\"", "property": "Uniform Capability Access: Retrieve and update capabilities in a uniform fashion, regardless of whether they reside in a CNode or inside a TCB.\n\nGet Capability: Retrieve a capability from a CNode or TCB, ensuring that the CNode is well-formed and the capability exists at the specified location.\n\nSet Capability: Update a capability in a CNode or TCB, ensuring that the CNode is well-formed and the capability is valid for the specified location.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": ""}
{"spec": "definition\n  ensure_empty :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"ensure_empty slot \\<equiv> doE\n    cap \\<leftarrow> liftE $ get_cap slot;\n    whenE (cap \\<noteq> NullCap) (throwError DeleteFirst)\n  odE\"", "property": "Ensure Capability Slot Emptiness: Guarantee that a capability slot is empty by checking if it contains a non-Null capability, and if so, throw an error.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "Ensure a capability slot is empty."}
{"spec": "text \\<open>Set the capability derivation tree.\\<close>\ndefinition\n  set_cdt :: \"cdt \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"set_cdt t \\<equiv> do\n    s \\<leftarrow> get;\n    put $ s\\<lparr> cdt := t \\<rparr>\n  od\"", "property": "Set Capability Derivation Tree: Update the capability derivation tree (CDT) with a new value, ensuring that the system's capability hierarchy is correctly maintained and updated.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": ""}
{"spec": "definition\n  update_cdt :: \"(cdt \\<Rightarrow> cdt) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"update_cdt f \\<equiv> do\n     t \\<leftarrow> gets cdt;\n     set_cdt (f t)\n  od\"", "property": "Update Capability Derivation Tree: Modify the capability derivation tree by applying a given transformation function to the current tree, ensuring that the updated tree is correctly stored in the system state.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "Update the capability derivation tree."}
{"spec": "definition\n  set_original :: \"cslot_ptr \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_original slot v \\<equiv> do\n     r \\<leftarrow> gets is_original_cap;\n     modify (\\<lambda>s. s \\<lparr> is_original_cap := r (slot := v) \\<rparr>)\n  od\"", "property": "Set Original Flag: Set the original flag for a given capability slot, indicating whether the capability is original or derived.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "Set the original flag for a given cap slot."}
{"spec": "definition\n  is_cdt_parent :: \"cdt \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\" where\n  \"is_cdt_parent t p c \\<equiv> t c = Some p\"\n\ndefinition\n  cdt_parent_rel :: \"cdt \\<Rightarrow> (cslot_ptr \\<times> cslot_ptr) set\" where\n  \"cdt_parent_rel t \\<equiv> {(p,c). is_cdt_parent t p c}\"\n\nabbreviation\n  parent_of :: \"cdt \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of _\" [60,0,60] 61)\nwhere\n  \"t \\<turnstile> p cdt_parent_of c \\<equiv> (p,c) \\<in> cdt_parent_rel t\"\n\nabbreviation\n  parent_of_trancl :: \"cdt \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of\\<^sup>+ _\" [60,0,60] 61)\nwhere\n  \"t \\<turnstile> x cdt_parent_of\\<^sup>+ y \\<equiv> (x, y) \\<in> (cdt_parent_rel t)\\<^sup>+\"\n\nabbreviation\n  parent_of_rtrancl :: \"cdt \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of\\<^sup>* _\" [60,0,60] 61)\nwhere\n  \"t \\<turnstile> x cdt_parent_of\\<^sup>* y \\<equiv> (x, y) \\<in> (cdt_parent_rel t)\\<^sup>*\"\n\n\nnotation\n  parent_of (\"_ \\<Turnstile> _ \\<leadsto> _\" [60,0,60] 60)\nand\n  parent_of_trancl (\"_ \\<Turnstile> _ \\<rightarrow> _\" [60,0,60] 60)\nand\n  parent_of_rtrancl (\"_ \\<Turnstile> _ \\<rightarrow>* _\" [60,0,60] 60)", "property": "Capability Derivation Tree Predicates: Define relationships between capability slots in the capability derivation tree, including direct parent-child relationships and transitive relationships. These predicates enable reasoning about the structure and navigation of the capability derivation tree. \n\nSubproperties:\n- Direct Parent Relationship: Determine if one capability slot is the direct parent of another in the capability derivation tree.\n- Transitive Parent Relationship: Determine if one capability slot is an ancestor of another in the capability derivation tree, through any number of intermediate slots.\n- Reflexive Transitive Parent Relationship: Determine if one capability slot is an ancestor of another, or the same slot, in the capability derivation tree, through any number of intermediate slots.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "Definitions and syntax for predicates on capability derivation."}
{"spec": "definition\n  descendants_of :: \"cslot_ptr \\<Rightarrow> cdt \\<Rightarrow> cslot_ptr set\" where\n  \"descendants_of p t \\<equiv> {q. (p,q) \\<in> (cdt_parent_rel t)\\<^sup>+}\"\n\nend", "property": "Capability Derivation Tree Descendants: Retrieves the set of descendant slots in the capability derivation tree for a given slot.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "The set of descendants of a particular slot in the CDT."}
{"spec": "definition\n  get_message_info :: \"obj_ref \\<Rightarrow> (message_info,'z::state_ext) s_monad\"\nwhere\n  \"get_message_info thread \\<equiv> do\n     x \\<leftarrow> as_user thread $ getRegister msg_info_register;\n     return $ data_to_message_info x\n   od\"", "property": "Get Message Info: Retrieve the message information from a thread's message info register.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "IPC Capability Transfers", "comment": ""}
{"spec": "definition\n  remove_rights :: \"cap_rights \\<Rightarrow> cap \\<Rightarrow> cap\"\nwhere\n \"remove_rights rights cap \\<equiv> cap_rights_update (cap_rights cap - rights) cap\"", "property": "Capability Rights Removal: Remove specified rights from a capability, ensuring that the resulting capability has reduced privileges.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": ""}
{"spec": "definition\n  buffer_cptr_index :: nat\nwhere\n \"buffer_cptr_index \\<equiv> (msg_max_length + 2)\"\n\nprimrec\n  get_extra_cptrs :: \"obj_ref option \\<Rightarrow> message_info \\<Rightarrow> (cap_ref list,'z::state_ext) s_monad\"\nwhere\n  \"get_extra_cptrs (Some buf) mi =\n    (liftM (map data_to_cptr) $ mapM (load_word_offs buf)\n        [buffer_cptr_index ..< buffer_cptr_index + (unat (mi_extra_caps mi))])\"\n| \"get_extra_cptrs None mi = return []\"\n\ndefinition\n  get_extra_cptr :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> (cap_ref,'z::state_ext) s_monad\"\nwhere\n  \"get_extra_cptr buffer n \\<equiv> liftM data_to_cptr\n      (load_word_offs buffer (n + buffer_cptr_index))\"", "property": "Retrieve Extra Capabilities: Retrieve additional capability pointers from a thread's IPC buffer, handling cases where the buffer is present or absent. \n\n Load Capability Pointer: Load a capability pointer from a specific offset in the IPC buffer.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "In addition to the data payload a message may also contain capabilities.\nWhen a thread requests additional capabilities be transferred the identities of\nthose capabilities are retreived from the thread's IPC buffer."}
{"spec": "definition\n  lookup_extra_caps :: \"obj_ref \\<Rightarrow> data option \\<Rightarrow> message_info \\<Rightarrow> ((cap \\<times> cslot_ptr) list,'z::state_ext) f_monad\" where\n  \"lookup_extra_caps thread buffer mi \\<equiv> doE\n       cptrs \\<leftarrow> liftE $ get_extra_cptrs buffer mi;\n       mapME (\\<lambda>cptr. cap_fault_on_failure (of_bl cptr) False $ lookup_cap_and_slot thread cptr) cptrs\n  odE\"", "property": "Lookup Extra Capabilities: Retrieve additional capabilities from the sender's CSpace by looking up their addresses and fetching the corresponding capabilities, handling potential faults during the lookup process.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "This function both looks up the addresses of the additional capabilities\nand retreives them from the sender's CSpace."}
{"spec": "definition\n  set_extra_badge :: \"obj_ref \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_extra_badge buffer badge n \\<equiv>\n      store_word_offs buffer (buffer_cptr_index + n) badge\"\n\ntype_synonym transfer_caps_data = \"(cap \\<times> cslot_ptr) list \\<times> cslot_ptr list\"\n\nfun\n  transfer_caps_loop :: \"obj_ref option \\<Rightarrow> obj_ref \\<Rightarrow> nat\n                          \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> cslot_ptr list\n                          \\<Rightarrow> message_info \\<Rightarrow> (message_info,'z::state_ext) s_monad\"\nwhere\n  \"transfer_caps_loop ep rcv_buffer n [] slots\n      mi = return (MI (mi_length mi) (of_nat n) (mi_caps_unwrapped mi)\n                        (mi_label mi))\"\n| \"transfer_caps_loop ep rcv_buffer n ((cap, slot) # morecaps)\n         slots mi =\n  const_on_failure (MI (mi_length mi) (of_nat n) (mi_caps_unwrapped mi)\n                       (mi_label mi)) (doE\n    transfer_rest \\<leftarrow> returnOk $ transfer_caps_loop ep\n         rcv_buffer (n + 1) morecaps;\n    if (is_ep_cap cap \\<and> ep = Some (obj_ref_of cap))\n    then doE\n       liftE $ set_extra_badge rcv_buffer (cap_ep_badge cap) n;\n       liftE $ transfer_rest slots (MI (mi_length mi) (mi_extra_caps mi)\n         (mi_caps_unwrapped mi || (1 << n)) (mi_label mi))\n    odE\n    else if slots \\<noteq> []\n    then doE\n      cap' \\<leftarrow> derive_cap slot cap;\n      whenE (cap' = NullCap) $ throwError undefined;\n      liftE $ cap_insert cap' slot (hd slots);\n      liftE $ transfer_rest (tl slots) mi\n    odE\n    else returnOk (MI (mi_length mi) (of_nat n) (mi_caps_unwrapped mi)\n                       (mi_label mi))\n  odE)\"\n\ndefinition\n  transfer_caps :: \"message_info \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n                   obj_ref option \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow>\n                   (message_info,'z::state_ext) s_monad\"\nwhere\n  \"transfer_caps info caps endpoint receiver recv_buffer \\<equiv> do\n     dest_slots \\<leftarrow> get_receive_slots receiver recv_buffer;\n     mi' \\<leftarrow> return $ MI (mi_length info) 0 0 (mi_label info);\n     case recv_buffer of\n       None \\<Rightarrow> return mi'\n     | Some receive_buffer \\<Rightarrow>\n         transfer_caps_loop endpoint receive_buffer 0 caps dest_slots mi'\n   od\"", "property": "Capability Transfer: Transfer capabilities passed along with a message, splitting them into two groups: capabilities to the same endpoint as the message, which are not copied but have their badges unwrapped and stored in the receiver's message buffer, and other capabilities, which are copied into the given slots.\n\nSubproperties:\n- Badge Unwrapping: Unwrap badges of capabilities to the same endpoint as the message and store them in the receiver's message buffer.\n- Capability Copying: Copy capabilities that are not to the same endpoint as the message into the given slots.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "Capability transfers. Capabilities passed along with a message are split\ninto two groups. Capabilities to the same endpoint as the message is passed\nthrough are not copied. Their badges are unwrapped and stored in the receiver's\nmessage buffer instead. Other capabilities are copied into the given slots.\n\nCapability unwrapping allows a client to efficiently demonstrate to a server\nthat it possesses authority to two or more services that server provides.\n"}
{"spec": "text \\<open>Threads fault when they attempt to access services that are not backed\nby any resources. Such a thread is then blocked and a fault messages is sent to\nits supervisor. When a reply to that message is sent the thread is reactivated.\n\\<close>", "property": "Fault Handling: A thread that attempts to access services without backing resources is blocked and a fault message is sent to its supervisor, allowing for reactivation upon receiving a reply.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": ""}
{"spec": "fun\n  make_fault_msg :: \"fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\nwhere\n  \"make_fault_msg (CapFault cptr rp lf) thread = (do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (1, pc # cptr # (if rp then 1 else 0) # msg_from_lookup_failure lf)\n   od)\"\n| \"make_fault_msg (UnknownSyscallException n) thread = (do\n     msg \\<leftarrow> as_user thread $ mapM getRegister syscallMessage;\n     return (2, msg @ [n])\n   od)\"\n| \"make_fault_msg (UserException exception code) thread = (do\n     msg \\<leftarrow> as_user thread $ mapM getRegister exceptionMessage;\n     return (3, msg @ [exception, code])\n   od)\"\n| \"make_fault_msg (ArchFault af) thread = make_arch_fault_msg af thread \" (* arch_fault *)", "property": "Fault Message Formatting: Create a formatted message for a given fault type, including capability faults, unknown system call exceptions, user exceptions, and architecture-specific faults, to facilitate fault handling and reporting. \n\nSubproperties:\n- Capability Fault Message: Format a message for a capability fault, including the capability pointer, restart PC, and lookup failure information.\n- Unknown System Call Exception Message: Format a message for an unknown system call exception, including the system call message and the exception number.\n- User Exception Message: Format a message for a user exception, including the exception message, exception number, and error code.\n- Architecture-Specific Fault Message: Format a message for an architecture-specific fault, handled by the make_arch_fault_msg function.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "Format a message for a given fault type."}
{"spec": "fun\n  handle_fault_reply :: \"fault \\<Rightarrow> obj_ref \\<Rightarrow>\n                         data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault_reply (CapFault cptr rp lf) thread x y = return True\"\n| \"handle_fault_reply (UnknownSyscallException n) thread label msg = do\n     t \\<leftarrow> arch_get_sanitise_register_info thread;\n     as_user thread $ zipWithM_x\n         (\\<lambda>r v. setRegister r $ sanitise_register t r v)\n         syscallMessage msg;\n     return (label = 0)\n   od\"\n| \"handle_fault_reply (UserException exception code) thread label msg = do\n     t \\<leftarrow> arch_get_sanitise_register_info thread;\n     as_user thread $ zipWithM_x\n         (\\<lambda>r v. setRegister r $ sanitise_register t r v)\n         exceptionMessage msg;\n     return (label = 0)\n   od\"\n| \" handle_fault_reply (ArchFault af) thread label msg =\n    handle_arch_fault_reply af thread label msg\" (* arch_fault *)", "property": "Fault Reply Handling: React to a fault reply message based on the original fault type, potentially reconfiguring the thread and saving an additional system call, and return a boolean indicating whether the thread should be restarted.\n\nSubproperties:\n- CapFault Handling: Always return True for capability faults.\n- Unknown Syscall and User Exception Handling: Sanitize and set registers based on the fault message and return whether the label is 0.\n- ArchFault Handling: Handle architecture-specific faults using a separate function.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "React to a fault reply. The reply message is interpreted in a manner\nthat depends on the type of the original fault. For some fault types a thread\nreconfiguration is performed. This is done entirely to save the fault message\nrecipient an additional system call. This function returns a boolean indicating\nwhether the thread should now be restarted."}
{"spec": "definition\n  do_fault_transfer :: \"data \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref\n                             \\<Rightarrow> obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"do_fault_transfer badge sender receiver buf \\<equiv> do\n    fault \\<leftarrow> thread_get tcb_fault sender;\n    f \\<leftarrow> (case fault of\n         Some f \\<Rightarrow> return f\n       | None \\<Rightarrow> fail);\n    (label, msg) \\<leftarrow> make_fault_msg f sender;\n    sent \\<leftarrow> set_mrs receiver buf msg;\n    set_message_info receiver $ MI sent 0 0 label;\n    as_user receiver $ setRegister badge_register badge\n  od\"", "property": "Fault Transfer: Transfer a fault message from a faulting thread to its supervisor, including retrieving the fault information, creating a fault message, sending the message, and updating the supervisor's message information and badge register.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "Transfer a fault message from a faulting thread to its supervisor."}
{"spec": "text \\<open>Transfer a non-fault message.\\<close>\ndefinition\n  do_normal_transfer :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> obj_ref option\n                                    \\<Rightarrow> data \\<Rightarrow> bool \\<Rightarrow> obj_ref\n                                    \\<Rightarrow> obj_ref option\n                                    \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"do_normal_transfer sender sbuf endpoint badge grant\n                     receiver rbuf  \\<equiv>\n  do\n    mi \\<leftarrow> get_message_info sender;\n    caps \\<leftarrow> if grant then lookup_extra_caps sender sbuf mi <catch> K (return [])\n      else return [];\n    mrs_transferred \\<leftarrow> copy_mrs sender sbuf receiver rbuf (mi_length mi);\n    mi' \\<leftarrow> transfer_caps mi caps endpoint receiver rbuf;\n    set_message_info receiver $ MI mrs_transferred (mi_extra_caps mi')\n                                   (mi_caps_unwrapped mi') (mi_label mi);\n    as_user receiver $ setRegister badge_register badge\n  od\"", "property": "Synchronous Message Transfer: Transfer a non-fault message between threads, involving the transfer of message registers, capability pointers, and updating the message info of the receiving thread. \n\nMessage Register Transfer: Copy message registers from the sender's buffer to the receiver's buffer.\n\nCapability Transfer: Transfer capability pointers from the sender to the receiver, updating the message info accordingly.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": ""}
{"spec": "definition\n  do_ipc_transfer :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow>\n                       badge \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"do_ipc_transfer sender ep badge grant\n     receiver \\<equiv> do\n\n     recv_buffer \\<leftarrow> lookup_ipc_buffer True receiver;\n     fault \\<leftarrow> thread_get tcb_fault sender;\n\n     case fault\n        of None \\<Rightarrow> do\n            send_buffer \\<leftarrow> lookup_ipc_buffer False sender;\n            do_normal_transfer sender send_buffer ep badge grant\n                           receiver recv_buffer\n            od\n         | Some f \\<Rightarrow> do_fault_transfer badge sender receiver recv_buffer\n   od\"", "property": "Synchronous Message Transfer: Transfer a message between a sender and a receiver, either involving a fault or not, while handling the lookup of IPC buffers and badge information. \n\nNormal Transfer: Perform a normal message transfer between the sender and receiver using their respective IPC buffers, while considering grant and badge information.\n\nFault Transfer: Handle a fault during message transfer by performing a fault transfer between the sender and receiver using the receiver's IPC buffer and badge information.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Transfer a message either involving a fault or not."}
{"spec": "definition\n  do_reply_transfer :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"do_reply_transfer sender receiver slot grant \\<equiv> do\n    state \\<leftarrow> get_thread_state receiver;\n    assert (state = BlockedOnReply);\n    fault \\<leftarrow> thread_get tcb_fault receiver;\n    case fault of\n      None \\<Rightarrow> do\n         do_ipc_transfer sender None 0 grant receiver;\n         cap_delete_one slot;\n         set_thread_state receiver Running;\n         do_extended_op (possible_switch_to receiver)\n      od\n    | Some f \\<Rightarrow> do\n         cap_delete_one slot;\n         mi \\<leftarrow> get_message_info sender;\n         buf \\<leftarrow> lookup_ipc_buffer False sender;\n         mrs \\<leftarrow> get_mrs sender buf mi;\n         restart \\<leftarrow> handle_fault_reply f receiver (mi_label mi) mrs;\n         thread_set (\\<lambda>tcb. tcb \\<lparr> tcb_fault := None \\<rparr>) receiver;\n         set_thread_state receiver (if restart then Restart else Inactive);\n         when restart $ do_extended_op (possible_switch_to receiver);\n         return ()\n       od\n  od\"", "property": "Synchronous Message Transfer: Transfer a reply message from the sender to the receiver, delete the one-use Reply capability, and update the receiver's thread state accordingly. \n\nSubproperties:\n- If the receiver is blocked on a reply and has no fault, perform the IPC transfer, delete the Reply capability, set the receiver to running, and consider switching to it.\n- If the receiver is blocked on a reply and has a fault, delete the Reply capability, handle the fault, clear the receiver's fault, set its state to inactive or restart, and consider switching to it if restarted.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Transfer a reply message and delete the one-use Reply capability."}
{"spec": "definition\n  reply_from_kernel :: \"obj_ref \\<Rightarrow> (data \\<times> data list) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"reply_from_kernel thread x \\<equiv> do\n    (label, msg) \\<leftarrow> return x;\n    buf \\<leftarrow> lookup_ipc_buffer True thread;\n    as_user thread $ setRegister badge_register 0;\n    len \\<leftarrow> set_mrs thread buf msg;\n    set_message_info thread $ MI len 0 0 label\n  od\"", "property": "Synchronous Message Transfers: Transfer a reply message from the kernel to a thread, updating the thread's IPC buffer, message registers, and message info.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "This function transfers a reply message to a thread when that message\nis generated by a kernel service."}
{"spec": "definition\n  setup_caller_cap :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"setup_caller_cap sender receiver grant \\<equiv> do\n    set_thread_state sender BlockedOnReply;\n    cap_insert (ReplyCap sender False (if grant then {AllowGrant, AllowWrite} else {AllowWrite}))\n               (sender, tcb_cnode_index 2)\n      (receiver, tcb_cnode_index 3)\n  od\"", "property": "Synchronous Message Transfer Setup: Install a one-use Reply capability for synchronous message transfers, setting the sender's thread state to BlockedOnReply and configuring the Reply capability's permissions based on the grant parameter.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Install a one-use Reply capability."}
{"spec": "definition\n  send_ipc :: \"bool \\<Rightarrow> bool \\<Rightarrow> badge \\<Rightarrow> bool \\<Rightarrow> bool\n                \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"send_ipc block call badge can_grant can_grant_reply thread epptr \\<equiv> do\n     ep \\<leftarrow> get_endpoint epptr;\n     case (ep, block) of\n         (IdleEP, True) \\<Rightarrow> do\n               set_thread_state thread (BlockedOnSend epptr\n                                   \\<lparr> sender_badge = badge,\n                                     sender_can_grant = can_grant,\n                                     sender_can_grant_reply = can_grant_reply,\n                                     sender_is_call = call \\<rparr>);\n               set_endpoint epptr $ SendEP [thread]\n             od\n       | (SendEP queue, True) \\<Rightarrow> do\n               set_thread_state thread (BlockedOnSend epptr\n                                   \\<lparr> sender_badge = badge,\n                                     sender_can_grant = can_grant,\n                                     sender_can_grant_reply = can_grant_reply,\n                                     sender_is_call = call\\<rparr>);\n               set_endpoint epptr $ SendEP (queue @ [thread])\n             od\n       | (IdleEP, False) \\<Rightarrow> return ()\n       | (SendEP queue, False) \\<Rightarrow> return ()\n       | (RecvEP (dest # queue), _) \\<Rightarrow> do\n                set_endpoint epptr $ (case queue of [] \\<Rightarrow> IdleEP\n                                                     | _ \\<Rightarrow> RecvEP queue);\n                recv_state \\<leftarrow> get_thread_state dest;\n                reply_can_grant \\<leftarrow> case recv_state\n                  of (BlockedOnReceive x data) \\<Rightarrow> do\n                           do_ipc_transfer thread (Some epptr) badge can_grant dest;\n                           return (receiver_can_grant data)\n                           od\n                  | _ \\<Rightarrow> fail;\n                set_thread_state dest Running;\n                do_extended_op (possible_switch_to dest);\n                when call $\n                  if (can_grant \\<or> can_grant_reply)\n                  then setup_caller_cap thread dest reply_can_grant\n                  else set_thread_state thread Inactive\n                od\n\n       | (RecvEP [], _) \\<Rightarrow> fail\n   od\"", "property": "Synchronous Message Transfer: Handle a message send operation performed by a thread on an endpoint, transferring the message to a waiting receiver if available, or blocking the thread in the endpoint's sending queue if no receiver is available and the thread is willing to wait.\n\nSubproperties:\n- If a receiver is waiting, transfer the message and update the receiver's state.\n- If no receiver is available and the thread is willing to block, add the thread to the endpoint's sending queue.\n- If no receiver is available and the thread is not willing to block, do nothing.\n- If the endpoint is in an invalid state, fail the operation.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Handle a message send operation performed on an endpoint by a thread.\nIf a receiver is waiting then transfer the message. If no receiver is available\nand the thread is willing to block waiting to send then put it in the endpoint\nsending queue."}
{"spec": "definition\n  isActive :: \"notification \\<Rightarrow> bool\"\nwhere\n  \"isActive ntfn \\<equiv> case ntfn_obj ntfn\n     of ActiveNtfn _ \\<Rightarrow> True\n      | _ \\<Rightarrow> False\"", "property": "Check Notification Status: Determine if a notification is active. \n\n isActive: A notification is considered active if its object is an active notification.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Handle a message receive operation performed on an endpoint by a thread.\nIf a sender is waiting then transfer the message, otherwise put the thread in\nthe endpoint receiving queue."}
{"spec": "definition\n  complete_signal :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"complete_signal ntfnptr tcb \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     case ntfn_obj ntfn of\n       ActiveNtfn badge \\<Rightarrow> do\n           as_user tcb $ setRegister badge_register badge;\n           set_notification ntfnptr $ ntfn_set_obj ntfn IdleNtfn\n         od\n     | _ \\<Rightarrow> fail\n   od\"\n\ndefinition\n  do_nbrecv_failed_transfer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"do_nbrecv_failed_transfer thread = do as_user thread $ setRegister badge_register 0; return () od\"\n\ndefinition\n  receive_ipc :: \"obj_ref \\<Rightarrow> cap \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"receive_ipc thread cap is_blocking \\<equiv> do\n     (epptr,rights) \\<leftarrow> (case cap\n                       of EndpointCap ref badge rights \\<Rightarrow> return (ref,rights)\n                        | _ \\<Rightarrow> fail);\n     ep \\<leftarrow> get_endpoint epptr;\n     ntfnptr \\<leftarrow> get_bound_notification thread;\n     ntfn \\<leftarrow> case_option (return default_notification) get_notification ntfnptr;\n     if (ntfnptr \\<noteq> None \\<and> isActive ntfn)\n     then\n       complete_signal (the ntfnptr) thread\n     else\n       case ep\n         of IdleEP \\<Rightarrow> (case is_blocking of\n              True \\<Rightarrow> do\n                  set_thread_state thread (BlockedOnReceive epptr\n                                           \\<lparr>receiver_can_grant = (AllowGrant \\<in> rights)\\<rparr>);\n                  set_endpoint epptr (RecvEP [thread])\n                od\n              | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n            | RecvEP queue \\<Rightarrow> (case is_blocking of\n              True \\<Rightarrow> do\n                  set_thread_state thread (BlockedOnReceive epptr\n                                           \\<lparr>receiver_can_grant = (AllowGrant \\<in> rights)\\<rparr>);\n                  set_endpoint epptr (RecvEP (queue @ [thread]))\n                od\n              | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n          | SendEP q \\<Rightarrow> do\n              assert (q \\<noteq> []);\n              queue \\<leftarrow> return $ tl q;\n              sender \\<leftarrow> return $ hd q;\n              set_endpoint epptr $\n                (case queue of [] \\<Rightarrow> IdleEP | _ \\<Rightarrow> SendEP queue);\n              sender_state \\<leftarrow> get_thread_state sender;\n              data \\<leftarrow> (case sender_state\n                       of BlockedOnSend ref data \\<Rightarrow> return data\n                        | _ \\<Rightarrow> fail);\n              do_ipc_transfer sender (Some epptr)\n                        (sender_badge data) (sender_can_grant data)\n                        thread;\n              if (sender_is_call data)\n              then\n                if (sender_can_grant data \\<or> sender_can_grant_reply data)\n                then setup_caller_cap sender thread (AllowGrant \\<in> rights)\n                else set_thread_state sender Inactive\n              else do\n                set_thread_state sender Running;\n                do_extended_op (possible_switch_to sender)\n              od\n            od\n   od\"", "property": "Synchronous Message Transfers: Ensure that threads can receive IPC messages from endpoints, handling various scenarios such as receiving signals from notifications, performing transfers from sending endpoints, and updating thread states accordingly.\n\nSubproperties:\n- Signal Completion: Complete signal reception by updating the notification object and setting the badge register.\n- Failed Non-Blocking Receive: Handle failed non-blocking receives by resetting the badge register.\n- Endpoint State Management: Update endpoint states based on the type of endpoint and the blocking mode of the receiving thread.\n- Message Transfer: Perform IPC transfers between sending and receiving threads, handling call and reply capabilities, and updating thread states accordingly.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Helper function for performing \\emph{signal} when receiving on a normal\nendpoint"}
{"spec": "text \\<open>Helper function to handle a signal operation in the case\nwhere a receiver is waiting.\\<close>\ndefinition\n  update_waiting_ntfn :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref option \\<Rightarrow> badge \\<Rightarrow>\n                         (unit,'z::state_ext) s_monad\"\nwhere\n  \"update_waiting_ntfn ntfnptr queue bound_tcb badge \\<equiv> do\n     assert (queue \\<noteq> []);\n     (dest,rest) \\<leftarrow> return $ (hd queue, tl queue);\n     set_notification ntfnptr $ \\<lparr>\n         ntfn_obj = (case rest of [] \\<Rightarrow> IdleNtfn | _ \\<Rightarrow> WaitingNtfn rest),\n         ntfn_bound_tcb = bound_tcb \\<rparr>;\n     set_thread_state dest Running;\n     as_user dest $ setRegister badge_register badge;\n     do_extended_op (possible_switch_to dest)\n\n   od\"", "property": "Asynchronous Message Transfer to Waiting Receiver: When a receiver is waiting for a notification, update the notification object, set the receiver's thread state to running, set the badge register, and potentially switch to the receiver's thread. \n\nUpdate Notification Object: Update the notification object's state to either IdleNtfn or WaitingNtfn, depending on whether there are remaining waiting threads.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Asynchronous Message Transfers", "comment": ""}
{"spec": "definition\n  receive_blocked :: \"thread_state \\<Rightarrow> bool\"\nwhere\n  \"receive_blocked st \\<equiv> case st of\n       BlockedOnReceive _ _ \\<Rightarrow> True\n     | _ \\<Rightarrow> False\"\n\ndefinition\n  send_signal :: \"obj_ref \\<Rightarrow> badge \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"send_signal ntfnptr badge \\<equiv> do\n    ntfn \\<leftarrow> get_notification ntfnptr;\n    case (ntfn_obj ntfn, ntfn_bound_tcb ntfn) of\n          (IdleNtfn, Some tcb) \\<Rightarrow> do\n                  st \\<leftarrow> get_thread_state tcb;\n                  if (receive_blocked st)\n                  then do\n                      cancel_ipc tcb;\n                      set_thread_state tcb Running;\n                      as_user tcb $ setRegister badge_register badge;\n                      do_extended_op (possible_switch_to tcb)\n                    od\n                  else set_notification ntfnptr $ ntfn_set_obj ntfn (ActiveNtfn badge)\n            od\n       | (IdleNtfn, None) \\<Rightarrow> set_notification ntfnptr $ ntfn_set_obj ntfn (ActiveNtfn badge)\n       | (WaitingNtfn queue, bound_tcb) \\<Rightarrow> update_waiting_ntfn ntfnptr queue bound_tcb badge\n       | (ActiveNtfn badge', _) \\<Rightarrow>\n           set_notification ntfnptr $ ntfn_set_obj ntfn $\n             ActiveNtfn (combine_ntfn_badges badge badge')\n   od\"", "property": "Send Signal to Notification: Deliver a signal to a notification object, potentially unblocking a waiting thread or updating the notification's state. If a thread is blocked on receive and the notification is idle, the thread is unblocked and its state is updated. If the notification is idle and not bound to a thread, it is marked as active. If the notification is waiting, its queue is updated. If the notification is already active, its badge is combined with the new badge.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Asynchronous Message Transfers", "comment": " helper function for checking if thread is blocked "}
{"spec": "definition\n  receive_signal :: \"obj_ref \\<Rightarrow> cap \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n   \"receive_signal thread cap is_blocking \\<equiv> do\n    ntfnptr \\<leftarrow>\n      case cap\n        of NotificationCap ntfnptr badge rights \\<Rightarrow> return ntfnptr\n         | _ \\<Rightarrow> fail;\n    ntfn \\<leftarrow> get_notification ntfnptr;\n    case ntfn_obj ntfn\n      of IdleNtfn \\<Rightarrow>\n                   (case is_blocking of\n                     True \\<Rightarrow> do\n                          set_thread_state thread (BlockedOnNotification ntfnptr);\n                          set_notification ntfnptr $ ntfn_set_obj ntfn $ WaitingNtfn [thread]\n                        od\n                   | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n       | WaitingNtfn queue \\<Rightarrow>\n                   (case is_blocking of\n                     True \\<Rightarrow> do\n                          set_thread_state thread (BlockedOnNotification ntfnptr);\n                          set_notification ntfnptr $ ntfn_set_obj ntfn $ WaitingNtfn (queue @ [thread])\n                        od\n                   | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n       | ActiveNtfn badge \\<Rightarrow> do\n                     as_user thread $ setRegister badge_register badge;\n                     set_notification ntfnptr $ ntfn_set_obj ntfn IdleNtfn\n                   od\n    od\"", "property": "Notification Receive: Handle a receive operation on a notification object, performing the transfer if a message is waiting, or putting the thread in the endpoint's receiving queue if not, ensuring that threads can effectively receive and process notifications.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Asynchronous Message Transfers", "comment": "Handle a receive operation performed on a notification object by a\nthread. If a message is waiting then perform the transfer, otherwise put the\nthread in the endpoint's receiving queue."}
{"spec": "text \\<open>When a thread encounters a fault, retreive its fault handler capability\nand send a fault message.\\<close>\ndefinition\n  send_fault_ipc :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n  \"send_fault_ipc tptr fault \\<equiv> doE\n     handler_cptr \\<leftarrow> liftE $ thread_get tcb_fault_handler tptr;\n     handler_cap \\<leftarrow> cap_fault_on_failure (of_bl handler_cptr) False $\n         lookup_cap tptr handler_cptr;\n\n     let f = CapFault (of_bl handler_cptr) False (MissingCapability 0)\n     in\n     (case handler_cap\n       of EndpointCap ref badge rights \\<Rightarrow>\n           if AllowSend \\<in> rights \\<and> (AllowGrant \\<in> rights \\<or> AllowGrantReply \\<in> rights)\n           then liftE $ (do\n               thread_set (\\<lambda>tcb. tcb \\<lparr> tcb_fault := Some fault \\<rparr>) tptr;\n               send_ipc True True (cap_ep_badge handler_cap)\n                        (AllowGrant \\<in> rights) True tptr (cap_ep_ptr handler_cap)\n             od)\n           else throwError f\n        | _ \\<Rightarrow> throwError f)\n   odE\"", "property": "Send Fault IPC: When a thread encounters a fault, retrieve its fault handler capability and send a fault message to the handler if it has the necessary rights, otherwise throw an error. \n\nSubproperties:\n- Retrieve the fault handler capability from the thread.\n- Check if the handler capability has the necessary rights to send a fault message.\n- If the rights are sufficient, update the thread's fault state and send the fault message to the handler.\n- If the rights are insufficient, throw an error indicating a missing capability.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Sending Fault Messages", "comment": ""}
{"spec": "definition\n  handle_double_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_double_fault tptr ex1 ex2 \\<equiv> set_thread_state tptr Inactive\"", "property": "Fault Handling: If a fault message cannot be sent, the thread is left inactive.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Sending Fault Messages", "comment": "If a fault message cannot be sent then leave the thread inactive."}
{"spec": "definition\n  handle_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault thread ex \\<equiv> do\n     _ \\<leftarrow> gets_the $ get_tcb thread;\n     send_fault_ipc thread ex\n          <catch> handle_double_fault thread ex;\n     return ()\n   od\"\n\nend", "property": "Fault Handling: Handle a thread fault by sending a fault message if possible, and catch any double faults that occur during the sending process. \n\nSubproperties:\n- Send a fault message to the faulting thread if possible.\n- Catch and handle double faults that occur during the sending process.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Sending Fault Messages", "comment": "Handle a thread fault by sending a fault message if possible."}
{"spec": "text \\<open>This definition decodes CNode invocations.\\<close>\n\ndefinition\n  decode_cnode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap \\<Rightarrow> cap list \\<Rightarrow> (cnode_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_cnode_invocation label args cap excaps \\<equiv> doE\n  unlessE (gen_invocation_type label \\<in> set [CNodeRevoke .e. CNodeSaveCaller]) $\n    throwError IllegalOperation;\n  whenE (length args < 2) (throwError TruncatedMessage);\n  index \\<leftarrow> returnOk $ data_to_cptr $ args ! 0;\n  bits \\<leftarrow> returnOk $ data_to_nat $ args ! 1;\n  args \\<leftarrow> returnOk $ drop 2 args;\n  dest_slot \\<leftarrow> lookup_target_slot cap index bits;\n  if length args \\<ge> 2 \\<and> length excaps > 0\n        \\<and> gen_invocation_type label \\<in> set [CNodeCopy .e. CNodeMutate] then\n  doE\n    src_index \\<leftarrow> returnOk $ data_to_cptr $ args ! 0;\n    src_depth \\<leftarrow> returnOk $ data_to_nat $ args ! 1;\n    args \\<leftarrow> returnOk $ drop 2 args;\n    src_root_cap \\<leftarrow> returnOk $ excaps ! 0;\n    ensure_empty dest_slot;\n    src_slot \\<leftarrow>\n         lookup_source_slot src_root_cap src_index src_depth;\n    src_cap \\<leftarrow> liftE $ get_cap src_slot;\n    whenE (src_cap = NullCap) $\n         throwError $ FailedLookup True $ MissingCapability src_depth;\n    (rights, cap_data, is_move) \\<leftarrow> case (gen_invocation_type label, args) of\n      (CNodeCopy, rightsWord # _) \\<Rightarrow> doE\n                    rights \\<leftarrow> returnOk $ data_to_rights $ rightsWord;\n                    returnOk $ (rights, None, False)\n                odE\n     | (CNodeMint, rightsWord # capData # _) \\<Rightarrow> doE\n                    rights \\<leftarrow> returnOk $ data_to_rights $ rightsWord;\n                    returnOk $ (rights, Some capData, False)\n                odE\n     | (CNodeMove, _) \\<Rightarrow> returnOk (all_rights, None, True)\n     | (CNodeMutate, capData # _) \\<Rightarrow> returnOk (all_rights, Some capData, True)\n     | _ \\<Rightarrow> throwError TruncatedMessage;\n    src_cap \\<leftarrow> returnOk $ mask_cap rights src_cap;\n    new_cap \\<leftarrow> (if is_move then returnOk else derive_cap src_slot) (case cap_data of\n                  Some w \\<Rightarrow> update_cap_data is_move w src_cap\n                | None \\<Rightarrow> src_cap);\n    whenE (new_cap = NullCap) $ throwError IllegalOperation;\n    returnOk $ (if is_move then MoveCall else InsertCall) new_cap src_slot dest_slot\n  odE\n  else if gen_invocation_type label = CNodeRevoke then returnOk $ RevokeCall dest_slot\n  else if gen_invocation_type label = CNodeDelete then returnOk $ DeleteCall dest_slot\n  else if gen_invocation_type label = CNodeSaveCaller then doE\n    ensure_empty dest_slot;\n    returnOk $ SaveCall dest_slot\n  odE\n  else if gen_invocation_type label = CNodeCancelBadgedSends then doE\n    cap \\<leftarrow> liftE $ get_cap dest_slot;\n    unlessE (has_cancel_send_rights cap) $ throwError IllegalOperation;\n    returnOk $ CancelBadgedSendsCall cap\n  odE\n  else if gen_invocation_type label = CNodeRotate \\<and> length args > 5\n          \\<and> length excaps > 1 then\n  doE\n    pivot_new_data \\<leftarrow> returnOk $ args ! 0;\n    pivot_index \\<leftarrow> returnOk $ data_to_cptr $ args ! 1;\n    pivot_depth \\<leftarrow> returnOk $ data_to_nat $ args ! 2;\n    src_new_data \\<leftarrow> returnOk $ args ! 3;\n    src_index \\<leftarrow> returnOk $ data_to_cptr $ args ! 4;\n    src_depth \\<leftarrow> returnOk $ data_to_nat $ args ! 5;\n    pivot_root_cap <- returnOk $ excaps ! 0;\n    src_root_cap <- returnOk $ excaps ! 1;\n\n    src_slot <- lookup_source_slot src_root_cap src_index src_depth;\n    pivot_slot <- lookup_pivot_slot pivot_root_cap pivot_index pivot_depth;\n\n    whenE (pivot_slot = src_slot \\<or> pivot_slot = dest_slot) $\n      throwError IllegalOperation;\n\n    unlessE (src_slot = dest_slot) $ ensure_empty dest_slot;\n\n    src_cap <- liftE $ get_cap src_slot;\n    whenE (src_cap = NullCap) $\n      throwError $ FailedLookup True $ MissingCapability src_depth;\n\n    pivot_cap <- liftE $ get_cap pivot_slot;\n    whenE (pivot_cap = NullCap) $\n      throwError $ FailedLookup False $ MissingCapability pivot_depth;\n\n    new_src_cap \\<leftarrow> returnOk $ update_cap_data True src_new_data src_cap;\n    new_pivot_cap \\<leftarrow> returnOk $ update_cap_data True pivot_new_data pivot_cap;\n\n    whenE (new_src_cap = NullCap) $ throwError IllegalOperation;\n    whenE (new_pivot_cap = NullCap) $ throwError IllegalOperation;\n\n    returnOk $ RotateCall new_src_cap new_pivot_cap src_slot pivot_slot dest_slot\n  odE\n  else\n    throwError TruncatedMessage\nodE\"", "property": "CNode Invocation Decoding: Decodes CNode invocations, ensuring the invocation type is valid and the message is not truncated. It retrieves the destination slot, checks for sufficient arguments and capabilities, and performs the required operation (e.g., copy, move, mutate, revoke, delete, save caller, cancel badged sends, or rotate) based on the invocation type.\n\nSubproperties:\n- Invocation Type Validation: Verifies that the invocation type is one of the allowed CNode invocation types.\n- Message Validation: Checks that the message is not truncated and contains the required number of arguments.\n- Destination Slot Retrieval: Looks up the destination slot based on the provided index and bits.\n- Operation-Specific Handling: Performs the specific operation based on the invocation type, which may involve retrieving source slots, checking capabilities, and updating or moving capabilities.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Threads", "comment": ""}
{"spec": "text \\<open>The definitions in this section decode invocations\non TCBs.\n\\<close>", "property": "TCB Invocation Decoding: Correctly interpret and decode system calls related to thread control blocks (TCBs), ensuring that the kernel accurately understands and responds to thread management requests.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Threads", "comment": ""}
{"spec": "definition\n  decode_read_registers :: \"data list \\<Rightarrow> cap \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_read_registers data cap \\<equiv> case data of\n  flags#n#_ \\<Rightarrow> doE\n    range_check n 1 $ of_nat (length frameRegisters + length gpRegisters);\n    p \\<leftarrow> case cap of ThreadCap p \\<Rightarrow> returnOk p;\n    self \\<leftarrow> liftE $ gets cur_thread;\n    whenE (p = self) $ throwError IllegalOperation;\n    returnOk $ ReadRegisters p (flags !! 0) n ArchDefaultExtraRegisters\n  odE\n| _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition\n  decode_copy_registers :: \"data list \\<Rightarrow> cap \\<Rightarrow> cap list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_copy_registers data cap extra_caps \\<equiv> case data of\n  flags#_ \\<Rightarrow>  doE\n    suspend_source \\<leftarrow> returnOk (flags !! 0);\n    resume_target \\<leftarrow> returnOk (flags !! 1);\n    transfer_frame \\<leftarrow> returnOk (flags !! 2);\n    transfer_integer \\<leftarrow> returnOk (flags !! 3);\n    whenE (extra_caps = []) $ throwError TruncatedMessage;\n    src_tcb \\<leftarrow> (case extra_caps of\n      ThreadCap p # _ \\<Rightarrow> returnOk p\n    | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n    p \\<leftarrow> case cap of ThreadCap p \\<Rightarrow> returnOk p;\n    returnOk $ CopyRegisters p src_tcb\n                             suspend_source resume_target\n                             transfer_frame transfer_integer\n                             ArchDefaultExtraRegisters\n  odE\n| _ \\<Rightarrow>  throwError TruncatedMessage\"\n\n\ndefinition\n  decode_write_registers :: \"data list \\<Rightarrow> cap \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_write_registers data cap \\<equiv> case data of\n  flags#n#values \\<Rightarrow> doE\n    whenE (length values < unat n) $ throwError TruncatedMessage;\n    p \\<leftarrow> case cap of ThreadCap p \\<Rightarrow> returnOk p;\n    self \\<leftarrow> liftE $ gets cur_thread;\n    whenE (p = self) $ throwError IllegalOperation;\n    returnOk $ WriteRegisters p (flags !! 0)\n               (take (unat n) values) ArchDefaultExtraRegisters\n  odE\n| _ \\<Rightarrow> throwError TruncatedMessage\"\n\n\ndefinition\n  check_prio :: \"data \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"check_prio new_prio auth_tcb \\<equiv>\n    doE\n      mcp \\<leftarrow> liftE $ thread_get tcb_mcpriority auth_tcb;\n      whenE (new_prio > ucast mcp) $ throwError (RangeError 0 (ucast mcp))\n    odE\"\n\n\ndefinition\n  decode_set_priority :: \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_priority args cap slot extra_caps \\<equiv> doE\n     whenE (length args = 0 \\<or> length extra_caps = 0) $ throwError TruncatedMessage;\n     prio \\<leftarrow> returnOk $ ucast (args ! 0);\n     auth_tcb \\<leftarrow> case fst (extra_caps ! 0) of\n         ThreadCap tcb_ptr \\<Rightarrow> returnOk tcb_ptr\n       | _ \\<Rightarrow> throwError (InvalidCapability 1);\n     check_prio (args ! 0) auth_tcb;\n     returnOk (ThreadControl (obj_ref_of cap) slot None None\n                             (Some (prio, auth_tcb)) None None None)\n     odE\"\n\n\ndefinition\n  decode_set_mcpriority :: \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_mcpriority args cap slot extra_caps \\<equiv> doE\n     whenE (length args = 0 \\<or> length extra_caps = 0) $ throwError TruncatedMessage;\n     new_mcp \\<leftarrow> returnOk $ ucast $ args ! 0;\n     auth_tcb \\<leftarrow> case fst (extra_caps ! 0) of\n         ThreadCap tcb_ptr \\<Rightarrow> returnOk tcb_ptr\n       | _ \\<Rightarrow> throwError (InvalidCapability 1);\n     check_prio (args ! 0) auth_tcb;\n     returnOk (ThreadControl (obj_ref_of cap) slot None (Some (new_mcp, auth_tcb))\n                             None None None None)\n     odE\"\n\n\ndefinition\n  decode_set_sched_params :: \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_sched_params args cap slot extra_caps \\<equiv> doE\n     whenE (length args < 2) $ throwError TruncatedMessage;\n     whenE (length extra_caps = 0) $ throwError TruncatedMessage;\n     new_mcp \\<leftarrow> returnOk $ ucast $ args ! 0;\n     new_prio \\<leftarrow> returnOk $ ucast $ args ! 1;\n     auth_tcb \\<leftarrow> case fst (extra_caps ! 0) of\n         ThreadCap tcb_ptr \\<Rightarrow> returnOk tcb_ptr\n       | _ \\<Rightarrow> throwError (InvalidCapability 1);\n     check_prio (args ! 0) auth_tcb;\n     check_prio (args ! 1) auth_tcb;\n     returnOk (ThreadControl (obj_ref_of cap) slot None\n                             (Some (new_mcp, auth_tcb)) (Some (new_prio, auth_tcb)) None None None)\n     odE\"\n\n\ndefinition\n  decode_set_ipc_buffer ::\n  \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_set_ipc_buffer args cap slot excs \\<equiv> doE\n  whenE (length args = 0) $ throwError TruncatedMessage;\n  whenE (length excs = 0) $ throwError TruncatedMessage;\n  buffer \\<leftarrow> returnOk $ data_to_vref $ args ! 0;\n  (bcap, bslot) \\<leftarrow> returnOk $ excs ! 0;\n  newbuf \\<leftarrow> if buffer = 0 then returnOk None\n           else doE\n      buffer_cap \\<leftarrow> derive_cap bslot bcap;\n      check_valid_ipc_buffer buffer buffer_cap;\n      returnOk $ Some (buffer_cap, bslot)\n    odE;\n  returnOk $\n    ThreadControl (obj_ref_of cap) slot None None None None None (Some (buffer, newbuf))\nodE\"\n\n\ndefinition\n  decode_set_space\n  :: \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_space args cap slot excaps \\<equiv> doE\n   whenE (length args < 3 \\<or> length excaps < 2) $ throwError TruncatedMessage;\n   fault_ep \\<leftarrow> returnOk $ args ! 0;\n   croot_data  \\<leftarrow> returnOk $ args ! 1;\n   vroot_data  \\<leftarrow> returnOk $ args ! 2;\n   croot_arg  \\<leftarrow> returnOk $ excaps ! 0;\n   vroot_arg  \\<leftarrow> returnOk $ excaps ! 1;\n   can_chg_cr \\<leftarrow> liftE $ liftM Not $ slot_cap_long_running_delete\n                      $ get_tcb_ctable_ptr $ obj_ref_of cap;\n   can_chg_vr \\<leftarrow> liftE $ liftM Not $ slot_cap_long_running_delete\n                      $ get_tcb_vtable_ptr $ obj_ref_of cap;\n   unlessE (can_chg_cr \\<and> can_chg_vr) $ throwError IllegalOperation;\n\n   croot_cap  \\<leftarrow> returnOk $ fst croot_arg;\n   croot_slot \\<leftarrow> returnOk $ snd croot_arg;\n   croot_cap' \\<leftarrow> derive_cap croot_slot $\n                   (if croot_data = 0 then id else update_cap_data False croot_data)\n                   croot_cap;\n   unlessE (is_cnode_cap croot_cap') $ throwError IllegalOperation;\n   croot \\<leftarrow> returnOk (croot_cap', croot_slot);\n\n   vroot_cap  \\<leftarrow> returnOk $ fst vroot_arg;\n   vroot_slot \\<leftarrow> returnOk $ snd vroot_arg;\n   vroot_cap' \\<leftarrow> derive_cap vroot_slot $\n                   (if vroot_data = 0 then id else update_cap_data False vroot_data)\n                   vroot_cap;\n   unlessE (is_valid_vtable_root vroot_cap') $ throwError IllegalOperation;\n   vroot \\<leftarrow> returnOk (vroot_cap', vroot_slot);\n\n   returnOk $ ThreadControl (obj_ref_of cap) slot (Some (to_bl fault_ep)) None None\n                            (Some croot) (Some vroot) None\n odE\"\n\n\ndefinition\n  decode_tcb_configure ::\n  \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_tcb_configure args cap slot extra_caps \\<equiv> doE\n     whenE (length args < 4) $ throwError TruncatedMessage;\n     whenE (length extra_caps < 3) $ throwError TruncatedMessage;\n     fault_ep \\<leftarrow> returnOk $ args ! 0;\n     croot_data \\<leftarrow> returnOk $ args ! 1;\n     vroot_data \\<leftarrow> returnOk $ args ! 2;\n     crootvroot \\<leftarrow> returnOk $ take 2 extra_caps;\n     buffer_cap \\<leftarrow> returnOk $ extra_caps ! 2;\n     buffer \\<leftarrow> returnOk $ args ! 3;\n     set_params \\<leftarrow> decode_set_ipc_buffer [buffer] cap slot [buffer_cap];\n     set_space \\<leftarrow> decode_set_space [fault_ep, croot_data, vroot_data] cap slot crootvroot;\n     returnOk $ ThreadControl (obj_ref_of cap) slot (tc_new_fault_ep set_space)\n                              None None\n                              (tc_new_croot set_space) (tc_new_vroot set_space)\n                              (tc_new_buffer set_params)\n   odE\"\n\ndefinition\n  decode_bind_notification ::\n  \"cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_bind_notification cap extra_caps \\<equiv> case cap of\n    ThreadCap tcb \\<Rightarrow> doE\n     whenE (length extra_caps = 0) $ throwError TruncatedMessage;\n     nTFN \\<leftarrow> liftE $ get_bound_notification tcb;\n     case nTFN of\n         Some _ \\<Rightarrow> throwError IllegalOperation\n       | None \\<Rightarrow> returnOk ();\n     (ntfnptr, rights) \\<leftarrow> case fst (hd extra_caps) of\n         NotificationCap ptr _ r \\<Rightarrow> returnOk (ptr, r)\n       | _ \\<Rightarrow> throwError IllegalOperation;\n     whenE (AllowRecv \\<notin> rights) $ throwError IllegalOperation;\n     ntfn \\<leftarrow> liftE  $ get_notification ntfnptr;\n     case (ntfn_obj ntfn, ntfn_bound_tcb ntfn) of\n         (IdleNtfn, None) \\<Rightarrow> returnOk ()\n       | (ActiveNtfn _, None) \\<Rightarrow> returnOk ()\n       | _ \\<Rightarrow> throwError IllegalOperation;\n      returnOk $ NotificationControl tcb (Some ntfnptr)\n   odE\n | _ \\<Rightarrow> throwError IllegalOperation\"\n\n\ndefinition\n  decode_unbind_notification :: \"cap \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_unbind_notification cap \\<equiv> case cap of\n     ThreadCap tcb \\<Rightarrow> doE\n       nTFN \\<leftarrow> liftE $ get_bound_notification tcb;\n       case nTFN of\n           None \\<Rightarrow> throwError IllegalOperation\n         | Some _ \\<Rightarrow> returnOk ();\n       returnOk $ NotificationControl tcb None\n    odE\n | _ \\<Rightarrow> throwError IllegalOperation\"\n\ndefinition\n  decode_set_tls_base :: \"data list \\<Rightarrow> cap \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_tls_base args cap \\<equiv> doE\n     whenE (length args = 0) $ throwError TruncatedMessage;\n     returnOk (SetTLSBase (obj_ref_of cap) (ucast (args ! 0)))\n   odE\"\n\ndefinition\n  decode_tcb_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n  (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n \"decode_tcb_invocation label args cap slot excs \\<equiv>\n  case gen_invocation_type label of\n      TCBReadRegisters \\<Rightarrow> decode_read_registers args cap\n    | TCBWriteRegisters \\<Rightarrow> decode_write_registers args cap\n    | TCBCopyRegisters \\<Rightarrow> decode_copy_registers args cap $ map fst excs\n    | TCBSuspend \\<Rightarrow> returnOk $ Suspend $ obj_ref_of cap\n    | TCBResume \\<Rightarrow> returnOk $ Resume $ obj_ref_of cap\n    | TCBConfigure \\<Rightarrow> decode_tcb_configure args cap slot excs\n    | TCBSetPriority \\<Rightarrow> decode_set_priority args cap slot excs\n    | TCBSetMCPriority \\<Rightarrow> decode_set_mcpriority args cap slot excs\n    | TCBSetSchedParams \\<Rightarrow> decode_set_sched_params args cap slot excs\n    | TCBSetIPCBuffer \\<Rightarrow> decode_set_ipc_buffer args cap slot excs\n    | TCBSetSpace \\<Rightarrow> decode_set_space args cap slot excs\n    | TCBBindNotification \\<Rightarrow> decode_bind_notification cap excs\n    | TCBUnbindNotification \\<Rightarrow> decode_unbind_notification cap\n    | TCBSetTLSBase \\<Rightarrow> decode_set_tls_base args cap\n    | _ \\<Rightarrow> throwError IllegalOperation\"\n\ndefinition\n  decode_domain_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    ((obj_ref \\<times> domain), 'z::state_ext) se_monad\"\nwhere\n  \"decode_domain_invocation label args excs \\<equiv> doE\n     whenE (gen_invocation_type label \\<noteq> DomainSetSet) $ throwError IllegalOperation;\n     domain \\<leftarrow> (case args of\n       x # xs \\<Rightarrow> doE\n         whenE (unat x \\<ge> numDomains) $ throwError $ InvalidArgument 0;\n         returnOk (ucast x)\n       odE\n       | _ \\<Rightarrow> throwError TruncatedMessage);\n     whenE (length excs = 0) $ throwError TruncatedMessage;\n     case (fst (hd excs)) of ThreadCap ptr \\<Rightarrow> returnOk $ (ptr, domain)\n       | _ \\<Rightarrow> throwError $ InvalidArgument 1\n   odE\"", "property": "TCB Invocation Decoding: Decodes system calls related to thread control, including reading and writing registers, copying registers, suspending and resuming threads, configuring threads, setting priorities and scheduling parameters, binding and unbinding notifications, and setting the TLS base.\n\nSubproperties:\n- Decodes system calls for reading and writing registers, ensuring that the thread being accessed is not the current thread.\n- Decodes system calls for copying registers between threads.\n- Decodes system calls for suspending and resuming threads.\n- Decodes system calls for configuring threads, including setting fault endpoints, capability roots, and IPC buffers.\n- Decodes system calls for setting priorities and scheduling parameters, ensuring that the new priority is within the valid range.\n- Decodes system calls for binding and unbinding notifications, ensuring that the notification is not already bound and that the thread has the necessary rights.\n- Decodes system calls for setting the TLS base.\n\nDomain Invocation Decoding: Decodes system calls related to domain management, specifically setting the domain for a thread.\n\nSubproperties:\n- Decodes system calls for setting the domain for a thread, ensuring that the domain is valid and that the thread is a ThreadCap.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Threads", "comment": "This definition checks whether the first argument is\nbetween the second and third.\n"}
{"spec": "text \\<open>The following two definitions decode system calls for the\ninterrupt controller and interrupt handlers\\<close>\n\ndefinition\n  decode_irq_control_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list\n                                     \\<Rightarrow> (irq_control_invocation,'z::state_ext) se_monad\" where\n \"decode_irq_control_invocation label args src_slot cps \\<equiv>\n  (if gen_invocation_type label = IRQIssueIRQHandler\n    then if length args \\<ge> 3 \\<and> length cps \\<ge> 1\n      then let irq_word = args ! 0;\n               index = args ! 1;\n               depth = args ! 2;\n               cnode = cps ! 0;\n               irq = ucast irq_word\n      in doE\n        arch_check_irq irq_word;\n        irq_active \\<leftarrow> liftE $ is_irq_active irq;\n        whenE irq_active $ throwError RevokeFirst;\n\n        dest_slot \\<leftarrow> lookup_target_slot\n               cnode (data_to_cptr index) (unat depth);\n        ensure_empty dest_slot;\n\n        returnOk $ IRQControl irq dest_slot src_slot\n      odE\n    else throwError TruncatedMessage\n  else liftME ArchIRQControl $ arch_decode_irq_control_invocation label args src_slot cps)\"\n\ndefinition\n  decode_irq_handler_invocation :: \"data \\<Rightarrow> irq \\<Rightarrow> (cap \\<times> cslot_ptr) list\n                                     \\<Rightarrow> (irq_handler_invocation,'z::state_ext) se_monad\" where\n \"decode_irq_handler_invocation label irq cps \\<equiv>\n  if gen_invocation_type label = IRQAckIRQ\n    then returnOk $ ACKIrq irq\n  else if gen_invocation_type label = IRQSetIRQHandler\n    then if cps \\<noteq> []\n      then let (cap, slot) = hd cps in\n      if is_ntfn_cap cap \\<and> AllowSend \\<in> cap_rights cap\n      then returnOk $ SetIRQHandler irq cap slot\n      else throwError $ InvalidCapability 0\n    else throwError TruncatedMessage\n  else if gen_invocation_type label = IRQClearIRQHandler\n    then returnOk $ ClearIRQHandler irq\n  else throwError IllegalOperation\"", "property": "IRQ Decoding: Decodes system calls for interrupt controller and interrupt handlers, ensuring that the invocation type matches the expected format and that the provided arguments and capabilities are valid.\n\nSubproperties:\n- IRQ Issue IRQ Handler: Validates the IRQ word, checks if the IRQ is active, and ensures the destination slot is empty before issuing the IRQ handler.\n- IRQ Handler Invocation: Decodes the invocation type and validates the provided capabilities and arguments for ACK IRQ, Set IRQ Handler, and Clear IRQ Handler operations.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "IRQ", "comment": ""}
{"spec": "text \\<open>The definitions in this section deal with decoding invocations\nof untyped memory capabilities.\n\\<close>\n\ndefinition\n  data_to_obj_type :: \"data \\<Rightarrow> (apiobject_type,'z::state_ext) se_monad\" where\n  \"data_to_obj_type type \\<equiv> doE\n    n \\<leftarrow> returnOk $ data_to_nat type;\n    if n = 0 then\n      returnOk $ Untyped\n    else if n = 1 then\n      returnOk $ TCBObject\n    else if n = 2 then\n      returnOk $ EndpointObject\n    else if n = 3 then\n      returnOk $ NotificationObject\n    else if n = 4 then\n      returnOk $ CapTableObject\n    else (case arch_data_to_obj_type (n - 5)\n       of Some tp \\<Rightarrow> returnOk (ArchObject tp)\n        | None \\<Rightarrow> throwError (InvalidArgument 0))\n  odE\"\n\ndefinition\n  decode_untyped_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> cap list \\<Rightarrow> (untyped_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_untyped_invocation label args slot cap excaps \\<equiv> doE\n  unlessE (gen_invocation_type label = UntypedRetype) $ throwError IllegalOperation;\n  whenE (length args < 6) $ throwError TruncatedMessage;\n  whenE (length excaps = 0) $ throwError TruncatedMessage;\n  root_cap \\<leftarrow> returnOk $ excaps ! 0;\n  new_type \\<leftarrow> data_to_obj_type (args!0);\n\n  user_obj_size \\<leftarrow> returnOk $ data_to_nat (args!1);\n  object_size \\<leftarrow> returnOk (obj_bits_api new_type user_obj_size);\n  unlessE (user_obj_size < word_bits \\<and> object_size \\<le> untyped_max_bits)\n    $ throwError (RangeError 0 (of_nat untyped_max_bits));\n  whenE (new_type = CapTableObject \\<and> user_obj_size = 0)\n    $ throwError (InvalidArgument 1);\n  whenE (new_type = Untyped \\<and> user_obj_size < untyped_min_bits)\n    $ throwError (InvalidArgument 1);\n  node_index \\<leftarrow> returnOk $ data_to_cptr (args!2);\n  node_depth \\<leftarrow> returnOk $ data_to_nat (args!3);\n\n  node_cap \\<leftarrow> if node_depth = 0\n        then returnOk root_cap\n        else doE\n            node_slot \\<leftarrow> lookup_target_slot\n                root_cap node_index node_depth;\n            liftE $ get_cap node_slot\n        odE;\n\n  if is_cnode_cap node_cap\n        then  returnOk ()\n        else  throwError $ FailedLookup False $ MissingCapability node_depth;\n\n  node_offset \\<leftarrow> returnOk $ data_to_nat (args ! 4);\n  node_window \\<leftarrow> returnOk $ data_to_nat (args ! 5);\n  radix_bits \\<leftarrow> returnOk $ bits_of node_cap;\n  node_size \\<leftarrow> returnOk (2 ^ radix_bits);\n\n  whenE (node_offset < 0 \\<or> node_offset > node_size - 1) $\n    throwError $ RangeError 0 (of_nat (node_size - 1));\n\n  whenE (node_window < 1 \\<or> node_window > unat retypeFanOutLimit) $ throwError $ RangeError 1 retypeFanOutLimit;\n\n  whenE (node_window < 1 \\<or> node_window > node_size - node_offset) $\n    throwError $ RangeError 1 (of_nat (node_size - node_offset));\n\n  oref \\<leftarrow> returnOk $ obj_ref_of node_cap;\n  offsets \\<leftarrow> returnOk $ map (nat_to_cref radix_bits)\n                           [node_offset ..< node_offset + node_window];\n  slots \\<leftarrow> returnOk $ map (\\<lambda>cref. (oref, cref)) offsets;\n\n  mapME_x ensure_empty slots;\n\n  reset \\<leftarrow> liftE $ const_on_failure False $ (doE\n    ensure_no_children slot;\n    returnOk True\n  odE);\n\n  free_index \\<leftarrow> returnOk (if reset then 0 else free_index_of cap);\n  free_ref \\<leftarrow> returnOk (get_free_ref (obj_ref_of cap) free_index);\n  aligned_free_ref \\<leftarrow> returnOk (alignUp free_ref object_size);\n  untyped_free_bytes \\<leftarrow> returnOk (obj_size cap - of_nat (free_index));\n\n  max_count \\<leftarrow> returnOk ( untyped_free_bytes >> object_size);\n  whenE (unat max_count < node_window) $\n        throwError $ NotEnoughMemory $ untyped_free_bytes;\n\n  not_frame \\<leftarrow> returnOk (\\<not> is_frame_type new_type);\n  (ptr, is_device) \\<leftarrow> case cap of\n                        UntypedCap dev p n f \\<Rightarrow> returnOk (p,dev)\n                      | _ \\<Rightarrow> fail;\n  whenE (is_device \\<and> not_frame \\<and> new_type \\<noteq> Untyped) $\n           throwError $ InvalidArgument 1;\n  returnOk $ Retype slot reset ptr aligned_free_ref new_type user_obj_size slots is_device\nodE\"", "property": "Untyped Invocation Decoding: Decodes invocations of untyped memory capabilities, ensuring the validity of the provided arguments, capability lists, and memory requirements. It checks for errors such as truncated messages, invalid arguments, range errors, and failed lookups, and returns a valid untyped invocation if all checks pass.\n\nSubproperties:\n- Argument Validation: Verifies that the provided arguments are valid, including the label, capability lists, and data.\n- Memory Requirement Checks: Ensures that the requested memory allocation is within the allowed limits and that the object size is valid.\n- Capability List Validation: Checks that the provided capability lists are not empty and contain the required capabilities.\n- Error Handling: Throws errors if any of the checks fail, providing specific error messages for each type of error.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Untyped", "comment": ""}
{"spec": "text \\<open>This definition is the toplevel decoding definition; it dispatches\nto the above definitions, after checking, in some cases, whether the\ninvocation is allowed.\n\\<close>\n\ndefinition\n  decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_invocation label args cap_index slot cap excaps \\<equiv>\n  case cap of\n    EndpointCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeEndpoint ptr badge (AllowGrant \\<in> rights) (AllowGrantReply \\<in> rights)\n      else throwError $ InvalidCapability 0\n  | NotificationCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeNotification ptr badge\n      else throwError $ InvalidCapability 0\n  | ReplyCap thread False rights \\<Rightarrow>\n      returnOk $ InvokeReply thread slot (AllowGrant \\<in> rights)\n  | IRQControlCap \\<Rightarrow>\n      liftME InvokeIRQControl\n        $ decode_irq_control_invocation label args slot (map fst excaps)\n  | IRQHandlerCap irq \\<Rightarrow>\n      liftME InvokeIRQHandler\n        $ decode_irq_handler_invocation label irq excaps\n  | ThreadCap ptr \\<Rightarrow>\n      liftME InvokeTCB $ decode_tcb_invocation label args cap slot excaps\n  | DomainCap \\<Rightarrow>\n      liftME (case_prod InvokeDomain) $ decode_domain_invocation label args excaps\n  | CNodeCap ptr bits _ \\<Rightarrow>\n      liftME InvokeCNode $ decode_cnode_invocation label args cap (map fst excaps)\n  | UntypedCap dev ptr sz fi \\<Rightarrow>\n      liftME InvokeUntyped $ decode_untyped_invocation label args slot cap (map fst excaps)\n  | ArchObjectCap arch_cap \\<Rightarrow>\n      liftME InvokeArchObject $\n        arch_decode_invocation label args cap_index slot arch_cap excaps\n  | _ \\<Rightarrow>\n      throwError $ InvalidCapability 0\"\n\nend", "property": "System Call Decoding: Decodes the invocation of a system call based on the provided capability, arguments, and slot information, dispatching to specific decoding functions for different capability types and checking for permission and validity as necessary. \n\nSubproperties:\n- Endpoint Invocation: Decodes an endpoint invocation, checking for send rights and returning an error if not allowed.\n- Notification Invocation: Decodes a notification invocation, checking for send rights and returning an error if not allowed.\n- Reply Invocation: Decodes a reply invocation, checking for grant rights.\n- IRQ Control Invocation: Decodes an IRQ control invocation using the provided label, arguments, and slot information.\n- IRQ Handler Invocation: Decodes an IRQ handler invocation using the provided label, IRQ, and extra capabilities.\n- TCB Invocation: Decodes a TCB invocation using the provided label, arguments, capability, slot, and extra capabilities.\n- Domain Invocation: Decodes a domain invocation using the provided label, arguments, and extra capabilities.\n- CNode Invocation: Decodes a CNode invocation using the provided label, arguments, capability, and extra capabilities.\n- Untyped Invocation: Decodes an untyped invocation using the provided label, arguments, slot, capability, and extra capabilities.\n- Arch Object Invocation: Decodes an architecture-specific object invocation using the provided label, arguments, capability index, slot, architecture-specific capability, and extra capabilities.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Toplevel invocation decode.", "comment": ""}
{"spec": "definition\n  get_ep_queue :: \"endpoint \\<Rightarrow> (obj_ref list,'z::state_ext) s_monad\"\nwhere\n \"get_ep_queue ep \\<equiv> case ep of SendEP q \\<Rightarrow> return q\n                              | RecvEP q \\<Rightarrow> return q\n                              | _ \\<Rightarrow> fail\"\n\nprimrec (nonexhaustive)\n  update_ep_queue :: \"endpoint \\<Rightarrow> obj_ref list \\<Rightarrow> endpoint\"\nwhere\n  \"update_ep_queue (RecvEP q) q' = RecvEP q'\"\n| \"update_ep_queue (SendEP q) q' = SendEP q'\"", "property": "Endpoint Queue Management: Allows getting and setting the queues of an endpoint, handling both send and receive endpoints while rejecting other types of endpoints. \n\nGet Endpoint Queue: Retrieve the queue of threads waiting to send or receive on an endpoint.\n\nUpdate Endpoint Queue: Modify the queue of threads associated with a send or receive endpoint.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Getting and setting endpoint queues."}
{"spec": "definition\n  cancel_all_ipc :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_all_ipc epptr \\<equiv> do\n     ep \\<leftarrow> get_endpoint epptr;\n     case ep of IdleEP \\<Rightarrow> return ()\n               | _ \\<Rightarrow> do\n                        queue \\<leftarrow> get_ep_queue ep;\n                        set_endpoint epptr IdleEP;\n                        mapM_x (\\<lambda>t. do set_thread_state t Restart;\n                                       do_extended_op (tcb_sched_action (tcb_sched_enqueue) t) od) $ queue;\n                        do_extended_op (reschedule_required)\n                     od\n   od\"", "property": "Cancel All IPC Operations: Cancel all message operations on threads currently queued within a synchronous message endpoint, placing them in the Restart state to reattempt the operation upon scheduling.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel all message operations on threads currently queued within this\nsynchronous message endpoint. Threads so queued are placed in the Restart state.\nOnce scheduled they will reattempt the operation that previously caused them\nto be queued here."}
{"spec": "primrec (nonexhaustive)\n  blocking_ipc_badge :: \"thread_state \\<Rightarrow> badge\"\nwhere\n  \"blocking_ipc_badge (BlockedOnSend t payload) = sender_badge payload\"", "property": "Blocking IPC Badge: The badge stored by a thread waiting on a message send operation is the sender badge from the payload.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "The badge stored by thread waiting on a message send operation."}
{"spec": "definition\n  cancel_badged_sends :: \"obj_ref \\<Rightarrow> badge \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_badged_sends epptr badge \\<equiv> do\n    ep \\<leftarrow> get_endpoint epptr;\n    case ep of\n          IdleEP \\<Rightarrow> return ()\n        | RecvEP _ \\<Rightarrow>  return ()\n        | SendEP queue \\<Rightarrow>  do\n            set_endpoint epptr IdleEP;\n            queue' \\<leftarrow> (swp filterM queue) (\\<lambda> t. do\n                st \\<leftarrow> get_thread_state t;\n                if blocking_ipc_badge st = badge then do\n                  set_thread_state t Restart;\n                  do_extended_op (tcb_sched_action (tcb_sched_enqueue) t);\n                  return False od\n                else return True\n            od);\n            ep' \\<leftarrow> return (case queue' of\n                           [] \\<Rightarrow> IdleEP\n                         | _ \\<Rightarrow> SendEP queue');\n            set_endpoint epptr ep';\n            do_extended_op (reschedule_required)\n        od\n  od\"", "property": "Cancel Badged Sends: Cancel all message send operations on threads queued in a specific endpoint that are using a particular badge, and reschedule the affected threads. \n\nSubproperties:\n- Set the endpoint to idle if all send operations are cancelled.\n- Update the thread state to restart and re-enqueue the thread if its blocking IPC badge matches the specified badge.\n- Reschedule the threads after cancelling the send operations.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel all message send operations on threads queued in this endpoint\nand using a particular badge."}
{"spec": "abbreviation\n  do_unbind_notification :: \"obj_ref \\<Rightarrow> notification \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"do_unbind_notification ntfnptr ntfn tcbptr \\<equiv> do\n      ntfn' \\<leftarrow> return $ ntfn_set_bound_tcb ntfn None;\n      set_notification ntfnptr ntfn';\n      set_bound_notification tcbptr None\n    od\"\n\ndefinition\n  unbind_notification :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"unbind_notification tcb \\<equiv> do\n     ntfnptr \\<leftarrow> get_bound_notification tcb;\n     case ntfnptr of\n         Some ntfnptr' \\<Rightarrow> do\n             ntfn \\<leftarrow> get_notification ntfnptr';\n             do_unbind_notification ntfnptr' ntfn tcb\n          od\n       | None \\<Rightarrow> return ()\n   od\"\n\ndefinition\n  unbind_maybe_notification :: \"obj_ref \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"unbind_maybe_notification ntfnptr \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     (case ntfn_bound_tcb ntfn of\n       Some t \\<Rightarrow> do_unbind_notification ntfnptr ntfn t\n     | None \\<Rightarrow> return ())\n   od\"\n\ndefinition\n  cancel_all_signals :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_all_signals ntfnptr \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     case ntfn_obj ntfn of WaitingNtfn queue \\<Rightarrow> do\n                      _ \\<leftarrow> set_notification ntfnptr $ ntfn_set_obj ntfn IdleNtfn;\n                      mapM_x (\\<lambda>t. do set_thread_state t Restart;\n                                     do_extended_op (tcb_sched_action tcb_sched_enqueue t) od) queue;\n                      do_extended_op (reschedule_required)\n                     od\n               | _ \\<Rightarrow> return ()\n   od\"", "property": "Notification Endpoint Management: Cancel all message operations on threads queued in a notification endpoint, unbind notifications from threads, and update the notification object and thread states accordingly. \n\nSubproperties:\n- Unbind Notification: Remove the binding between a notification and a thread, updating the notification object and thread state.\n- Cancel Signals: Cancel all signals associated with a notification, updating the notification object and thread states, and rescheduling as necessary.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel all message operations on threads queued in a notification\nendpoint."}
{"spec": "definition\n  get_blocking_object :: \"thread_state \\<Rightarrow> (obj_ref,'z::state_ext) s_monad\"\nwhere\n \"get_blocking_object state \\<equiv>\n       case state of BlockedOnReceive epptr x \\<Rightarrow> return epptr\n                    | BlockedOnSend epptr x \\<Rightarrow> return epptr\n                    | _ \\<Rightarrow> fail\"", "property": "Get Blocking Object: Retrieve the endpoint pointer that a thread is blocked on, either for receiving or sending a message. \n\nSubproperties: \n- If the thread is blocked on receiving, return the endpoint pointer.\n- If the thread is blocked on sending, return the endpoint pointer.\n- If the thread is not blocked on receiving or sending, the operation fails.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "The endpoint pointer stored by a thread waiting for a message to be\ntransferred in either direction."}
{"spec": "definition\n  blocked_cancel_ipc :: \"thread_state \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"blocked_cancel_ipc state tptr \\<equiv> do\n     epptr \\<leftarrow> get_blocking_object state;\n     ep \\<leftarrow> get_endpoint epptr;\n     queue \\<leftarrow> get_ep_queue ep;\n     queue' \\<leftarrow> return $ remove1 tptr queue;\n     ep' \\<leftarrow> return (case queue' of [] \\<Rightarrow> IdleEP\n                                |  _ \\<Rightarrow> update_ep_queue ep queue');\n     set_endpoint epptr ep';\n     set_thread_state tptr Inactive\n   od\"", "property": "Cancel IPC Operation: Cancel the ongoing IPC operation of a thread by removing it from the endpoint queue, updating the endpoint state, and setting the thread state to inactive.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel whatever IPC operation a thread is engaged in."}
{"spec": "fun\n  fast_finalise :: \"cap \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"fast_finalise NullCap                  final = return ()\"\n| \"fast_finalise (ReplyCap r m R)         final = return ()\"\n| \"fast_finalise (EndpointCap r b R)      final =\n      (when final $ cancel_all_ipc r)\"\n| \"fast_finalise (NotificationCap r b R) final =\n      (when final $ do\n          unbind_maybe_notification r;\n          cancel_all_signals r\n       od)\"\n| \"fast_finalise (CNodeCap r bits g)      final = fail\"\n| \"fast_finalise (ThreadCap r)            final = fail\"\n| \"fast_finalise DomainCap                final = fail\"\n| \"fast_finalise (Zombie r b n)           final = fail\"\n| \"fast_finalise IRQControlCap            final = fail\"\n| \"fast_finalise (IRQHandlerCap irq)      final = fail\"\n| \"fast_finalise (UntypedCap dev r n f)       final = fail\"\n| \"fast_finalise (ArchObjectCap a)        final = fail\"", "property": "Fast Finalise Capability: Immediately finalise a capability if it is of a kind that can be finalised, specifically NullCap, ReplyCap, EndpointCap, or NotificationCap, and perform necessary cleanup actions such as cancelling IPC or signals, and unbinding notifications.\n\nSubproperties:\n- NullCap and ReplyCap finalisation are no-ops.\n- EndpointCap finalisation cancels all IPC when final flag is set.\n- NotificationCap finalisation unbinds notifications and cancels signals when final flag is set.\n- Other capability types (CNodeCap, ThreadCap, DomainCap, Zombie, IRQControlCap, IRQHandlerCap, UntypedCap, ArchObjectCap) cannot be fast finalised.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Finalise a capability if the capability is known to be of the kind\nwhich can be finalised immediately. This is a simplified version of the\n@{text finalise_cap} operation."}
{"spec": "definition\n  cap_irq_opt :: \"cap \\<Rightarrow> irq option\" where\n \"cap_irq_opt cap \\<equiv> case cap of IRQHandlerCap irq \\<Rightarrow> Some irq | _ \\<Rightarrow> None\"\n\ndefinition\n  cap_irqs :: \"cap \\<Rightarrow> irq set\" where\n \"cap_irqs cap \\<equiv> set_option (cap_irq_opt cap)\"", "property": "IRQ Retrieval: Extract the optional IRQ or set of IRQs associated with a capability. \n\nSubproperties:\n- Optional IRQ: Retrieve the optional IRQ stored in a capability, returning None if the capability is not an IRQHandlerCap.\n- IRQ Set: Convert the optional IRQ to a set, providing a collection of IRQs associated with the capability.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "The optional IRQ stored in a capability, presented either as an optional\nvalue or a set."}
{"spec": "datatype gen_obj_ref =\n    ObjRef obj_ref\n  | IRQRef irq\n  | ArchRef arch_gen_obj_ref\n\ndefinition\n  arch_cap_set_map :: \"(arch_cap \\<Rightarrow> 'a set) \\<Rightarrow> cap \\<Rightarrow> 'a set\"\nwhere\n  \"arch_cap_set_map f cap \\<equiv> case cap of\n       ArchObjectCap acap \\<Rightarrow> f acap\n     | _ \\<Rightarrow> {}\"\n\nabbreviation\n  arch_gen_refs :: \"cap \\<Rightarrow> arch_gen_obj_ref set\"\nwhere\n  \"arch_gen_refs \\<equiv> arch_cap_set_map arch_gen_obj_refs\"\n\ndefinition\n  gen_obj_refs :: \"cap \\<Rightarrow> gen_obj_ref set\"\nwhere\n  \"gen_obj_refs c \\<equiv> ObjRef ` (obj_refs c)\n                      \\<union> IRQRef ` (cap_irqs c)\n                      \\<union> ArchRef ` (arch_gen_refs c)\"\n\ndefinition\n  cap_cleanup_opt :: \"cap \\<Rightarrow> cap\"\nwhere\n  \"cap_cleanup_opt c \\<equiv> case c of\n      IRQHandlerCap _ \\<Rightarrow> c\n    | ArchObjectCap acap \\<Rightarrow> arch_cap_cleanup_opt acap\n    | _ \\<Rightarrow> NullCap\"", "property": "Generic Object Reference: Provides a way to refer to objects for finalization purposes, allowing comparison of capabilities to determine if they refer to the same object.\n\nSubproperties:\n- Object Reference Mapping: Maps a capability to a set of generic object references, including object references, IRQ references, and architecture-specific references.\n- Capability Cleanup: Cleans up a capability by either returning the original capability, applying architecture-specific cleanup, or replacing it with a null capability.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "A generic reference to an object. Used for the purposes of finalisation,\nwhere we want to be able to compare caps to decide if they refer to the \"same object\",\nwhich can be determined in several ways"}
{"spec": "definition\n  is_final_cap' :: \"cap \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n \"is_final_cap' cap s \\<equiv>\n    \\<exists>cref. {cref. \\<exists>cap'. fst (get_cap cref s) = {(cap', s)}\n                       \\<and> (gen_obj_refs cap \\<inter> gen_obj_refs cap' \\<noteq> {})}\n         = {cref}\"\n\ndefinition\n  is_final_cap :: \"cap \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n  \"is_final_cap cap \\<equiv> gets (is_final_cap' cap)\"", "property": "Detect Final Capability: Determine if a capability is the last one referencing a specific object in the system, requiring finalization actions upon its deletion. \n\nIs Final Capability: Check if a capability is the final capability to an object by verifying that there are no other capabilities referencing the same object.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Detect whether a capability is the final capability to a given object\nremaining in the system. Finalisation actions need to be taken when the final\ncapability to the object is deleted."}
{"spec": "definition\n  deleted_irq_handler :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"deleted_irq_handler irq \\<equiv> set_irq_state IRQInactive irq\"", "property": "IRQ Handler Deletion: Set the IRQ state to inactive after an IRQ handler capability is deleted.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after an IRQ handler capability is deleted."}
{"spec": "definition\n  post_cap_deletion :: \"cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"post_cap_deletion cap \\<equiv> case cap of\n       IRQHandlerCap irq \\<Rightarrow> deleted_irq_handler irq\n     | ArchObjectCap acap \\<Rightarrow> arch_post_cap_deletion acap\n     | _ \\<Rightarrow> return ()\"", "property": "Post Cap Deletion Actions: Perform necessary actions after a capability is deleted, including handling deleted IRQ handlers and architecture-specific post-deletion actions. \n\nSubproperties:\n- IRQ Handler Deletion: Handle deleted IRQ handlers.\n- Architecture-Specific Post-Deletion: Perform architecture-specific actions after capability deletion.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "definition\n  empty_slot :: \"cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"empty_slot slot cleanup_info \\<equiv> do\n      cap \\<leftarrow> get_cap slot;\n      if cap = NullCap then\n        return ()\n      else do\n        slot_p \\<leftarrow> gets (\\<lambda>s. cdt s slot);\n        cdt \\<leftarrow> gets cdt;\n        parent \\<leftarrow> return $ cdt slot;\n        set_cdt ((\\<lambda>p. if cdt p = Some slot\n                     then parent\n                     else cdt p) (slot := None));\n        do_extended_op (empty_slot_ext slot slot_p);\n        set_original slot False;\n        set_cap NullCap slot;\n\n        post_cap_deletion cleanup_info\n      od\n  od\"", "property": "Empty Capability Slot: Remove a capability from a slot, assuming it has been finalized, and update the Capability Derivation Tree (CDT) accordingly. \n\nUpdate CDT: Modify the CDT by removing the slot and updating its parent's child pointers.\nPost-Deletion Cleanup: Perform cleanup actions after deleting the capability.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Empty a capability slot assuming that the capability in it has been\nfinalised already."}
{"spec": "definition\n  cap_delete_one :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"cap_delete_one slot \\<equiv> do\n    cap \\<leftarrow> get_cap slot;\n    unless (cap = NullCap) $ do\n      final \\<leftarrow> is_final_cap cap;\n      fast_finalise cap final;\n      empty_slot slot NullCap\n    od\n  od\"", "property": "Capability Deletion: Delete a capability from a slot, assuming fast finalisation is sufficient, by retrieving the capability, checking if it's not null, determining if it's the final capability, performing fast finalisation, and then emptying the slot. \n\n Fast Finalisation: Ensure that the capability is finalised quickly, without the need for additional cleanup, by checking if it's the final capability and performing the necessary actions.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Delete a capability with the assumption that the fast finalisation\nprocess will be sufficient."}
{"spec": "definition\n  reply_cancel_ipc :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"reply_cancel_ipc tptr \\<equiv> do\n    thread_set (\\<lambda>tcb. tcb \\<lparr> tcb_fault := None \\<rparr>) tptr;\n    cap \\<leftarrow> get_cap (tptr, tcb_cnode_index 2);\n    descs \\<leftarrow> gets (descendants_of (tptr, tcb_cnode_index 2) o cdt);\n    when (descs \\<noteq> {}) $ do\n      assert (\\<exists>cslot_ptr. descs = {cslot_ptr});\n      cslot_ptr \\<leftarrow> select descs;\n      cap_delete_one cslot_ptr\n    od\n  od\"", "property": "Cancel IPC Reply: Cancel the message receive operation of a thread waiting for a Reply capability it has issued to be invoked, by clearing the thread's fault handler, retrieving the Reply capability, and deleting any descendants of the Reply capability.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel the message receive operation of a thread waiting for a Reply\ncapability it has issued to be invoked."}
{"spec": "definition\n  cancel_signal :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_signal threadptr ntfnptr \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     queue \\<leftarrow> (case ntfn_obj ntfn of WaitingNtfn queue \\<Rightarrow> return queue\n                        | _ \\<Rightarrow> fail);\n     queue' \\<leftarrow> return $ remove1 threadptr queue;\n     newNTFN \\<leftarrow> return $ ntfn_set_obj ntfn (case queue' of [] \\<Rightarrow> IdleNtfn\n                                                      | _  \\<Rightarrow> WaitingNtfn queue');\n     set_notification ntfnptr newNTFN;\n     set_thread_state threadptr Inactive\n   od\"", "property": "Cancel Signal: Cancel a thread's message receive operation from a notification object, removing the thread from the notification queue and updating the notification object's state accordingly, ultimately setting the thread's state to inactive.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel the message receive operation of a thread queued in an\nnotification object."}
{"spec": "definition\n  cancel_ipc :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_ipc tptr \\<equiv> do\n     state \\<leftarrow> get_thread_state tptr;\n     case state\n       of\n          BlockedOnSend x y \\<Rightarrow> blocked_cancel_ipc state tptr\n        | BlockedOnReceive x y \\<Rightarrow> blocked_cancel_ipc state tptr\n        | BlockedOnNotification event \\<Rightarrow> cancel_signal tptr event\n        | BlockedOnReply \\<Rightarrow> reply_cancel_ipc tptr\n        | _ \\<Rightarrow> return ()\n   od\"", "property": "Cancel IPC Operations: Cancel any ongoing message operations that a thread is waiting on, handling different blocking scenarios such as sending, receiving, notification, and reply.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel any message operations a given thread is waiting on."}
{"spec": "definition\n  update_restart_pc :: \"obj_ref \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"update_restart_pc thread_ptr =\n        as_user thread_ptr (getRegister nextInstructionRegister\n                            >>= setRegister faultRegister)\"", "property": "Update Restart PC: Update the restart program counter for a thread by retrieving the next instruction register value and setting it to the fault register.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Currently, @{text update_restart_pc} can be defined generically up to\nthe actual register numbers."}
{"spec": "definition\n  suspend :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"suspend thread \\<equiv> do\n     cancel_ipc thread;\n     state \\<leftarrow> get_thread_state thread;\n     (if state = Running then update_restart_pc thread else return ());\n     set_thread_state thread Inactive;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) thread)\n   od\"\n\nend", "property": "Thread Suspension: Suspend a thread, cancelling its pending operations, updating its restart PC if running, setting it to the Inactive state, and dequeuing it from the scheduler.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Suspend a thread, cancelling any pending operations and preventing it\nfrom further execution by setting it to the Inactive state."}
{"spec": "datatype rights = AllowRead | AllowWrite | AllowGrant | AllowGrantReply\n\ndefinition\n  \"AllowSend \\<equiv> AllowWrite\"\ndefinition\n  \"AllowRecv \\<equiv> AllowRead\"\ndefinition\n  \"CanModify \\<equiv> AllowWrite\"", "property": "Access Control Rights: Define the possible access-control rights in the system, including AllowRead, AllowWrite, AllowGrant, and AllowGrantReply, with some rights being synonymous with others (AllowSend for AllowWrite, AllowRecv for AllowRead, and CanModify for AllowWrite).", "title": "./spec/abstract/CapRights_A.thy", "chapter": "", "section": "", "comment": "The possible access-control rights that exist in the system.\n        Note that some rights are synonyms for others."}
{"spec": "type_synonym cap_rights = \"rights set\"", "property": "Capability Rights: Represented as a set of access rights.", "title": "./spec/abstract/CapRights_A.thy", "chapter": "", "section": "", "comment": "Cap rights are just a set of access rights"}
{"spec": "definition\n  all_rights :: cap_rights\nwhere\n \"all_rights \\<equiv> UNIV\"\n\nend", "property": "Complete Rights: The set of all rights is defined as the universal set, encompassing all possible rights.", "title": "./spec/abstract/CapRights_A.thy", "chapter": "", "section": "", "comment": "The set of all rights:"}
{"spec": "definition\n  store_word_offs :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"store_word_offs ptr offs v \\<equiv>\n    do s \\<leftarrow> get;\n       assert (in_user_frame (ptr + of_nat (offs * word_size)) s);\n       do_machine_op $ storeWord (ptr + of_nat (offs * word_size)) v\n    od\"", "property": "Word Access: Store or load a word at an offset from an IPC buffer, ensuring the accessed address is within a valid user frame.", "title": "./spec/abstract/TcbAcc_A.thy", "chapter": "", "section": "", "comment": "Store or load a word at an offset from an IPC buffer."}
{"spec": "definition\n  set_message_info :: \"obj_ref \\<Rightarrow> message_info \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_message_info thread info \\<equiv>\n     as_user thread $ setRegister msg_info_register $\n                      message_info_to_data info\"\n\n\ndefinition\n  set_mrs :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> message list \\<Rightarrow> (length_type,'z::state_ext) s_monad\" where\n  \"set_mrs thread buf msgs \\<equiv>\n   do\n     tcb \\<leftarrow> gets_the $ get_tcb thread;\n     context \\<leftarrow> return (arch_tcb_get_registers (tcb_arch tcb));\n     new_regs \\<leftarrow> return (\\<lambda>reg. if reg \\<in> set (take (length msgs) msg_registers)\n                              then msgs ! (the_index msg_registers reg)\n                              else context reg);\n     set_object thread (TCB (tcb \\<lparr> tcb_arch := arch_tcb_set_registers new_regs (tcb_arch tcb) \\<rparr>));\n     remaining_msgs \\<leftarrow> return (drop (length msg_registers) msgs);\n     case buf of\n     None      \\<Rightarrow> return $ nat_to_len (min (length msg_registers) (length msgs))\n   | Some pptr \\<Rightarrow> do\n       zipWithM_x (\\<lambda>x. store_word_offs pptr x)\n          [length msg_registers + 1 ..< Suc msg_max_length] remaining_msgs;\n       return $ nat_to_len $ min (length msgs) msg_max_length\n     od\n   od\"\n\nend", "property": "Message Management: Set the message information and store the message registers for a thread. This involves updating the thread's register with the message information and storing the message registers in the thread's TCB or in a buffer if provided.", "title": "./spec/abstract/TcbAcc_A.thy", "chapter": "", "section": "", "comment": " Needed for page invocations. "}
{"spec": "datatype apiobject_type =\n    Untyped\n  | TCBObject\n  | EndpointObject\n  | NotificationObject\n  | CapTableObject\n  | ArchObject aobject_type\n\ndefinition\n  is_frame_type :: \"apiobject_type \\<Rightarrow> bool\"\nwhere\n  \"is_frame_type obj \\<equiv> case obj of\n        ArchObject aobj \\<Rightarrow> arch_is_frame_type aobj\n      | _ \\<Rightarrow> False\"", "property": "Object Creation: User mode can request creation of various objects, including untyped, TCB, endpoint, notification, capability table, and architecture-specific objects. \n\nObject Type Classification: Distinguish between frame and non-frame object types, with frame types being architecture-specific.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "\n  User mode can request these objects to be created by retype:\n"}
{"spec": "type_synonym badge = data\ntype_synonym msg_label = data\ntype_synonym message = data", "property": "IPC Type Definitions: Define type synonyms for badge, message label, and message as data, allowing for more informative type signatures in IPC operations.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "These allow more informative type signatures for IPC operations."}
{"spec": "type_synonym cnode_index = \"bool list\"\ntype_synonym cslot_ptr = \"obj_ref \\<times> cnode_index\"", "property": "Capability Slot References: Uniquely identify capability slots using a tuple of object reference and slot index within that object.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "This type models refences to capability slots. The first element\n  of the tuple points to the object the capability is contained in. The second\n  element is the index of the slot inside a slot-containing object. The default\n  slot-containing object is a cnode, thus the name @{text cnode_index}.\n"}
{"spec": "datatype cap\n         = NullCap\n         | UntypedCap bool obj_ref nat nat\n           \\<comment> \\<open>device flag, pointer, size in bits (i.e. @{text \"size = 2^bits\"}) and freeIndex (i.e. @{text \"freeRef = obj_ref + (freeIndex * 2^4)\"})\\<close>\n         | EndpointCap obj_ref badge cap_rights\n         | NotificationCap obj_ref badge cap_rights\n         | ReplyCap obj_ref bool cap_rights\n         | CNodeCap obj_ref nat \"bool list\"\n           \\<comment> \\<open>CNode ptr, number of bits translated, guard\\<close>\n         | ThreadCap obj_ref\n         | DomainCap\n         | IRQControlCap\n         | IRQHandlerCap irq\n         | Zombie obj_ref \"nat option\" nat\n           \\<comment> \\<open>@{text \"cnode ptr * nat + tcb or cspace ptr\"}\\<close>\n         | ArchObjectCap (the_arch_cap: arch_cap)\n\nlemmas cap_cases =\n  cap.induct[where cap=cap and P=\"\\<lambda>cap'. cap' = cap \\<longrightarrow> P cap'\" for cap P, simplified, rule_format]\n\nlemmas cap_cases_asm =\ncap.induct[where cap=cap and P=\"\\<lambda>cap'. cap = cap' \\<longrightarrow> P cap' \\<longrightarrow> R\" for P R cap,\n  simplified, rule_format, rotated -1]", "property": "Capability Types and Properties: Define the various types of capabilities, including Null, Untyped, Endpoint, Notification, Reply, CNode, Thread, Domain, IRQControl, IRQHandler, Zombie, and ArchObject capabilities, each representing explicit authority to perform specific actions or manipulate kernel objects, with distinct properties and constraints.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "Capabilities. Capabilities represent explicit authority to perform some\naction and are required for all system calls. Capabilities to Endpoint,\nNotification, Thread and CNode objects allow manipulation of standard kernel\nobjects. Untyped capabilities allow the creation and removal of kernel objects\nfrom a memory region. Reply capabilities allow sending a one-off message to\na thread waiting for a reply. IRQHandler and IRQControl caps allow a user to\nconfigure the way interrupts on one or all IRQs are handled. Capabilities to\narchitecture-specific facilities are provided through the @{text arch_cap} type.\nNull capabilities are the contents of empty capability slots; they confer no\nauthority and can be freely replaced. Zombie capabilities are stored when\nthe deletion of CNode and Thread objects is partially completed; they confer no\nauthority but cannot be replaced until the deletion is finished.\n"}
{"spec": "type_synonym cnode_contents = \"cnode_index \\<Rightarrow> cap option\"", "property": "CNode Contents: A CNode is represented as an array of capability slots, where each slot is indexed and may contain a capability or be empty (Null capability).", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "The CNode object is an array of capability slots. The domain of the\nfunction will always be the set of boolean lists of some specific length.\nEmpty slots contain a Null capability.\n"}
{"spec": "definition\n  the_cnode_cap :: \"cap \\<Rightarrow> obj_ref \\<times> nat \\<times> bool list\" where\n  \"the_cnode_cap cap \\<equiv>\n  case cap of\n    CNodeCap oref bits guard \\<Rightarrow> (oref, bits, guard)\"\n\nprimrec (nonexhaustive)\n  cap_ep_badge :: \"cap \\<Rightarrow> badge\"\nwhere\n  \"cap_ep_badge (EndpointCap _ badge _) = badge\"\n| \"cap_ep_badge (NotificationCap _ badge _) = badge\"\n\nprimrec (nonexhaustive)\n  cap_ep_ptr :: \"cap \\<Rightarrow> badge\"\nwhere\n  \"cap_ep_ptr (EndpointCap obj_ref _ _) = obj_ref\"\n| \"cap_ep_ptr (NotificationCap obj_ref _ _) = obj_ref\"\n\ndefinition\n  bits_of :: \"cap \\<Rightarrow> nat\" where\n  \"bits_of cap \\<equiv> case cap of\n    UntypedCap _ _ bits _ \\<Rightarrow> bits\n  | CNodeCap _ radix_bits _ \\<Rightarrow> radix_bits\"\n\ndefinition\n  free_index_of :: \"cap \\<Rightarrow> nat\" where\n  \"free_index_of cap \\<equiv> case cap of\n    UntypedCap _ _ _ free_index \\<Rightarrow> free_index\"\n\ndefinition\n  is_reply_cap :: \"cap \\<Rightarrow> bool\" where\n  \"is_reply_cap cap \\<equiv> case cap of ReplyCap _ m _ \\<Rightarrow> \\<not> m | _ \\<Rightarrow> False\"\ndefinition\n  is_master_reply_cap :: \"cap \\<Rightarrow> bool\" where\n  \"is_master_reply_cap cap \\<equiv> case cap of ReplyCap _ m _ \\<Rightarrow> m | _ \\<Rightarrow> False\"\ndefinition\n  is_zombie :: \"cap \\<Rightarrow> bool\" where\n  \"is_zombie cap \\<equiv> case cap of Zombie _ _ _ \\<Rightarrow> True | _ \\<Rightarrow> False\"\ndefinition\n  is_arch_cap :: \"cap \\<Rightarrow> bool\" where\n  \"is_arch_cap cap \\<equiv> case cap of ArchObjectCap _ \\<Rightarrow> True | _ \\<Rightarrow> False\"\n\ncontext\nnotes [[function_internals =true]]\nbegin\n\nfun is_cnode_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_cnode_cap (CNodeCap _ _ _) = True\"\n| \"is_cnode_cap _                = False\"\n\nfun is_thread_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_thread_cap (ThreadCap _) = True\"\n| \"is_thread_cap _             = False\"\n\nfun is_domain_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_domain_cap DomainCap = True\"\n| \"is_domain_cap _ = False\"\n\nfun is_untyped_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_untyped_cap (UntypedCap _ _ _ _) = True\"\n| \"is_untyped_cap _                  = False\"\n\nfun is_ep_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_ep_cap (EndpointCap _ _ _) = True\"\n| \"is_ep_cap _                   = False\"\n\nfun is_ntfn_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_ntfn_cap (NotificationCap _ _ _) = True\"\n| \"is_ntfn_cap _                        = False\"\n\nprimrec (nonexhaustive)\n  cap_rights :: \"cap \\<Rightarrow> cap_rights\"\nwhere\n  \"cap_rights (EndpointCap _ _ cr) = cr\"\n| \"cap_rights (NotificationCap _ _ cr) = cr\"\n| \"cap_rights (ReplyCap _ _ cr) = cr\"\n| \"cap_rights (ArchObjectCap acap) = acap_rights acap\"\nend", "property": "Capability Inspection: Provide various functions to inspect and extract information from capabilities, including checking the type of capability, retrieving specific fields, and determining the rights associated with a capability. \n\nSubproperties:\n- Capability Type Checking: Determine the type of a capability (e.g., CNodeCap, ThreadCap, DomainCap, UntypedCap, EndpointCap, NotificationCap).\n- Capability Field Extraction: Extract specific fields from a capability (e.g., the object reference, radix bits, guard, badge, free index).\n- Capability Rights Inspection: Retrieve the rights associated with a capability (e.g., the rights of an endpoint, notification, reply, or architecture-specific capability).", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "Various access functions for the cap type are defined for\nconvenience."}
{"spec": "definition\n  cap_rights_update :: \"cap_rights \\<Rightarrow> cap \\<Rightarrow> cap\" where\n  \"cap_rights_update cr' cap \\<equiv>\n   case cap of\n     EndpointCap oref badge cr \\<Rightarrow> EndpointCap oref badge cr'\n   | NotificationCap oref badge cr\n     \\<Rightarrow> NotificationCap oref badge (cr' - {AllowGrant, AllowGrantReply})\n   | ReplyCap t m cr \\<Rightarrow> ReplyCap t m (cr' - {AllowRead, AllowGrantReply} \\<union> {AllowWrite})\n   | ArchObjectCap acap \\<Rightarrow> ArchObjectCap (acap_rights_update cr' acap)\n   | _ \\<Rightarrow> cap\"\n\ndefinition\n  badge_update :: \"badge \\<Rightarrow> cap \\<Rightarrow> cap\" where\n  \"badge_update data cap \\<equiv>\n   case cap of\n     EndpointCap oref badge cr \\<Rightarrow> EndpointCap oref (data && mask badge_bits) cr\n   | NotificationCap oref badge cr \\<Rightarrow> NotificationCap oref (data && mask badge_bits) cr\n   | _ \\<Rightarrow> cap\"\n\n\ndefinition\n  mask_cap :: \"cap_rights \\<Rightarrow> cap \\<Rightarrow> cap\" where\n  \"mask_cap rights cap \\<equiv> cap_rights_update (cap_rights cap \\<inter> rights) cap\"", "property": "Capability Update Functions: Update the properties of a capability, including its rights and badge. Ensure that the updated capability adheres to the rules and constraints of its type, such as restricting certain rights for specific capability types.\n\nSubproperties:\n- Rights Update: Modify the rights of a capability, taking into account the specific rules for each capability type.\n- Badge Update: Update the badge of a capability, applying a mask to ensure it stays within the allowed range.\n- Mask Capability: Mask the rights of a capability, effectively restricting its permissions to the intersection of its current rights and the provided mask.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "Various update functions for cap data common to various kinds of\ncap are defined here."}
{"spec": "text \\<open>The message info is the first thing interpreted on a user system call\nand determines the structure of the message the user thread is sending either to\nanother user or to a system service. It is also passed to user threads receiving\na message to indicate the structure of the message they have received. The\n@{text mi_length} parameter is the number of data words in the body of the\nmessage. The @{text mi_extra_caps} parameter is the number of caps to be passed\ntogether with the message. The @{text mi_caps_unwrapped} parameter is a bitmask\nallowing threads receiving a message to determine how extra capabilities were\ntransferred. The @{text mi_label} parameter is transferred directly from sender\nto receiver as part of the message.\n\\<close>\n\ndatatype message_info =\n  MI (mi_length: length_type)\n     (mi_extra_caps: length_type)\n     (mi_caps_unwrapped: data)\n     (mi_label: msg_label)", "property": "Message Info Structure: Defines the structure of a message being sent or received by a user thread, including the number of data words, extra capabilities, capability transfer information, and a message label.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": ""}
{"spec": "primrec\n  message_info_to_data :: \"message_info \\<Rightarrow> data\"\nwhere\n  \"message_info_to_data (MI len exc unw mlabel) =\n   (let\n        extra = exc << 7;\n        unwrapped = unw << 9;\n        label = mlabel << 12\n    in\n       label || extra || unwrapped || len)\"\n\ndefinition\n  data_to_message_info :: \"data \\<Rightarrow> message_info\"\nwhere\n  \"data_to_message_info w \\<equiv>\n   MI (let v = w && mask 7 in if v > 120 then 120 else v)\n      ((w >> 7) && mask 2)\n      ((w >> 9) && mask 3)\n      ((w >> 12) && mask msg_label_bits)\"", "property": "Message Info Encoding and Decoding: Encode message information into a data word and decode a data word into message information, ensuring that the message length, extra capabilities, unwrapped status, and message label are correctly represented and retrieved. \n\nMessage Info Structure: A message info consists of four components: message length, extra capabilities, unwrapped status, and message label, which are encoded in a specific bit pattern within a data word.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Message infos are encoded to or decoded from a data word."}
{"spec": "text \\<open>Endpoints are synchronous points of communication for threads. At any\ntime an endpoint may contain a queue of threads waiting to send, a queue of\nthreads waiting to receive or be idle. Whenever threads would be waiting to\nsend and receive simultaneously messages are transferred immediately.\n\\<close>\n\ndatatype endpoint\n           = IdleEP\n           | SendEP \"obj_ref list\"\n           | RecvEP \"obj_ref list\"", "property": "Endpoint States: An endpoint can be in one of three states: idle, sending, or receiving, managing thread communication and message transfer. \n\nSubproperties:\n- Idle State: The endpoint is not currently being used for communication.\n- Sending State: The endpoint has a queue of threads waiting to send messages.\n- Receiving State: The endpoint has a queue of threads waiting to receive messages.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": ""}
{"spec": "datatype ntfn\n           = IdleNtfn\n           | WaitingNtfn \"obj_ref list\"\n           | ActiveNtfn badge\n\nrecord notification =\n  ntfn_obj :: ntfn\n  ntfn_bound_tcb :: \"obj_ref option\"\n\n\ndefinition\n  default_ep :: endpoint where\n  \"default_ep \\<equiv> IdleEP\"\n\ndefinition\n  default_ntfn :: ntfn where\n  \"default_ntfn \\<equiv> IdleNtfn\"\n\ndefinition\n  default_notification :: notification where\n  \"default_notification \\<equiv> \\<lparr>\n     ntfn_obj = default_ntfn,\n     ntfn_bound_tcb = None \\<rparr>\"", "property": "Notification Object Properties: Notifications are binary semaphores that allow threads to block waiting to receive, but not to send, and have three states: Idle, Waiting, and Active.\n\nSubproperties:\n- Notification States: Notifications can be in one of three states: Idle (default), Waiting (with a list of waiting threads), or Active (with a badge).\n- Notification Structure: A notification object consists of an ntfn object (representing the notification state) and an optional bound thread (ntfn_bound_tcb).", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Notifications are sets of binary semaphores (stored in the\n\\emph{badge word}). Unlike endpoints, threads may choose to block waiting to\nreceive, but not to send."}
{"spec": "record sender_payload =\n sender_badge           :: badge\n sender_can_grant       :: bool\n sender_can_grant_reply :: bool\n sender_is_call         :: bool\n\nrecord receiver_payload =\n receiver_can_grant :: bool\n\ndatatype thread_state\n  = Running\n  | Inactive\n  | Restart\n  | BlockedOnReceive obj_ref receiver_payload\n  | BlockedOnSend obj_ref sender_payload\n  | BlockedOnReply\n  | BlockedOnNotification obj_ref\n  | IdleThreadState\n\ntype_synonym priority = word8\n\nrecord tcb =\n tcb_ctable        :: cap\n tcb_vtable        :: cap\n tcb_reply         :: cap\n tcb_caller        :: cap\n tcb_ipcframe      :: cap\n tcb_state         :: thread_state\n tcb_fault_handler :: cap_ref\n tcb_ipc_buffer    :: vspace_ref\n tcb_fault         :: \"fault option\"\n tcb_bound_notification     :: \"obj_ref option\"\n tcb_mcpriority    :: priority\n tcb_arch          :: arch_tcb (* arch_tcb must have a field for user context *)", "property": "Thread Control Block Structure: Represents a thread in the kernel, containing its execution state (Running, Restart, IdleThreadState, or Blocked), special-purpose capability slots (CTable, VTable, Reply, Caller, IPCFrame), and other attributes (fault handler, IPC buffer, priority, and architecture-specific context).", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Thread Control Blocks are the in-kernel representation of a thread.\n\nThreads which can execute are either in the Running state for normal execution,\nin the Restart state if their last operation has not completed yet or in the\nIdleThreadState for the unique system idle thread. Threads can also be blocked\nwaiting for any of the different kinds of system messages. The Inactive state\nindicates that the TCB is not currently used by a running thread.\n\nTCBs also contain some special-purpose capability slots. The CTable slot is a\ncapability to a CNode through which the thread accesses capabilities with which\nto perform system calls. The VTable slot is a capability to a virtual address\nspace (an architecture-specific capability type) in which the thread runs. If\nthe thread has issued a Reply cap to another thread and is awaiting a reply,\nthat cap will have a \"master\" Reply cap as its parent in the Reply slot. The\nCaller slot is used to initially store any Reply cap issued to this thread. The\nIPCFrame slot stores a capability to a memory frame (an architecture-specific\ncapability type) through which messages will be sent and received.\n\nIf the thread has encountered a fault and is waiting to send it to its\nsupervisor the fault is stored in @{text tcb_fault}. The user register file is\nstored in @{text tcb_context}, the pointer to the cap in the IPCFrame slot in\n@{text tcb_ipc_buffer} and the identity of the Endpoint cap through which faults\nare to be sent in @{text tcb_fault_handler}.\n"}
{"spec": "primrec\n  runnable :: \"Structures_A.thread_state \\<Rightarrow> bool\"\nwhere\n  \"runnable (Running)               = True\"\n| \"runnable (Inactive)              = False\"\n| \"runnable (Restart)               = True\"\n| \"runnable (BlockedOnReceive x y)  = False\"\n| \"runnable (BlockedOnSend x y)     = False\"\n| \"runnable (BlockedOnNotification x) = False\"\n| \"runnable (IdleThreadState)       = False\"\n| \"runnable (BlockedOnReply)        = False\"\n\n\ndefinition\n  default_tcb :: tcb where\n  \"default_tcb \\<equiv> \\<lparr>\n      tcb_ctable   = NullCap,\n      tcb_vtable   = NullCap,\n      tcb_reply    = NullCap,\n      tcb_caller   = NullCap,\n      tcb_ipcframe = NullCap,\n      tcb_state    = Inactive,\n      tcb_fault_handler = to_bl (0::machine_word),\n      tcb_ipc_buffer = 0,\n      tcb_fault      = None,\n      tcb_bound_notification  = None,\n      tcb_mcpriority = minBound,\n      tcb_arch       = default_arch_tcb\\<rparr>\"", "property": "Thread Schedulability: Determine whether a thread in a given state can be scheduled. \n\nThread States: Define the possible states a thread can be in, including Running, Inactive, Restart, and various blocked states. \n\nDefault Thread Control Block (TCB): Establish the default values for a TCB, including capability tables, reply and caller capabilities, IPC frame, thread state, fault handler, IPC buffer, fault information, bound notification, and priority.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Determines whether a thread in a given state may be scheduled."}
{"spec": "datatype kernel_object\n         = CNode nat cnode_contents \\<comment> \\<open>size in bits, and contents\\<close>\n         | TCB tcb\n         | Endpoint endpoint\n         | Notification notification\n         | ArchObj (the_arch_obj: arch_kernel_obj)\n\nlemmas kernel_object_cases =\n  kernel_object.induct[where kernel_object=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P, simplified, rule_format]\n\nlemmas kernel_object_cases_asm =\nkernel_object.induct[where kernel_object=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n  simplified, rule_format, rotated -1]\n\ndefinition aobj_of :: \"kernel_object \\<Rightarrow> arch_kernel_obj option\"\n  where\n  \"aobj_of ko \\<equiv> case ko of ArchObj aobj \\<Rightarrow> Some aobj | _ \\<Rightarrow> None\"", "property": "Kernel Object Classification: All kernel objects are classified into five types: CNodes, TCBs, Endpoints, Notifications, or architecture-specific objects. \n\nSubproperties:\n- CNode: Defined by its size in bits and contents.\n- TCB: Represents a thread control block.\n- Endpoint: Represents a communication endpoint.\n- Notification: Represents a notification object.\n- ArchObj: Represents an architecture-specific kernel object.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "\nAll kernel objects are CNodes, TCBs, Endpoints, Notifications or architecture\nspecific.\n"}
{"spec": "definition\n  well_formed_cnode_n :: \"nat \\<Rightarrow> cnode_contents \\<Rightarrow> bool\" where\n \"well_formed_cnode_n n \\<equiv> \\<lambda>cs. dom cs = {x. length x = n}\"\n\nprimrec\n  obj_bits :: \"kernel_object \\<Rightarrow> nat\"\nwhere\n  \"obj_bits (CNode sz cs) = cte_level_bits + sz\"\n| \"obj_bits (TCB t) = tcb_bits\"\n| \"obj_bits (Endpoint ep) = endpoint_bits\"\n| \"obj_bits (Notification ntfn) = ntfn_bits\"\n| \"obj_bits (ArchObj ao) = arch_kobj_size ao\"\n\nprimrec (nonexhaustive)\n  obj_size :: \"cap \\<Rightarrow> machine_word\"\nwhere\n  \"obj_size NullCap = 0\"\n| \"obj_size (UntypedCap dev r bits f) = 1 << bits\"\n| \"obj_size (EndpointCap r b R) = 1 << obj_bits (Endpoint undefined)\"\n| \"obj_size (NotificationCap r b R) = 1 << obj_bits (Notification undefined)\"\n| \"obj_size (CNodeCap r bits g) = 1 << (cte_level_bits + bits)\"\n| \"obj_size (ThreadCap r) = 1 << obj_bits (TCB undefined)\"\n| \"obj_size (Zombie r zb n) = (case zb of None \\<Rightarrow> 1 << obj_bits (TCB undefined)\n                                        | Some n \\<Rightarrow> 1 << (cte_level_bits + n))\"\n| \"obj_size (ArchObjectCap a) = 1 << arch_obj_size a\"", "property": "Kernel Object Properties: Ensure that kernel objects are well-formed and have correct sizes. \n\nWell-Formed CNode: A cnode's contents are well-formed if its domain matches the expected length.\n\nObject Size: Calculate the size of kernel objects based on their types, ensuring that each object has a correct and consistent size.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Checks whether a cnode's contents are well-formed."}
{"spec": "datatype a_type =\n    ATCB\n  | AEndpoint\n  | ANTFN\n  | ACapTable nat\n  | AGarbage nat \\<comment> \\<open>number of bytes of garbage\\<close>\n  | AArch aa_type\n\ndefinition\n  a_type :: \"kernel_object \\<Rightarrow> a_type\"\nwhere\n \"a_type ob \\<equiv> case ob of\n           CNode sz cspace           \\<Rightarrow> if well_formed_cnode_n sz cspace\n                                        then ACapTable sz else AGarbage (cte_level_bits + sz)\n         | TCB tcb                   \\<Rightarrow> ATCB\n         | Endpoint endpoint         \\<Rightarrow> AEndpoint\n         | Notification notification \\<Rightarrow> ANTFN\n         | ArchObj ao                \\<Rightarrow> AArch (aa_type ao)\"", "property": "Kernel Object Classification: Classify kernel objects into distinct types, including TCB, Endpoint, Notification, Capability Table, Garbage, and Architecture-specific objects. \n\nSubproperties:\n- TCB Classification: Identify TCB objects.\n- Endpoint Classification: Identify Endpoint objects.\n- Notification Classification: Identify Notification objects.\n- Capability Table Classification: Identify Capability Table objects with a specific size.\n- Garbage Classification: Identify Garbage objects with a specific size.\n- Architecture-specific Object Classification: Identify Architecture-specific objects based on their type.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Object types:"}
{"spec": "text \\<open>The kernel's heap is a partial function containing kernel objects.\\<close>\ntype_synonym kheap = \"obj_ref \\<Rightarrow> kernel_object option\"", "property": "Kernel Heap Structure: The kernel's heap is represented as a partial function that maps object references to kernel objects, allowing for efficient storage and retrieval of kernel objects.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel State", "comment": ""}
{"spec": "type_synonym cdt = \"cslot_ptr \\<Rightarrow> cslot_ptr option\"\n\ndatatype irq_state =\n   IRQInactive\n | IRQSignal\n | IRQTimer\n | IRQReserved", "property": "Kernel State Management: The kernel maintains a capability derivation tree (CDT) to track the relationships between capabilities, allowing for efficient revocation of derived capabilities. The CDT is represented as a partial mapping from capability slots to parent capability slots.\n\nIRQ State: The kernel manages IRQ states, which can be in one of four modes: inactive, signal, timer, or reserved.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel State", "comment": "\nCapabilities are created either by cloning an existing capability or by creating\na subordinate capability from it. This results in a capability derivation tree\nor CDT. The kernel provides a Revoke operation which deletes all capabilities\nderived from one particular capability. To support this, the kernel stores the\nCDT explicitly. It is here stored as a tree, a partial mapping from\ncapability slots to parent capability slots.\n"}
{"spec": "record abstract_state =\n  kheap              :: kheap\n  cdt                :: cdt\n  is_original_cap    :: \"cslot_ptr \\<Rightarrow> bool\"\n  cur_thread         :: obj_ref\n  idle_thread        :: obj_ref\n  machine_state      :: machine_state\n  interrupt_irq_node :: \"irq \\<Rightarrow> obj_ref\"\n  interrupt_states   :: \"irq \\<Rightarrow> irq_state\"\n  arch_state         :: arch_state", "property": "Kernel State Structure: The kernel state comprises various components, including the heap, capability derivation tree, original capability bitmap, current and idle thread pointers, machine state, interrupt-related data structures (irq nodes and states), and architecture-specific state. These components collectively define the kernel's current state and facilitate its operation. \n\nKernel State Components: \n- Heap Management: The kernel state includes a heap (kheap) that stores kernel objects.\n- Capability Management: The capability derivation tree (CDT) and original capability bitmap (is_original_cap) track capability relationships and authenticity.\n- Thread Management: Pointers to the current thread (cur_thread) and idle thread (idle_thread) are maintained.\n- Machine State: The kernel state includes the underlying machine's state (machine_state).\n- Interrupt Handling: Per-irq pointers to cnodes (interrupt_irq_node) and an array of interrupt states (interrupt_states) facilitate interrupt delivery and management.\n- Architecture-Specific State: The kernel state includes architecture-specific components (arch_state).", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel State", "comment": "The kernel state includes a heap, a capability derivation tree\n(CDT), a bitmap used to determine if a capability is the original\ncapability to that object, a pointer to the current thread, a pointer\nto the system idle thread, the state of the underlying machine,\nper-irq pointers to cnodes (each containing one notification through which\ninterrupts are delivered), an array recording which\ninterrupts are used for which purpose, and the state of the\narchitecture-specific kernel module.\n\nNote: for each irq, @{text \"interrupt_irq_node irq\"} points to a cnode which\ncan contain the notification cap through which interrupts are delivered. In\nC, this all lives in a single array. In the abstract spec though, to prove\nsecurity, we can't have a single object accessible by everyone. Hence the need\nto separate irq handlers.\n"}
{"spec": "record 'a state = abstract_state + exst :: 'a", "property": "Kernel State Extension: The kernel state is extended with an additional component of an arbitrary type, allowing for different instantiations of the kernel specifications at varying levels of abstraction.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel State", "comment": "The following record extends the abstract kernel state with extra\nstate of type @{typ \"'a\"}. The specification operates over states of\nthis extended type. By choosing an appropriate concrete type for @{typ \"'a\"}\nwe may obtain different \\emph{instantiations} of the kernel specifications\nat differing levels of abstraction. See \\autoref{c:ext-spec} for further\ninformation.\n"}
{"spec": "text \\<open>This wrapper lifts monadic operations on the underlying machine state to\nmonadic operations on the kernel state.\\<close>\ndefinition\n  do_machine_op :: \"(machine_state, 'a) nondet_monad \\<Rightarrow> ('z state, 'a) nondet_monad\"\nwhere\n \"do_machine_op mop \\<equiv> do\n    ms \\<leftarrow> gets machine_state;\n    (r, ms') \\<leftarrow> select_f (mop ms);\n    modify (\\<lambda>state. state \\<lparr> machine_state := ms' \\<rparr>);\n    return r\n  od\"", "property": "Kernel State Management: Lifts monadic operations on the underlying machine state to monadic operations on the kernel state, ensuring that changes to the machine state are correctly propagated to the kernel state. \n\nMachine State Update: Update the machine state within the kernel state, ensuring that the kernel state remains consistent with the underlying machine state.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": ""}
{"spec": "definition\n  tcb_cnode_index :: \"nat \\<Rightarrow> cnode_index\" where\n  \"tcb_cnode_index n \\<equiv> to_bl (of_nat n :: 3 word)\"", "property": "TCB CNode Index Generation: Generate the cnode indices used to address capability slots within a TCB.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "This function generates the cnode indices used when addressing the\ncapability slots within a TCB.\n"}
{"spec": "definition\n  zombie_cte_bits :: \"nat option \\<Rightarrow> nat\" where\n \"zombie_cte_bits N \\<equiv> case N of Some n \\<Rightarrow> n | None \\<Rightarrow> 3\"\n\nlemma zombie_cte_bits_simps[simp]:\n \"zombie_cte_bits (Some n) = n\"\n \"zombie_cte_bits None     = 3\"\n  by (simp add: zombie_cte_bits_def)+", "property": "Zombie Capability Decoding: Determine the bit-length of CNode indices from zombie capabilities, defaulting to 3 if created from a TCB capability.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "Zombie capabilities store the bit size of the CNode cap they were\ncreated from or None if they were created from a TCB cap. This function\ndecodes the bit-length of cnode indices into the relevant kernel objects.\n"}
{"spec": "primrec (nonexhaustive)\n  first_cslot_of :: \"cap \\<Rightarrow> cslot_ptr\"\nwhere\n  \"first_cslot_of (ThreadCap oref) = (oref, tcb_cnode_index 0)\"\n| \"first_cslot_of (CNodeCap oref bits g) = (oref, replicate bits False)\"\n| \"first_cslot_of (Zombie oref bits n) = (oref, replicate (zombie_cte_bits bits) False)\"", "property": "First Capability Slot of Kernel Objects: Returns the first capability slot of a given kernel object, which can be a thread, CNode, or zombie. \n\nSubproperties:\n- For threads, it returns the slot at index 0 of the thread's CNode.\n- For CNodes, it returns the slot at the start of the CNode's capability array.\n- For zombies, it returns the slot at the start of the zombie's capability array, taking into account the zombie's CTE bits.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "The first capability slot of the relevant kernel object."}
{"spec": "primrec\n  obj_refs :: \"cap \\<Rightarrow> obj_ref set\"\nwhere\n  \"obj_refs NullCap = {}\"\n| \"obj_refs (ReplyCap r m cr) = {}\"\n| \"obj_refs IRQControlCap = {}\"\n| \"obj_refs (IRQHandlerCap irq) = {}\"\n| \"obj_refs (UntypedCap dev r s f) = {}\"\n| \"obj_refs (CNodeCap r bits guard) = {r}\"\n| \"obj_refs (EndpointCap r b cr) = {r}\"\n| \"obj_refs (NotificationCap r b cr) = {r}\"\n| \"obj_refs (ThreadCap r) = {r}\"\n| \"obj_refs DomainCap = {}\"\n| \"obj_refs (Zombie ptr b n) = {ptr}\"\n| \"obj_refs (ArchObjectCap x) = set_option (aobj_ref x)\"", "property": "Capability Object References: Determine the set of object references associated with a given capability, identifying the specific objects that the capability can access or manipulate.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "The set of all objects referenced by a capability."}
{"spec": "primrec (nonexhaustive)\n  obj_ref_of :: \"cap \\<Rightarrow> obj_ref\"\nwhere\n  \"obj_ref_of (UntypedCap dev r s f) = r\"\n| \"obj_ref_of (ReplyCap r m cr) = r\"\n| \"obj_ref_of (CNodeCap r bits guard) = r\"\n| \"obj_ref_of (EndpointCap r b cr) = r\"\n| \"obj_ref_of (NotificationCap r b cr) = r\"\n| \"obj_ref_of (ThreadCap r) = r\"\n| \"obj_ref_of (Zombie ptr b n) = ptr\"\n| \"obj_ref_of (ArchObjectCap x) = the (aobj_ref x)\"\n\nprimrec (nonexhaustive)\n  cap_bits_untyped :: \"cap \\<Rightarrow> nat\"\nwhere\n  \"cap_bits_untyped (UntypedCap dev r s f) = s\"\n\ndefinition tcb_cnode_map :: \"tcb \\<Rightarrow> cnode_index \\<Rightarrow> cap option\"\n  where\n  \"tcb_cnode_map tcb \\<equiv>\n   [tcb_cnode_index 0 \\<mapsto> tcb_ctable tcb,\n    tcb_cnode_index 1 \\<mapsto> tcb_vtable tcb,\n    tcb_cnode_index 2 \\<mapsto> tcb_reply tcb,\n    tcb_cnode_index 3 \\<mapsto> tcb_caller tcb,\n    tcb_cnode_index 4 \\<mapsto> tcb_ipcframe tcb]\"\n\ndefinition cap_of :: \"kernel_object \\<Rightarrow> cnode_index \\<Rightarrow> cap option\"\n  where\n  \"cap_of kobj \\<equiv> case kobj of CNode _ cs \\<Rightarrow> cs | TCB tcb \\<Rightarrow> tcb_cnode_map tcb | _ \\<Rightarrow> Map.empty\"", "property": "Capability Object Reference Extraction: Extract the object reference from a capability, providing a unified way to access the reference for various capability types.\n\nSubproperties:\n- Untyped Capability Reference: Extract the object reference from an untyped capability.\n- Reply Capability Reference: Extract the object reference from a reply capability.\n- CNode Capability Reference: Extract the object reference from a CNode capability.\n- Endpoint Capability Reference: Extract the object reference from an endpoint capability.\n- Notification Capability Reference: Extract the object reference from a notification capability.\n- Thread Capability Reference: Extract the object reference from a thread capability.\n- Zombie Capability Reference: Extract the object reference from a zombie capability.\n- Architectural Object Capability Reference: Extract the object reference from an architectural object capability.\n\nCapability Bits Extraction: Extract the size in bits from an untyped capability.\n\nTCB CNode Mapping: Map a TCB to its corresponding CNode index and capability option.\n\nKernel Object Capability Extraction: Extract a capability option from a kernel object and CNode index, handling CNodes, TCBs, and other kernel objects.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "\n  The partial definition below is sometimes easier to work with.\n  It also provides cases for UntypedCap and ReplyCap which are not\n  true object references in the sense of the other caps.\n"}
{"spec": "definition\n  caps_of :: \"kernel_object \\<Rightarrow> cap set\" where\n  \"caps_of kobj \\<equiv> ran (cap_of kobj)\"", "property": "Kernel Object Capability Set: The set of all capabilities contained in a kernel object is defined as the range of the capability mapping function for that object.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "The set of all caps contained in a kernel object."}
{"spec": "record captransfer =\n  ct_receive_root :: cap_ref\n  ct_receive_index :: cap_ref\n  ct_receive_depth :: data", "property": "Cap Transfer Structure: Defines the structure for capability transfers, including the receive root, receive index, and receive depth. \n\nReceive Root Validity: The receive root must be a valid capability reference.\nReceive Index Validity: The receive index must be a valid capability reference.\nReceive Depth Validity: The receive depth must be a valid data value.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Cap transfers", "comment": ""}
{"spec": "definition cap_transfer_data_size :: nat\n  where\n  \"cap_transfer_data_size \\<equiv> 3\"\n\ndefinition msg_max_length :: nat\n  where\n  \"msg_max_length \\<equiv> 120\"\n\ndefinition msg_max_extra_caps :: nat\n  where\n  \"msg_max_extra_caps \\<equiv> 3\"\n\ndefinition max_ipc_length :: nat\n  where\n  \"max_ipc_length \\<equiv> cap_transfer_data_size + msg_max_length + msg_max_extra_caps + 2\"\n\ndefinition msg_align_bits :: nat\n  where\n  \"msg_align_bits \\<equiv> word_size_bits + (LEAST n. max_ipc_length \\<le> 2 ^ n)\"\n\nlemma msg_align_bits':\n  \"msg_align_bits = word_size_bits + 7\"\nproof -\n  have \"(LEAST n. (cap_transfer_data_size + msg_max_length + msg_max_extra_caps + 2) \\<le> 2 ^ n) = 7\"\n  proof (rule Least_equality)\n    show \"(cap_transfer_data_size + msg_max_length + msg_max_extra_caps + 2)  \\<le> 2 ^ 7\"\n      by (simp add: cap_transfer_data_size_def msg_max_length_def msg_max_extra_caps_def)\n  next\n    fix y\n    assume \"(cap_transfer_data_size + msg_max_length + msg_max_extra_caps + 2) \\<le> 2 ^ y\"\n    hence \"(2 :: nat) ^ 7 \\<le> 2 ^ y\"\n      by (simp add: cap_transfer_data_size_def msg_max_length_def msg_max_extra_caps_def)\n    thus \"7 \\<le> y\"\n      by (rule power_le_imp_le_exp [rotated], simp)\n  qed\n  thus ?thesis unfolding msg_align_bits_def max_ipc_length_def by simp\nqed\n\nend", "property": "IPC Buffer Page Alignment: The IPC buffer capability of a thread must point to a page that can contain the entire buffer without spilling into another page, ensuring proper alignment and data integrity.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Cap transfers", "comment": "A thread's IPC buffer capability must be to a page that is capable of\ncontaining the IPC buffer without the end of the buffer spilling into another\npage."}
{"spec": "text \\<open>Interpret a set of rights from a user data word.\\<close>\ndefinition\n  data_to_rights :: \"data \\<Rightarrow> cap_rights\" where\n  \"data_to_rights data \\<equiv> let\n    w = data_to_16 data\n   in {x. case x of AllowWrite \\<Rightarrow> w !! 0\n                  | AllowRead \\<Rightarrow> w !! 1\n                  | AllowGrant \\<Rightarrow> w !! 2\n                  | AllowGrantReply \\<Rightarrow> w !! 3}\"", "property": "Data to Rights Conversion: Convert a user data word to a set of capability rights, where each right (AllowWrite, AllowRead, AllowGrant, AllowGrantReply) is determined by a specific bit in the data word.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Resolving capability references", "comment": ""}
{"spec": "definition\n  ensure_no_children :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"ensure_no_children cslot_ptr \\<equiv> doE\n    cdt \\<leftarrow> liftE $ gets cdt;\n    whenE (\\<exists>c. cdt c = Some cslot_ptr) (throwError RevokeFirst)\n  odE\"\n\ndefinition\n  max_free_index :: \"nat \\<Rightarrow> nat\" where\n  \"max_free_index magnitude_bits \\<equiv> 2 ^ magnitude_bits\"\n\ndefinition\n  free_index_update :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> cap \\<Rightarrow> cap\"\nwhere\n  \"free_index_update g cap \\<equiv>\n   case cap of UntypedCap dev ref sz f \\<Rightarrow> UntypedCap dev ref sz (g f) | _ \\<Rightarrow> cap\"\n\nprimrec (nonexhaustive)\n  untyped_sz_bits :: \"cap \\<Rightarrow> nat\"\nwhere\n  \"untyped_sz_bits (UntypedCap dev ref sz f) = sz\"\n\nabbreviation\n  max_free_index_update :: \"cap \\<Rightarrow> cap\"\nwhere\n  \"max_free_index_update cap \\<equiv> cap \\<lparr> free_index:= max_free_index (untyped_sz_bits cap) \\<rparr>\"\n\ndefinition\n  set_untyped_cap_as_full :: \"cap \\<Rightarrow> cap \\<Rightarrow> obj_ref \\<times> bool list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_untyped_cap_as_full src_cap new_cap src_slot \\<equiv>\n   if (is_untyped_cap src_cap \\<and> is_untyped_cap new_cap\n       \\<and> obj_ref_of src_cap = obj_ref_of new_cap \\<and> cap_bits_untyped src_cap = cap_bits_untyped new_cap)\n       then set_cap (max_free_index_update src_cap) src_slot else return ()\"", "property": "CSpace Capability Management: Ensure that a capability stored in a slot does not have any children, and manage the free index of untyped capabilities to prevent overwriting existing capabilities. \n\n Untyped Capability Update: Update the free index of an untyped capability to its maximum value based on its size bits. \n\n Capability Update: Set an untyped capability as full in a slot if the source and new capabilities are untyped, have the same object reference, and the same size bits.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Resolving capability references", "comment": "Check that a capability stored in a slot is not a parent of any other\ncapability."}
{"spec": "definition\nderive_cap :: \"cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap,'z::state_ext) se_monad\" where\n\"derive_cap slot cap \\<equiv>\n case cap of\n    ArchObjectCap c \\<Rightarrow> arch_derive_cap c\n    | UntypedCap dev ptr sz f \\<Rightarrow> doE ensure_no_children slot; returnOk cap odE\n    | Zombie ptr n sz \\<Rightarrow> returnOk NullCap\n    | ReplyCap ptr m cr \\<Rightarrow> returnOk NullCap\n    | IRQControlCap \\<Rightarrow> returnOk NullCap\n    | _ \\<Rightarrow> returnOk cap\"", "property": "Capability Derivation: Derive a capability into a form that can be copied, taking into account internal restrictions on copying certain capability types. \n\nSubproperties:\n- Architecture-specific capabilities are derived using a specialized function.\n- Untyped capabilities can be derived unchanged after ensuring they have no children.\n- Zombie, Reply, and IRQControl capabilities are derived as Null capabilities.\n- All other capability types can be derived unchanged.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Resolving capability references", "comment": "Derive a cap into a form in which it can be copied. For internal reasons\nnot all capability types can be copied at all times and not all capability types\ncan be copied unchanged."}
{"spec": "definition\n  update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> cap \\<Rightarrow> cap\" where\n\"update_cap_data preserve w cap \\<equiv>\n  if is_ep_cap cap then\n    if cap_ep_badge cap = 0 \\<and> \\<not> preserve then\n      badge_update w cap\n    else NullCap\n  else if is_ntfn_cap cap then\n    if cap_ep_badge cap = 0 \\<and> \\<not> preserve then\n      badge_update w cap\n    else NullCap\n  else if is_cnode_cap cap then\n    let\n        (oref, bits, guard) = the_cnode_cap cap;\n        (guard_size', guard'') = update_cnode_cap_data w;\n        guard' = drop (size guard'' - guard_size') (to_bl guard'')\n    in\n        if guard_size' + bits > word_bits\n        then NullCap\n        else CNodeCap oref bits guard'\n  else if is_arch_cap cap then\n    arch_update_cap_data preserve w (the_arch_cap cap)\n  else\n    cap\"", "property": "Capability Update: Transform a capability based on a user-supplied argument word, with different interpretations for different capability types, while considering the preserve flag to maintain valid CDT relationships.\n\nSubproperties:\n- Endpoint and Notification Capabilities: Update the badge of the capability if it is zero and the preserve flag is not set; otherwise, return a NullCap.\n- CNode Capabilities: Update the guard of the capability based on the provided word, ensuring the resulting guard size does not exceed the word size.\n- Architecture-Specific Capabilities: Update the capability according to architecture-specific rules.\n- Other Capabilities: Leave the capability unchanged.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Resolving capability references", "comment": "Transform a capability on request from a user thread. The user-supplied\nargument word is interpreted differently for different cap types. If the\npreserve flag is set this transformation is being done in-place which means some\nchanges are disallowed because they would invalidate existing CDT relationships.\n"}
{"spec": "text \\<open>\nRecursively looks up a capability address to a CNode slot by walking over\nmultiple CNodes until all the bits in the address are used or there are\nno further CNodes.\n\\<close>\nfunction resolve_address_bits' :: \"'z itself \\<Rightarrow> cap \\<times> cap_ref \\<Rightarrow> (cslot_ptr \\<times> cap_ref,'z::state_ext) lf_monad\"\nwhere\n  \"resolve_address_bits' z (cap, cref) =\n  (case cap of\n     CNodeCap oref radix_bits guard  \\<Rightarrow>\n     if radix_bits + size guard = 0 then\n       fail \\<comment> \\<open>nothing is translated: table broken\\<close>\n     else doE\n       whenE (\\<not> guard \\<le> cref)\n             \\<comment> \\<open>guard does not match\\<close>\n             (throwError $ GuardMismatch (size cref) guard);\n\n       whenE (size cref < radix_bits + size guard)\n             \\<comment> \\<open>not enough bits to resolve: table malformed\\<close>\n             (throwError $ DepthMismatch (size cref) (radix_bits+size guard));\n\n       offset \\<leftarrow> returnOk $ take radix_bits (drop (size guard) cref);\n       rest \\<leftarrow> returnOk $ drop (radix_bits + size guard) cref;\n       if rest = [] then\n         returnOk ((oref,offset), [])\n       else doE\n         next_cap \\<leftarrow> liftE $ get_cap (oref, offset);\n         if is_cnode_cap next_cap then\n           resolve_address_bits' z (next_cap, rest)\n         else\n           returnOk ((oref,offset), rest)\n       odE\n     odE\n   | _ \\<Rightarrow> throwError InvalidRoot)\"\n  by auto\n\nlemma rab_termination:\n  \"\\<forall>cref guard radix_bits.\n    \\<not> length cref \\<le> radix_bits + length guard \\<and>\n    (0 < radix_bits \\<or> guard \\<noteq> []) \\<longrightarrow>\n      length cref - (radix_bits + length guard) < length cref\"\n  apply clarsimp\n  apply (erule disjE)\n   apply arith\n  apply (clarsimp simp: neq_Nil_conv)\n  apply arith\n  done\n\ntermination\n  apply (relation \"measure (\\<lambda>(z,cap, cs). size cs)\")\n  apply (auto simp: whenE_def returnOk_def return_def rab_termination)\n  done\n\ndeclare resolve_address_bits'.simps[simp del]\n\ndefinition resolve_address_bits where\n\"resolve_address_bits \\<equiv> resolve_address_bits' TYPE('z::state_ext)\"", "property": "Resolve Address Bits: Recursively looks up a capability address to a CNode slot by walking over multiple CNodes until all the bits in the address are used or there are no further CNodes, ensuring that the guard matches and the table is well-formed.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Transferring capabilities", "comment": ""}
{"spec": "definition\n  lookup_slot_for_thread :: \"obj_ref \\<Rightarrow> cap_ref \\<Rightarrow> (cslot_ptr \\<times> cap_ref,'z::state_ext) lf_monad\"\nwhere\n  \"lookup_slot_for_thread thread cref \\<equiv> doE\n     tcb \\<leftarrow> liftE $ gets_the $ get_tcb thread;\n     resolve_address_bits (tcb_ctable tcb, cref)\n  odE\"\n\ndefinition\n  lookup_cap_and_slot :: \"obj_ref \\<Rightarrow> cap_ref \\<Rightarrow> (cap \\<times> cslot_ptr,'z::state_ext) lf_monad\" where\n  \"lookup_cap_and_slot thread cptr \\<equiv> doE\n      (slot, cr) \\<leftarrow> lookup_slot_for_thread thread cptr;\n      cap \\<leftarrow> liftE $ get_cap slot;\n      returnOk (cap, slot)\n  odE\"\n\ndefinition\n  lookup_cap :: \"obj_ref \\<Rightarrow> cap_ref \\<Rightarrow> (cap,'z::state_ext) lf_monad\" where\n  \"lookup_cap thread ref \\<equiv> doE\n     (ref', _) \\<leftarrow> lookup_slot_for_thread thread ref;\n     liftE $ get_cap ref'\n   odE\"\n\ndefinition\n  lookup_slot_for_cnode_op ::\n  \"bool \\<Rightarrow> cap \\<Rightarrow> cap_ref \\<Rightarrow> nat \\<Rightarrow> (cslot_ptr,'z::state_ext) se_monad\"\nwhere\n \"lookup_slot_for_cnode_op is_source croot ptr depth \\<equiv>\n  if is_cnode_cap croot then\n  doE\n    whenE (depth < 1 \\<or> depth > word_bits)\n      $ throwError (RangeError 1 (of_nat word_bits));\n    lookup_error_on_failure is_source $ doE\n      ptrbits_for_depth \\<leftarrow> returnOk $ drop (length ptr - depth) ptr;\n      (slot, rem) \\<leftarrow> resolve_address_bits (croot, ptrbits_for_depth);\n      case rem of\n        [] \\<Rightarrow> returnOk slot\n      | _  \\<Rightarrow> throwError $ DepthMismatch (length rem) 0\n    odE\n  odE\n  else\n    throwError (FailedLookup is_source InvalidRoot)\"\n\ndefinition\n  lookup_source_slot :: \"cap \\<Rightarrow> cap_ref \\<Rightarrow> nat \\<Rightarrow> (cslot_ptr,'z::state_ext) se_monad\"\nwhere\n \"lookup_source_slot \\<equiv> lookup_slot_for_cnode_op True\"\n\ndefinition\n  lookup_target_slot :: \"cap \\<Rightarrow> cap_ref \\<Rightarrow> nat \\<Rightarrow> (cslot_ptr,'z::state_ext) se_monad\"\nwhere\n \"lookup_target_slot \\<equiv> lookup_slot_for_cnode_op False\"\n\ndefinition\n  lookup_pivot_slot :: \"cap \\<Rightarrow> cap_ref \\<Rightarrow> nat \\<Rightarrow> (cslot_ptr,'z::state_ext) se_monad\"\nwhere\n \"lookup_pivot_slot  \\<equiv> lookup_slot_for_cnode_op True\"", "property": "Capability Lookup: Provides various specializations of the capability lookup process for standard cases, including looking up slots for threads, capabilities, and slots for CNode operations. These operations ensure that capabilities can be efficiently and accurately resolved, enabling secure and reliable capability-based addressing.\n\nSubproperties:\n- Lookup Slot for Thread: Resolves the address bits for a given thread and capability reference.\n- Lookup Cap and Slot: Retrieves the capability and slot for a given thread and capability pointer.\n- Lookup Cap: Retrieves the capability for a given thread and capability reference.\n- Lookup Slot for CNode Op: Resolves the slot for a CNode operation, handling depth and range errors, and ensuring accurate capability resolution.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Transferring capabilities", "comment": "Specialisations of the capability lookup process to various standard\ncases."}
{"spec": "text \\<open>These functions are used in interpreting from user arguments the manner\nin which a capability transfer should take place.\\<close>\n\ndefinition\n  captransfer_from_words :: \"machine_word \\<Rightarrow> (captransfer,'z::state_ext) s_monad\"\nwhere\n  \"captransfer_from_words ptr \\<equiv> do\n     w0 \\<leftarrow> do_machine_op $ loadWord ptr;\n     w1 \\<leftarrow> do_machine_op $ loadWord (ptr + word_size);\n     w2 \\<leftarrow> do_machine_op $ loadWord (ptr + 2 * word_size);\n     return \\<lparr> ct_receive_root = data_to_cptr w0,\n              ct_receive_index = data_to_cptr w1,\n              ct_receive_depth = w2 \\<rparr>\n   od\"\n\ndefinition\n  load_cap_transfer :: \"obj_ref \\<Rightarrow> (captransfer,'z::state_ext) s_monad\" where\n \"load_cap_transfer buffer \\<equiv> do\n     offset \\<leftarrow> return $ msg_max_length + msg_max_extra_caps + 2;\n     captransfer_from_words (buffer + of_nat offset * word_size)\n  od\"\n\nfun\n  get_receive_slots :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow>\n                         (cslot_ptr list,'z::state_ext) s_monad\"\nwhere\n  \"get_receive_slots thread (Some buffer) = do\n     ct \\<leftarrow> load_cap_transfer buffer;\n\n     empty_on_failure $ doE\n       cnode \\<leftarrow> unify_failure $\n                  lookup_cap thread (ct_receive_root ct);\n       slot \\<leftarrow> unify_failure $ lookup_target_slot cnode\n                  (ct_receive_index ct) (unat (ct_receive_depth ct));\n\n       cap \\<leftarrow> liftE $ get_cap slot;\n\n       whenE (cap \\<noteq> NullCap) (throwError ());\n\n       returnOk [slot]\n     odE\n   od\"\n|  \"get_receive_slots x None = return []\"", "property": "Capability Transfer Interpretation: Interprets user arguments to determine how a capability transfer should occur, including loading capability transfer information from memory and resolving receive slots for capability transfer. \n\nLoad Capability Transfer: Load capability transfer information from a buffer, including the receive root, index, and depth.\n\nGet Receive Slots: Resolve the receive slots for a capability transfer based on the capability transfer information, ensuring that the target slot is empty.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Transferring capabilities", "comment": ""}
{"spec": "text \\<open>Deletion of the final capability to any object is a long running\noperation if the capability is of these types.\\<close>\ndefinition\n  long_running_delete :: \"cap \\<Rightarrow> bool\" where\n \"long_running_delete cap \\<equiv> case cap of\n    CNodeCap ptr bits gd \\<Rightarrow> True\n  | Zombie ptr bits n \\<Rightarrow> True\n  | ThreadCap ptr \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"\n\n\ndefinition\n  slot_cap_long_running_delete :: \"cslot_ptr \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"slot_cap_long_running_delete slot \\<equiv> do\n     cap \\<leftarrow> get_cap slot;\n     case cap of\n         NullCap \\<Rightarrow> return False\n       | _ \\<Rightarrow> do\n           final \\<leftarrow> is_final_cap cap;\n           return (final \\<and> long_running_delete cap)\n         od\n   od\"", "property": "Long Running Delete: Determine if deleting the final capability to an object is a long-running operation based on the capability type. \nLong Running Delete Check: Check if a capability in a specific slot is the final capability and if its deletion is a long-running operation.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": ""}
{"spec": "definition\n  cap_swap :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cap_swap cap1 slot1 cap2 slot2 \\<equiv>\n  do\n    set_cap cap2 slot1;\n    set_cap cap1 slot2;\n    slot1_p \\<leftarrow> gets (\\<lambda>s. cdt s slot1);\n    slot2_p \\<leftarrow> gets (\\<lambda>s. cdt s slot2);\n    cdt \\<leftarrow> gets cdt;\n    \\<comment> \\<open>update children:\\<close>\n    cdt' \\<leftarrow> return (\\<lambda>n. if cdt n = Some slot1\n                        then Some slot2\n                        else if cdt n = Some slot2\n                        then Some slot1\n                        else cdt n);\n    \\<comment> \\<open>update parents:\\<close>\n    set_cdt (cdt' (slot1 := cdt' slot2, slot2 := cdt' slot1));\n    do_extended_op (cap_swap_ext slot1 slot2 slot1_p slot2_p);\n    is_original \\<leftarrow> gets is_original_cap;\n    set_original slot1 (is_original slot2);\n    set_original slot2 (is_original slot1)\n  od\"", "property": "Capability Swap: Swap the contents of two capability slots, transforming the capabilities as requested, and update the Capability Derivation Tree (CDT) and original capability status accordingly. \n\nUpdate CDT: Update the children and parents in the CDT to reflect the swapped capabilities. \n\nUpdate Original Capability Status: Swap the original capability status of the two slots.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Swap the contents of two capability slots. The capability parameters are\nthe new states of the capabilities, as the user may request that the\ncapabilities are transformed as they are swapped."}
{"spec": "definition\n  cap_move :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cap_move new_cap src_slot dest_slot \\<equiv> do\n    set_cap new_cap dest_slot;\n    set_cap NullCap src_slot;\n    src_p \\<leftarrow> gets (\\<lambda>s. cdt s src_slot);\n    dest_p \\<leftarrow> gets (\\<lambda>s. cdt s dest_slot);\n    cdt \\<leftarrow> gets cdt;\n    parent \\<leftarrow> return $ cdt src_slot;\n    cdt' \\<leftarrow> return $ cdt(dest_slot := parent, src_slot := None);\n    set_cdt (\\<lambda>r. if cdt' r = Some src_slot then Some dest_slot else cdt' r);\n    do_extended_op (cap_move_ext src_slot dest_slot src_p dest_p);\n    is_original \\<leftarrow> gets is_original_cap;\n    set_original dest_slot (is_original src_slot);\n    set_original src_slot False\n  od\"", "property": "Capability Move: Move a capability from one slot to another, transforming it if necessary, while updating the capability derivation tree (CDT) and original capability status accordingly. \n\nSubproperties:\n- Set the new capability at the destination slot.\n- Set the NullCap at the source slot.\n- Update the CDT by replacing the source slot with the destination slot as the child of the parent.\n- Update the original capability status for the source and destination slots.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Move a capability from one slot to another. Once again the new\ncapability is a parameter as it may be transformed while it is moved."}
{"spec": "definition\n  cap_swap_for_delete :: \"cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cap_swap_for_delete slot1 slot2 \\<equiv>\n  when (slot1 \\<noteq> slot2) $ do\n    cap1 \\<leftarrow> get_cap slot1;\n    cap2 \\<leftarrow> get_cap slot2;\n    cap_swap cap1 slot1 cap2 slot2\n  od\"", "property": "Capability Swap for Delete: Swap the capabilities in two slots without modifying the capabilities themselves, ensuring the existing capabilities are preserved during the swap operation.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "This version of capability swap does not change the capabilities that\nare swapped, passing the existing capabilities to the more general function."}
{"spec": "datatype\n  rec_del_call\n  = CTEDeleteCall cslot_ptr bool\n  | FinaliseSlotCall cslot_ptr bool\n  | ReduceZombieCall cap cslot_ptr bool", "property": "Recursive Delete Operations: Allow for the revocation and deletion of capabilities through three types of recursive delete calls: CTEDeleteCall, FinaliseSlotCall, and ReduceZombieCall. \n\nSubproperties:\n- CTEDeleteCall: Delete a capability from a slot, potentially recursively deleting related capabilities.\n- FinaliseSlotCall: Finalize the deletion of a capability slot, handling any remaining cleanup or bookkeeping.\n- ReduceZombieCall: Reduce a zombie capability, removing any unnecessary or redundant capabilities.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "The type of possible recursive deletes."}
{"spec": "definition\n  locate_slot :: \"cslot_ptr \\<Rightarrow> nat \\<Rightarrow> cslot_ptr\" where\n \"locate_slot \\<equiv> \\<lambda>(a, b) n. (a, drop (32 - length b)\n                           (to_bl (of_bl b + of_nat n :: word32)))\"", "property": "Capability Slot Location: Given a base capability slot and an offset, locate the nth capability slot beyond the base slot.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Locate the nth capability beyond some base capability slot."}
{"spec": "definition\n  deleting_irq_handler :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"deleting_irq_handler irq \\<equiv> do\n    slot \\<leftarrow> get_irq_slot irq;\n    cap_delete_one slot\n  od\"", "property": "IRQ Handler Deletion: When an IRQ Handler capability is deleted, the corresponding IRQ slot is retrieved and the capability is deleted from that slot.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Actions to be taken after deleting an IRQ Handler capability."}
{"spec": "fun\n  finalise_cap :: \"cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"finalise_cap NullCap                  final = return (NullCap, NullCap)\"\n| \"finalise_cap (UntypedCap dev r bits f)    final = return (NullCap, NullCap)\"\n| \"finalise_cap (ReplyCap r m R)         final = return (NullCap, NullCap)\"\n| \"finalise_cap (EndpointCap r b R)      final =\n      (liftM (K (NullCap, NullCap)) $ when final $ cancel_all_ipc r)\"\n| \"finalise_cap (NotificationCap r b R)  final =\n      (liftM (K (NullCap, NullCap)) $ when final $ do\n          unbind_maybe_notification r;\n          cancel_all_signals r\n        od)\"\n| \"finalise_cap (CNodeCap r bits g)  final =\n      return (if final then Zombie r (Some bits) (2 ^ bits) else NullCap, NullCap)\"\n| \"finalise_cap (ThreadCap r)            final =\n      do\n         when final $ unbind_notification r;\n         when final $ suspend r;\n         when final $ prepare_thread_delete r;\n         return (if final then (Zombie r None 5) else NullCap, NullCap)\n      od\"\n| \"finalise_cap DomainCap                final = return (NullCap, NullCap)\"\n| \"finalise_cap (Zombie r b n)           final =\n      do assert final; return (Zombie r b n, NullCap) od\"\n| \"finalise_cap IRQControlCap            final = return (NullCap, NullCap)\"\n| \"finalise_cap (IRQHandlerCap irq)      final = (\n       if final then do\n         deleting_irq_handler irq;\n         return (NullCap, (IRQHandlerCap irq))\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (ArchObjectCap a)        final =\n      (arch_finalise_cap a final)\"\n\ndefinition\n  can_fast_finalise :: \"cap \\<Rightarrow> bool\" where\n \"can_fast_finalise cap \\<equiv> case cap of\n    ReplyCap r m R \\<Rightarrow> True\n  | EndpointCap r b R \\<Rightarrow> True\n  | NotificationCap r b R \\<Rightarrow> True\n  | NullCap \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"", "property": "Capability Finalisation: Ensure that when a capability is deleted, necessary actions are taken to maintain system integrity, such as cancelling IPC, unbinding notifications, suspending threads, and preparing for thread deletion. This may involve replacing the deleted capability with a Zombie capability or performing post-deletion actions like clearing IRQs.\n\n Fast Finalisation: Determine whether a capability can be quickly finalised without requiring additional actions, applicable to Reply, Endpoint, Notification, and Null capabilities.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Actions that must be taken when a capability is deleted. Returns two\ncapabilities: The first is a capability to be re-inserted into the slot in place\nof the deleted capability; in particular, this will be a Zombie if the deletion\nrequires a long-running operation. The second represents some further\npost-deletion action to be performed after the slot is cleared. For example,\nan IRQHandlerCap indicates an IRQ to be cleared. Arch capabilities may also be\nassociated with arch-specific post-deletion actions. For most cases, however,\nNullCap is used to indicate that no post-deletion action is required."}
{"spec": "lemma fast_finalise_def2:\n  \"fast_finalise cap final = do\n     assert (can_fast_finalise cap);\n     result \\<leftarrow> finalise_cap cap final;\n     assert (result = (NullCap, NullCap))\n   od\"\n  supply K_def[simp]\n  by (cases cap, simp_all add: liftM_def assert_def can_fast_finalise_def)", "property": "Fast Finalisation of Capabilities: Ensure that a capability can be quickly finalised without invoking a long-running operation, by asserting the capability's eligibility for fast finalisation and verifying the result of the finalisation operation. \n\nSubproperties:\n- Can Fast Finalise: Verify that the capability is eligible for fast finalisation.\n- Finalisation Result: Confirm that the finalisation operation yields the expected result of (NullCap, NullCap).", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "This operation is used to delete a capability when it is known that a\nlong-running operation is impossible. It is equivalent to calling the regular\nfinalisation operation. It cannot be defined in that way as doing so\nwould create a circular definition."}
{"spec": "primrec (nonexhaustive)\n  cap_removeable :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\"\nwhere\n  \"cap_removeable NullCap slot = True\"\n| \"cap_removeable (Zombie slot' bits n) slot =\n    ((n = 0) \\<or> (n = 1 \\<and> (slot', replicate (zombie_cte_bits bits) False) = slot))\"", "property": "Capability Removal: Determine if a capability can be removed from a slot. A Null capability can always be removed, while a Zombie capability can be removed if it covers no slots or only the slot it is currently stored in.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "The finalisation process on a Zombie or Null capability is finished for\nall Null capabilities and for Zombies that cover no slots or only the slot they\nare currently stored in."}
{"spec": "definition\n  cap_cyclic_zombie :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\" where\n \"cap_cyclic_zombie cap slot \\<equiv> case cap of\n         Zombie slot' bits n \\<Rightarrow> (slot', replicate (zombie_cte_bits bits) False) = slot\n       | _ \\<Rightarrow> False\"", "property": "Detect Cyclic Zombie Capabilities: Identify Zombie capabilities that refer to their own containing CNode or TCB, indicating a self-referential cycle.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Checks for Zombie capabilities that refer to the CNode or TCB they are\nstored in."}
{"spec": "function (sequential)\n  rec_del :: \"rec_del_call \\<Rightarrow> (bool * cap,'z::state_ext) p_monad\"\nwhere\n  \"rec_del (CTEDeleteCall slot exposed) s =\n (doE\n    (success, cleanup_info) \\<leftarrow> rec_del (FinaliseSlotCall slot exposed);\n    without_preemption $ when (exposed \\<or> success) $ empty_slot slot cleanup_info;\n    returnOk undefined\n  odE) s\"\n|\n  \"rec_del (FinaliseSlotCall slot exposed) s =\n (doE\n    cap \\<leftarrow> without_preemption $ get_cap slot;\n    if (cap = NullCap)\n    then returnOk (True, NullCap)\n    else (doE\n      is_final \\<leftarrow> without_preemption $ is_final_cap cap;\n      (remainder, cleanup_info) \\<leftarrow> without_preemption $ finalise_cap cap is_final;\n      if (cap_removeable remainder slot)\n      then returnOk (True, cleanup_info)\n      else if (cap_cyclic_zombie remainder slot \\<and> \\<not> exposed)\n      then doE\n        without_preemption $ set_cap remainder slot;\n        returnOk (False, NullCap)\n      odE\n      else doE\n        without_preemption $ set_cap remainder slot;\n        rec_del (ReduceZombieCall remainder slot exposed);\n        preemption_point;\n        rec_del (FinaliseSlotCall slot exposed)\n      odE\n    odE)\n  odE) s\"\n\n| \"rec_del (ReduceZombieCall (Zombie ptr bits (Suc n)) slot False) s =\n (doE\n    cn \\<leftarrow> returnOk $ first_cslot_of (Zombie ptr bits (Suc n));\n    assertE (cn \\<noteq> slot);\n    without_preemption $ cap_swap_for_delete cn slot;\n    returnOk undefined\n  odE) s\"\n|\n \"rec_del (ReduceZombieCall (Zombie ptr bits (Suc n)) slot True) s =\n (doE\n    end_slot \\<leftarrow> returnOk (ptr, nat_to_cref (zombie_cte_bits bits) n);\n    rec_del (CTEDeleteCall end_slot False);\n    new_cap \\<leftarrow> without_preemption $ get_cap slot;\n    if (new_cap = Zombie ptr bits (Suc n))\n    then without_preemption $ set_cap (Zombie ptr bits n) slot\n    else assertE (new_cap = NullCap \\<or>\n                  is_zombie new_cap \\<and> first_cslot_of new_cap = slot\n                   \\<and> first_cslot_of (Zombie ptr bits (Suc n)) \\<noteq> slot);\n    returnOk undefined\n  odE) s\"\n|\n \"rec_del (ReduceZombieCall cap slot exposed) s =\n  fail s\"\n  by pat_completeness auto", "property": "Recursive Capability Deletion: Completely delete a capability from the system, handling various cases such as finalizing the capability, removing it from the slot, and handling zombie capabilities by reducing or deleting them, ensuring that the capability is properly removed and system consistency is maintained.\n\nSubproperties:\n- Finalize Capability: Finalize a capability, checking if it is removable or if it needs to be reduced or deleted.\n- Remove Capability: Remove a capability from its slot, handling cases where the capability is a zombie or needs to be swapped with another capability.\n- Reduce Zombie Capability: Reduce a zombie capability by deleting or swapping it with another capability, ensuring that the zombie capability is properly handled and removed from the system.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "The complete recursive delete operation."}
{"spec": "definition\n  cap_delete :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n \"cap_delete slot \\<equiv> doE rec_del (CTEDeleteCall slot True); returnOk () odE\"", "property": "Capability Deletion: Delete a capability from the capability space by performing a recursive delete operation on the specified slot.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Delete a capability by calling the recursive delete operation."}
{"spec": "definition\n  finalise_slot :: \"cslot_ptr \\<Rightarrow> bool \\<Rightarrow> (bool * cap,'z::state_ext) p_monad\"\nwhere\n  \"finalise_slot p e \\<equiv> rec_del (FinaliseSlotCall p e)\"", "property": "Capability Revocation Preparation: Prepare a capability in a slot for deletion without actually deleting it, ensuring the capability is in a state ready for removal while maintaining system consistency.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Prepare the capability in a slot for deletion but do not delete it."}
{"spec": "primrec\n  exposed_rdcall :: \"rec_del_call \\<Rightarrow> bool\"\nwhere\n  \"exposed_rdcall (CTEDeleteCall slot exposed) = exposed\"\n| \"exposed_rdcall (FinaliseSlotCall slot exposed) = exposed\"\n| \"exposed_rdcall (ReduceZombieCall cap slot exposed) = exposed\"\n\nprimrec\n  isCTEDeleteCall :: \"rec_del_call \\<Rightarrow> bool\"\nwhere\n  \"isCTEDeleteCall (CTEDeleteCall slot exposed) = True\"\n| \"isCTEDeleteCall (FinaliseSlotCall slot exposed) = False\"\n| \"isCTEDeleteCall (ReduceZombieCall cap slot exposed) = False\"\n\nprimrec\n  slot_rdcall :: \"rec_del_call \\<Rightarrow> cslot_ptr\"\nwhere\n  \"slot_rdcall (CTEDeleteCall slot exposed) = slot\"\n| \"slot_rdcall (FinaliseSlotCall slot exposed) = slot\"\n| \"slot_rdcall (ReduceZombieCall cap slot exposed) = slot\"", "property": "Recursive Delete Calls: Identify and manage recursive delete calls for capabilities, including CTE delete calls, finalise slot calls, and reduce zombie calls, while tracking exposed status and slot information. \n\nSubproperties:\n- Exposed Status: Determine if a recursive delete call is exposed.\n- Call Type Identification: Identify if a recursive delete call is a CTE delete call.\n- Slot Information: Retrieve the slot pointer associated with a recursive delete call.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Helper functions for the type of recursive delete calls."}
{"spec": "function cap_revoke :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n\"cap_revoke slot s = (doE\n    cap \\<leftarrow> without_preemption $ get_cap slot;\n    cdt \\<leftarrow> without_preemption $ gets cdt;\n    descendants \\<leftarrow> returnOk $ descendants_of slot cdt;\n    whenE (cap \\<noteq> NullCap \\<and> descendants \\<noteq> {}) (doE\n      child \\<leftarrow> without_preemption $ select_ext (next_revoke_cap slot) descendants;\n      cap \\<leftarrow> without_preemption $ get_cap child;\n      assertE (cap \\<noteq> NullCap);\n      cap_delete child;\n      preemption_point;\n      cap_revoke slot\n    odE)\nodE) s\"\nby auto", "property": "Revoke Capability: Revoke and delete all derived capabilities of a given capability, ensuring that all its descendants are removed from the capability derivation tree. \n\nRecursive Revocation: If the capability has non-null descendants, select the next capability to revoke, delete it, and then recursively revoke the original capability to ensure all descendants are removed.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Revoke the derived capabilities of a given capability, deleting them\nall."}
{"spec": "definition\n  get_badge :: \"cap \\<Rightarrow> badge option\" where\n \"get_badge cap \\<equiv> case cap of\n    NotificationCap oref badge cr \\<Rightarrow> Some badge\n  | EndpointCap oref badge cr      \\<Rightarrow> Some badge\n  | _                              \\<Rightarrow> None\"\n\n\ndefinition\n  is_physical :: \"cap \\<Rightarrow> bool\" where\n  \"is_physical cap \\<equiv> case cap of\n    NullCap \\<Rightarrow> False\n  | DomainCap \\<Rightarrow> False\n  | IRQControlCap \\<Rightarrow> False\n  | IRQHandlerCap _ \\<Rightarrow> False\n  | ReplyCap _ _ _ \\<Rightarrow> False\n  | ArchObjectCap c \\<Rightarrow> arch_is_physical c\n  | _ \\<Rightarrow> True\"\n\nfun\n  same_region_as :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"same_region_as NullCap c' = False\"\n| \"same_region_as (UntypedCap dev r bits free) c' =\n    (is_physical c' \\<and>\n     r \\<le> obj_ref_of c' \\<and>\n     obj_ref_of c' \\<le> obj_ref_of c' + obj_size c' - 1 \\<and>\n     obj_ref_of c' + obj_size c' - 1 \\<le> r + (1 << bits) - 1)\"\n| \"same_region_as (EndpointCap r b R) c' =\n    (is_ep_cap c' \\<and> obj_ref_of c' = r)\"\n| \"same_region_as (NotificationCap r b R) c' =\n    (is_ntfn_cap c' \\<and> obj_ref_of c' = r)\"\n| \"same_region_as (CNodeCap r bits g) c' =\n    (is_cnode_cap c' \\<and> obj_ref_of c' = r \\<and> bits_of c' = bits)\"\n| \"same_region_as (ReplyCap n m cr) c' = (\\<exists>m' cr. c' = ReplyCap n m' cr)\"\n| \"same_region_as (ThreadCap r) c' =\n    (is_thread_cap c' \\<and> obj_ref_of c' = r)\"\n| \"same_region_as (Zombie r b n) c' = False\"\n| \"same_region_as (IRQControlCap) c' =\n    (c' = IRQControlCap \\<or> (\\<exists>n. c' = IRQHandlerCap n))\"\n| \"same_region_as DomainCap c' = (c' = DomainCap)\"\n| \"same_region_as (IRQHandlerCap n) c' =\n    (c' = IRQHandlerCap n)\"\n| \"same_region_as (ArchObjectCap a) c' =\n    (case c' of ArchObjectCap a' \\<Rightarrow> arch_same_region_as a a' | _ \\<Rightarrow> False)\"", "property": "Capability Properties: Define the properties and relationships of capabilities, including the extraction of badges, identification of physical capabilities, and determination of whether two capabilities belong to the same region. These properties ensure that capabilities are correctly managed and accessed within the system, maintaining the integrity of the CSpace. \n\nBadge Extraction: Retrieve the badge associated with a capability, if it exists.\n\nPhysical Capability Identification: Determine whether a capability is physical, based on its type.\n\nSame Region Identification: Check whether two capabilities belong to the same region, based on their types and attributes.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": ""}
{"spec": "definition\n  same_object_as :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\" where\n \"same_object_as cp cp' \\<equiv>\n   (case (cp, cp') of\n      (UntypedCap dev r bits free, _) \\<Rightarrow> False\n    | (IRQControlCap, IRQHandlerCap n) \\<Rightarrow> False\n    | (ArchObjectCap ac, ArchObjectCap ac') \\<Rightarrow> same_aobject_as ac ac'\n    | _ \\<Rightarrow> same_region_as cp cp')\"", "property": "Capability Equivalence: Determine if two capabilities refer to the same object, considering their types and attributes. \n\n Subproperties:\n- Untyped capabilities are never considered equivalent to any other capability.\n- IRQControlCap and IRQHandlerCap are never equivalent.\n- Architecture-specific object capabilities are compared using a specialized function (same_aobject_as).\n- Other capabilities are compared based on their regions (same_region_as).", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "Check whether two capabilities are to the same object."}
{"spec": "definition\n  should_be_parent_of :: \"cap \\<Rightarrow> bool \\<Rightarrow> cap \\<Rightarrow> bool \\<Rightarrow> bool\" where\n  \"should_be_parent_of c original c' original' \\<equiv>\n   original \\<and>\n   same_region_as c c' \\<and>\n   (case c of\n      EndpointCap ref badge R \\<Rightarrow> badge \\<noteq> 0 \\<longrightarrow> cap_ep_badge c' = badge \\<and> \\<not>original'\n    | NotificationCap ref badge R \\<Rightarrow> badge \\<noteq> 0 \\<longrightarrow> cap_ep_badge c' = badge \\<and> \\<not>original'\n    | _ \\<Rightarrow> True)\"", "property": "Capability Parentage: A capability should be a parent of another if it is the original capability to the object, covers the same memory region, and meets specific conditions for endpoint and notification capabilities, including badge matching and originality.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "\nThe function @{text \"should_be_parent_of\"}\nchecks whether an existing capability should be a parent of\nanother to-be-inserted capability. The test is the following:\nFor capability @{term c} to be a parent of capability @{term c'},\n@{term c} needs to be the original capability to the object and needs\nto cover the same memory region as @{term c'} (i.e.\\ cover the same\nobject). In the case of endpoint capabilities, if @{term c} is a\nbadged endpoint cap (@{text \"badge \\<noteq> 0\"}), then it should be a parent\nof @{text c'} if @{text c'} has the same badge and is itself not an\noriginal badged endpoint cap.\n\n\\begin{figure}\n\\begin{center}\n\\includegraphics[width=0.8\\textwidth]{imgs/CDT}\n\\end{center}\n\\caption{Example capability derivation tree.}\\label{fig:CDT}\n\\end{figure}\n\nFigure \\ref{fig:CDT} shows an example capability derivation tree that\nillustrates a standard scenario: the top level is a large untyped\ncapability, the second level splits this capability into two regions\ncovered by their own untyped caps, both are children of the first\nlevel.  The third level on the left is a copy of the level 2 untyped\ncapability.  Untyped capabilities when copied always create children,\nnever siblings.  In this scenario, the untyped capability was typed\ninto two separate objects, creating two capabilities on level 4, both\nare the original capability to the respective object, both are\nchildren of the untyped capability they were created from.\n\n Ordinary original capabilities can have one level of derived capabilities\n(created, for instance, by the copy or mint operations). Further copies\nof these derived capabilities will create sibling, in this case\nremaining on level 5. There is an exception to this scheme for endpoint\ncapabilities --- they support an additional layer of depth with the\nconcept of badged and unbadged endpoints. The original endpoint\ncapability will be unbadged. Using the mint operation, a copy of\nthe capability with a specific badge can be created. This new, badged\ncapability to the same object is treated as an original capability\n(the ``original badged endpoint capability'') and supports one level\nof derived children like other capabilities.\n"}
{"spec": "definition\n  is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"is_cap_revocable new_cap src_cap \\<equiv> case new_cap of\n      ArchObjectCap acap \\<Rightarrow> arch_is_cap_revocable new_cap src_cap\n    | EndpointCap _ _ _ \\<Rightarrow> cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n    | NotificationCap _ _ _ \\<Rightarrow> cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n    | IRQHandlerCap _ \\<Rightarrow> src_cap = IRQControlCap\n    | UntypedCap _ _ _ _ \\<Rightarrow> True\n    | _ \\<Rightarrow> False\"", "property": "Capability Revocability: Determine if a new capability should be considered as the original capability to an object, allowing for exceptions such as newly badged endpoint capabilities, IRQ handlers, untyped caps, and specific architecture capabilities. \n\nSubproperties:\n- Endpoint and Notification Capabilities: Considered revocable if the new capability has a different badge than the source capability.\n- IRQ Handler Capabilities: Considered revocable if the source capability is an IRQ Control Capability.\n- Untyped Capabilities: Always considered revocable.\n- Architecture Capabilities: Determined by architecture-specific rules.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "This helper function determines if the new capability\nshould be counted as the original capability to the object. This test\nis usually false, apart from the exceptions listed (newly badged\nendpoint capabilities, irq handlers, untyped caps, and possibly some\narch caps)."}
{"spec": "definition\n  cap_insert :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"cap_insert new_cap src_slot dest_slot \\<equiv> do\n    src_cap \\<leftarrow> get_cap src_slot;\n\n    dest_original \\<leftarrow> return $ is_cap_revocable new_cap src_cap;\n\n    old_cap \\<leftarrow> get_cap dest_slot;\n    assert (old_cap = NullCap);\n    set_untyped_cap_as_full src_cap new_cap src_slot;\n    set_cap new_cap dest_slot;\n\n    is_original \\<leftarrow> gets is_original_cap;\n    src_parent \\<leftarrow> return $\n       should_be_parent_of src_cap (is_original src_slot) new_cap dest_original;\n    src_p \\<leftarrow> gets (\\<lambda>s. cdt s src_slot);\n    dest_p \\<leftarrow> gets (\\<lambda>s. cdt s dest_slot);\n    update_cdt (\\<lambda>cdt. cdt (dest_slot := if src_parent\n                                        then Some src_slot\n                                        else cdt src_slot));\n    do_extended_op (cap_insert_ext src_parent src_slot dest_slot src_p dest_p);\n    set_original dest_slot dest_original\n  od\"\n\n\ndefinition\n  has_cancel_send_rights :: \"cap \\<Rightarrow> bool\" where\n  \"has_cancel_send_rights cap \\<equiv> case cap of\n   EndpointCap _ _ R \\<Rightarrow> R = all_rights\n   | _ \\<Rightarrow> False\"", "property": "Capability Insertion: Insert a new capability as a sibling or child of an existing capability, updating the Capability Derivation Tree (CDT) accordingly, while ensuring the new capability's originality and revocability are correctly set. \n\nSubproperties:\n- Capability Revocability: Determine if the new capability should be counted as the original capability to the object.\n- CDT Update: Update the CDT to reflect the insertion of the new capability, setting the parent-child relationship between the source and destination slots.\n- Originality Setting: Set the originality of the new capability based on whether it is a newly badged endpoint capability, an IRQ handler, or an untyped capability.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "Insert a new capability as either a sibling or child of an\nexisting capability. The function @{const should_be_parent_of}\ndetermines which it will be.\n\nThe term for @{text dest_original} determines if the new capability\nshould be counted as the original capability to the object. This test\nis usually false, apart from the exceptions listed (newly badged\nendpoint capabilities, irq handlers, and untyped caps).\n"}
{"spec": "definition\n  tcb_registers_caps_merge :: \"tcb \\<Rightarrow> tcb \\<Rightarrow> tcb\"\nwhere\n \"tcb_registers_caps_merge regtcb captcb \\<equiv>\n  regtcb \\<lparr> tcb_ctable := tcb_ctable captcb,\n           tcb_vtable := tcb_vtable captcb,\n           tcb_reply := tcb_reply captcb,\n           tcb_caller := tcb_caller captcb,\n           tcb_ipcframe := tcb_ipcframe captcb \\<rparr>\"", "property": "TCB Capability Merge: Merge the capabilities of two TCBs, overwriting the capabilities of the first TCB with those of the second while preserving the register set and other fields.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "Overwrite the capabilities stored in a TCB while preserving the register\nset and other fields."}
{"spec": "text \\<open>The CNode capability confers authority to various methods\nwhich act on CNodes and the capabilities within them. Copies of\ncapabilities may be inserted in empty CNode slots by\nInsert. Capabilities may be moved to empty slots with Move or swapped\nwith others in a three way rotate by Rotate. A Reply capability stored\nin a thread's last-caller slot may be saved into a regular CNode slot\nwith Save.  The Revoke, Delete and Recycle methods may also be\ninvoked on the capabilities stored in the CNode.\\<close>\n\ndefinition\n  invoke_cnode :: \"cnode_invocation \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"invoke_cnode i \\<equiv> case i of\n    RevokeCall dest_slot \\<Rightarrow> cap_revoke dest_slot\n  | DeleteCall dest_slot \\<Rightarrow> cap_delete dest_slot\n  | InsertCall cap src_slot dest_slot \\<Rightarrow>\n       without_preemption $ cap_insert cap src_slot dest_slot\n  | MoveCall cap src_slot dest_slot \\<Rightarrow>\n       without_preemption $ cap_move cap src_slot dest_slot\n  | RotateCall cap1 cap2 slot1 slot2 slot3 \\<Rightarrow>\n       without_preemption $\n       if slot1 = slot3 then\n         cap_swap cap1 slot1 cap2 slot2\n       else\n         do cap_move cap2 slot2 slot3; cap_move cap1 slot1 slot2 od\n  | SaveCall slot \\<Rightarrow> without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    src_slot \\<leftarrow> return (thread, tcb_cnode_index 3);\n    cap \\<leftarrow> get_cap src_slot;\n    (case cap of\n          NullCap \\<Rightarrow> return ()\n        | ReplyCap _ False _ \\<Rightarrow> cap_move cap src_slot slot\n        | _ \\<Rightarrow> fail) od\n  | CancelBadgedSendsCall (EndpointCap ep b R) \\<Rightarrow>\n    without_preemption $ when (b \\<noteq> 0) $ cancel_badged_sends ep b\n  | CancelBadgedSendsCall _ \\<Rightarrow> fail\"", "property": "CNode Invocation Actions: Authorize various operations on CNodes and their capabilities, including inserting, moving, swapping, saving, revoking, deleting, and recycling capabilities, as well as cancelling badged sends, while ensuring the integrity and consistency of the capability space.\n\nSubproperties:\n- Insert and Move: Insert copies of capabilities into empty CNode slots or move them to empty slots.\n- Rotate: Swap capabilities in a three-way rotate.\n- Save: Save a Reply capability from a thread's last-caller slot into a regular CNode slot.\n- Revoke, Delete, and Recycle: Revoke, delete, or recycle capabilities stored in the CNode.\n- Cancel Badged Sends: Cancel badged sends for a specific endpoint.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Invoking CNode capabilities", "comment": ""}
{"spec": "datatype capclass =\n  PhysicalClass | ReplyClass \"obj_ref\" | IRQClass | ASIDMasterClass | NullClass | DomainClass | IOPortClass\n\nend", "property": "Capability Classification: Classify capabilities into distinct categories, including Physical, Reply, IRQ, ASID Master, Null, Domain, and IOPort, to define invariants and ensure proper capability management.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Cap classification used to define invariants", "comment": ""}
{"spec": "definition\n  get_object :: \"obj_ref \\<Rightarrow> (kernel_object,'z::state_ext) s_monad\"\nwhere\n  \"get_object ptr \\<equiv> do\n     kh \\<leftarrow> gets kheap;\n     assert (kh ptr \\<noteq> None);\n     return $ the $ kh ptr\n   od\"\n\ndefinition\n  set_object :: \"obj_ref \\<Rightarrow> kernel_object \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_object ptr obj \\<equiv> do\n     kobj <- get_object ptr;\n     assert (a_type kobj = a_type obj);\n     s \\<leftarrow> get;\n     put (s\\<lparr>kheap := (kheap s)(ptr \\<mapsto> obj)\\<rparr>)\n   od\"", "property": "Kernel Heap Access: Provide controlled access to the kernel heap, allowing for retrieval and modification of kernel objects. \n\nGet Object: Retrieve a kernel object from the kernel heap, ensuring the object exists at the specified location.\n\nSet Object: Update a kernel object in the kernel heap, verifying that the new object has the same type as the existing one to maintain consistency.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "TCBs", "comment": ""}
{"spec": "definition\n  get_tcb :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> tcb option\"\nwhere\n  \"get_tcb tcb_ref state \\<equiv>\n   case kheap state tcb_ref of\n      None      \\<Rightarrow> None\n    | Some kobj \\<Rightarrow> (case kobj of\n        TCB tcb \\<Rightarrow> Some tcb\n      | _       \\<Rightarrow> None)\"\n\ndefinition\n  thread_get :: \"(tcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"thread_get f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     return $ f tcb\n   od\"\n\ndefinition\n  thread_set :: \"(tcb \\<Rightarrow> tcb) \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"thread_set f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     set_object tptr $ TCB $ f tcb\n   od\"\n\ndefinition\n  arch_thread_get :: \"(arch_tcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"arch_thread_get f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     return $ f (tcb_arch tcb)\n   od\"\n\ndefinition\n  arch_thread_set :: \"(arch_tcb \\<Rightarrow> arch_tcb) \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"arch_thread_set f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     set_object tptr $ TCB $ tcb \\<lparr> tcb_arch := f (tcb_arch tcb) \\<rparr>\n   od\"\n\ndefinition\n  get_thread_state :: \"obj_ref \\<Rightarrow> (thread_state,'z::state_ext) s_monad\"\nwhere\n  \"get_thread_state ref \\<equiv> thread_get tcb_state ref\"\n\ndefinition\n  get_bound_notification :: \"obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\"\nwhere\n  \"get_bound_notification ref \\<equiv> thread_get tcb_bound_notification ref\"\n\ndefinition\n  set_bound_notification :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"set_bound_notification ref ntfn \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb ref;\n     set_object ref (TCB (tcb \\<lparr> tcb_bound_notification := ntfn \\<rparr>))\n   od\"\n\ndefinition set_thread_state_ext :: \"obj_ref \\<Rightarrow> unit det_ext_monad\" where\n  \"set_thread_state_ext t \\<equiv> do\n     ts \\<leftarrow> get_thread_state t;\n     cur \\<leftarrow> gets cur_thread;\n     action \\<leftarrow> gets scheduler_action;\n     when (\\<not> (runnable ts) \\<and> cur = t \\<and> action = resume_cur_thread) (set_scheduler_action choose_new_thread)\n   od\"\n\ndefinition\n  set_thread_state :: \"obj_ref \\<Rightarrow> thread_state \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_thread_state ref ts \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb ref;\n     set_object ref (TCB (tcb \\<lparr> tcb_state := ts \\<rparr>));\n     do_extended_op (set_thread_state_ext ref)\n   od\"\n\ndefinition\n  set_priority :: \"obj_ref \\<Rightarrow> priority \\<Rightarrow> unit det_ext_monad\" where\n  \"set_priority tptr prio \\<equiv> do\n     tcb_sched_action tcb_sched_dequeue tptr;\n     thread_set_priority tptr prio;\n     ts \\<leftarrow> get_thread_state tptr;\n     when (runnable ts) $ do\n       cur \\<leftarrow> gets cur_thread;\n       if tptr = cur then reschedule_required else possible_switch_to tptr\n     od\n   od\"\n\ndefinition\n  set_mcpriority :: \"obj_ref \\<Rightarrow> priority \\<Rightarrow> (unit, 'z::state_ext) s_monad\"  where\n  \"set_mcpriority ref mcp \\<equiv> thread_set (\\<lambda>tcb. tcb\\<lparr>tcb_mcpriority:=mcp\\<rparr>) ref \"", "property": "TCB Access and Modification: Provides functions to access and modify thread control blocks (TCBs) in the kernel heap, including retrieving TCBs, getting and setting thread states, priorities, and bound notifications, and updating TCB fields.\n\nSubproperties:\n- TCB Retrieval: Retrieves a TCB from the kernel heap using its object reference.\n- Thread State Management: Gets and sets the state of a thread, including its current state and bound notification.\n- Priority Management: Sets the priority of a thread and updates the scheduler accordingly.\n- TCB Field Updates: Updates specific fields of a TCB, such as its priority and bound notification.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "TCBs", "comment": ""}
{"spec": "(* to be used for abstraction unifying kernel objects other than TCB and CNode *)\n\ndefinition\n  partial_inv :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('b \\<Rightarrow> 'a option)\"\nwhere\n  \"partial_inv f x = (if \\<exists>!y. f y = x then Some (THE y. f y = x) else None)\"\n\nlemma proj_inj: \"inj f \\<Longrightarrow> (partial_inv f ko = Some v) = (f v = ko)\"\n  by (auto simp: partial_inv_def the_equality injD)\n\nlemma inj_Endpoint: \"inj Endpoint\" by (auto intro: injI)\nlemma inj_Notification: \"inj Notification\"  by (auto intro: injI)\n\nlemmas proj_inj_ep[simp] = proj_inj[OF inj_Endpoint]\nlemma proj_ko_type_ep[simp]: \"(\\<exists>v. partial_inv Endpoint  ko = Some (v::endpoint)) = (a_type ko = AEndpoint)\"\n  by (cases ko; auto simp: partial_inv_def a_type_def)\n\nlemmas proj_inj_ntfn[simp] = proj_inj[OF inj_Notification]\nlemma proj_ko_type_ntfn[simp]:\n  \"(\\<exists>v. partial_inv Notification  ko = Some (v::notification)) = (a_type ko = ANTFN)\"\n  by (cases ko; auto simp: partial_inv_def a_type_def)\n\n\nabbreviation\n  \"is_simple_type \\<equiv> (\\<lambda>ob. a_type ob \\<in> {AEndpoint, ANTFN})\"\n\n\ndefinition\n  get_simple_ko :: \"('a \\<Rightarrow> kernel_object) \\<Rightarrow> obj_ref \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"get_simple_ko f ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     assert (is_simple_type kobj);\n     (case partial_inv f kobj of Some e \\<Rightarrow> return e | _ \\<Rightarrow> fail)\n   od\"\n\n\ndefinition\n  set_simple_ko :: \"('a \\<Rightarrow> kernel_object) \\<Rightarrow> obj_ref \\<Rightarrow> 'a \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_simple_ko f ptr ep \\<equiv> do\n     obj \\<leftarrow> get_object ptr;\n     assert (is_simple_type obj);\n     assert (partial_inv f obj \\<noteq> None);\n     set_object ptr (f ep)\n   od\"", "property": "Kernel Heap Access for Simple Objects: Provides functions to get and set simple kernel objects (endpoints and notifications) from the kernel heap, ensuring the object type is valid and the operation is type-safe. \n\nGet Simple Kernel Object: Retrieves a simple kernel object from the kernel heap, asserting the object type is valid and returning the object if successful.\n\nSet Simple Kernel Object: Sets a simple kernel object in the kernel heap, asserting the object type is valid and the new object is compatible with the existing object.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "simple kernel objects", "comment": ""}
{"spec": "abbreviation\n  get_endpoint :: \"obj_ref \\<Rightarrow> (endpoint,'z::state_ext) s_monad\" where\n  \"get_endpoint \\<equiv> get_simple_ko Endpoint\"\n\nabbreviation\n  set_endpoint :: \"obj_ref \\<Rightarrow> endpoint \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_endpoint \\<equiv> set_simple_ko Endpoint\"\n\nabbreviation\n  get_notification :: \"obj_ref \\<Rightarrow> (notification,'z::state_ext) s_monad\" where\n  \"get_notification \\<equiv> get_simple_ko Notification\"\n\nabbreviation\n  set_notification :: \"obj_ref \\<Rightarrow> notification \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_notification \\<equiv> set_simple_ko Notification\"\n\nabbreviation\n  ntfn_set_bound_tcb :: \"notification \\<Rightarrow> obj_ref option \\<Rightarrow> notification\" where\n  \"ntfn_set_bound_tcb ntfn t \\<equiv> ntfn \\<lparr> ntfn_bound_tcb := t \\<rparr>\"\n\nabbreviation\n  ntfn_set_obj :: \"notification \\<Rightarrow> ntfn \\<Rightarrow> notification\" where\n  \"ntfn_set_obj ntfn a \\<equiv> ntfn \\<lparr> ntfn_obj := a \\<rparr>\"", "property": "Kernel Heap Access for Endpoints and Notifications: Provides functions to access and modify endpoints and notifications in the kernel heap, including retrieving and setting endpoint and notification objects, as well as updating notification bindings and objects.\n\nSubproperties:\n- Get and Set Endpoints: Access and modify endpoint objects in the kernel heap.\n- Get and Set Notifications: Access and modify notification objects in the kernel heap.\n- Update Notification Bindings and Objects: Modify notification bindings and objects within the kernel heap.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "Synchronous and Asyncronous Endpoints", "comment": ""}
{"spec": "definition\n  get_irq_state :: \"irq \\<Rightarrow> (irq_state,'z::state_ext) s_monad\" where\n \"get_irq_state irq \\<equiv> gets (\\<lambda>s. interrupt_states s irq)\"\n\ndefinition\n  set_irq_state :: \"irq_state \\<Rightarrow> irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"set_irq_state state irq \\<equiv> do\n    modify (\\<lambda>s. s \\<lparr> interrupt_states := (interrupt_states s) (irq := state)\\<rparr>);\n    do_machine_op $ maskInterrupt (state = IRQInactive) irq\n  od\"\n\ndefinition\n  get_irq_slot :: \"irq \\<Rightarrow> (cslot_ptr,'z::state_ext) s_monad\" where\n \"get_irq_slot irq \\<equiv> gets (\\<lambda>st. (interrupt_irq_node st irq, []))\"", "property": "IRQ State Management: Manage the state of an IRQ (Interrupt Request), allowing for retrieval and modification of its state, and control of its interrupt mask based on its state.\n\nSubproperties:\n- Get IRQ State: Retrieve the current state of an IRQ.\n- Set IRQ State: Set the state of an IRQ and update the interrupt mask accordingly.\n- Get IRQ Slot: Retrieve the slot associated with an IRQ.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "IRQ State and Slot", "comment": ""}
{"spec": "definition\n  is_irq_active :: \"irq \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n \"is_irq_active irq \\<equiv> liftM (\\<lambda>st. st \\<noteq> IRQInactive) $ get_irq_state irq\"", "property": "IRQ State Check: Determine if an IRQ identifier is active by checking its state is not inactive.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "IRQ State and Slot", "comment": "Tests whether an IRQ identifier is in use."}
{"spec": "text \\<open>\n  Changes user context of specified thread by running\n  specified user monad.\n\\<close>\ndefinition\n  as_user :: \"obj_ref \\<Rightarrow> 'a user_monad \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"as_user tptr f \\<equiv> do\n    tcb \\<leftarrow> gets_the $ get_tcb tptr;\n    uc \\<leftarrow> return $ arch_tcb_context_get (tcb_arch tcb);\n    (a, uc') \\<leftarrow> select_f $ f uc;\n    new_tcb \\<leftarrow> return $ tcb \\<lparr> tcb_arch := arch_tcb_context_set uc' (tcb_arch tcb)\\<rparr>;\n    set_object tptr (TCB new_tcb);\n    return a\n  od\"", "property": "Change User Context: Modify the user context of a specified thread by executing a given user monad, updating the thread's control block (TCB) with the new context.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "User Context", "comment": ""}
{"spec": "definition\nthrow_on_false :: \"'e \\<Rightarrow> (bool,'z::state_ext) s_monad \\<Rightarrow> ('e + unit,'z::state_ext) s_monad\" where\n\"throw_on_false ex f \\<equiv> doE v \\<leftarrow> liftE f; unlessE v $ throwError ex odE\"\n\nend", "property": "Exception Handling: Raise an exception if a specified property does not hold, ensuring that the system maintains its integrity and reports errors when necessary.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "User Context", "comment": "Raise an exception if a property does not hold."}
{"spec": "datatype lookup_failure\n     = InvalidRoot\n     | MissingCapability nat\n     | DepthMismatch nat nat\n     | GuardMismatch nat \"bool list\"\n\ndatatype fault\n         = CapFault obj_ref bool lookup_failure\n         | UnknownSyscallException data\n         | UserException data data\n         | ArchFault arch_fault\n\ndatatype syscall_error\n         = InvalidArgument nat\n         | InvalidCapability nat\n         | IllegalOperation\n         | RangeError data data\n         | AlignmentError\n         | FailedLookup bool lookup_failure\n         | TruncatedMessage\n         | DeleteFirst\n         | RevokeFirst\n         | NotEnoughMemory data", "property": "Exception Handling: Distinguish between faults and errors, where faults are reported to the user's fault handler and errors are reported directly to the user. \n\nSubproperties:\n- Fault Classification: Identify and classify faults, including capability faults, unknown syscall exceptions, user exceptions, and architecture-specific faults.\n- Error Classification: Identify and classify syscall errors, including invalid arguments, invalid capabilities, illegal operations, range errors, alignment errors, failed lookups, truncated messages, and memory-related errors.", "title": "./spec/abstract/ExceptionTypes_A.thy", "chapter": "", "section": "", "comment": "\n  There are two types of exceptions that can occur in the kernel:\n  faults and errors. Faults are reported to the user's fault handler.\n  Errors are reported to the user directly.\n\n  Capability lookup failures can be be either fault or error,\n  depending on context.\n"}
{"spec": "primrec\n  msg_from_lookup_failure :: \"lookup_failure \\<Rightarrow> data list\"\nwhere\n  \"msg_from_lookup_failure InvalidRoot           = [1]\"\n| \"msg_from_lookup_failure (MissingCapability n) = [2, of_nat n]\"\n| \"msg_from_lookup_failure (DepthMismatch n m)   = [3, of_nat n, of_nat m]\"\n| \"msg_from_lookup_failure (GuardMismatch n g)   = [4, of_nat n, of_bl g, of_nat (size g)]\"\n\nprimrec\n  msg_from_syscall_error :: \"syscall_error \\<Rightarrow> (data \\<times> data list)\"\nwhere\n  \"msg_from_syscall_error (InvalidArgument n)    = (1, [of_nat n])\"\n| \"msg_from_syscall_error (InvalidCapability n)  = (2, [of_nat n])\"\n| \"msg_from_syscall_error IllegalOperation       = (3, [])\"\n| \"msg_from_syscall_error (RangeError minv maxv) = (4, [minv, maxv])\"\n| \"msg_from_syscall_error AlignmentError         = (5, [])\"\n| \"msg_from_syscall_error (FailedLookup s lf)    = (6, [if s then 1 else 0]@(msg_from_lookup_failure lf))\"\n| \"msg_from_syscall_error TruncatedMessage       = (7, [])\"\n| \"msg_from_syscall_error DeleteFirst            = (8, [])\"\n| \"msg_from_syscall_error RevokeFirst            = (9, [])\"\n| \"msg_from_syscall_error (NotEnoughMemory n)    = (10, [n])\"\n\nend", "property": "System Call Error Messages: Create a message from a system-call failure to be returned to the thread attempting the operation that failed, providing specific error codes and relevant information for different types of failures. \n\nError Message Format: The message format includes an error code and additional data specific to the error type, such as invalid argument or capability numbers, range error bounds, or lookup failure details.", "title": "./spec/abstract/ExceptionTypes_A.thy", "chapter": "", "section": "", "comment": "Create a message from a system-call failure to be returned to the\nthread attempting the operation that failed."}
{"spec": "definition trans_state :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a state \\<Rightarrow> 'b state\" where\n\"trans_state t s = \\<lparr>kheap = kheap s, cdt = cdt s, is_original_cap = is_original_cap s,\n                     cur_thread = cur_thread s, idle_thread = idle_thread s,\n                     machine_state = machine_state s,\n                     interrupt_irq_node = interrupt_irq_node s,\n                     interrupt_states = interrupt_states s, arch_state = arch_state s,\n                     exst = t(exst s)\\<rparr>\"", "property": "State Translation: Translate a state of one type to another type via a given function, preserving most of the state components and transforming the extended state.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "", "comment": "Translate a state of type @{typ \"'a state\"} to one of type @{typ \"'b state\"}\n  via a function @{term t} from @{typ \"'a\"} to @{typ \"'b\"}.\n"}
{"spec": "lemma trans_state[simp]: \"kheap (trans_state t s) = kheap s\"\n                            \"cdt (trans_state t s) = cdt s\"\n                            \"is_original_cap (trans_state t s) = is_original_cap s\"\n                            \"cur_thread (trans_state t s) = cur_thread s\"\n                            \"idle_thread (trans_state t s) = idle_thread s\"\n                            \"machine_state (trans_state t s) = machine_state s\"\n                            \"interrupt_irq_node (trans_state t s) = interrupt_irq_node s\"\n                           \"interrupt_states (trans_state t s) = interrupt_states s\"\n                            \"arch_state (trans_state t s) = arch_state s\"\n                            \"exst (trans_state t s) = (t (exst s))\"\n                            \"exst (trans_state (\\<lambda>_. e) s) = e\"\n  apply (simp add: trans_state_def)+\n  done\n\nlemma trans_state_update[simp]:\n \"trans_state t (kheap_update f s) = kheap_update f (trans_state t s)\"\n \"trans_state t (cdt_update g s) = cdt_update g (trans_state t s)\"\n \"trans_state t (is_original_cap_update h s) = is_original_cap_update h (trans_state t s)\"\n \"trans_state t (cur_thread_update i s) = cur_thread_update i (trans_state t s)\"\n \"trans_state t (idle_thread_update j s) = idle_thread_update j (trans_state t s)\"\n \"trans_state t (machine_state_update k s) = machine_state_update k (trans_state t s)\"\n \"trans_state t (interrupt_irq_node_update l s) = interrupt_irq_node_update l (trans_state t s)\"\n \"trans_state t (arch_state_update m s) = arch_state_update m (trans_state t s)\"\n \"trans_state t (interrupt_states_update p s) = interrupt_states_update p (trans_state t s)\"\n  apply (simp add: trans_state_def)+\n  done\n\n\nlemma trans_state_update':\n  \"trans_state f = exst_update f\"\n  apply (rule ext)\n  apply simp\n  done\n\nlemma trans_state_update''[simp]:\n  \"trans_state t' (trans_state t s) = trans_state (\\<lambda>e. t' (t e)) s\"\n  apply simp\n  done", "property": "State Transition Properties: The trans_state function preserves various system components, including the kernel heap, capability derivation tree, original capability status, current thread, idle thread, machine state, interrupt IRQ node, interrupt states, and architecture state, while updating the exst (extra state) component according to the provided transformation function.\n\nUpdate Properties: The trans_state function commutes with update functions for various system components, ensuring that the order of updates does not affect the resulting system state.\n\nComposition Property: The trans_state function can be composed with other transformation functions to create a new transformation function that applies the transformations sequentially.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "", "comment": "<"}
{"spec": "abbreviation \"truncate_state \\<equiv> trans_state (\\<lambda>_. ())\"", "property": "State Truncation: Truncate an extended state by discarding all extended information.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "", "comment": "Truncate an extended state of type @{typ \"'a state\"}\n  by effectively throwing away all the @{typ \"'a\"} information.\n"}
{"spec": "text \\<open>\\label{s:det-spec}\n  The deterministic abstract specification tracks the state of the scheduler\nand ordering information about sibling nodes in the CDT.\\<close>", "property": "Deterministic Abstract Specification: Tracks the state of the scheduler and maintains ordering information about sibling nodes in the CDT.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": ""}
{"spec": "datatype scheduler_action =\n    resume_cur_thread\n  | switch_thread (sch_act_target : obj_ref)\n  | choose_new_thread\n\ntype_synonym domain = word8\n\nrecord etcb =\n tcb_priority :: \"priority\"\n tcb_time_slice :: \"nat\"\n tcb_domain :: \"domain\"\n\ndefinition default_priority :: \"priority\" where\n  \"default_priority \\<equiv> minBound\"\n\ndefinition default_domain :: \"domain\" where\n  \"default_domain \\<equiv> minBound\"\n\ndefinition default_etcb :: \"etcb\" where\n  \"default_etcb \\<equiv> \\<lparr>tcb_priority = default_priority, tcb_time_slice = timeSlice, tcb_domain = default_domain\\<rparr>\"\n\ntype_synonym ready_queue = \"obj_ref list\"", "property": "Scheduler State Management: Defines the possible actions for the scheduler, including resuming the current thread, switching to a different thread, or choosing a new thread. The scheduler state also includes the priority, time slice, and domain for each thread, with default values defined for these attributes.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "The current scheduler action,\n  which is part of the scheduling state."}
{"spec": "type_synonym cdt_list = \"cslot_ptr \\<Rightarrow> cslot_ptr list\"\n\ndefinition work_units_limit :: \"machine_word\" where\n  \"work_units_limit = 0x64\"", "property": "CDT Sibling Node Ordering: Maintain an ordered list of child nodes for each entry in the Capability Derivation Tree (CDT), ensuring a consistent and predictable ordering of sibling nodes.\nWork Units Limit: Establish a maximum limit for work units, set to 0x64.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  For each entry in the CDT, we record an ordered list of its children.\n  This encodes the order of sibling nodes in the CDT.\n"}
{"spec": "record det_ext =\n   work_units_completed_internal :: \"machine_word\"\n   scheduler_action_internal :: scheduler_action\n   ekheap_internal :: \"obj_ref \\<Rightarrow> etcb option\"\n   domain_list_internal :: \"(domain \\<times> machine_word) list\"\n   domain_index_internal :: nat\n   cur_domain_internal :: domain\n   domain_time_internal :: \"machine_word\"\n   ready_queues_internal :: \"domain \\<Rightarrow> priority \\<Rightarrow> ready_queue\"\n   cdt_list_internal :: cdt_list", "property": "Extended State: The abstract specification maintains an extended state that includes various internal components, such as work units completed, scheduler actions, an extended kernel heap, domain lists, domain indices, current domains, domain times, ready queues, and a current domain tree list. \n\nSubproperties:\n- Work Units Completed: Tracks the number of work units completed.\n- Scheduler Action: Maintains the current scheduler action.\n- Extended Kernel Heap: Manages the extended kernel heap with object references and extended thread control blocks.\n- Domain List: Keeps a list of domains with their corresponding machine words.\n- Domain Index: Maintains the current domain index.\n- Current Domain: Tracks the current domain.\n- Domain Time: Manages the time spent in each domain.\n- Ready Queues: Maintains ready queues for each domain and priority.\n- Current Domain Tree List: Manages the current domain tree list.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  The extended state of the deterministic abstract specification.\n"}
{"spec": "type_synonym det_state = \"det_ext state\"", "property": "Abstract State Extension: The deterministic abstract specification extends the abstract state with a record of type det_ext.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  The state of the deterministic abstract specification extends the\n  abstract state with the @{typ det_ext} record.\n"}
{"spec": "abbreviation\n  \"work_units_completed (s::det_state) \\<equiv> work_units_completed_internal (exst s)\"\n\nabbreviation\n  \"work_units_completed_update f (s::det_state) \\<equiv>  trans_state (work_units_completed_internal_update f) s\"\n\nabbreviation\n  \"scheduler_action (s::det_state) \\<equiv> scheduler_action_internal (exst s)\"\n\nabbreviation\n  \"scheduler_action_update f (s::det_state) \\<equiv>  trans_state (scheduler_action_internal_update f) s\"\n\nabbreviation\n  \"ekheap (s::det_state) \\<equiv> ekheap_internal (exst s)\"\n\nabbreviation\n  \"ekheap_update f (s::det_state) \\<equiv> trans_state (ekheap_internal_update f) s\"\n\nabbreviation\n  \"domain_list (s::det_state) \\<equiv> domain_list_internal (exst s)\"\n\nabbreviation\n  \"domain_list_update f (s::det_state) \\<equiv> trans_state (domain_list_internal_update f) s\"\n\nabbreviation\n  \"domain_index (s::det_state) \\<equiv> domain_index_internal (exst s)\"\n\nabbreviation\n  \"domain_index_update f (s::det_state) \\<equiv> trans_state (domain_index_internal_update f) s\"\n\nabbreviation\n  \"cur_domain (s::det_state) \\<equiv> cur_domain_internal (exst s)\"\n\nabbreviation\n  \"cur_domain_update f (s::det_state) \\<equiv> trans_state (cur_domain_internal_update f) s\"\n\nabbreviation\n  \"domain_time (s::det_state) \\<equiv> domain_time_internal (exst s)\"\n\nabbreviation\n  \"domain_time_update f (s::det_state) \\<equiv> trans_state (domain_time_internal_update f) s\"\n\nabbreviation\n  \"ready_queues (s::det_state) \\<equiv> ready_queues_internal (exst s)\"\n\nabbreviation\n  \"ready_queues_update f (s::det_state) \\<equiv> trans_state (ready_queues_internal_update f) s\"\n\nabbreviation\n  \"cdt_list (s::det_state) \\<equiv> cdt_list_internal (exst s)\"\n\nabbreviation\n  \"cdt_list_update f (s::det_state) \\<equiv> trans_state (cdt_list_internal_update f) s\"\n\ntype_synonym 'a det_ext_monad = \"(det_state,'a) nondet_monad\"", "property": "Extended State Accessors and Updates: Provide functions to access and update various components of the extended state in the deterministic abstract specification, including work units completed, scheduler action, ekheap, domain list, domain index, current domain, domain time, ready queues, and CDT list. \n\nSubproperties:\n- Work Units Completed Access and Update\n- Scheduler Action Access and Update\n- Ekheap Access and Update\n- Domain List Access and Update\n- Domain Index Access and Update\n- Current Domain Access and Update\n- Domain Time Access and Update\n- Ready Queues Access and Update\n- CDT List Access and Update", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "Accessor and update functions for the extended state of the\n  deterministic abstract specification.\n"}
{"spec": "definition\n  get_etcb :: \"obj_ref \\<Rightarrow> det_state \\<Rightarrow> etcb option\"\nwhere\n  \"get_etcb tcb_ref es \\<equiv> ekheap es tcb_ref\"\n\ndefinition\n  ethread_get :: \"(etcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> 'a det_ext_monad\"\nwhere\n  \"ethread_get f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_etcb tptr;\n     return $ f tcb\n   od\"", "property": "Extended State Access: Provides functions to access and retrieve information from the extended state of the deterministic abstract specification. \n\nGet ETCB: Retrieves the extended thread control block (ETCB) associated with a given object reference from the extended kernel heap. \n\nGet EThread: Retrieves a specific value from the extended thread control block (ETCB) associated with a given object reference.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  Basic monadic functions for operating on the extended state of the\n  deterministic abstract specification.\n"}
{"spec": "definition\n  ethread_get_when :: \"bool \\<Rightarrow> (etcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> 'a det_ext_monad\"\nwhere\n  \"ethread_get_when b f tptr \\<equiv> if b then (ethread_get f tptr) else return undefined\"\n\ndefinition set_eobject :: \"obj_ref \\<Rightarrow> etcb \\<Rightarrow> unit det_ext_monad\"\n  where\n \"set_eobject ptr obj \\<equiv>\n  do es \\<leftarrow> get;\n    ekh \\<leftarrow> return $ (ekheap es)(ptr \\<mapsto> obj);\n    put (es\\<lparr>ekheap := ekh\\<rparr>)\n  od\"\n\ndefinition\n  ethread_set :: \"(etcb \\<Rightarrow> etcb) \\<Rightarrow> obj_ref \\<Rightarrow> unit det_ext_monad\"\nwhere\n  \"ethread_set f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_etcb tptr;\n     set_eobject tptr $ f tcb\n   od\"\n\ndefinition\n  set_scheduler_action :: \"scheduler_action \\<Rightarrow> unit det_ext_monad\" where\n  \"set_scheduler_action action \\<equiv>\n     modify (\\<lambda>es. es\\<lparr>scheduler_action := action\\<rparr>)\"\n\ndefinition\n  thread_set_priority :: \"obj_ref \\<Rightarrow> priority \\<Rightarrow> unit det_ext_monad\" where\n  \"thread_set_priority tptr prio \\<equiv> ethread_set (\\<lambda>tcb. tcb\\<lparr>tcb_priority := prio\\<rparr>) tptr\"\n\ndefinition\n  thread_set_time_slice :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> unit det_ext_monad\" where\n  \"thread_set_time_slice tptr time \\<equiv> ethread_set (\\<lambda>tcb. tcb\\<lparr>tcb_time_slice := time\\<rparr>) tptr\"\n\ndefinition\n  thread_set_domain :: \"obj_ref \\<Rightarrow> domain \\<Rightarrow> unit det_ext_monad\" where\n  \"thread_set_domain tptr domain \\<equiv> ethread_set (\\<lambda>tcb. tcb\\<lparr>tcb_domain := domain\\<rparr>) tptr\"\n\n\ndefinition\n  get_tcb_queue :: \"domain \\<Rightarrow> priority \\<Rightarrow> ready_queue det_ext_monad\" where\n  \"get_tcb_queue d prio \\<equiv> do\n     queues \\<leftarrow> gets ready_queues;\n     return (queues d prio)\n   od\"\n\ndefinition\n  set_tcb_queue :: \"domain \\<Rightarrow> priority \\<Rightarrow> ready_queue \\<Rightarrow> unit det_ext_monad\" where\n  \"set_tcb_queue d prio queue \\<equiv>\n     modify (\\<lambda>es. es\\<lparr> ready_queues :=\n      (\\<lambda>d' p. if d' = d \\<and> p = prio then queue else ready_queues es d' p)\\<rparr>)\"\n\n\ndefinition\n  tcb_sched_action :: \"(obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list) \\<Rightarrow> obj_ref  \\<Rightarrow> unit det_ext_monad\" where\n  \"tcb_sched_action action thread \\<equiv> do\n     d \\<leftarrow> ethread_get tcb_domain thread;\n     prio \\<leftarrow> ethread_get tcb_priority thread;\n     queue \\<leftarrow> get_tcb_queue d prio;\n     set_tcb_queue d prio (action thread queue)\n   od\"\n\ndefinition\n  tcb_sched_enqueue :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list\" where\n  \"tcb_sched_enqueue thread queue \\<equiv> if (thread \\<notin> set queue) then thread # queue else queue\"\n\ndefinition\n  tcb_sched_append :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list\" where\n  \"tcb_sched_append thread queue \\<equiv> if (thread \\<notin> set queue) then queue @ [thread] else queue\"\n\ndefinition\n  tcb_sched_dequeue :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list\" where\n  \"tcb_sched_dequeue thread queue \\<equiv> filter (\\<lambda>x. x \\<noteq> thread) queue\"\n\n\ndefinition reschedule_required :: \"unit det_ext_monad\" where\n  \"reschedule_required \\<equiv> do\n     action \\<leftarrow> gets scheduler_action;\n     case action of switch_thread t \\<Rightarrow> tcb_sched_action (tcb_sched_enqueue) t | _ \\<Rightarrow> return ();\n     set_scheduler_action choose_new_thread\n   od\"\n\ndefinition\n  possible_switch_to :: \"obj_ref \\<Rightarrow> unit det_ext_monad\" where\n  \"possible_switch_to target \\<equiv> do\n     cur_dom \\<leftarrow> gets cur_domain;\n     target_dom \\<leftarrow> ethread_get tcb_domain target;\n     action \\<leftarrow> gets scheduler_action;\n\n     if (target_dom \\<noteq> cur_dom) then\n       tcb_sched_action tcb_sched_enqueue target\n     else if (action \\<noteq> resume_cur_thread) then\n       do\n         reschedule_required;\n         tcb_sched_action tcb_sched_enqueue target\n       od\n     else\n       set_scheduler_action $ switch_thread target\n   od\"\n\ndefinition\n  next_domain :: \"unit det_ext_monad\" where\n  \"next_domain \\<equiv>\n    modify (\\<lambda>s.\n      let domain_index' = (domain_index s + 1) mod length (domain_list s) in\n      let next_dom = (domain_list s)!domain_index'\n      in s\\<lparr> domain_index := domain_index',\n            cur_domain := fst next_dom,\n            domain_time := snd next_dom,\n            work_units_completed := 0\\<rparr>)\"\n\ndefinition\n  dec_domain_time :: \"unit det_ext_monad\" where\n  \"dec_domain_time = modify (\\<lambda>s. s\\<lparr>domain_time := domain_time s - 1\\<rparr>)\"\n\ndefinition set_cdt_list :: \"cdt_list \\<Rightarrow> (det_state, unit) nondet_monad\" where\n  \"set_cdt_list t \\<equiv> do\n    s \\<leftarrow> get;\n    put $ s\\<lparr> cdt_list := t \\<rparr>\n  od\"\n\ndefinition\n  update_cdt_list :: \"(cdt_list \\<Rightarrow> cdt_list) \\<Rightarrow> (det_state, unit) nondet_monad\"\nwhere\n  \"update_cdt_list f \\<equiv> do\n     t \\<leftarrow> gets cdt_list;\n     set_cdt_list (f t)\n  od\"", "property": "Nondeterministic Abstract Specification: Provides a set of abstract operations for managing threads, scheduling, and domains in a nondeterministic manner, ensuring that the system's behavior is correctly specified and constrained.\n\nThread Management: Allows for getting and setting thread properties (priority, time slice, domain), and performing scheduling actions (enqueue, dequeue, append) on threads.\n\nScheduling: Specifies rescheduling requirements, possible thread switches, and domain management (next domain, decrement domain time).\n\nDomain Management: Manages the domain list, updates the current domain, and sets the domain time.\n\nCapability Management: Updates the CDT list, allowing for the modification of capability delegations.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": " For infoflow, we want to avoid certain read actions, such as reading the priority of the\n   current thread when it could be idle. Then we need to make sure we do not rely on the result.\n   undefined is the closest we have to a result that can't be relied on "}
{"spec": "definition next_child :: \"cslot_ptr \\<Rightarrow> cdt_list \\<Rightarrow> cslot_ptr option\" where\n  \"next_child slot t \\<equiv> case (t slot) of [] \\<Rightarrow> None |\n                                        x # xs \\<Rightarrow> Some x\"\n\ndefinition next_sib :: \"cslot_ptr \\<Rightarrow> cdt_list \\<Rightarrow> cdt \\<Rightarrow> cslot_ptr option\" where\n  \"next_sib slot t m \\<equiv> case m slot of None \\<Rightarrow> None |\n                       Some p \\<Rightarrow> after_in_list (t p) slot\"\n\n\nfunction (domintros) next_not_child :: \"cslot_ptr \\<Rightarrow> cdt_list \\<Rightarrow> cdt \\<Rightarrow> cslot_ptr option\" where\n  \"next_not_child slot t m = (if next_sib slot t m = None\n                             then (case m slot of\n                               None \\<Rightarrow> None |\n                               Some p \\<Rightarrow> next_not_child p t m)\n                             else next_sib slot t m)\"\n  by auto", "property": "CDT Traversal: Traverse the abstract representation of the Capability Derivation Tree (CDT) to yield corresponding information, specifically the next child, sibling, or non-child node in the tree. \n\nSubproperties:\n- Next Child: Given a slot and a CDT list, return the next child node in the tree, if it exists.\n- Next Sibling: Given a slot, a CDT list, and a CDT, return the next sibling node in the tree, if it exists.\n- Next Non-Child: Given a slot, a CDT list, and a CDT, return the next non-child node in the tree, traversing up the tree if necessary.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "The CDT in the implementation is stored in prefix traversal order.\n  The following functions traverse its abstract representation here to\n  yield corresponding information.\n"}
{"spec": "definition next_slot :: \"cslot_ptr \\<Rightarrow> cdt_list \\<Rightarrow> cdt \\<Rightarrow> cslot_ptr option\" where\n  \"next_slot slot t m \\<equiv> if t slot \\<noteq> []\n                        then next_child slot t\n                        else next_not_child slot t m\"", "property": "CDT Traversal: Traverse the capability derivation tree (CDT) to find the next slot, prioritizing child nodes and then siblings or ancestors.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": " next_slot traverses the cdt, replicating mdb_next in the Haskell spec.\n        The cdt is traversed child first, by next_child\n        going to a nodes first child when it exists,\n        otherwise next_not_child looks up the tree until it finds\n        a new node to visit as a sibling of its self or some ancestor "}
{"spec": "definition max_non_empty_queue :: \"(priority \\<Rightarrow> ready_queue) \\<Rightarrow> ready_queue\" where\n  \"max_non_empty_queue queues \\<equiv> queues (Max {prio. queues prio \\<noteq> []})\"\n\n\ndefinition default_ext :: \"apiobject_type \\<Rightarrow> domain \\<Rightarrow> etcb option\" where\n  \"default_ext type cdom \\<equiv>\n      case type of TCBObject \\<Rightarrow> Some (default_etcb\\<lparr>tcb_domain := cdom\\<rparr>)\n                         | _ \\<Rightarrow> None\"\n\ndefinition retype_region_ext :: \"obj_ref list \\<Rightarrow> apiobject_type \\<Rightarrow> unit det_ext_monad\" where\n  \"retype_region_ext ptrs type \\<equiv>  do\n                                     ekh \\<leftarrow> gets ekheap;\n                                     cdom \\<leftarrow> gets cur_domain;\n                                     ekh' \\<leftarrow> return $ foldr (\\<lambda>p ekh. (ekh(p := default_ext type cdom))) ptrs ekh;\n                                     modify (\\<lambda>s. s\\<lparr>ekheap := ekh'\\<rparr>)\n                                  od\"\n\ndefinition cap_swap_ext where\n\"cap_swap_ext \\<equiv> (\\<lambda> slot1 slot2 slot1_op slot2_op.\n      do\n       update_cdt_list (\\<lambda>list. list(slot1 := list slot2, slot2 := list slot1));\n       update_cdt_list\n        (\\<lambda>list. case if slot2_op = Some slot1 then Some slot2\n                     else if slot2_op = Some slot2 then Some slot1 else slot2_op of\n                None \\<Rightarrow> (case if slot1_op = Some slot1 then Some slot2\n                            else if slot1_op = Some slot2 then Some slot1 else slot1_op of\n                       None \\<Rightarrow> list\n                       | Some slot2_p \\<Rightarrow> list(slot2_p := list_replace (list slot2_p) slot1 slot2))\n                | Some slot1_p \\<Rightarrow>\n                    (case if slot1_op = Some slot1 then Some slot2\n                         else if slot1_op = Some slot2 then Some slot1 else slot1_op of\n                    None \\<Rightarrow> list(slot1_p := list_replace (list slot1_p) slot2 slot1)\n                    | Some slot2_p \\<Rightarrow>\n                        if slot1_p = slot2_p\n                        then list(slot1_p := list_swap (list slot1_p) slot1 slot2)\n                        else list(slot1_p := list_replace (list slot1_p) slot2 slot1,\n                                  slot2_p := list_replace (list slot2_p) slot1 slot2)))\n    od)\"\n\ndefinition cap_move_ext where\n\"cap_move_ext \\<equiv> (\\<lambda> src_slot dest_slot src_p dest_p.\n do\n\n    update_cdt_list (\\<lambda>list. case (dest_p) of\n      None \\<Rightarrow> list |\n      Some p \\<Rightarrow> list (p := list_remove (list p) dest_slot));\n\n   if (src_slot = dest_slot) then return () else\n\n    (do\n    update_cdt_list (\\<lambda>list. case (src_p) of\n      None \\<Rightarrow> list |\n      Some p \\<Rightarrow> list (p := list_replace (list p) src_slot dest_slot));\n\n    update_cdt_list (\\<lambda>list. list (src_slot := [], dest_slot := (list src_slot) @ (list dest_slot)))\n    od)\n\n  od)\"\n\n\ndefinition cap_insert_ext where\n\"cap_insert_ext \\<equiv> (\\<lambda> src_parent src_slot dest_slot src_p dest_p.\n do\n\n update_cdt_list (\\<lambda>list. case (dest_p) of\n      None \\<Rightarrow> list |\n      Some p \\<Rightarrow> (list (p := list_remove (list p) dest_slot)));\n\n    update_cdt_list (\\<lambda>list. case (src_p) of\n      None \\<Rightarrow> list (\n        src_slot := if src_parent then [dest_slot] @ (list src_slot) else list src_slot) |\n      Some p \\<Rightarrow> list (\n        src_slot := if src_parent then [dest_slot] @ (list src_slot) else list src_slot,\n        p := if (src_parent \\<and> p \\<noteq> src_slot) then (list p) else if (src_slot \\<noteq> dest_slot) then (list_insert_after (list p) src_slot dest_slot) else (dest_slot # (list p))))\n od)\"\n\ndefinition empty_slot_ext where\n\"empty_slot_ext \\<equiv> (\\<lambda> slot slot_p.\n\n    update_cdt_list (\\<lambda>list. case slot_p of None \\<Rightarrow> list (slot := []) |\n      Some p \\<Rightarrow> if (p = slot) then list(p := list_remove (list p) slot) else list (p := list_replace_list (list p) slot (list slot), slot := [])))\"\n\ndefinition create_cap_ext where\n\"create_cap_ext \\<equiv> (\\<lambda> untyped dest dest_p. do\n\n    update_cdt_list (\\<lambda>list. case dest_p of\n      None \\<Rightarrow> list |\n      Some p \\<Rightarrow> (list (p := list_remove (list p) dest)));\n\n    update_cdt_list (\\<lambda>list. list (untyped := [dest] @ (list untyped)))\n  od)\"\n\ndefinition next_revoke_cap where\n\"next_revoke_cap \\<equiv> (\\<lambda>slot ext. the (next_child slot (cdt_list ext)))\"\n\ndefinition\n  free_asid_select :: \"(asid_high_index \\<rightharpoonup> 'a) \\<Rightarrow> asid_high_index\"\nwhere\n  \"free_asid_select \\<equiv> \\<lambda>asid_table. fst (hd (filter (\\<lambda>(x,y). x \\<le> 2 ^ asid_high_bits - 1 \\<and> y = None) (assocs asid_table)))\"\n\ndefinition\n  free_asid_pool_select :: \"(asid_low_index \\<rightharpoonup> 'a) \\<Rightarrow> asid \\<Rightarrow> asid_low_index\"\nwhere\n  \"free_asid_pool_select \\<equiv> (\\<lambda>pool base.\n     fst (hd ((filter (\\<lambda> (x,y). ucast x + base \\<noteq> 0 \\<and> y = None) (assocs pool)))))\"\n\ndefinition update_work_units where\n  \"update_work_units \\<equiv>\n     modify (\\<lambda>s. s\\<lparr>work_units_completed := work_units_completed s + 1\\<rparr>)\"\n\ndefinition reset_work_units where\n  \"reset_work_units \\<equiv>\n     modify (\\<lambda>s. s\\<lparr>work_units_completed := 0\\<rparr>)\"\n\ndefinition work_units_limit_reached where\n  \"work_units_limit_reached \\<equiv> do\n     work_units \\<leftarrow> gets work_units_completed;\n     return (work_units_limit \\<le> work_units)\n   od\"", "property": "Extended Operations: Provides a set of operations for managing kernel resources, including retyping memory regions, swapping and moving capabilities, inserting and removing capabilities, and managing work units. These operations ensure that the kernel's internal state remains consistent and that resources are allocated and deallocated correctly.\n\nSubproperties:\n- Memory Region Management: Allows for retyping memory regions to support the creation of new kernel objects.\n- Capability Management: Provides operations for swapping, moving, inserting, and removing capabilities to manage the kernel's capability hierarchy.\n- Work Unit Management: Tracks and manages work units to prevent excessive resource consumption and ensure efficient kernel operation.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\\emph{Extended operations} for the deterministic abstract specification."}
{"spec": "class state_ext =\n fixes unwrap_ext :: \"'a state \\<Rightarrow> det_ext state\"\n fixes wrap_ext :: \"(det_ext \\<Rightarrow> det_ext) \\<Rightarrow> ('a \\<Rightarrow> 'a)\"\n fixes wrap_ext_op :: \"unit det_ext_monad \\<Rightarrow> ('a state,unit) nondet_monad\"\n fixes wrap_ext_bool :: \"bool det_ext_monad \\<Rightarrow> ('a state,bool) nondet_monad\"\n fixes select_switch :: \"'a \\<Rightarrow> bool\"\n fixes ext_init :: \"'a\"\n\ndefinition detype_ext :: \"obj_ref set \\<Rightarrow> 'z::state_ext \\<Rightarrow> 'z\" where\n \"detype_ext S \\<equiv> wrap_ext (\\<lambda>s. s\\<lparr>ekheap_internal := (\\<lambda>x. if x \\<in> S then None else ekheap_internal s x)\\<rparr>)\"\n\ninstantiation  det_ext_ext :: (type) state_ext\nbegin\n\ndefinition \"unwrap_ext_det_ext_ext == (\\<lambda>x. x) :: det_ext state \\<Rightarrow> det_ext state\"\n\ndefinition \"wrap_ext_det_ext_ext == (\\<lambda>x. x) ::\n  (det_ext \\<Rightarrow> det_ext) \\<Rightarrow> det_ext \\<Rightarrow> det_ext\"\n\ndefinition \"wrap_ext_op_det_ext_ext == (\\<lambda>x. x) ::\n  (det_ext state \\<Rightarrow> ((unit \\<times> det_ext state) set) \\<times> bool)\n  \\<Rightarrow> det_ext state  \\<Rightarrow> ((unit \\<times> det_ext state) set) \\<times> bool\"\n\ndefinition \"wrap_ext_bool_det_ext_ext == (\\<lambda>x. x) ::\n  (det_ext state \\<Rightarrow> ((bool \\<times> det_ext state) set) \\<times> bool)\n  \\<Rightarrow> det_ext state \\<Rightarrow> ((bool \\<times> det_ext state) set) \\<times> bool\"\n\ndefinition \"select_switch_det_ext_ext == (\\<lambda>_. True)  :: det_ext\\<Rightarrow> bool\"", "property": "State Extension Abstraction: Provides an abstract interface for state extensions, allowing for different instantiations such as deterministic and nondeterministic abstract specifications. It defines a set of functions for wrapping and unwrapping state extensions, handling nondeterministic operations, and selecting switches.\n\nDetype Extension: Detype a set of objects in the state extension, effectively removing their type information.\n\nDeterministic Extension Instantiation: Provides a concrete instantiation of the state extension abstraction for deterministic extensions, where the wrapping and unwrapping functions are identity functions, and the select switch is always true.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  A type class for all instantiations of the abstract specification. In\n  practice, this is restricted to basically allow only two sensible\n  implementations at present: the deterministic abstract specification and\n  the nondeterministic one.\n"}
{"spec": "definition \"ext_init_det_ext_ext \\<equiv>\n     \\<lparr>work_units_completed_internal = 0,\n      scheduler_action_internal = resume_cur_thread,\n      ekheap_internal = Map.empty (idle_thread_ptr \\<mapsto> default_etcb),\n      domain_list_internal = [(0,15)],\n      domain_index_internal = 0,\n      cur_domain_internal = 0,\n      domain_time_internal = 15,\n      ready_queues_internal = const (const []),\n      cdt_list_internal = const []\\<rparr> :: det_ext\"\n\ninstance ..\n\nend", "property": "Nondeterministic Abstract Specification Initialization: Initializes the deterministic extension with default values, including work units completed, scheduler action, ekheap, domain list, domain index, current domain, domain time, ready queues, and CDT list. \n\nSubproperties:\n- Work Units Completed: Set to 0.\n- Scheduler Action: Set to resume the current thread.\n- Ekheap: Initialized with an empty map containing the idle thread pointer mapped to the default ETCB.\n- Domain List: Set to a list containing a single domain with index 0 and 15 time units.\n- Domain Index: Set to 0.\n- Current Domain: Set to 0.\n- Domain Time: Set to 15.\n- Ready Queues: Initialized with empty lists for all priorities.\n- CDT List: Initialized with empty lists for all objects.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": " this probably doesn't satisfy the invariants "}
{"spec": "text \\<open>\\label{s:nondet-spec}\nThe nondeterministic abstract specification instantiates the extended state\nwith the unit type -- i.e. it doesn't have any meaningful extended state.\n\\<close>\n\ninstantiation unit :: state_ext\nbegin\n\n\ndefinition \"unwrap_ext_unit == (\\<lambda>_. undefined) :: unit state \\<Rightarrow> det_ext state\"\n\ndefinition \"wrap_ext_unit == (\\<lambda>f s. ()) :: (det_ext \\<Rightarrow> det_ext) \\<Rightarrow> unit \\<Rightarrow> unit\"\n\n\ndefinition \"wrap_ext_op_unit == (\\<lambda>m. return ()) ::\n  (det_ext state \\<Rightarrow> ((unit \\<times> det_ext state) set) \\<times> bool) \\<Rightarrow> unit state \\<Rightarrow> ((unit \\<times> unit state) set) \\<times> bool\"\n\ndefinition \"wrap_ext_bool_unit == (\\<lambda>m. select UNIV) ::\n  (det_ext state \\<Rightarrow> ((bool \\<times> det_ext state ) set) \\<times> bool) \\<Rightarrow> unit state \\<Rightarrow> ((bool \\<times> unit state) set) \\<times> bool\"\n\ndefinition \"select_switch_unit == (\\<lambda>s. False) :: unit \\<Rightarrow> bool\"\n\ndefinition \"ext_init_unit \\<equiv> () :: unit\"\n\ninstance ..\n\nend", "property": "Nondeterministic Abstract Specification: Provides an abstract specification for nondeterministic behavior, instantiating the extended state with the unit type, effectively ignoring any meaningful extended state. \n\nUnit State Instantiation: Defines the unwrap, wrap, and wrap operations for the unit state, ensuring compatibility with the abstract specification. \n\nNondeterministic Operations: Specifies the behavior of nondeterministic operations, such as select and switch, in the context of the unit state.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": ""}
{"spec": "lemmas ext_init_def = ext_init_det_ext_ext_def ext_init_unit_def\n\ndefinition OR_choice :: \"bool det_ext_monad \\<Rightarrow> ('z::state_ext state,'a) nondet_monad \\<Rightarrow> ('z state,'a) nondet_monad \\<Rightarrow> ('z state,'a) nondet_monad\" where\n\"OR_choice c f g \\<equiv>\n  do\n    ex \\<leftarrow> get;\n    (rv,_) \\<leftarrow> select_f (mk_ef ((wrap_ext_bool c) ex));\n    if rv then f else g\n  od\"\n\ndefinition OR_choiceE :: \"bool det_ext_monad \\<Rightarrow> ('z::state_ext state,'e + 'a) nondet_monad \\<Rightarrow> ('z state,'e + 'a) nondet_monad \\<Rightarrow> ('z state,'e + 'a) nondet_monad\" where\n\"OR_choiceE c f g \\<equiv>\n  doE\n    ex \\<leftarrow> liftE get;\n    (rv,_) \\<leftarrow> liftE $ select_f (mk_ef ((wrap_ext_bool c) ex));\n    if rv then f else g\n  odE\"", "property": "Nondeterministic Choice: Run an extended operation to choose between two computations without modifying the extended state. \n\nSubproperties:\n- Get the current extended state.\n- Use the extended operation to select a boolean value based on the current state.\n- Choose between two computations based on the selected boolean value.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "Run an extended operation over the extended state without\n  modifying it and use the return value to choose between two computations\n  to run.\n"}
{"spec": "definition do_extended_op :: \"unit det_ext_monad \\<Rightarrow> ('z::state_ext state,unit) nondet_monad\" where\n \"do_extended_op eop \\<equiv> do\n                         ex \\<leftarrow> get;\n                         (_,es') \\<leftarrow> select_f (mk_ef ((wrap_ext_op eop) ex));\n                         modify (\\<lambda> state. state\\<lparr>exst := (exst es')\\<rparr>)\n                        od\"", "property": "Extended Operation Execution: Run an extended operation to update the extended state, ignoring any return value, and update the state with the new extended state.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "Run an extended operation over the extended state to update the\n  extended state, ignoring any return value that the extended operation might\n  yield.\n"}
{"spec": "definition select_ext :: \"(det_ext state \\<Rightarrow> 'd) \\<Rightarrow> ('d set) \\<Rightarrow> ('a::state_ext state,'d) nondet_monad\" where\n  \"select_ext a S \\<equiv> do\n                      s \\<leftarrow> get;\n                      x \\<leftarrow> if (select_switch (exst s)) then (return (a (unwrap_ext s)))\n                          else (select S);\n                      assert (x \\<in> S);\n                      return x\n                    od\"", "property": "Nondeterministic Selection: Select a value from a bounding set, either by using the extended state when a switch is enabled or by choosing nondeterministically from the set when the switch is disabled, ensuring the selected value is within the set.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  Use the extended state to choose a value from a bounding set @{term S} when\n  @{term select_switch} is true. Otherwise just select from @{term S}.\n"}
{"spec": "definition valid_list_2 :: \"cdt_list \\<Rightarrow> cdt \\<Rightarrow> bool\" where\n  \"valid_list_2 t m \\<equiv> (\\<forall>p. set (t p) = {c. m c = Some p}) \\<and> (\\<forall>p. distinct (t p))\"\n\nabbreviation valid_list :: \"det_ext state \\<Rightarrow> bool\" where\n  \"valid_list s \\<equiv> valid_list_2 (cdt_list s) (cdt s)\"\n\nend", "property": "Valid List Property: The capability derivation tree (CDT) list is valid if it accurately represents the CDT, with each node's children correctly identified and no duplicates in the list. \n\n Subproperties:\n- Set correspondence: For every node in the CDT, the set of its children in the list matches the children in the actual CDT.\n- Distinctness: All children of each node in the list are distinct, ensuring no duplicates.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "Defined here because it's asserted before empty_slot"}
{"spec": "text \\<open>The original capability created when an object of a given type is\ncreated with a particular address and size.\\<close>\nprimrec\n  default_cap :: \"apiobject_type  \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> cap\"\nwhere\n  \"default_cap CapTableObject oref s _ = CNodeCap oref s []\"\n| \"default_cap Untyped oref s dev = UntypedCap dev oref s 0\"\n| \"default_cap TCBObject oref s _ = ThreadCap oref\"\n| \"default_cap EndpointObject oref s _ = EndpointCap oref 0 UNIV\"\n| \"default_cap NotificationObject oref s _ =\n     NotificationCap oref 0 {AllowRead, AllowWrite}\"\n| \"default_cap (ArchObject aobj) oref s dev = ArchObjectCap (arch_default_cap aobj oref s dev)\"", "property": "Default Capability Creation: Creates the original capability for a newly created object based on its type, address, size, and device status, ensuring that the capability is correctly initialized for the specific object type. \n\nSubproperties:\n- CNode objects are assigned a CNode capability with an empty access control list.\n- Untyped objects are assigned an Untyped capability with a device flag and zero bits of extra information.\n- TCB objects are assigned a Thread capability.\n- Endpoint objects are assigned an Endpoint capability with a badge of zero and all rights.\n- Notification objects are assigned a Notification capability with a badge of zero and read and write rights.\n- Architecture-specific objects are assigned capabilities based on architecture-specific defaults.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": ""}
{"spec": "definition\n  create_cap ::\n  \"apiobject_type \\<Rightarrow> nat \\<Rightarrow> cslot_ptr \\<Rightarrow> bool \\<Rightarrow> cslot_ptr \\<times> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"create_cap type bits untyped is_device \\<equiv> \\<lambda>(dest,oref). do\n    dest_p \\<leftarrow> gets (\\<lambda>s. cdt s dest);\n    cdt \\<leftarrow> gets cdt;\n    set_cdt (cdt (dest \\<mapsto> untyped));\n    do_extended_op (create_cap_ext untyped dest dest_p);\n    set_original dest True;\n    set_cap (default_cap type oref bits is_device) dest\n   od\"", "property": "Create Object Capability: Create and install a new capability for a newly created object, updating the Capability Derivation Tree (CDT) and setting the original capability.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": "Create and install a new capability to a newly created object."}
{"spec": "text \\<open>Properties of an empty CNode object.\\<close>\ndefinition\n  empty_cnode :: \"nat \\<Rightarrow> cnode_contents\" where\n  \"empty_cnode bits \\<equiv> \\<lambda>x. if length x = bits then Some NullCap else None\"", "property": "Empty CNode Properties: An empty CNode object has a fixed bit length and contains only NullCap capabilities, with all other slots being empty.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": ""}
{"spec": "definition\n  default_object :: \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> kernel_object\" where\n  \"default_object api dev n \\<equiv> case api of\n           Untyped \\<Rightarrow> undefined\n         | CapTableObject \\<Rightarrow> CNode n (empty_cnode n)\n         | TCBObject \\<Rightarrow> TCB default_tcb\n         | EndpointObject \\<Rightarrow> Endpoint default_ep\n         | NotificationObject \\<Rightarrow> Notification default_notification\n         | ArchObject aobj \\<Rightarrow> ArchObj (default_arch_object aobj dev n)\"", "property": "Object Creation Defaults: Newly created objects are initialized with default values specific to their type, ensuring a consistent and predictable state for further operations. \n\nSubproperties:\n- CapTableObject: Initialized as a CNode with an empty cnode of a specified size.\n- TCBObject: Initialized as a TCB with default_tcb values.\n- EndpointObject: Initialized as an Endpoint with default_ep values.\n- NotificationObject: Initialized as a Notification with default_notification values.\n- ArchObject: Initialized as an ArchObj with default_arch_object values specific to the architecture, device, and size.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": "The initial state objects of various types are in when created."}
{"spec": "definition\n  obj_bits_api :: \"apiobject_type \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"obj_bits_api type obj_size_bits \\<equiv> case type of\n           Untyped \\<Rightarrow> obj_size_bits\n         | CapTableObject \\<Rightarrow> obj_size_bits + slot_bits\n         | TCBObject \\<Rightarrow> obj_bits (TCB default_tcb)\n         | EndpointObject \\<Rightarrow> obj_bits (Endpoint undefined)\n         | NotificationObject \\<Rightarrow> obj_bits (Notification undefined)\n         | ArchObject aobj \\<Rightarrow> obj_bits $ ArchObj $ default_arch_object aobj False obj_size_bits\"", "property": "Object Size Calculation: Determine the size in bits of objects to be created based on the requested type and size, considering the specific requirements of each object type. \n\nSubproperties:\n- Untyped objects have the requested size.\n- CapTableObjects require additional slot bits.\n- TCBObjects, EndpointObjects, and NotificationObjects have fixed sizes based on their default configurations.\n- ArchObjects' sizes are determined by their specific architecture and default object configurations.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": "The size in bits of the objects that will be created when a given type\nand size is requested."}
{"spec": "text \\<open>\nCreate @{text \"numObjects\"} objects, starting from\n@{text obj_ref}, return of list pointers to them. For some types, each\nreturned pointer points to a group of objects.\n\\<close>\n\ndefinition\n  retype_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> apiobject_type \\<Rightarrow> bool \\<Rightarrow> (obj_ref list,'z::state_ext) s_monad\"\nwhere\n  \"retype_region ptr numObjects o_bits type dev \\<equiv> do\n    obj_size \\<leftarrow> return $ 2 ^ obj_bits_api type o_bits;\n    ptrs \\<leftarrow> return $ map (\\<lambda>p. ptr_add ptr (p * obj_size)) [0..< numObjects];\n    when (type \\<noteq> Untyped) (do\n      kh \\<leftarrow> gets kheap;\n      kh' \\<leftarrow> return $ foldr (\\<lambda>p kh. kh(p \\<mapsto> default_object type dev o_bits)) ptrs kh;\n      do_extended_op (retype_region_ext ptrs type);\n      modify $ kheap_update (K kh')\n    od);\n    return $ ptrs\n  od\"", "property": "Retype Region: Create a specified number of objects of a given type, starting from a provided object reference, and return a list of pointers to these objects. The objects are created with a specified size, and for certain types, each returned pointer points to a group of objects. The kernel heap is updated to reflect the creation of these objects.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Main Retype Implementation", "comment": ""}
{"spec": "abbreviation (input) \"extended_state_update \\<equiv> trans_state\"", "property": "Untyped Capability Invocation: Update the extended state during untyped capability invocations.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": ""}
{"spec": "definition\n  detype :: \"(obj_ref set) \\<Rightarrow> 'z::state_ext state \\<Rightarrow> 'z::state_ext state\" where\n \"detype S s \\<equiv> s \\<lparr> kheap := (\\<lambda>x. if x \\<in> S then None else kheap s x), extended_state := detype_ext S (exst s)\\<rparr>\"", "property": "Detype Operation: Remove objects from a specified region of the heap, updating the kernel heap and extended state accordingly. \n\nSubproperties:\n- Update Kernel Heap: Set the kernel heap to None for the specified region.\n- Update Extended State: Update the extended state by detyping the specified region.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": "Remove objects from a region of the heap."}
{"spec": "definition\n  delete_objects :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"delete_objects ptr bits = do\n     do_machine_op (freeMemory ptr bits);\n     modify (detype {ptr..ptr + 2 ^ bits - 1})\n  od\"\n\ndefinition\n  get_free_ref :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> obj_ref\" where\n  \"get_free_ref base free_index \\<equiv> base +  (of_nat free_index)\"\n\ndefinition\n  get_free_index :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> nat\" where\n  \"get_free_index base free \\<equiv> unat $ (free - base)\"\n\nprimrec(nonexhaustive) is_device_untyped_cap\nwhere\n  \"is_device_untyped_cap (UntypedCap isdev _ _ _) = isdev\"", "property": "Untyped Capability Invocation: Delete objects within a specified region, freeing their memory and detyping the region.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": "Delete objects within a specified region."}
{"spec": "definition\n  reset_untyped_cap :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"reset_untyped_cap src_slot = doE\n  cap \\<leftarrow> liftE $ get_cap src_slot;\n  sz \\<leftarrow> returnOk $ bits_of cap;\n  base \\<leftarrow> returnOk $ obj_ref_of cap;\n  if free_index_of cap = 0\n    then returnOk ()\n  else doE\n    liftE $ delete_objects base sz;\n  dev \\<leftarrow> returnOk $ is_device_untyped_cap cap;\n\n  if dev \\<or> sz < resetChunkBits\n      then liftE $ do\n        unless dev $ do_machine_op $ clearMemory base (2 ^ sz);\n        set_cap (UntypedCap dev base sz 0) src_slot\n      od\n    else mapME_x (\\<lambda>i. doE\n          liftE $ do_machine_op $ clearMemory (base + (of_nat i << resetChunkBits))\n              (2 ^ resetChunkBits);\n          liftE $ set_cap (UntypedCap dev base sz\n              (i * 2 ^ resetChunkBits)) src_slot;\n          preemption_point\n        odE) (rev [i \\<leftarrow> [0 ..< 2 ^ (sz - resetChunkBits)].\n            i * 2 ^ resetChunkBits < free_index_of cap])\n    odE\n  odE\"", "property": "Untyped Capability Reset: Resets an untyped capability by clearing the underlying memory and updating the object level representation, progressively moving the free region pointer back to the start of the newly cleared region. \n\nProgressive Memory Clearing: Clears the memory in chunks, using the `clearMemory` operation, and updates the untyped capability to reflect the new free index. If the capability is a device untyped capability or the size is less than the reset chunk bits, clears the entire memory region at once. Otherwise, clears the memory in chunks and updates the capability after each chunk is cleared.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": "Untyped capabilities note a currently free region. Sometimes this\nregion is reset during a Retype operation. This progressively clears the\nunderlying memory and also the object level representation, moving the free\nregion pointer back to the start of the newly cleared region each time."}
{"spec": "definition\n  invoke_untyped :: \"untyped_invocation \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n\"invoke_untyped ui \\<equiv> case ui\n    of Retype src_slot reset base retype_base new_type obj_sz slots is_device \\<Rightarrow>\ndoE\n  whenE reset $ reset_untyped_cap src_slot;\n  liftE $ do\n\n  cap \\<leftarrow> get_cap src_slot;\n\n  \\<comment> \\<open>Update the untyped cap to track the amount of space used.\\<close>\n  total_object_size \\<leftarrow> return $ (of_nat (length slots) << (obj_bits_api new_type obj_sz));\n  free_ref \\<leftarrow> return $ retype_base + total_object_size;\n  set_cap (UntypedCap is_device base (bits_of cap) (unat (free_ref - base))) src_slot;\n\n  \\<comment> \\<open>Create new objects.\\<close>\n  orefs \\<leftarrow> retype_region retype_base (length slots) obj_sz new_type is_device;\n  init_arch_objects new_type is_device retype_base (length slots) obj_sz orefs;\n  sequence_x (map (create_cap new_type obj_sz src_slot is_device) (zip slots orefs))\nod odE\"\n\nend", "property": "Untyped Capability Invocation: Clears existing objects from a region, creates new objects of the requested type, initializes them, and installs new capabilities to them, while updating the untyped capability to track the amount of space used. \n\nSubproperties:\n- Reset Untyped Capability: Resets the untyped capability if requested.\n- Update Untyped Capability: Updates the untyped capability to reflect the new amount of space used.\n- Create New Objects: Creates new objects in the specified region with the requested type and size.\n- Initialize New Objects: Initializes the newly created objects.\n- Install New Capabilities: Installs new capabilities for the newly created objects.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": "Untyped capabilities confer authority to the Retype method. This\nclears existing objects from a region, creates new objects of the requested type,\ninitialises them and installs new capabilities to them."}
{"spec": "type_synonym ('a,'z) s_monad = \"('z state, 'a) nondet_monad\"", "property": "Basic Kernel Monad: Provides a fundamental execution environment without faults, interrupts, or errors, allowing for nondeterministic operations on the kernel state.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The basic kernel monad without faults, interrupts, or errors."}
{"spec": "type_synonym ('a,'z) f_monad = \"(fault + 'a,'z) s_monad\"\n\nterm \"a::(unit,'a) s_monad\"", "property": "Fault Handling: The fault monad may throw a fault exception, which is typically reported to the current thread's fault handler for handling and resolution.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The fault monad: may throw a @{text fault} exception which\nwill usually be reported to the current thread's fault handler."}
{"spec": "type_synonym ('a,'z) se_monad = \"(syscall_error + 'a,'z) s_monad\"", "property": "Error Handling: The system may throw a syscall_error exception, which will be reported to the current thread as a system call result, allowing for error handling and propagation in the system call execution.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The error monad: may throw a @{text syscall_error} exception\nwhich will usually be reported to the current thread as system call\nresult."}
{"spec": "type_synonym ('a,'z) lf_monad = \"(lookup_failure + 'a,'z) s_monad\"", "property": "Lookup Failure Handling: Allows for the possibility of throwing a lookup failure exception, which can be reported either directly to the current thread or to its fault handler.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The lookup failure monad: may throw a @{text lookup_failure}\nexception. Depending on context it may either be reported directly to\nthe current thread or to its fault handler.\n"}
{"spec": "type_synonym ('a,'z) p_monad = \"(unit + 'a,'z) s_monad\"", "property": "Preemption Monad: May throw an interrupt exception, allowing for preemption of the current execution.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The preemption monad. May throw an interrupt exception."}
{"spec": "translations\n  (type) \"'a s_monad\" <= (type) \"state \\<Rightarrow> (('a \\<times> state) \\<Rightarrow> bool) \\<times> bool\"\n  (type) \"'a f_monad\" <= (type) \"(fault + 'a) s_monad\"\n  (type) \"'a se_monad\" <= (type) \"(syscall_error + 'a) s_monad\"\n  (type) \"'a lf_monad\" <= (type) \"(lookup_failure + 'a) s_monad\"\n  (type) \"'a p_monad\" <=(type) \"(unit + 'a) s_monad\"", "property": "Monad Type Abbreviations: Define concise type abbreviations for various monads, including state, fault, syscall error, lookup failure, and unit plus monads, to simplify notation and improve readability.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "\n  Printing abbreviations for the above types.\n"}
{"spec": "definition\n  without_preemption :: \"('a,'z::state_ext) s_monad \\<Rightarrow> ('a,'z::state_ext) p_monad\"\nwhere without_preemption_def[simp]:\n \"without_preemption \\<equiv> liftE\"", "property": "Non-Preemptible Operations: Ensure that certain operations are executed without preemption, guaranteeing atomicity and preventing interruptions within critical sections of code.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "Perform non-preemptible operations within preemptible blocks."}
{"spec": "definition\n  preemption_point :: \"(unit,'z::state_ext) p_monad\" where\n \"preemption_point \\<equiv> doE liftE $ do_extended_op update_work_units;\n                         OR_choiceE (work_units_limit_reached)\n                           (doE liftE $ do_extended_op reset_work_units;\n                                irq_opt \\<leftarrow> liftE $ do_machine_op (getActiveIRQ True);\n                                case_option (returnOk ()) (K (throwError $ ())) irq_opt\n                           odE) (returnOk ())\n                     odE\"", "property": "Preemption Point: Allow preemption to occur by updating work units and checking if the work units limit has been reached. If the limit is reached, reset the work units and potentially handle an active IRQ, otherwise continue execution.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "Allow preemption at this point."}
{"spec": "definition\n  cap_fault_on_failure :: \"obj_ref \\<Rightarrow> bool \\<Rightarrow> ('a,'z::state_ext) lf_monad \\<Rightarrow> ('a,'z::state_ext) f_monad\" where\n \"cap_fault_on_failure cptr rp m \\<equiv> handleE' m (throwError \\<circ> CapFault cptr rp)\"\n\ndefinition\n  lookup_error_on_failure ::  \"bool \\<Rightarrow> ('a,'z::state_ext) lf_monad \\<Rightarrow> ('a,'z::state_ext) se_monad\" where\n \"lookup_error_on_failure s m \\<equiv> handleE' m (throwError \\<circ> FailedLookup s)\"\n\ndefinition\n  null_cap_on_failure :: \"(cap,'z::state_ext) lf_monad \\<Rightarrow> (cap,'z::state_ext) s_monad\" where\n \"null_cap_on_failure \\<equiv> liftM (case_sum (\\<lambda>x. NullCap) id)\"\n\ndefinition\n  unify_failure :: \"('f + 'a,'z::state_ext) s_monad \\<Rightarrow> (unit + 'a,'z::state_ext) s_monad\" where\n \"unify_failure m \\<equiv> handleE' m (\\<lambda>x. throwError ())\"\n\ndefinition\n  empty_on_failure :: \"('f + 'a list,'z::state_ext) s_monad \\<Rightarrow> ('a list,'z::state_ext) s_monad\" where\n \"empty_on_failure m \\<equiv> m <catch> (\\<lambda>x. return [])\"\n\ndefinition\n  const_on_failure :: \"'a \\<Rightarrow> ('f + 'a,'z::state_ext) s_monad \\<Rightarrow> ('a,'z::state_ext) s_monad\" where\n \"const_on_failure c m \\<equiv> m <catch> (\\<lambda>x. return c)\"", "property": "Error Handling Conversions: Convert errors from one kind of exception monad to another, handling failures by converting them into various other kinds of errors or return values, such as capability faults, lookup errors, null capabilities, unified failures, empty lists, or constant values. \n\nSubproperties:\n- Capability Fault Conversion: Convert errors into capability faults.\n- Lookup Error Conversion: Convert errors into lookup errors.\n- Null Capability Conversion: Convert errors into null capabilities.\n- Unified Failure Conversion: Convert errors into unified failures.\n- Empty List Conversion: Convert errors into empty lists.\n- Constant Value Conversion: Convert errors into constant values.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "Lift one kind of exception monad into another by converting the error\ninto various other kinds of error or return value."}
{"spec": "definition\n  range_check :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"range_check v min_v max_v \\<equiv>\n    unlessE (v \\<ge> min_v \\<and> v \\<le> max_v) $ throwError $ RangeError min_v max_v\"\n\nend", "property": "Range Check: Verifies that a given value falls within a specified range (inclusive) defined by a minimum and maximum value.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "Checks whether first argument is between second and third (inclusive)."}
{"spec": "text\\<open>The @{term syscall} operation generically describes the usual\nexecution of system calls in three phases, where the first phase may\nresult in a fault, the second phase may result in an error and the third\nphase may be interrupted. The first two phases are used for argument decoding\nand checking. The last phase commits and executes the system call.\n\nThe @{term syscall} operation has five arguments:\n\\begin{itemize}\n\\item the first operation @{text m_fault} to execute, that may\nresult in a fault;\n\\item the fault handler @{text h_fault} to execute if the first\noperation resulted in a fault;\n\\item the second operation @{text m_error} to execute (if no fault\noccurred in the first operation); this second operation may result in\nan error;\n\\item the error handler @{text h_error} to execute if the second\noperation resulted in an error;\n\\item the third and last operation @{text m_finalise} to execute (if\nno error occurred in the second operation); this operation may be\ninterrupted.\n\\end{itemize}\n\\<close>\n\ndefinition\n  syscall :: \"('a,'z::state_ext) f_monad\n                  \\<Rightarrow> (fault \\<Rightarrow> ('c,'z::state_ext) s_monad)\n                  \\<Rightarrow> ('a \\<Rightarrow> ('b,'z::state_ext) se_monad)\n                  \\<Rightarrow> (syscall_error \\<Rightarrow> ('c,'z::state_ext) s_monad)\n               \\<Rightarrow> ('b \\<Rightarrow> ('c,'z::state_ext) p_monad) \\<Rightarrow> ('c,'z::state_ext) p_monad\"\nwhere\n\"syscall m_fault h_fault m_error h_error m_finalise \\<equiv> doE\n    r_fault \\<leftarrow> without_preemption $ m_fault;\n    case r_fault of\n          Inl f \\<Rightarrow>   without_preemption $ h_fault f\n        | Inr a \\<Rightarrow>   doE\n            r_error \\<leftarrow> without_preemption $ m_error a;\n            case r_error of\n                  Inl e \\<Rightarrow>   without_preemption $ h_error e\n                | Inr b \\<Rightarrow>   m_finalise b\n        odE\nodE\"", "property": "System Call Execution: Execute a system call in three phases, handling faults, errors, and interruptions. The first phase may result in a fault, the second phase may result in an error, and the third phase may be interrupted, ensuring robust and reliable system call execution.\n\nSubproperties:\n- Fault Handling: Handle faults occurring in the first phase of system call execution.\n- Error Handling: Handle errors occurring in the second phase of system call execution.\n- Interruption Handling: Handle interruptions occurring in the third phase of system call execution.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "System call entry point", "comment": ""}
{"spec": "text\\<open>The kernel user can perform seven kinds of system calls,\ndescribed by the enumerated type @{term syscall}, defined in \\autoref{s:spec_syscall}.\nThese seven system calls can be categorised into two broad\nfamilies: sending messages and receiving messages, the two main\nservices provided by the kernel.\n\nThe usual case for sending messages (@{text Send} event) consists of the user\nsending a message to an object, without expecting any answer. The sender is\nblocked until the receiver is waiting to receive. In case the\nreceiver is not trusted, an explicit non-blocking send operation can\nbe used (@{text NBSend} event). If a reply is requested from the\nreceiver, the Call operation can be used (@{text Call} event). The Call operation\nwill automatically provide a @{text Reply} capability to the receiver.\n\nAll three sending operations are handled by the @{text\nhandle_invocation} operation, which takes two boolean arguments, one\nto indicate if a reply is requested and the other to indicate if the\nsend is blocking or not.\n\nThe other direction is the reception of messages. This is done by\nperforming a Recv operation on an endpoint kernel object. The receiver\nis then blocked until a sender performs a Send operation on the\nendpoint object, resulting in a message transfer between the sender\nand the receiver. The receiver may also perform a Reply operation\n(@{text Reply} event) in response to a @{text Call}, which is always\nnon-blocking. When the receiver is a user-level server, it generally\nruns a loop waiting for messages. On handling a received message, the\nserver will send a reply and then return to waiting. To avoid\nexcessive switching between user and kernel mode, the kernel provides\na ReplyRecv operation, which is simply a Reply followed by Recv.\n\nFinally, the last event, @{text Yield}, enables the user to donate its\nremaining timeslice.\\<close>", "property": "System Call Operations: Provide kernel services for sending and receiving messages between objects, including blocking and non-blocking send operations, call operations with automatic reply capability provision, and reply operations, as well as yield operations for donating remaining timeslices. \n\nMessage Sending: Allow users to send messages to objects with options for blocking or non-blocking sends and requesting replies. \n\nMessage Receiving: Enable receivers to block until a sender performs a send operation on an endpoint object, resulting in a message transfer, and provide options for replying to calls and yielding remaining timeslices.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "System call entry point", "comment": ""}
{"spec": "fun\n  perform_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"perform_invocation block call (InvokeUntyped i) =\n    doE\n      invoke_untyped i;\n      returnOk []\n    odE\"\n\n| \"perform_invocation block call (InvokeEndpoint ep badge canGrant canGrantReply) =\n    (without_preemption $ do\n       thread \\<leftarrow> gets cur_thread;\n       send_ipc block call badge canGrant canGrantReply thread ep;\n       return []\n     od)\"\n\n| \"perform_invocation block call (InvokeNotification ep badge) =\n    doE\n      without_preemption $ send_signal ep badge;\n      returnOk []\n    odE\"\n\n| \"perform_invocation block call (InvokeTCB i) = invoke_tcb i\"\n\n| \"perform_invocation block call (InvokeDomain tptr d) = invoke_domain tptr d\"\n\n| \"perform_invocation block call (InvokeReply thread slot grant) =\n    liftE (do\n      sender \\<leftarrow> gets cur_thread;\n      do_reply_transfer sender thread slot grant;\n      return []\n    od)\"\n\n| \"perform_invocation block call (InvokeCNode i) =\n    doE\n      invoke_cnode i;\n      returnOk []\n    odE\"\n\n| \"perform_invocation block call (InvokeIRQControl i) =\n   doE\n     invoke_irq_control i;\n     returnOk []\n   odE\"\n\n| \"perform_invocation block call (InvokeIRQHandler i) =\n   doE\n     liftE $ invoke_irq_handler i;\n     returnOk []\n   odE\"\n\n| \"perform_invocation block call (InvokeArchObject i) =\n    arch_perform_invocation i\"\n\n\ndefinition\n  handle_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_invocation calling blocking \\<equiv> doE\n    thread \\<leftarrow> liftE $ gets cur_thread;\n    info \\<leftarrow> without_preemption $ get_message_info thread;\n    ptr \\<leftarrow> without_preemption $ liftM data_to_cptr $\n          as_user thread $ getRegister cap_register;\n    syscall\n      (doE\n         (cap, slot) \\<leftarrow> cap_fault_on_failure (of_bl ptr) False $\n                           lookup_cap_and_slot thread ptr;\n         buffer \\<leftarrow> liftE $ lookup_ipc_buffer False thread;\n         extracaps \\<leftarrow> lookup_extra_caps thread buffer info;\n         returnOk (slot, cap, extracaps, buffer)\n       odE)\n      (\\<lambda>fault. when blocking $ handle_fault thread fault)\n      (\\<lambda>(slot,cap,extracaps,buffer). doE\n            args \\<leftarrow> liftE $ get_mrs thread buffer info;\n            decode_invocation (mi_label info) args ptr slot cap extracaps\n       odE)\n      (\\<lambda>err. when calling $\n            reply_from_kernel thread $ msg_from_syscall_error err)\n      (\\<lambda>oper. doE\n            without_preemption $ set_thread_state thread Restart;\n            reply \\<leftarrow> perform_invocation blocking calling oper;\n            without_preemption $ do\n                state \\<leftarrow> get_thread_state thread;\n                case state of\n                      Restart \\<Rightarrow> do\n                          when calling $\n                              reply_from_kernel thread (0, reply);\n                          set_thread_state thread Running\n                      od\n                    | _ \\<Rightarrow>  return ()\n            od\n       odE)\n  odE\"\n\n\ndefinition\n  handle_yield :: \"(unit,'z::state_ext) s_monad\" where\n  \"handle_yield \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) thread);\n     do_extended_op (tcb_sched_action (tcb_sched_append) thread);\n     do_extended_op (reschedule_required)\n   od\"\n\ndefinition\n  handle_send :: \"bool \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"handle_send bl \\<equiv> handle_invocation False bl\"\n\ndefinition\n  handle_call :: \"(unit,'z::state_ext) p_monad\" where\n \"handle_call \\<equiv> handle_invocation True True\"\n\ndefinition\n  delete_caller_cap :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"delete_caller_cap t \\<equiv> cap_delete_one (t, tcb_cnode_index 3)\"\n\ndefinition\n  handle_recv :: \"bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"handle_recv is_blocking \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n\n     ep_cptr \\<leftarrow> liftM data_to_cptr $ as_user thread $\n                 getRegister cap_register;\n\n     (cap_fault_on_failure (of_bl ep_cptr) True $ doE\n        ep_cap \\<leftarrow> lookup_cap thread ep_cptr;\n\n        let flt = (throwError $ MissingCapability 0)\n        in\n        case ep_cap\n          of EndpointCap ref badge rights \\<Rightarrow>\n             (if AllowRecv \\<in> rights\n              then liftE $ do\n                 delete_caller_cap thread;\n                 receive_ipc thread ep_cap is_blocking\n                od\n              else flt)\n           | NotificationCap ref badge rights \\<Rightarrow>\n             (if AllowRecv \\<in> rights\n              then doE\n                ntfn \\<leftarrow> liftE $ get_notification ref;\n                boundTCB \\<leftarrow> returnOk $ ntfn_bound_tcb ntfn;\n                if boundTCB = Some thread \\<or> boundTCB = None\n                then liftE $ receive_signal thread ep_cap is_blocking\n                else flt\n               odE\n              else flt)\n           | _ \\<Rightarrow> flt\n      odE)\n      <catch> handle_fault thread\n   od\"\n\ndefinition\n  handle_reply :: \"(unit,'z::state_ext) s_monad\" where\n \"handle_reply \\<equiv> do\n    thread \\<leftarrow> gets cur_thread;\n    caller_cap \\<leftarrow> get_cap (thread, tcb_cnode_index 3);\n    case caller_cap of\n      ReplyCap caller False R \\<Rightarrow>\n        do_reply_transfer thread caller (thread, tcb_cnode_index 3) (AllowGrant \\<in> R)\n    | NullCap \\<Rightarrow> return ()\n    | _ \\<Rightarrow> fail\n  od\"", "property": "System Call Handling: Ensure that system calls are handled correctly, including invocation, sending, receiving, and replying. This involves checking the validity of the invocation, decoding arguments, performing the invocation, and handling any faults or errors that may occur.\n\nSubproperties:\n- Invocation Validation: Validate the system call invocation, including checking the validity of the capability address and decoding the arguments.\n- Invocation Performance: Perform the system call invocation, which may involve sending or receiving IPC messages, handling notifications, or invoking TCB operations.\n- Fault Handling: Handle any faults or errors that occur during the system call, including missing capabilities, invalid arguments, or failed operations.\n- Reply Handling: Handle replies to system calls, including transferring data and updating the thread state.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "System call entry point", "comment": "The invocation is made up of three phases. The first phase\ncorresponds to a lookup of capabilities to check that the invocation\nis valid. This phase can result in a fault if a given CSpace address\nis invalid (see the function @{text \"resolve_address_bits\"}). The\nsecond phase is the decoding of the arguments given by the user. This\nis handled by the @{text decode_invocation} operation. This operation\ncan result in an error if, for example, the number of arguments is\nless than required by the operation, or if some argument capability\nhas the wrong type. Finally, the actual invocation is performed, using\nthe @{text perform_invocation} function. Note that this last phase is\npreemptable.\n"}
{"spec": "fun\n  handle_event :: \"event \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_event (SyscallEvent call) =\n   (case call of\n          SysSend \\<Rightarrow> handle_send True\n        | SysNBSend \\<Rightarrow> handle_send False\n        | SysCall \\<Rightarrow> handle_call\n        | SysRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysYield \\<Rightarrow> without_preemption handle_yield\n        | SysReply \\<Rightarrow> without_preemption handle_reply\n        | SysReplyRecv \\<Rightarrow> without_preemption $ do\n            handle_reply;\n            handle_recv True\n          od\n        | SysNBRecv \\<Rightarrow> without_preemption $ handle_recv False)\"\n\n| \"handle_event (UnknownSyscall n) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UnknownSyscallException $ of_nat n;\n    return ()\n  od)\"\n\n| \"handle_event (UserLevelFault w1 w2) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UserException (w1 && mask 32) (w2 && mask 28);\n    return ()\n  od)\"\n\n| \"handle_event Interrupt = (without_preemption $ do\n    active \\<leftarrow> do_machine_op $ getActiveIRQ False;\n    case active of\n       Some irq \\<Rightarrow> handle_interrupt irq\n     | None \\<Rightarrow> return ()\n  od)\"\n\n| \"handle_event (VMFaultEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_vm_fault thread fault_type <catch> handle_fault thread;\n    return ()\n  od)\"\n\n| \"handle_event (HypervisorEvent hypfault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_hypervisor_fault thread hypfault_type\n  od)\"", "property": "Top-level Event Handling: Handle system events, including system calls, unknown system calls, user-level faults, interrupts, VM faults, and hypervisor events, ensuring that each event is processed correctly and securely, with necessary fault handling and potential preemption. \n\nSubproperties:\n- System Call Handling: Handle various system calls, such as sending, receiving, yielding, replying, and receiving with reply, ensuring correct execution and potential preemption.\n- Unknown System Call Handling: Handle unknown system calls by reporting a fault to the current thread.\n- User-Level Fault Handling: Handle user-level faults by reporting the fault to the current thread.\n- Interrupt Handling: Handle interrupts by checking for active IRQs and handling them if present.\n- VM Fault Handling: Handle VM faults by reporting the fault to the current thread and handling potential errors.\n- Hypervisor Event Handling: Handle hypervisor events by reporting the fault to the current thread.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "Top-level event handling", "comment": ""}
{"spec": "text \\<open>\n  This function is the main kernel entry point. The main event loop of the\n  kernel handles events, handles a potential preemption interrupt, schedules\n  and switches back to the active thread.\n\\<close>\n\ndefinition\n  call_kernel :: \"event \\<Rightarrow> (unit,'z::state_ext_sched) s_monad\" where\n  \"call_kernel ev \\<equiv> do\n       handle_event ev <handle>\n           (\\<lambda>_. without_preemption $ do\n                  irq \\<leftarrow> do_machine_op $ getActiveIRQ True;\n                  when (irq \\<noteq> None) $ handle_interrupt (the irq)\n                od);\n       schedule;\n       activate_thread\n   od\"\n\nend", "property": "Kernel Entry Point: The kernel's main entry point handles events, checks for preemption interrupts, schedules, and switches to the active thread, ensuring efficient and controlled execution of system calls. \n\nHandle Event and Interrupt: Handle an event, then check for pending interrupts without preemption, ensuring timely and controlled interrupt handling. \n\nScheduling and Thread Activation: Schedule and activate the next thread, maintaining efficient and controlled thread execution.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "Kernel entry point", "comment": ""}
{"spec": "end", "property": "Unfortunately, you haven't provided any code or comment for me to summarize. Please provide the necessary information, and I'll be happy to help you summarize the property.", "title": "./spec/abstract/Intro_Doc.thy", "chapter": "", "section": "", "comment": "<"}
{"spec": "(*\n Generic functions for invocation labels\n*)\n\nchapter \"Kernel Object Invocations\"\n\ntheory InvocationLabels_A\nimports\n  MiscMachine_A\n  \"ExecSpec.ArchLabelFuns_H\"\nbegin\n\ndefinition\n  invocation_type :: \"data \\<Rightarrow> invocation_label\"\nwhere\n \"invocation_type x \\<equiv> if \\<exists>(v :: invocation_label). fromEnum v = data_to_nat x\n                      then toEnum (data_to_nat x) else GenInvocationLabel InvalidInvocation\"\n\ndefinition\n  gen_invocation_type :: \"data \\<Rightarrow> gen_invocation_labels\"\nwhere\n \"gen_invocation_type x \\<equiv>\n   case invocation_type x of\n     GenInvocationLabel l \\<Rightarrow> l\n   | ArchInvocationLabel _ \\<Rightarrow> InvalidInvocation\"\n\nend", "property": "Invocation Type Determination: Determine the invocation type of a kernel object based on its data value, mapping it to a specific invocation label if it corresponds to a valid enumeration value, and otherwise defaulting to an invalid invocation label. \n\nInvocation Label Extraction: Extract the generic invocation label from a given data value, handling both generic and architecture-specific invocation labels, and defaulting to an invalid invocation if the label is not a generic one.", "title": "./spec/abstract/InvocationLabels_A.thy", "chapter": "Kernel Object Invocations", "section": "", "comment": ""}
{"spec": "definition\n  getActiveTCB :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> tcb option\"\nwhere\n  \"getActiveTCB tcb_ref state \\<equiv>\n   case (get_tcb tcb_ref state)\n     of None           \\<Rightarrow> None\n      | Some tcb       \\<Rightarrow> if (runnable $ tcb_state tcb)\n                         then Some tcb else None\"", "property": "Get Active TCB: Retrieves the TCB at a given address if the thread is in a runnable state. \n\nSubproperties: \n- Returns None if the TCB does not exist at the given address.\n- Returns the TCB if it exists and its state is runnable.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Gets the TCB at an address if the thread can be scheduled."}
{"spec": "definition\n  allActiveTCBs :: \"(obj_ref set,'z::state_ext) s_monad\" where\n  \"allActiveTCBs \\<equiv> do\n    state \\<leftarrow> get;\n    return {x. getActiveTCB x state \\<noteq> None}\n   od\"", "property": "Get All Active Threads: Retrieves the set of all schedulable threads in the system.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Gets all schedulable threads in the system."}
{"spec": "definition\n  switch_to_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"switch_to_thread t \\<equiv> do\n     state \\<leftarrow> get;\n     assert (get_tcb t state \\<noteq> None);\n     arch_switch_to_thread t;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) t);\n     modify (\\<lambda>s. s \\<lparr> cur_thread := t \\<rparr>)\n   od\"", "property": "Thread Switching: Switch the current thread to a specified thread, ensuring the target thread exists and updating the current thread state. \n\nSubproperties:\n- Existence Check: Verify the target thread exists before switching.\n- Architecture-Specific Switching: Perform architecture-specific thread switching actions.\n- Dequeue Target Thread: Dequeue the target thread from the scheduler.\n- Update Current Thread: Update the current thread state to the target thread.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Switches the current thread to the specified one."}
{"spec": "definition guarded_switch_to :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"guarded_switch_to thread \\<equiv> do ts \\<leftarrow> get_thread_state thread;\n                    assert (runnable ts);\n                    switch_to_thread thread\n                 od\"", "property": "Thread Runnability Assertion: Ensure a thread is in a runnable state before switching to it.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Asserts that a thread is runnable before switching to it."}
{"spec": "definition\n  switch_to_idle_thread :: \"(unit,'z::state_ext) s_monad\" where\n  \"switch_to_idle_thread \\<equiv> do\n     thread \\<leftarrow> gets idle_thread;\n     arch_switch_to_idle_thread;\n     modify (\\<lambda>s. s \\<lparr> cur_thread := thread \\<rparr>)\n   od\"\n\nclass state_ext_sched = state_ext +\n  fixes schedule :: \"(unit,'a) s_monad\"\n\ndefinition choose_thread :: \"det_ext state \\<Rightarrow> (unit \\<times> det_ext state) set \\<times> bool\" where\n\"choose_thread \\<equiv>\n      do\n        d \\<leftarrow> gets cur_domain;\n        queues \\<leftarrow> gets (\\<lambda>s. ready_queues s d);\n        if (\\<forall>prio. queues prio = []) then (switch_to_idle_thread)\n        else (guarded_switch_to (hd (max_non_empty_queue queues)))\n      od\"", "property": "Thread Scheduling: Switch to the idle thread when there are no other threads to run, or choose the next thread to run from the ready queues based on priority, ensuring efficient and effective thread scheduling. \n\nSubproperties:\n- Idle Thread Switching: Switch to the idle thread when no other threads are available to run.\n- Priority-Based Thread Selection: Choose the next thread to run from the ready queues based on priority, ensuring efficient thread scheduling.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Switches to the idle thread."}
{"spec": "definition\n  is_highest_prio :: \"domain \\<Rightarrow> priority \\<Rightarrow> det_ext state \\<Rightarrow> bool\"\nwhere\n  \"is_highest_prio d p s \\<equiv>\n    (\\<forall>prio. ready_queues s d prio = [])\n    \\<or> p \\<ge> Max {prio. ready_queues s d prio \\<noteq> []}\"\n\ninstantiation  det_ext_ext :: (type) state_ext_sched\nbegin\n\ndefinition\n  \"schedule_switch_thread_fastfail ct it ct_prio target_prio \\<equiv>\n     if ct \\<noteq> it\n     then return (target_prio < ct_prio)\n     else return True\"\n\ndefinition\n  \"schedule_choose_new_thread \\<equiv> do\n     dom_time \\<leftarrow> gets domain_time;\n     when (dom_time = 0) next_domain;\n     choose_thread;\n     set_scheduler_action resume_cur_thread\n   od\"\n\ndefinition\n  \"schedule_det_ext_ext \\<equiv> do\n     ct \\<leftarrow> gets cur_thread;\n     ct_st \\<leftarrow> get_thread_state ct;\n     ct_runnable \\<leftarrow> return $ runnable ct_st;\n     action \\<leftarrow> gets scheduler_action;\n     (case action\n       of resume_cur_thread \\<Rightarrow> do\n            id \\<leftarrow> gets idle_thread;\n            assert (ct_runnable \\<or> ct = id);\n            return ()\n         od\n       | choose_new_thread \\<Rightarrow> do\n           when ct_runnable (tcb_sched_action tcb_sched_enqueue ct);\n           schedule_choose_new_thread\n         od\n       | switch_thread candidate \\<Rightarrow> do\n           when ct_runnable (tcb_sched_action tcb_sched_enqueue ct);\n\n           it \\<leftarrow> gets idle_thread;\n           target_prio \\<leftarrow> ethread_get tcb_priority candidate;\n\n           \\<comment> \\<open>Infoflow does not like asking about the idle thread's priority or domain.\\<close>\n           ct_prio \\<leftarrow> ethread_get_when (ct \\<noteq> it) tcb_priority ct;\n           \\<comment> \\<open>When to look at the bitmaps. This optimisation is used in the C fast path,\n              but there we know @{text cur_thread} is not idle.\\<close>\n           fastfail \\<leftarrow> schedule_switch_thread_fastfail ct it ct_prio target_prio;\n\n           cur_dom \\<leftarrow> gets cur_domain;\n           highest \\<leftarrow> gets (is_highest_prio cur_dom target_prio);\n           if (fastfail \\<and> \\<not>highest)\n           then do\n               \\<comment> \\<open>Candidate is not best candidate, choose a new thread\\<close>\n               tcb_sched_action tcb_sched_enqueue candidate;\n               set_scheduler_action choose_new_thread;\n               schedule_choose_new_thread\n             od\n           else if (ct_runnable \\<and> ct_prio = target_prio)\n           then do\n               \\<comment> \\<open>Current thread was runnable and candidate is not strictly better\n                  want current thread to run next, so append the candidate to end of queue\n                  and choose again\\<close>\n               tcb_sched_action tcb_sched_append candidate;\n               set_scheduler_action choose_new_thread;\n               schedule_choose_new_thread\n             od\n           else do\n             guarded_switch_to candidate;\n             \\<comment> \\<open>Duplication assists in wp proof under different scheduler actions\\<close>\n             set_scheduler_action resume_cur_thread\n           od\n        od)\n    od\"\n\ninstance ..\nend\n\n\ninstantiation unit :: state_ext_sched\nbegin", "property": "Highest Priority Thread Selection: Determine whether a given priority is the highest among queued ready threads in a given domain, trivially true if no threads are ready.\n\nThread Scheduling: The scheduler chooses the next thread to run based on priority, domain, and runnable state, ensuring that the highest priority thread is selected, and if not, it chooses a new thread or appends the candidate to the end of the queue and chooses again.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "\n  Determine whether given priority is highest among queued ready threads in given domain.\n  Trivially true if no threads are ready."}
{"spec": "definition schedule_unit :: \"(unit,unit) s_monad\" where\n\"schedule_unit \\<equiv> (do\n   cur \\<leftarrow> gets cur_thread;\n   threads \\<leftarrow> allActiveTCBs;\n   thread \\<leftarrow> select threads;\n   (if thread = cur then\n     return () \\<sqinter> switch_to_thread thread\n   else\n     switch_to_thread thread)\n od) \\<sqinter>\n (do\n   cur \\<leftarrow> gets cur_thread;\n   idl \\<leftarrow> gets idle_thread;\n   if idl = cur then\n     return () \\<sqinter> switch_to_idle_thread\n   else switch_to_idle_thread\n  od)\"\n\ninstance ..\nend\n\n\nlemmas schedule_def = schedule_det_ext_ext_def schedule_unit_def\n\nend", "property": "Scheduler Choice: The scheduler can choose any active thread or the idle thread to switch to, and may omit the switch if the chosen thread is the current thread. \n\nThread Switching: The scheduler switches to the chosen thread, which may be an active thread or the idle thread, unless it is the current thread, in which case the switch may be omitted.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "\n  The scheduler is heavily underspecified.\n  It is allowed to pick any active thread or the idle thread.\n  If the thread the scheduler picked is the current thread, it\n  may omit the call to @{const switch_to_thread}. Likewise it\n  may omit the call to @{const switch_to_idle_thread} if the\n  idle thread is the current thread.\n"}
{"spec": "translations\n  (type) \"'a user_monad\" <= (type) \"user_context \\<Rightarrow> ('a \\<times> user_context) set \\<times> bool\"\n\ndefinition\n  asid_high_bits :: nat\nwhere\n  \"asid_high_bits \\<equiv> LENGTH(asid_high_len)\"\n\ndefinition\n  asid_low_bits :: nat\nwhere\n  \"asid_low_bits \\<equiv> LENGTH(asid_low_len)\"\n\ndefinition\n  asid_bits :: nat\nwhere\n  \"asid_bits \\<equiv> LENGTH(asid_len)\"\n\nlemmas asid_bits_defs =\n  asid_bits_def asid_high_bits_def asid_low_bits_def", "property": "ASID Bit Length Definitions: Define the lengths of the high, low, and total bits of an ASID (Address Space Identifier).", "title": "./spec/abstract/MiscMachine_A.thy", "chapter": "", "section": "", "comment": " Needs to be done here after plain type names are exported "}
{"spec": "lemma asid_bits_len_checks:\n  \"asid_bits = asid_high_bits + asid_low_bits\"\n  \"asid_bits \\<le> LENGTH(asid_rep_len)\"\n  unfolding asid_bits_defs by auto\n\ndefinition ipa_size :: nat where\n  \"ipa_size \\<equiv> if config_ARM_PA_SIZE_BITS_40 then 40 else 44\"\n\nend", "property": "ASID and IPA Size Sanity Checks: Ensure that the ASID (Address Space Identifier) bits are correctly divided into high and low bits and do not exceed the length of the ASID representation. Also, define the IPA (Intermediate Physical Address) size based on the configuration of the ARM PA size bits.", "title": "./spec/abstract/MiscMachine_A.thy", "chapter": "", "section": "", "comment": " Sanity checks. "}
{"spec": "fun\n  invoke_irq_control :: \"irq_control_invocation \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"invoke_irq_control (IRQControl irq handler_slot control_slot) =\n     liftE (do set_irq_state IRQSignal irq;\n               cap_insert (IRQHandlerCap irq) control_slot handler_slot od)\"\n| \"invoke_irq_control (ArchIRQControl invok) =\n     arch_invoke_irq_control invok\"", "property": "IRQ Control Invocation: Allows the IRQControl capability to create a new IRQHandler capability and perform architecture-specific interrupt actions. \n\nSubproperties:\n- Set IRQ State: Set the IRQ state to IRQSignal for a specific IRQ.\n- Create IRQHandler Capability: Create a new IRQHandler capability for a specific IRQ and insert it into the specified slots.\n- Architecture-Specific Interrupt Actions: Perform architecture-specific interrupt actions through the ArchIRQControl invocation.", "title": "./spec/abstract/Interrupt_A.thy", "chapter": "", "section": "", "comment": "The IRQControl capability can be used to create a new IRQHandler\ncapability as well as to perform whatever architecture specific interrupt\nactions are available."}
{"spec": "fun\n  invoke_irq_handler :: \"irq_handler_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"invoke_irq_handler (ACKIrq irq) = arch_invoke_irq_handler (ACKIrq irq)\"\n| \"invoke_irq_handler (SetIRQHandler irq cap slot) = (do\n     irq_slot \\<leftarrow> get_irq_slot irq;\n     cap_delete_one irq_slot;\n     cap_insert cap slot irq_slot\n   od)\"\n| \"invoke_irq_handler (ClearIRQHandler irq) = (do\n     irq_slot \\<leftarrow> get_irq_slot irq;\n     cap_delete_one irq_slot\n   od)\"", "property": "IRQ Handler Invocation: Configure interrupt delivery and acknowledge delivered interrupts by loading or clearing Notification capabilities in per-IRQ slots.\n\nSubproperties:\n- Acknowledge delivered interrupts.\n- Set Notification capabilities to configure interrupt delivery.\n- Clear Notification capabilities to disable interrupt delivery.", "title": "./spec/abstract/Interrupt_A.thy", "chapter": "", "section": "", "comment": "The IRQHandler capability may be used to configure how interrupts on an\nIRQ are delivered and to acknowledge a delivered interrupt. Interrupts are\ndelivered when Notification capabilities are installed in the relevant per-IRQ\nslot. The IRQHandler operations load or clear those capabilities."}
{"spec": "definition timer_tick :: \"unit det_ext_monad\" where\n  \"timer_tick \\<equiv> do\n     cur \\<leftarrow> gets cur_thread;\n     state \\<leftarrow> get_thread_state cur;\n     case state of Running \\<Rightarrow> do\n       ts \\<leftarrow> ethread_get tcb_time_slice cur;\n       let ts' = ts - 1 in\n       if (ts' > 0) then thread_set_time_slice cur ts' else do\n         thread_set_time_slice cur timeSlice;\n         tcb_sched_action tcb_sched_append cur;\n         reschedule_required\n       od\n     od\n     | _ \\<Rightarrow> return ();\n     when (numDomains > 1) (do\n       dec_domain_time;\n       dom_time \\<leftarrow> gets domain_time;\n       when (dom_time = 0) reschedule_required\n     od)\n   od\"\n\ndefinition\n  handle_interrupt :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"handle_interrupt irq \\<equiv>\n   if irq > maxIRQ then do_machine_op $ do\n    maskInterrupt True irq;\n    ackInterrupt irq\n    od\n  else do\n   st \\<leftarrow> get_irq_state irq;\n   case st of\n     IRQSignal \\<Rightarrow> do\n       slot \\<leftarrow> get_irq_slot irq;\n       cap \\<leftarrow> get_cap slot;\n       when (is_ntfn_cap cap \\<and> AllowSend \\<in> cap_rights cap)\n         $ send_signal (obj_ref_of cap) (cap_ep_badge cap);\n       arch_mask_irq_signal irq\n     od\n   | IRQTimer \\<Rightarrow> do\n       do_extended_op timer_tick;\n       do_machine_op resetTimer\n     od\n   | IRQInactive \\<Rightarrow> fail \\<comment> \\<open>not meant to be able to get IRQs from inactive lines\\<close>\n   | IRQReserved \\<Rightarrow> handle_reserved_irq irq;\n   do_machine_op $ ackInterrupt irq\n   od\"\n\nend", "property": "Handle Interrupt: Manage interrupt occurrences by either delivering a message to a notification capability if the IRQ has a valid notification cap loaded, or by performing timer tick operations if the IRQ is a timer interrupt, including updating thread time slices and potentially rescheduling. Mask and acknowledge interrupts as necessary. \n\nTimer Tick: Update the current thread's time slice, potentially rescheduling if the time slice expires, and update domain time if multiple domains exist, rescheduling if the domain time reaches zero.", "title": "./spec/abstract/Interrupt_A.thy", "chapter": "", "section": "", "comment": "Handle an interrupt occurence. Timing and scheduling details are not\nincluded in this model, so no scheduling action needs to be taken on timer\nticks. If the IRQ has a valid Notification cap loaded a message is\ndelivered."}
{"spec": "type_synonym vm_rights = cap_rights\n\ndefinition vm_kernel_only :: vm_rights\nwhere\n  \"vm_kernel_only \\<equiv> {}\"\n\ndefinition vm_read_only :: vm_rights\nwhere\n  \"vm_read_only \\<equiv> {AllowRead}\"\n\ndefinition vm_read_write :: vm_rights\nwhere\n  \"vm_read_write \\<equiv> {AllowRead,AllowWrite}\"", "property": "Page Access Rights: Define the access rights for virtual memory pages, including kernel-only, read-only, and read-write permissions. \n\nSubproperties:\n- Kernel-only access: No access rights are granted.\n- Read-only access: Only read access is granted.\n- Read-write access: Both read and write access are granted.", "title": "./spec/abstract/VMRights_A.thy", "chapter": "", "section": "", "comment": "Page access rights."}
{"spec": "definition valid_vm_rights :: \"vm_rights set\"\nwhere\n  \"valid_vm_rights \\<equiv> {vm_read_write, vm_read_only, vm_kernel_only}\"\n\ndefinition validate_vm_rights :: \"vm_rights \\<Rightarrow> vm_rights\"\nwhere\n  \"validate_vm_rights rs \\<equiv>\n     if AllowRead \\<in> rs\n     then if AllowWrite \\<in> rs then vm_read_write else vm_read_only\n     else vm_kernel_only\"", "property": "Virtual Memory Rights Validation: Ensure that only permitted combinations of virtual memory rights are used. \n\nValid VM Rights: Only allow specific combinations of virtual memory rights, namely read-write, read-only, and kernel-only. \n\nRights Validation: Validate a given set of rights by returning the largest permitted subset, based on the presence of read and write allowances.", "title": "./spec/abstract/VMRights_A.thy", "chapter": "", "section": "", "comment": "\n  Note that only the above combinations of virtual-memory rights are permitted.\n  We introduce the following definitions to reflect this fact:\n  The predicate @{text valid_vm_rights} holds iff a given set of rights is valid\n  (i.e., a permitted combination).\n  The function @{text validate_vm_rights} takes an arbitrary set of rights and\n  returns the largest permitted subset.\n"}
{"spec": "definition mask_vm_rights :: \"vm_rights \\<Rightarrow> cap_rights \\<Rightarrow> vm_rights\"\nwhere\n  \"mask_vm_rights V R \\<equiv> validate_vm_rights (V \\<inter> R)\"\n\nend", "property": "VM Rights Validation: Ensures that the intersection of VM rights and capability rights results in a valid VM rights value, preventing invalid combinations such as allowing only write access.", "title": "./spec/abstract/VMRights_A.thy", "chapter": "", "section": "", "comment": "On the abstract level, capability and VM rights share the same type.\n  Nevertheless, a simple set intersection might lead to an invalid value like\n  @{term \"{AllowWrite}\"}.  Hence, @{const validate_vm_rights}."}
{"spec": "end", "property": "Unfortunately, you haven't provided the code and comment for me to summarize the property. Please provide the necessary information, and I'll be happy to help. I will summarize the property in 1-3 sentences, following the format you specified.", "title": "./spec/abstract/Glossary_Doc.thy", "chapter": "", "section": "", "comment": "<"}
{"spec": "text \\<open>Threads that are active always have a master Reply capability to\nthemselves stored in their reply slot. This is so that a derived Reply\ncapability can be generated immediately if they wish to issue one. This function\nsets up a new master Reply capability if one does not exist.\\<close>\ndefinition\n  \"setup_reply_master thread \\<equiv> do\n     old_cap <- get_cap (thread, tcb_cnode_index 2);\n     when (old_cap = NullCap) $ do\n         set_original (thread, tcb_cnode_index 2) True;\n         set_cap (ReplyCap thread True {AllowGrant, AllowWrite}) (thread, tcb_cnode_index 2)\n     od\n  od\"", "property": "Thread Reply Capability Setup: Ensure that an active thread has a master Reply capability to itself in its reply slot, creating a new one if it does not exist, to facilitate immediate generation of derived Reply capabilities.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": ""}
{"spec": "definition\n  restart :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"restart thread \\<equiv> do\n    state \\<leftarrow> get_thread_state thread;\n    when (\\<not> runnable state \\<and> \\<not> idle state) $ do\n      cancel_ipc thread;\n      setup_reply_master thread;\n      set_thread_state thread Restart;\n      do_extended_op (tcb_sched_action (tcb_sched_enqueue) thread);\n      do_extended_op (possible_switch_to thread)\n    od\n  od\"", "property": "Thread Reactivation: Reactivate a thread that is not currently running by canceling any pending IPC, setting up the reply master, setting the thread state to Restart, and scheduling the thread for execution, potentially switching to it.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Reactivate a thread if it is not already running."}
{"spec": "definition\n  activate_thread :: \"(unit,'z::state_ext) s_monad\" where\n  \"activate_thread \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n     state \\<leftarrow> get_thread_state thread;\n     (case state\n       of Running \\<Rightarrow> return ()\n        | Restart \\<Rightarrow> (do\n            pc \\<leftarrow> as_user thread getRestartPC;\n            as_user thread $ setNextPC pc;\n            set_thread_state thread Running\n          od)\n        | IdleThreadState \\<Rightarrow> arch_activate_idle_thread thread\n        | _ \\<Rightarrow> fail)\n   od\"", "property": "Thread Activation: Ensure that the current thread is properly activated before restoring control to it, handling different thread states (Running, Restart, IdleThreadState) and updating the program counter and thread state as necessary.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "This action is performed at the end of a system call immediately before\ncontrol is restored to a used thread. If it needs to be restarted then its\nprogram counter is set to the operation it was performing rather than the next\noperation. The idle thread is handled specially."}
{"spec": "definition\n  load_word_offs :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n \"load_word_offs ptr offs \\<equiv>\n    do_machine_op $ loadWord (ptr + of_nat (offs * word_size))\"\ndefinition\n  load_word_offs_word :: \"obj_ref \\<Rightarrow> data \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n \"load_word_offs_word ptr offs \\<equiv>\n    do_machine_op $ loadWord (ptr + (offs * word_size))\"", "property": "Load Word Offsets: Load a machine word from a memory location specified by an object reference and an offset, either as a natural number or a data type, ensuring that the word is retrieved correctly from the memory address calculated by adding the offset to the base address.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": ""}
{"spec": "definition\n  copy_mrs :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> obj_ref \\<Rightarrow>\n               obj_ref option \\<Rightarrow> length_type \\<Rightarrow> (length_type,'z::state_ext) s_monad\" where\n  \"copy_mrs sender sbuf receiver rbuf n \\<equiv>\n   do\n     hardware_mrs \\<leftarrow> return $ take (unat n) msg_registers;\n     mapM (\\<lambda>r. do\n         v \\<leftarrow> as_user sender $ getRegister r;\n         as_user receiver $ setRegister r v\n       od) hardware_mrs;\n     buf_mrs \\<leftarrow> case (sbuf, rbuf) of\n       (Some sb_ptr, Some rb_ptr) \\<Rightarrow> mapM (\\<lambda>x. do\n                                       v \\<leftarrow> load_word_offs sb_ptr x;\n                                       store_word_offs rb_ptr x v\n                                     od)\n               [length msg_registers + 1 ..< Suc (unat n)]\n     | _ \\<Rightarrow> return [];\n     return $ min n $ nat_to_len $ length hardware_mrs + length buf_mrs\n   od\"", "property": "Copy Message Registers: Copy message registers from one thread to another, including both hardware registers and buffer registers. Ensure that the register values are correctly transferred between threads, maintaining the integrity of the message being communicated.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Copy message registers from one thread to another."}
{"spec": "definition\n  get_tcb_ctable_ptr :: \"obj_ref \\<Rightarrow> cslot_ptr\" where\n  \"get_tcb_ctable_ptr tcb_ref \\<equiv> (tcb_ref, tcb_cnode_index 0)\"\n\ndefinition\n  get_tcb_vtable_ptr :: \"obj_ref \\<Rightarrow> cslot_ptr\" where\n  \"get_tcb_vtable_ptr tcb_ref \\<equiv> (tcb_ref, tcb_cnode_index 1)\"", "property": "TCB Slot Pointers: Provide pointers to the ctable and vtable slots of a TCB. \n\nGet TCB CTable Pointer: Return the ctable slot pointer of a TCB.\nGet TCB VTable Pointer: Return the vtable slot pointer of a TCB.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "The ctable and vtable slots of the TCB."}
{"spec": "definition\n  option_update_thread :: \"obj_ref \\<Rightarrow> ('a \\<Rightarrow> tcb \\<Rightarrow> tcb) \\<Rightarrow> 'a option \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"option_update_thread thread fn \\<equiv> case_option (return ()) (\\<lambda>v. thread_set (fn v) thread)\"", "property": "TCB Update: Optionally update the thread control block (TCB) at a specified address with a given function. If no update value is provided, the operation has no effect.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Optionally update the tcb at an address."}
{"spec": "definition\n  check_cap_at :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"check_cap_at cap slot m \\<equiv> do\n    cap' \\<leftarrow> get_cap slot;\n    when (same_object_as cap cap') m\n  od\"", "property": "Check Capability at Address: Verify that a related capability exists at a given address before performing a capability insertion to prevent issues with moved or deleted parent capabilities.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Check that a related capability is at an address. This is done before\ncalling @{const cap_insert} to avoid a corner case where the would-be parent of\nthe cap to be inserted has been moved or deleted."}
{"spec": "definition\n  bind_notification :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"bind_notification tcbptr ntfnptr \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     ntfn' \\<leftarrow> return $ ntfn_set_bound_tcb ntfn (Some tcbptr);\n     set_notification ntfnptr ntfn';\n     set_bound_notification tcbptr $ Some ntfnptr\n   od\"", "property": "Notification Binding: Associate a notification with a thread by updating the notification's bound TCB and the thread's bound notification.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Helper function for binding notifications"}
{"spec": "fun\n  invoke_tcb :: \"tcb_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"invoke_tcb (Suspend thread) = liftE (do suspend thread; return [] od)\"\n| \"invoke_tcb (Resume thread) = liftE (do restart thread; return [] od)\"\n\n| \"invoke_tcb (ThreadControl target slot faultep mcp priority croot vroot buffer)\n   = doE\n    liftE $ option_update_thread target (tcb_fault_handler_update o K) faultep;\n    liftE $  case mcp of None \\<Rightarrow> return()\n     | Some (newmcp, _) \\<Rightarrow> set_mcpriority target newmcp;\n    (case croot of None \\<Rightarrow> returnOk ()\n     | Some (new_cap, src_slot) \\<Rightarrow> doE\n      cap_delete (target, tcb_cnode_index 0);\n      liftE $ check_cap_at new_cap src_slot\n            $ check_cap_at (ThreadCap target) slot\n            $ cap_insert new_cap src_slot (target, tcb_cnode_index 0)\n    odE);\n    (case vroot of None \\<Rightarrow> returnOk ()\n     | Some (new_cap, src_slot) \\<Rightarrow> doE\n      cap_delete (target, tcb_cnode_index 1);\n      liftE $ check_cap_at new_cap src_slot\n            $ check_cap_at (ThreadCap target) slot\n            $ cap_insert new_cap src_slot (target, tcb_cnode_index 1)\n    odE);\n    (case buffer of None \\<Rightarrow> returnOk ()\n     | Some (ptr, frame) \\<Rightarrow> doE\n      cap_delete (target, tcb_cnode_index 4);\n      liftE $ thread_set (\\<lambda>t. t \\<lparr> tcb_ipc_buffer := ptr \\<rparr>) target;\n      liftE $ case frame of None \\<Rightarrow> return ()\n       | Some (new_cap, src_slot) \\<Rightarrow>\n            check_cap_at new_cap src_slot\n          $ check_cap_at (ThreadCap target) slot\n          $ cap_insert new_cap src_slot (target, tcb_cnode_index 4);\n      cur \\<leftarrow> liftE $ gets cur_thread;\n      liftE $ when (target = cur) (do_extended_op reschedule_required)\n    odE);\n    liftE $ case priority\n              of None \\<Rightarrow> return()\n               | Some (prio, _) \\<Rightarrow> do_extended_op (set_priority target prio);\n    returnOk []\n  odE\"\n\n| \"invoke_tcb (CopyRegisters dest src suspend_source resume_target transfer_frame transfer_integer transfer_arch) =\n  (liftE $ do\n    when suspend_source $ suspend src;\n    when resume_target $ restart dest;\n    when transfer_frame $ do\n        mapM_x (\\<lambda>r. do\n                v \\<leftarrow> as_user src $ getRegister r;\n                as_user dest $ setRegister r v\n        od) frame_registers;\n        pc \\<leftarrow> as_user dest getRestartPC;\n        as_user dest $ setNextPC pc\n    od;\n    when transfer_integer $\n        mapM_x (\\<lambda>r. do\n                v \\<leftarrow> as_user src $ getRegister r;\n                as_user dest $ setRegister r v\n        od) gpRegisters;\n    cur \\<leftarrow> gets cur_thread;\n    arch_post_modify_registers cur dest;\n    when (dest = cur) (do_extended_op reschedule_required);\n    return []\n  od)\"\n\n| \"invoke_tcb (ReadRegisters src suspend_source n arch) =\n  (liftE $ do\n    when suspend_source $ suspend src;\n    self \\<leftarrow> gets cur_thread;\n    regs \\<leftarrow> return (take (unat n) $ frame_registers @ gp_registers);\n    as_user src $ mapM getRegister regs\n  od)\"\n\n| \"invoke_tcb (WriteRegisters dest resume_target values arch) =\n  (liftE $ do\n    self \\<leftarrow> gets cur_thread;\n    b \\<leftarrow> arch_get_sanitise_register_info dest;\n    as_user dest $ do\n        zipWithM (\\<lambda>r v. setRegister r (sanitise_register b r v))\n            (frameRegisters @ gpRegisters) values;\n        pc \\<leftarrow> getRestartPC;\n        setNextPC pc\n    od;\n    arch_post_modify_registers self dest;\n    when resume_target $ restart dest;\n    when (dest = self) (do_extended_op reschedule_required);\n    return []\n  od)\"\n\n| \"invoke_tcb (NotificationControl tcb (Some ntfnptr)) =\n  (liftE $ do\n    bind_notification tcb ntfnptr;\n    return []\n  od)\"\n\n| \"invoke_tcb (NotificationControl tcb None) =\n  (liftE $ do\n    unbind_notification tcb;\n    return []\n  od)\"\n\n| \"invoke_tcb (SetTLSBase tcb tls_base) =\n  (liftE $ do\n    as_user tcb $ setRegister tlsBaseRegister tls_base;\n    cur \\<leftarrow> gets cur_thread;\n    when (tcb = cur) (do_extended_op reschedule_required);\n    return []\n  od)\"\n\ndefinition\n  set_domain :: \"obj_ref \\<Rightarrow> domain \\<Rightarrow> unit det_ext_monad\" where\n  \"set_domain tptr new_dom \\<equiv> do\n     cur \\<leftarrow> gets cur_thread;\n     tcb_sched_action tcb_sched_dequeue tptr;\n     thread_set_domain tptr new_dom;\n     ts \\<leftarrow> get_thread_state tptr;\n     when (runnable ts) (tcb_sched_action tcb_sched_enqueue tptr);\n     when (tptr = cur) reschedule_required\n   od\"\n\ndefinition invoke_domain:: \"obj_ref \\<Rightarrow> domain \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"invoke_domain thread domain \\<equiv>\n     liftE (do do_extended_op (set_domain thread domain); return [] od)\"", "property": "TCB Invocation Actions: Allows threads to perform actions such as suspending and resuming other threads, controlling various thread settings (fault endpoints, priorities, capability roots, IPC buffers), copying registers between threads, reading and writing thread registers, controlling notifications (binding and unbinding), and setting the TLS base. These actions ensure that threads can manage their state and capabilities effectively, maintaining the integrity and performance of the kernel.\n\nSubproperties:\n- Thread Control: Update thread settings, such as fault endpoints, priorities, capability roots, and IPC buffers.\n- Register Management: Copy, read, and write registers between threads.\n- Notification Control: Bind and unbind notifications to threads.\n- TLS Base Management: Set the TLS base for a thread.\n- Domain Management: Set the scheduling domain for a thread, ensuring correct dequeuing, domain updating, and re-enqueueing if runnable.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "TCB capabilities confer authority to perform seven actions. A thread can\nrequest to yield its timeslice to another, to suspend or resume another, to\nreconfigure another thread, or to copy register sets into, out of or between\nother threads."}
{"spec": "definition\n  get_mrs :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> message_info \\<Rightarrow>\n              (message list,'z::state_ext) s_monad\" where\n  \"get_mrs thread buf info \\<equiv> do\n     context \\<leftarrow> thread_get (arch_tcb_get_registers o tcb_arch) thread;\n     cpu_mrs \\<leftarrow> return (map context msg_registers);\n     buf_mrs \\<leftarrow> case buf\n       of None      \\<Rightarrow> return []\n        | Some pptr \\<Rightarrow> mapM (\\<lambda>x. load_word_offs pptr x)\n               [length msg_registers + 1 ..< Suc msg_max_length];\n     return (take (unat (mi_length info)) $ cpu_mrs @ buf_mrs)\n   od\"\n\nend", "property": "Get Message Registers: Retrieve all message registers from a thread's current register file and its IPC buffer, returning a list of message registers based on the provided message information.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Get all of the message registers, both from the sending thread's current\nregister file and its IPC buffer."}
{"spec": "(*\nFormalisation of interrupt handling.\n*)\n\nchapter \"Arch-specific Interrupts\"\n\ntheory ArchInterrupt_A\nimports Ipc_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition handle_reserved_irq :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where \"handle_reserved_irq irq = return ()\"\n\nfun arch_invoke_irq_handler :: \"irq_handler_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"arch_invoke_irq_handler (ACKIrq irq) = (do_machine_op $ maskInterrupt False irq)\"\n| \"arch_invoke_irq_handler _ = return ()\"\n\ndefinition arch_mask_irq_signal :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"arch_mask_irq_signal irq \\<equiv> do_machine_op $ maskInterrupt True irq\"\n\nend\n\nend", "property": "Arch-specific Interrupt Handling: Provides functions for handling interrupts, including acknowledging and masking interrupts. Ensures proper management of interrupt signals and handlers.\n\nSubproperties:\n- Handle Reserved IRQ: Returns a null operation for reserved IRQs.\n- Invoke IRQ Handler: Handles IRQ handler invocations, specifically acknowledging IRQs by masking interrupts.\n- Mask IRQ Signal: Masks the interrupt signal for a given IRQ.", "title": "./spec/abstract/ARM/ArchInterrupt_A.thy", "chapter": "Arch-specific Interrupts", "section": "", "comment": ""}
{"spec": "definition\n  arch_switch_to_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_switch_to_thread t \\<equiv> do\n     set_vm_root t;\n     do_machine_op $ clearExMonitor\n   od\"", "property": "Thread Context Switching: Switch to a thread's virtual address space context and clear the load-exclusive monitor, ensuring a clean and isolated execution environment for the thread.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "Switch to a thread's virtual address space context. Clear the load-exclusive monitor."}
{"spec": "definition\n   arch_switch_to_idle_thread :: \"(unit,'z::state_ext) s_monad\" where\n   \"arch_switch_to_idle_thread \\<equiv> do\n     thread \\<leftarrow> gets idle_thread;\n     set_vm_root thread\n   od\"\n\ndefinition\n  arch_activate_idle_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_activate_idle_thread t \\<equiv> return ()\"", "property": "Clear Globals Frame: Clear the globals frame when switching to the idle thread to ease infoflow reasoning.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": " Clear the globals frame when switching to the idle thread. This is\n    specificially to ease infoflow reasoning VER-207 "}
{"spec": "definition\nperform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_control_invocation iv \\<equiv> case iv of\n  MakePool frame slot parent base \\<Rightarrow> do\n    delete_objects frame page_bits;\n    pcap \\<leftarrow> get_cap parent;\n    set_cap (max_free_index_update pcap) parent;\n    retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n    cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n    assert (base && mask asid_low_bits = 0);\n    asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n    modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>arm_asid_table := asid_table'\\<rparr>\\<rparr>)\nod\"", "property": "ASID Control Invocation: Create a new ASID pool object, provide a capability to it, and connect it to the global virtual ASID table. \n\nSubproperties:\n- Delete objects in the specified frame.\n- Update the parent capability with the maximum free index.\n- Retype the specified region to an ASID pool object.\n- Insert the new ASID pool capability into the specified slot.\n- Update the ASID table with the new ASID pool mapping.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDControl capability confers the authority to create a new ASID\npool object. This operation creates the new ASID pool, provides a capability\nto it and connects it to the global virtual ASID table."}
{"spec": "definition\nperform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_pool_invocation iv \\<equiv> case iv of Assign asid pool_ptr ct_slot \\<Rightarrow>\ndo\n    pd_cap \\<leftarrow> get_cap ct_slot;\n    case pd_cap of\n      ArchObjectCap (PageDirectoryCap pd_base _) \\<Rightarrow> do\n        pool \\<leftarrow> get_asid_pool pool_ptr;\n        pool' \\<leftarrow> return (pool (ucast asid \\<mapsto> pd_base));\n        set_cap (ArchObjectCap $ PageDirectoryCap pd_base (Some asid)) ct_slot;\n        set_asid_pool pool_ptr pool'\n      od\n    | _ \\<Rightarrow> fail\nod\"", "property": "ASID Pool Invocation: Assign a virtual ASID to a page directory, updating the ASID pool and the page directory capability accordingly. \n\nSubproperties:\n- Retrieve the page directory capability from the specified slot.\n- Update the ASID pool with the new assignment.\n- Set the page directory capability with the assigned ASID.\n- Update the ASID pool with the new mapping.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign a virtual ASID\nto a page directory."}
{"spec": "definition\n  perform_page_directory_invocation :: \"page_directory_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"perform_page_directory_invocation iv \\<equiv> case iv of\n       PageDirectoryFlush typ start end pstart pd asid \\<Rightarrow>\n         when (start < end) $ do\n           root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n           do_machine_op $ do_flush typ start end pstart;\n           when root_switched $ do\n             tcb \\<leftarrow> gets cur_thread;\n             set_vm_root tcb\n           od\n        od\n     | PageDirectoryNothing \\<Rightarrow> return ()\"\n\ndefinition\n  pte_check_if_mapped :: \"32 word \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pte_check_if_mapped slot \\<equiv> do\n     pt \\<leftarrow> get_master_pte slot;\n     return (pt \\<noteq> InvalidPTE)\n  od\"\n\ndefinition\n  pde_check_if_mapped :: \"32 word \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pde_check_if_mapped slot \\<equiv> do\n     pd \\<leftarrow> get_master_pde slot;\n     return (pd \\<noteq> InvalidPDE)\n  od\"", "property": "Page Directory Invocation: Flush cache entries associated with a page directory, ensuring cache consistency and coherence.\n\nCache Management: Check if a page table entry (PTE) or page directory entry (PDE) is mapped, verifying the validity of memory mappings.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "The PageDirectory capability confers the authority to flush cache entries\nassociated with that PD"}
{"spec": "definition\nperform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n\"perform_page_invocation iv \\<equiv> case iv of\n  PageMap asid cap ct_slot entries \\<Rightarrow> do\n    set_cap cap ct_slot;\n    case entries of\n          Inl (pte, slots) \\<Rightarrow> do\n            flush \\<leftarrow> pte_check_if_mapped (hd slots);\n            store_pte (hd slots) pte;\n            mapM (swp store_pte InvalidPTE) (tl slots);\n            do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pte (last slots))\n                                                (addrFromPPtr (hd slots));\n            if flush then (invalidate_tlb_by_asid asid) else return ()\n          od\n        | Inr (pde, slots) \\<Rightarrow> do\n            flush \\<leftarrow> pde_check_if_mapped (hd slots);\n            store_pde (hd slots) pde;\n            mapM (swp store_pde InvalidPDE) (tl slots);\n            do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pde (last slots))\n                                                (addrFromPPtr (hd slots));\n            if flush then (invalidate_tlb_by_asid asid) else return ()\n          od;\n    return []\n  od\n| PageUnmap cap ct_slot \\<Rightarrow>\n    (case cap of\n      PageCap dev p R vp_size vp_mapped_addr \\<Rightarrow> do\n        case vp_mapped_addr of\n            Some (asid, vaddr) \\<Rightarrow> unmap_page vp_size asid vaddr p\n          | None \\<Rightarrow> return ();\n        cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n        set_cap (ArchObjectCap $ update_map_data cap None) ct_slot;\n        return []\n      od\n    | _ \\<Rightarrow> fail)\n| PageFlush typ start end pstart pd asid \\<Rightarrow> do\n    when (start < end) $ do\n      root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n      do_machine_op $ do_flush typ start end pstart;\n      when root_switched $ do\n        tcb \\<leftarrow> gets cur_thread;\n        set_vm_root tcb\n      od\n    od;\n    return []\n  od\n| PageGetAddr ptr \\<Rightarrow>\n    return [addrFromPPtr ptr]\n  \"", "property": "Page Management: Authorize and perform actions on memory pages, including mapping, unmapping, and flushing, while maintaining cache and TLB consistency. \n\nSubproperties:\n- Page Mapping: Map a page into a virtual address space, handling PTE and PDE updates, cache cleaning, and TLB invalidation as needed.\n- Page Unmapping: Unmap a page from a virtual address space, updating the page's mapped address and capability.\n- Page Flushing: Flush a range of pages, handling root switching, cache flushing, and TLB invalidation as needed.\n- Page Address Retrieval: Retrieve the physical address of a page.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "The Page capability confers the authority to map, unmap and flush the\n  memory page."}
{"spec": "definition\nperform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_page_table_invocation iv \\<equiv>\ncase iv of PageTableMap cap ct_slot pde pd_slot \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pde pd_slot pde;\n    do_machine_op $ cleanByVA_PoU pd_slot (addrFromPPtr pd_slot)\n  od\n  | PageTableUnmap (ArchObjectCap (PageTableCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_page_table asid vaddr p;\n      pte_bits \\<leftarrow> return 2;\n      slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + (1 << pt_bits) - 1];\n      mapM_x (swp store_pte InvalidPTE) slots;\n      do_machine_op $ cleanCacheRange_PoU p (p + (1 << pt_bits) - 1)\n                                          (addrFromPPtr p)\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"", "property": "Page Table Management: Authorize page table mapping and unmapping operations, ensuring the correct configuration of page tables and the underlying hardware. \n\nMap Page Table: Set the capability for a page table, store the page directory entry, and clean the cache for the affected virtual address range.\n\nUnmap Page Table: Remove the mapping of a page table, invalidate the relevant page table entries, and clean the cache for the affected range. Update the capability to reflect the unmapped state.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page\ntables."}
{"spec": "definition\n  arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\" where\n  \"arch_perform_invocation i \\<equiv> liftE $\n    case i of\n      InvokePageTable oper \\<Rightarrow> do\n        perform_page_table_invocation oper;\n        return []\n      od\n    | InvokePageDirectory oper \\<Rightarrow> do\n        perform_page_directory_invocation oper;\n        return []\n      od\n    | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n    | InvokeASIDControl oper \\<Rightarrow> do\n        perform_asid_control_invocation oper;\n        return []\n      od\n    | InvokeASIDPool oper \\<Rightarrow> do\n        perform_asid_pool_invocation oper;\n        return []\n      od\n  \"\n\nend\n\nend", "property": "ARM-Specific System Call Dispatch: Dispatches and performs ARM-specific system calls, handling various invocations related to page tables, directories, pages, ASID control, and ASID pools.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call despatcher for all ARM-specific system calls."}
{"spec": "chapter \"Handle Hyperviser Fault Event\"\n\ntheory Hypervisor_A\nimports Exceptions_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"word32 \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n\"handle_hypervisor_fault thread ARMNoHypFaults = return ()\"\n\n\nend\nend", "property": "Handle Hypervisor Fault Event: Ignore ARMNoHypFaults type faults when handling hypervisor faults for a given thread.", "title": "./spec/abstract/ARM/Hypervisor_A.thy", "chapter": "Handle Hyperviser Fault Event", "section": "", "comment": ""}
{"spec": "definition\n  reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Memory Region Reservation: Reserve a memory region with the specified pointer, byte length, and kernel flag, currently a no-op placeholder for potential future extension to explicitly tag kernel data regions in memory.", "title": "./spec/abstract/ARM/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory."}
{"spec": "definition vs_apiobj_size where\n  \"vs_apiobj_size ty \\<equiv>\n     case ty of\n       ArchObject SmallPageObj \\<Rightarrow> pageBitsForSize ARMSmallPage\n     | ArchObject LargePageObj \\<Rightarrow> pageBitsForSize ARMLargePage\n     | ArchObject SectionObj \\<Rightarrow> pageBitsForSize ARMSection\n     | ArchObject SuperSectionObj \\<Rightarrow> pageBitsForSize ARMSuperSection\n     | ArchObject PageTableObj \\<Rightarrow> pt_bits\n     | ArchObject PageDirectoryObj \\<Rightarrow> pd_bits\"\n\ndefinition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv> do\n     when (new_type = ArchObject PageDirectoryObj) $ mapM_x copy_global_mappings refs;\n     if \\<not>is_device \\<and>\n        new_type \\<in> {ArchObject SmallPageObj, ArchObject LargePageObj,\n                    ArchObject SectionObj, ArchObject SuperSectionObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_RAM ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else if new_type \\<in> {ArchObject PageTableObj, ArchObject PageDirectoryObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_PoU ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else\n       return ()\n   od\"\n\ndefinition\n  empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context \\<rparr>\"\n\n\nend\n\nend", "property": "Initialise Architecture-Specific Objects: Initialise architecture-specific objects, including page tables, page directories, and various types of page objects, ensuring correct configuration and cache management for these objects. \n\nSubproperties:\n- Page Directory Initialisation: When initialising a page directory, copy global mappings to the referenced objects.\n- Page Object Initialisation: Clean the cache range for non-device page objects, such as small, large, section, and super section page objects.\n- Page Table and Directory Cache Management: Clean the cache range for page tables and directories to ensure correct operation.\n- Architecture-Specific TCB Initialisation: Initialise the architecture-specific components of a TCB (Thread Control Block) with an empty context.", "title": "./spec/abstract/ARM/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition\n  arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arch_post_cap_deletion _ \\<equiv> return ()\"", "property": "Post-Capability Deletion: No specific actions are taken after a capability is deleted.", "title": "./spec/abstract/ARM/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = unit\n\ndefinition\n  arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\"\nwhere\n  \"arch_gen_obj_refs _ = {}\"\n\ndefinition\n  arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_cap_cleanup_opt ac \\<equiv> NullCap\"\n\nend\nend", "property": "Architectural Generic Object References: Provide an empty set of architectural generic object references for each architectural capability, indicating that no additional references are required beyond the generic references. \n\nArchitectural Capability Cleanup: Clean up architectural capabilities by replacing them with a null capability, effectively removing any architectural-specific information.", "title": "./spec/abstract/ARM/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition\n  init_tcb_ptr :: word32 where\n  \"init_tcb_ptr = kernel_base + 0x2000\"\n\ndefinition\n  init_irq_node_ptr :: word32 where\n  \"init_irq_node_ptr = kernel_base + 0x8000\"", "property": "Dummy Initial State: Defines the initial state of the kernel with dummy values, ensuring consistency of invariants and refinement relations. \n\nInitialization Constants: Specifies the initial pointers for the thread control block (TCB) and interrupt request (IRQ) node.", "title": "./spec/abstract/ARM/Init_A.thy", "chapter": "", "section": "", "comment": "\n  This is not a specification of true kernel\n  initialisation. This theory describes a dummy initial state only, to\n  show that the invariants and refinement relation are consistent.\n"}
{"spec": "definition\n  init_globals_frame :: word32 where\n  \"init_globals_frame = kernel_base + 0x5000\"\n\ndefinition\n  init_global_pd :: word32 where\n  \"init_global_pd = kernel_base + 0x60000\"\n\ndefinition\n  \"init_arch_state \\<equiv> \\<lparr>\n    arm_asid_table = Map.empty,\n    arm_hwasid_table = Map.empty,\n    arm_next_asid = 0,\n    arm_asid_map = Map.empty,\n    arm_global_pd = init_global_pd,\n    arm_global_pts = [],\n    arm_kernel_vspace = \\<lambda>ref.\n      if ref \\<in> {kernel_base .. kernel_base + mask 20}\n      then ArmVSpaceKernelWindow\n      else ArmVSpaceInvalidRegion\n  \\<rparr>\"\n\ndefinition\n  [simp]:\n  \"global_pd \\<equiv> (\\<lambda>_. InvalidPDE)( ucast (kernel_base >> 20) := SectionPDE (addrFromPPtr kernel_base) {} 0 {})\"\n\ndefinition\n  \"init_kheap \\<equiv>\n  (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n       then Some (CNode 0 (empty_cnode 0)) else None)\n  (idle_thread_ptr \\<mapsto> TCB \\<lparr>\n    tcb_ctable = NullCap,\n    tcb_vtable = NullCap,\n    tcb_reply = NullCap,\n    tcb_caller = NullCap,\n    tcb_ipcframe = NullCap,\n    tcb_state = IdleThreadState,\n    tcb_fault_handler = replicate word_bits False,\n    tcb_ipc_buffer = 0,\n    tcb_fault = None,\n    tcb_bound_notification = None,\n    tcb_mcpriority = minBound,\n    tcb_arch = init_arch_tcb\n  \\<rparr>,\n  init_globals_frame \\<mapsto> ArchObj (DataPage False ARMSmallPage), \\<comment> \\<open>same reason as why we kept the definition of @{term init_globals_frame}\\<close>\n  init_global_pd \\<mapsto> ArchObj (PageDirectory global_pd)\n  )\"\n\ndefinition\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. Structures_A.IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\n\n\nend", "property": "Initialization of Kernel State: The kernel's initial state is defined, including the memory layout, page directory, and page tables. The kernel's base address, global page directory, and global page tables are set up. The initial kernel heap, capability derivation tree, and I/O controller are also defined.\n\nSubproperties:\n\n* Memory Layout: The kernel's memory layout is defined, including the base address, global page directory, and global page tables.\n* Kernel Heap Initialization: The initial kernel heap is defined, including the idle thread, global frame, and global page directory.\n* Capability Derivation Tree Initialization: The initial capability derivation tree is defined as an empty map.\n* I/O Controller Initialization: The initial I/O controller is defined, which checks if an object exists in the kernel heap and has a non-null capability.", "title": "./spec/abstract/ARM/Init_A.thy", "chapter": "", "section": "", "comment": " It is easy to remove a memory slot here, but once if we want to reserve other slots of memory, we have to do the proof of disjoint for example state again.\n   Comment is left here so that next time we need 4k memory, we don't need to fix example state and can simply change its name. "}
{"spec": "definition largePagePTE_offsets :: \"obj_ref list\"\n  where\n  \"largePagePTE_offsets \\<equiv>\n    let pts = of_nat 2\n    in [0, 2 ^ pts  .e.  (15 << 2)]\"\n\ndefinition superSectionPDE_offsets :: \"obj_ref list\"\n  where\n  \"superSectionPDE_offsets \\<equiv>\n    let pts = of_nat 2\n    in [0, 2 ^ pts  .e.  (15 << 2)]\"\n\nfun create_mapping_entries ::\n  \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vm_rights \\<Rightarrow> vm_attributes \\<Rightarrow> word32 \\<Rightarrow>\n  ((pte * word32 list) + (pde * word32 list),'z::state_ext) se_monad\"\nwhere\n  \"create_mapping_entries base vptr ARMSmallPage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (SmallPagePTE base (attrib - {Global, ParityEnabled})\n                                 vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMLargePage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (LargePagePTE base (attrib - {Global, ParityEnabled})\n                                 vm_rights, map (\\<lambda>x. x + p) largePagePTE_offsets)\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SectionPDE base (attrib - {Global}) 0 vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSuperSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SuperSectionPDE base (attrib - {Global}) vm_rights, map (\\<lambda>x. x + p) superSectionPDE_offsets)\n  odE\"\n\ndefinition get_master_pde :: \"word32 \\<Rightarrow> (pde,'z::state_ext)s_monad\"\n  where \"get_master_pde ptr \\<equiv> do\n    pde \\<leftarrow> (get_pde (ptr && ~~ mask 6));\n    (case pde of SuperSectionPDE _ _ _ \\<Rightarrow> return pde\n    | _ \\<Rightarrow> get_pde ptr)\n  od\"\n\ndefinition get_master_pte :: \"word32 \\<Rightarrow> (pte, 'z::state_ext)s_monad\"\n  where \"get_master_pte ptr \\<equiv> do\n    pte \\<leftarrow> (get_pte (ptr && ~~ mask 6));\n    (case pte of LargePagePTE _ _ _ \\<Rightarrow> return pte\n    | _ \\<Rightarrow> get_pte ptr)\n  od\"", "property": "Create Mapping Entries: Save the set of entries that would be inserted into a page table or page directory to map various different sizes of frames at a given virtual address, considering the page size, virtual machine rights, and attributes.\n\nGet Master Page Table/Directory Entry: Retrieve the master page directory or page table entry for a given virtual address, handling cases where the entry is a super section or large page.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Save the set of entries that would be inserted into a page table or\npage directory to map various different sizes of frame at a given virtual\naddress."}
{"spec": "fun ensure_safe_mapping ::\n  \"(pte * word32 list) + (pde * word32 list) \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n\"ensure_safe_mapping (Inl (InvalidPTE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inl (SmallPagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda>slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | SmallPagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst)\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inl (LargePagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | LargePagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inr (InvalidPDE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inr (PageTablePDE _ _ _, _)) = fail\"\n|\n\"ensure_safe_mapping (Inr (SectionPDE _ _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SectionPDE _ _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"\n|\n\"ensure_safe_mapping (Inr (SuperSectionPDE _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SuperSectionPDE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"", "property": "Ensure Safe Mapping: Verify that page table or directory entries being replaced are either invalid or have the same granularity as the new entry, preventing unsafe mappings that could compromise memory integrity. \n\nSubproperties:\n- Invalid entries can be safely replaced.\n- Entries of the same granularity (e.g., SmallPagePTE, LargePagePTE, SectionPDE, SuperSectionPDE) can be safely replaced.\n- Entries of different granularities cannot be replaced, throwing a DeleteFirst error.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Placing an entry which maps a frame within the set of entries that map a\nlarger frame is unsafe. This function checks that given entries replace either\ninvalid entries or entries of the same granularity."}
{"spec": "definition\nlookup_ipc_buffer :: \"bool \\<Rightarrow> word32 \\<Rightarrow> (word32 option,'z::state_ext) s_monad\" where\n\"lookup_ipc_buffer is_receiver thread \\<equiv> do\n    buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n    buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n    buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n    (case buffer_cap of\n      ArchObjectCap (PageCap _ p R vms _) \\<Rightarrow>\n        if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n        then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n        else return None\n    | _ \\<Rightarrow> return None)\nod\"", "property": "Lookup IPC Buffer: Retrieve the IPC buffer pointer for a given thread and verify that the thread has the necessary authority to read or write to it, depending on whether it is the receiver or sender. \n\nAuthority Verification: Check that the buffer's capability allows read-only access if the thread is not the receiver, or read-write access if it is the receiver.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Look up a thread's IPC buffer and check that the thread has the right\nauthority to read or (in the receiver case) write to it."}
{"spec": "definition\nfind_pd_for_asid :: \"asid \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"find_pd_for_asid asid \\<equiv> doE\n    assertE (asid > 0);\n    asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n    pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of asid));\n    pool \\<leftarrow> (case pool_ptr of\n               Some ptr \\<Rightarrow> liftE $ get_asid_pool ptr\n             | None \\<Rightarrow> throwError InvalidRoot);\n    pd \\<leftarrow> returnOk (pool (ucast asid));\n    (case pd of\n          Some ptr \\<Rightarrow> returnOk ptr\n        | None \\<Rightarrow> throwError InvalidRoot)\nodE\"", "property": "Find Page Directory for ASID: Locate the page directory associated with a given virtual ASID, ensuring the ASID is valid and retrieving the corresponding page directory pointer from the ASID table and pool. \n\nSubproperties:\n- ASID Validation: Verify that the given ASID is greater than 0.\n- ASID Table Lookup: Retrieve the ASID table from the arch state and extract the pool pointer for the given ASID.\n- Pool Lookup: Retrieve the page directory pointer from the pool, handling cases where the pool or page directory is invalid.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory associated with a given virtual ASID."}
{"spec": "definition\nfind_pd_for_asid_assert :: \"asid \\<Rightarrow> (word32,'z::state_ext) s_monad\" where\n\"find_pd_for_asid_assert asid \\<equiv> do\n   pd \\<leftarrow> find_pd_for_asid asid <catch> K fail;\n   get_pde pd;\n   return pd\n od\"", "property": "Page Directory Location: Locate the page directory for a given ASID and verify its validity by successfully retrieving a page directory entry.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory and check that this process succeeds and\nreturns a pointer to a real page directory."}
{"spec": "fun\nhandle_vm_fault :: \"word32 \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n\"handle_vm_fault thread ARMDataAbort = doE\n    addr \\<leftarrow> liftE $ do_machine_op getFAR;\n    fault \\<leftarrow> liftE $ do_machine_op getDFSR;\n    throwError $ ArchFault $ VMFault addr [0, fault && mask 14]\nodE\"\n|\n\"handle_vm_fault thread ARMPrefetchAbort = doE\n    pc \\<leftarrow> liftE $ as_user thread $ getRestartPC;\n    fault \\<leftarrow> liftE $ do_machine_op getIFSR;\n    throwError $ ArchFault $ VMFault pc [1, fault && mask 14]\nodE\"", "property": "VM Fault Handling: Formats a VM fault message to be passed to a thread's supervisor after encountering a page fault, providing the fault address and relevant fault status register information. \n\nSubproperties:\n- For data aborts, retrieves the fault address from the Fault Address Register (FAR) and the fault status from the Data Fault Status Register (DFSR).\n- For prefetch aborts, retrieves the fault address from the thread's current program counter (PC) and the fault status from the Instruction Fault Status Register (IFSR).", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Format a VM fault message to be passed to a thread's supervisor after\nit encounters a page fault."}
{"spec": "definition\nload_hw_asid :: \"asid \\<Rightarrow> (hardware_asid option,'z::state_ext) s_monad\" where\n\"load_hw_asid asid \\<equiv> do\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    return $ option_map fst $ asid_map asid\nod\"", "property": "Load Hardware ASID: Retrieve the optional hardware ASID associated with a given virtual ASID from the ASID map.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Load the optional hardware ASID currently associated with this virtual\nASID."}
{"spec": "definition\nstore_hw_asid :: \"asid \\<Rightarrow> hardware_asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"store_hw_asid asid hw_asid \\<equiv> do\n    pd \\<leftarrow> find_pd_for_asid_assert asid;\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    asid_map' \\<leftarrow> return (asid_map (asid \\<mapsto> (hw_asid, pd)));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_map := asid_map' \\<rparr>\\<rparr>);\n    hw_asid_map \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n    hw_asid_map' \\<leftarrow> return (hw_asid_map (hw_asid \\<mapsto> asid));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_hwasid_table := hw_asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Associate Hardware ASID with Virtual ASID: Maps a hardware ASID to a virtual ASID, updating the ASID map and hardware ASID table to maintain the association between them. \n\nSubproperties:\n- Find the page directory (PD) for the given virtual ASID.\n- Update the ASID map with the new association between the virtual ASID and the hardware ASID along with the PD.\n- Update the hardware ASID table with the new association between the hardware ASID and the virtual ASID.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associate a hardware ASID with a virtual ASID."}
{"spec": "definition\ninvalidate_tlb_by_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_tlb_by_asid asid \\<equiv> do\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    (case maybe_hw_asid of\n          None \\<Rightarrow> return ()\n        | Some hw_asid \\<Rightarrow> do_machine_op $ invalidateLocalTLB_ASID hw_asid)\nod\"", "property": "TLB Invalidation: Clear all TLB mappings associated with a given virtual ASID, ensuring that any stale translations are removed and the TLB is updated accordingly. \n\nSubproperties:\n- Load the hardware ASID associated with the given virtual ASID.\n- If a hardware ASID is found, invalidate the local TLB entries for that ASID using a machine operation.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Clear all TLB mappings associated with this virtual ASID."}
{"spec": "definition\nflush_space :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_space asid \\<equiv> do\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    do_machine_op cleanCaches_PoU;\n    (case maybe_hw_asid of\n          None \\<Rightarrow> return ()\n        | Some hw_asid \\<Rightarrow> do_machine_op $ invalidateLocalTLB_ASID hw_asid)\nod\"", "property": "Flush Virtual ASID: Flush all cache and TLB entries associated with a given virtual ASID, ensuring that the corresponding hardware ASID is cleaned and invalidated. \n\nCache Cleaning: Clean the caches to the point of unification, ensuring that all cache entries are removed.\n\nTLB Invalidation: Invalidate the local TLB entries for the given hardware ASID, ensuring that all stale translations are removed.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush all cache and TLB entries associated with this virtual ASID."}
{"spec": "definition\ninvalidate_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_asid asid \\<equiv> do\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    asid_map' \\<leftarrow> return (asid_map (asid:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_map := asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Invalidate ASID Mapping: Remove the mapping from a virtual ASID to a hardware ASID, ensuring that the ASID is no longer associated with a hardware ASID.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this virtual ASID to a hardware ASID."}
{"spec": "definition\ninvalidate_hw_asid_entry :: \"hardware_asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_hw_asid_entry hw_asid \\<equiv> do\n  hw_asid_map \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n  hw_asid_map' \\<leftarrow> return (hw_asid_map (hw_asid:= None));\n  modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_hwasid_table := hw_asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Invalidate Hardware ASID Entry: Remove the mapping from a hardware ASID to a virtual ASID by updating the hardware ASID table.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this hardware ASID to a virtual ASID."}
{"spec": "definition\ninvalidate_asid_entry :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_asid_entry asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  when (maybe_hw_asid \\<noteq> None) $ invalidate_hw_asid_entry (the maybe_hw_asid);\n  invalidate_asid asid\nod\"", "property": "ASID Entry Invalidation: Remove virtual to physical mappings associated with a given virtual ASID in both directions. \n\nSubproperties:\n- If the ASID is mapped to a hardware ASID, invalidate the corresponding hardware ASID entry.\n- Invalidate the ASID itself.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove virtual to physical mappings in either direction involving this\nvirtual ASID."}
{"spec": "definition\nfind_free_hw_asid :: \"(hardware_asid,'z::state_ext) s_monad\" where\n\"find_free_hw_asid \\<equiv> do\n    hw_asid_table \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n    next_asid \\<leftarrow> gets (arm_next_asid \\<circ> arch_state);\n    maybe_asid \\<leftarrow> return (find (\\<lambda>a. hw_asid_table a = None)\n                    (take (length [minBound :: hardware_asid .e. maxBound])\n                        ([next_asid .e. maxBound] @ [minBound .e. next_asid])));\n    (case maybe_asid of\n       Some hw_asid \\<Rightarrow> return hw_asid\n     | None \\<Rightarrow>  do\n            invalidate_asid $ the $ hw_asid_table next_asid;\n            do_machine_op $ invalidateLocalTLB_ASID next_asid;\n            invalidate_hw_asid_entry next_asid;\n            new_next_asid \\<leftarrow> return (next_asid + 1);\n            modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_next_asid := new_next_asid \\<rparr>\\<rparr>);\n            return next_asid\n       od)\nod\"", "property": "Find Free Hardware ASID: Locate an unused hardware ASID, and if none are available, reclaim one from another virtual ASID in a round-robin manner, ensuring that the reclaimed ASID is invalidated and the next ASID is updated.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate a hardware ASID that is not in use, if necessary by reclaiming\none from another virtual ASID in a round-robin manner."}
{"spec": "definition\nget_hw_asid :: \"asid \\<Rightarrow> (hardware_asid,'z::state_ext) s_monad\" where\n\"get_hw_asid asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  (case maybe_hw_asid of\n    Some hw_asid \\<Rightarrow> return hw_asid\n  | None \\<Rightarrow>  do\n      new_hw_asid \\<leftarrow> find_free_hw_asid;\n      store_hw_asid asid new_hw_asid;\n      return new_hw_asid\n  od)\nod\"\n\n\nabbreviation\n  \"arm_context_switch_hwasid pd hwasid \\<equiv> do\n              set_current_pd $ addrFromPPtr pd;\n              setHardwareASID hwasid\n          od\"\n\ndefinition\n  arm_context_switch :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arm_context_switch pd asid \\<equiv> do\n      hwasid \\<leftarrow> get_hw_asid asid;\n      do_machine_op $ arm_context_switch_hwasid pd hwasid\n    od\"", "property": "Get Hardware ASID: Retrieve the hardware ASID associated with a virtual ASID, assigning a new one if none is already assigned.\nContext Switch: Perform a context switch by setting the current page directory and hardware ASID for a given virtual ASID.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get the hardware ASID associated with a virtual ASID, assigning one if\nnone is already assigned."}
{"spec": "definition\n  set_vm_root :: \"word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"set_vm_root tcb \\<equiv> do\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    (case thread_root of\n       ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow> doE\n           pd' \\<leftarrow> find_pd_for_asid asid;\n           whenE (pd \\<noteq> pd') $ throwError InvalidRoot;\n           liftE $ arm_context_switch pd asid\n       odE\n     | _ \\<Rightarrow> throwError InvalidRoot) <catch>\n    (\\<lambda>_. do\n       global_pd \\<leftarrow> gets (arm_global_pd \\<circ> arch_state);\n       do_machine_op $ set_current_pd $ addrFromKPPtr global_pd\n    od)\nod\"", "property": "Set VM Root: Switch into the address space of a given thread or the global address space if the thread's address space is not correctly configured, ensuring that the correct page directory is used for memory access. \n\nSubproperties:\n- Validate Thread Root: Verify that the thread's root capability is a valid page directory capability with a matching address space identifier (ASID).\n- Handle Invalid Root: If the thread's root capability is invalid, fall back to using the global page directory.\n- Switch Address Space: Perform the actual address space switch by updating the current page directory and ASID.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch into the address space of a given thread or the global address\nspace if none is correctly configured."}
{"spec": "definition\ndelete_asid_pool :: \"asid \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid_pool base ptr \\<equiv> do\n  assert (base && mask asid_low_bits = 0);\n  asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n  when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n    pool \\<leftarrow> get_asid_pool ptr;\n    mapM (\\<lambda>offset. (when (pool (ucast offset) \\<noteq> None) $ do\n                          flush_space $ base + offset;\n                          invalidate_asid_entry $ base + offset\n                    od)) [0  .e.  (1 << asid_low_bits) - 1];\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_table := asid_table' \\<rparr>\\<rparr>);\n    tcb \\<leftarrow> gets cur_thread;\n    set_vm_root tcb\n  od\nod\"", "property": "ASID Pool Deletion: Before deleting an ASID pool object, deactivate all page directories installed in it by flushing and invalidating their entries, updating the ASID table, and resetting the VM root for the current thread.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Before deleting an ASID pool object we must deactivate all page\ndirectories that are installed in it."}
{"spec": "definition\ndelete_asid :: \"asid \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid asid pd \\<equiv> do\n  asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n  (case asid_table (asid_high_bits_of asid) of\n    None \\<Rightarrow> return ()\n  | Some pool_ptr \\<Rightarrow>  do\n     pool \\<leftarrow> get_asid_pool pool_ptr;\n     when (pool (ucast asid) = Some pd) $ do\n                flush_space asid;\n                invalidate_asid_entry asid;\n                pool' \\<leftarrow> return (pool (ucast asid := None));\n                set_asid_pool pool_ptr pool';\n                tcb \\<leftarrow> gets cur_thread;\n                set_vm_root tcb\n            od\n    od)\nod\"", "property": "ASID Deletion: When deleting a page directory from an ASID pool, ensure it is deactivated by flushing the address space, invalidating the ASID entry, updating the ASID pool, and resetting the VM root for the current thread.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "When deleting a page directory from an ASID pool we must deactivate\nit."}
{"spec": "definition\nset_vm_root_for_flush :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n\"set_vm_root_for_flush pd asid \\<equiv> do\n    tcb \\<leftarrow> gets cur_thread;\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    not_is_pd \\<leftarrow> (case thread_root of\n                    ArchObjectCap (PageDirectoryCap cur_pd (Some _)) \\<Rightarrow> return (cur_pd \\<noteq> pd)\n                  | _ \\<Rightarrow> return True);\n    (if not_is_pd then do\n        arm_context_switch pd asid;\n        return True\n    od\n    else return False)\nod\"\n\ndefinition\ndo_flush :: \"flush_type \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\" where\n\"do_flush flush_type vstart vend pstart \\<equiv>\n    case flush_type of\n       Clean \\<Rightarrow> cleanCacheRange_RAM vstart vend pstart\n     | Invalidate \\<Rightarrow> invalidateCacheRange_RAM vstart vend pstart\n     | CleanInvalidate \\<Rightarrow> cleanInvalidateCacheRange_RAM vstart vend pstart\n     | Unify \\<Rightarrow> do\n         cleanCacheRange_PoU vstart vend pstart;\n         dsb;\n         invalidateCacheRange_I vstart vend pstart;\n         branchFlushRange vstart vend pstart;\n         isb\n     od\"", "property": "Flush Operations: Perform cache flush operations on a specific address space by switching to the corresponding address space and executing the desired flush operation (clean, invalidate, clean and invalidate, or unify). Ensure that the current thread's address space is updated if necessary, and the flush operation is executed correctly. \n\nAddress Space Switching: Switch to a particular address space for a flush operation by updating the current thread's address space if it does not match the target address space.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch to a particular address space in order to perform a flush\noperation."}
{"spec": "definition\nflush_table :: \"word32 \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_table pd asid vptr pt \\<equiv> do\n    assert (vptr && mask (pageBitsForSize ARMSection) = 0);\n    root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    when (maybe_hw_asid \\<noteq> None) $ do\n      hw_asid \\<leftarrow> return (the maybe_hw_asid);\n      do_machine_op $ invalidateLocalTLB_ASID hw_asid;\n      when root_switched $ do\n        tcb \\<leftarrow> gets cur_thread;\n        set_vm_root tcb\n      od\n    od\nod\"", "property": "Flush Table Mappings: Flush the mappings associated with a page table, ensuring that the virtual memory root is set correctly and the local TLB is invalidated for the specified ASID. \n\nSubproperties:\n- Validate the virtual pointer alignment.\n- Set the virtual memory root for flushing.\n- Load the hardware ASID.\n- Invalidate the local TLB for the specified ASID.\n- Set the virtual memory root if the root was switched.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a page table."}
{"spec": "definition\nflush_page :: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_page page_size pd asid vptr\\<equiv> do\n    assert (vptr && mask pageBits = 0);\n    root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    when (maybe_hw_asid \\<noteq> None) $ do\n      hw_asid \\<leftarrow> return (the maybe_hw_asid);\n      do_machine_op $ invalidateLocalTLB_VAASID (vptr || ucast hw_asid);\n      when root_switched $ do\n          tcb \\<leftarrow> gets cur_thread;\n          set_vm_root tcb\n      od\n   od\nod\"", "property": "Flush Page Mappings: Flush the mappings associated with a given page, ensuring that the virtual memory is correctly updated and the hardware's translation lookaside buffer (TLB) is invalidated for the specified address space identifier (ASID) and virtual pointer (vptr). \n\nSubproperties:\n- Validate the virtual pointer alignment.\n- Set the virtual memory root for flushing.\n- Load the hardware ASID.\n- Invalidate the local TLB for the specified virtual address and ASID.\n- Update the virtual memory root if necessary.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a given page."}
{"spec": "definition\npage_table_mapped :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\" where\n\"page_table_mapped asid vaddr pt \\<equiv> doE\n    pd \\<leftarrow> find_pd_for_asid asid;\n    pd_slot \\<leftarrow> returnOk $ lookup_pd_slot pd vaddr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    case pde of\n      PageTablePDE addr _ _ \\<Rightarrow> returnOk $\n             if addrFromPPtr pt = addr then Some pd else None\n    | _ \\<Rightarrow> returnOk None\nodE <catch> (K $ return None)\"", "property": "Page Table Mapping: Return the optional page directory that a page table is mapped in, based on the address space identifier, virtual address, and page table object reference.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Return the optional page directory a page table is mapped in."}
{"spec": "definition\nunmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page_table asid vaddr pt \\<equiv> do\n    pdOpt \\<leftarrow> page_table_mapped asid vaddr pt;\n    case pdOpt of\n      None \\<Rightarrow> return ()\n    | Some pd \\<Rightarrow> do\n        pd_slot \\<leftarrow> return $ lookup_pd_slot pd vaddr;\n        store_pde pd_slot InvalidPDE;\n        do_machine_op $ cleanByVA_PoU pd_slot (addrFromPPtr pd_slot);\n        flush_table pd asid vaddr pt\n    od\nod\"", "property": "Unmap Page Table: Remove the mapping of a page table from its page directory, ensuring that the corresponding page directory entry is invalidated and the translation lookaside buffer (TLB) is updated to reflect the change. \n\nSubproperties:\n- Invalidate Page Directory Entry: Mark the page directory entry as invalid to prevent further accesses.\n- Clean and Flush: Clean the page directory entry and flush the TLB to ensure consistency and prevent stale translations.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a page table from its page directory."}
{"spec": "definition\ncheck_mapping_pptr :: \"obj_ref \\<Rightarrow> vmpage_size \\<Rightarrow> (obj_ref + obj_ref) \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n\"check_mapping_pptr pptr pgsz tablePtr \\<equiv> case tablePtr of\n   Inl ptePtr \\<Rightarrow> do\n     pte \\<leftarrow> get_pte ptePtr;\n     return $ case pte of\n       SmallPagePTE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSmallPage\n     | LargePagePTE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMLargePage\n     | _ \\<Rightarrow> False\n   od\n | Inr pdePtr \\<Rightarrow> do\n     pde \\<leftarrow> get_pde pdePtr;\n     return $ case pde of\n       SectionPDE x _ _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSection\n     | SuperSectionPDE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSuperSection\n     | _ \\<Rightarrow> False\n   od\"\n\n\ndefinition\n  \"last_byte_pte x \\<equiv> let pte_bits = 2 in x + ((1 << pte_bits) - 1)\"\n\ndefinition\n  \"last_byte_pde x \\<equiv> let pde_bits = 2 in x + ((1 << pde_bits) - 1)\"", "property": "Check Mapping Physical Pointer: Verify that a given frame is mapped by a specific mapping entry, ensuring the frame's physical address and page size match the mapping entry's attributes. \n\nMapping Entry Attributes: Distinguish between different types of mapping entries (PTE and PDE) and their corresponding page sizes (SmallPage, LargePage, Section, and SuperSection). \n\nFrame Address Validation: Validate the frame's physical address against the mapping entry's address, considering the page size and type.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Check that a given frame is mapped by a given mapping entry."}
{"spec": "definition\nunmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page pgsz asid vptr pptr \\<equiv> doE\n    pd \\<leftarrow> find_pd_for_asid asid;\n    (case pgsz of\n          ARMSmallPage \\<Rightarrow> doE\n            p \\<leftarrow> lookup_pt_slot pd vptr;\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inl p);\n            liftE $ do\n                store_pte p InvalidPTE;\n                do_machine_op $ cleanByVA_PoU p (addrFromPPtr p)\n            od\n          odE\n        | ARMLargePage \\<Rightarrow> doE\n            p \\<leftarrow> lookup_pt_slot pd vptr;\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inl p);\n            liftE $ do\n                assert $ p && mask 6 = 0;\n                slots \\<leftarrow> return (map (\\<lambda>x. x + p) [0, 4  .e.  60]);\n                mapM (swp store_pte InvalidPTE) slots;\n                do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pte (last slots))\n                                                    (addrFromPPtr (hd slots))\n            od\n          odE\n        | ARMSection \\<Rightarrow> doE\n            p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inr p);\n            liftE $ do\n                store_pde p InvalidPDE;\n                do_machine_op $ cleanByVA_PoU p (addrFromPPtr p)\n            od\n          odE\n        | ARMSuperSection \\<Rightarrow> doE\n            p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inr p);\n            liftE $ do\n                assert $ p && mask 6 = 0;\n                slots \\<leftarrow> return (map (\\<lambda>x. x + p) [0, 4  .e.  60]);\n                mapM (swp store_pde InvalidPDE) slots;\n                do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pde (last slots))\n                                                    (addrFromPPtr (hd slots))\n            od\n          odE);\n    liftE $ flush_page pgsz pd asid vptr\nodE <catch> (K $ return ())\"", "property": "Unmap Page: Unmap a mapped page if the given mapping details are still current, ensuring that the page is correctly removed from the page table and the cache is cleaned. \n\nSubproperties:\n- Check Mapping: Verify that the given mapping details are still current before attempting to unmap the page.\n- Update Page Table: Update the page table by storing an invalid page table entry (PTE) or page directory entry (PDE) for the specified page.\n- Clean Cache: Clean the cache range associated with the unmapped page to ensure data consistency.\n- Flush Page: Flush the page from the translation lookaside buffer (TLB) to ensure that the unmapping is propagated to the hardware.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition\n  arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\"\nwhere\n  \"arch_derive_cap c \\<equiv> case c of\n     PageTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageTableCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageDirectoryCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageDirectoryCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageCap dev r R pgs x \\<Rightarrow> returnOk (ArchObjectCap (PageCap dev r R pgs None))\n   | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n   | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\"", "property": "Derivation of Architecture-Specific Capabilities: Ensures that PageDirectory and PageTable capabilities can only be copied when they have a valid virtual ASID and location assigned, preventing multiple current virtual ASIDs for page directories and shared page tables between address spaces or virtual locations.\n\nSubproperties:\n- PageTableCap and PageDirectoryCap with a valid virtual ASID can be derived.\n- PageTableCap and PageDirectoryCap without a valid virtual ASID cannot be derived.\n- PageCap, ASIDControlCap, and ASIDPoolCap can be derived without restrictions.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "PageDirectory and PageTable capabilities cannot be copied until they\nhave a virtual ASID and location assigned. This is because page directories\ncannot have multiple current virtual ASIDs and page tables cannot be shared\nbetween address spaces or virtual locations."}
{"spec": "definition\n  arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "ARM-Specific Capability Integrity: Ensure that no user-modifiable data is stored in ARM-specific capabilities, maintaining the integrity and security of the system by preventing unauthorized modifications.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in ARM-specific capabilities."}
{"spec": "definition\n  arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n    (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n    delete_asid_pool b ptr;\n    return (NullCap, NullCap)\n    od\n  | (PageDirectoryCap ptr (Some a), True) \\<Rightarrow> do\n    delete_asid a ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageTableCap ptr (Some (a, v)), True) \\<Rightarrow> do\n    unmap_page_table a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageCap _ ptr _ s (Some (a, v)), _) \\<Rightarrow> do\n     unmap_page s a v ptr;\n     return (NullCap, NullCap)\n  od\n  | _ \\<Rightarrow> return (NullCap, NullCap)\"\n\n\ndefinition (* prepares a thread for deletion; nothing to do for ARM *)\n  prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"prepare_thread_delete p \\<equiv> return ()\"", "property": "Architectural Capability Finalisation: Ensure that ARM-specific capabilities are properly finalised by deleting or unmapping associated resources, such as ASID pools, page directories, page tables, and pages, when they are no longer needed.\n\nThread Deletion Preparation: No additional steps are required to prepare an ARM thread for deletion.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of ARM-specific\ncapabilities."}
{"spec": "definition\n  is_valid_vtable_root :: \"cap \\<Rightarrow> bool\" where\n  \"is_valid_vtable_root c \\<equiv> \\<exists>r a. c = ArchObjectCap (PageDirectoryCap r (Some a))\"\n\ndefinition\ncheck_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n\"check_valid_ipc_buffer vptr c \\<equiv> case c of\n  (ArchObjectCap (PageCap False _ _ _ _)) \\<Rightarrow> doE\n    whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError;\n    returnOk ()\n  odE\n| _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Valid IPC Buffer Capability: Ensure the capability associated with a thread's IPC buffer is valid. For ARM architecture, the capability must be to a page directory. \n\nSubproperties:\n- Alignment Check: Verify the IPC buffer's virtual address is aligned to the message alignment bits.\n- Capability Type Check: Confirm the capability is of the correct type (PageCap) and meets specific conditions (e.g., not a device memory page).", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A thread's virtual address space capability must be to a page directory\nto be valid on the ARM architecture."}
{"spec": "definition\nattribs_from_word :: \"word32 \\<Rightarrow> vm_attributes\" where\n\"attribs_from_word w \\<equiv>\n  let V = (if w !!0 then {PageCacheable} else {});\n      V' = (if w!!1 then insert ParityEnabled V else V)\n  in if w!!2 then insert XNever V' else V'\"", "property": "VM Attribute Decoding: Decode a 32-bit word to determine the VM attributes for a mapping, including cacheability, parity enablement, and execute never properties. \n\nSubproperties:\n- Cacheability: Determine if the mapping is cacheable based on bit 0 of the word.\n- Parity Enablement: Determine if parity is enabled for the mapping based on bit 1 of the word.\n- Execute Never: Determine if the mapping should never be executed based on bit 2 of the word.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Decode a user argument word describing the kind of VM attributes a\nmapping is to have."}
{"spec": "definition\n  update_map_data :: \"arch_cap \\<Rightarrow> (word32 \\<times> word32) option \\<Rightarrow> arch_cap\" where\n  \"update_map_data cap m \\<equiv> case cap of PageCap dev p R sz _ \\<Rightarrow> PageCap dev p R sz m\n                                     | PageTableCap p _ \\<Rightarrow> PageTableCap p m\"", "property": "Update Mapping Data: Update the mapping data saved in a page or page table capability with new data. \n\nMapping Data Update Rules: \n- For a Page Capability, update the mapping data while preserving other attributes (device, physical address, read-only status, and size).\n- For a Page Table Capability, update the mapping data while preserving the physical address.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Update the mapping data saved in a page or page table capability."}
{"spec": "definition\n  resolve_vaddr :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> ((vmpage_size \\<times> obj_ref) option, 'z::state_ext) s_monad\"\nwhere\n  \"resolve_vaddr pd vaddr \\<equiv> do\n     pd_slot \\<leftarrow> return $ lookup_pd_slot pd vaddr;\n     pde \\<leftarrow> get_master_pde pd_slot;\n     case pde of\n         SectionPDE f _ _ _ \\<Rightarrow> return $ Some (ARMSection, f)\n       | SuperSectionPDE f _ _ \\<Rightarrow> return $ Some (ARMSuperSection, f)\n       | PageTablePDE t _ _ \\<Rightarrow> (do\n           pt \\<leftarrow> return $ ptrFromPAddr t;\n           pte_slot \\<leftarrow> return $ lookup_pt_slot_no_fail pt vaddr;\n           pte \\<leftarrow> get_master_pte pte_slot;\n           case pte of\n               LargePagePTE f _ _ \\<Rightarrow> return $ Some (ARMLargePage, f)\n             | SmallPagePTE f _ _ \\<Rightarrow> return $ Some (ARMSmallPage, f)\n             | _ \\<Rightarrow> return None\n         od)\n       | _ \\<Rightarrow> return None\n   od\"", "property": "Resolve Virtual Address: Given a virtual address and a page directory, retrieve information about the corresponding frame, including its size and object reference. \n\nSubproperties:\n- The function first looks up the page directory slot for the given virtual address.\n- It then retrieves the page directory entry (PDE) for that slot.\n- Depending on the type of PDE, it either returns the frame information directly or performs further lookups in the page table.\n- If the PDE points to a page table, it looks up the page table entry (PTE) for the given virtual address and retrieves the frame information from there.\n- If the PTE is not a valid page, it returns None.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get information about the frame of a given virtual address"}
{"spec": "definition\n  in_user_frame :: \"word32 \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n  \"in_user_frame p s \\<equiv>\n   \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) =\n        Some (ArchObj (DataPage False sz))\"", "property": "User Frame Containment: A pointer is considered to be inside a user frame if its top bits point to a DataPage object in the kernel heap.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A pointer is inside a user frame if its top bits point to a @{text DataPage}.\n"}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\nend\nend", "property": "Message Alignment: The message alignment value is made visible through the msg_align_bits constant.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition\n  asid_high_bits_of :: \"asid \\<Rightarrow> 7 word\" where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"\n\nlocale_abbrev\n  \"asid_table \\<equiv> \\<lambda>s. arm_asid_table (arch_state s)\"", "property": "Virtual ASID Management: Extract the high bits of a virtual ASID.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "text \\<open>Manipulate ASID pools, page directories and page tables in the kernel\nheap.\\<close>", "property": "Kernel Heap Access: Provide access to ASID pools, page directories, and page tables within the kernel heap, enabling manipulation of these critical data structures for effective memory management.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\"\n  where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"\n\ndefinition\n  get_asid_pool :: \"obj_ref \\<Rightarrow> (10 word \\<rightharpoonup> obj_ref,'z::state_ext) s_monad\" where\n  \"get_asid_pool ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (ASIDPool pool) \\<Rightarrow> return pool\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_asid_pool :: \"obj_ref \\<Rightarrow> (10 word \\<rightharpoonup> obj_ref) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"set_asid_pool ptr pool \\<equiv> set_object ptr (ArchObj (arch_kernel_obj.ASIDPool pool))\"\n\ndefinition\n  get_pd :: \"obj_ref \\<Rightarrow> (12 word \\<Rightarrow> pde,'z::state_ext) s_monad\" where\n  \"get_pd ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageDirectory pd) \\<Rightarrow> return pd\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pd :: \"obj_ref \\<Rightarrow> (12 word \\<Rightarrow> pde) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pd ptr pd \\<equiv> set_object ptr (ArchObj (PageDirectory pd))\"\n\ndefinition\n  set_current_pd :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_current_pd pd \\<equiv> do\n     dsb;\n     writeTTBR0 ((pd && 0xffffe000) || 0x18);\n     isb\n   od\"", "property": "Accessing the ARM VSpace: \nKernel Heap Accessors provide functions to access and modify ARM VSpace objects, including ASID pools and page directories.\n\nSubproperties:\nGet ASID Pool: Retrieve the ASID pool associated with a given object reference.\nSet ASID Pool: Update the ASID pool associated with a given object reference.\nGet Page Directory: Retrieve the page directory associated with a given object reference.\nSet Page Directory: Update the page directory associated with a given object reference.\nSet Current Page Directory: Set the current page directory using a given physical address.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": " declared in Arch as workaround for VER-1099 "}
{"spec": "definition\n  get_pde :: \"obj_ref \\<Rightarrow> (pde,'z::state_ext) s_monad\" where\n  \"get_pde ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pd_bits);\n     offset \\<leftarrow> return ((ptr && mask pd_bits) >> 2);\n     pd \\<leftarrow> get_pd base;\n     return $ pd (ucast offset)\n   od\"\n\ndefinition\n  store_pde :: \"obj_ref \\<Rightarrow> pde \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pde p pde \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pd_bits);\n    offset \\<leftarrow> return ((p && mask pd_bits) >> 2);\n    pd \\<leftarrow> get_pd base;\n    pd' \\<leftarrow> return $ pd (ucast offset := pde);\n    set_pd base pd'\n  od\"\n\n\ndefinition\n  get_pt :: \"obj_ref \\<Rightarrow> (word8 \\<Rightarrow> pte,'z::state_ext) s_monad\" where\n  \"get_pt ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageTable pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pt :: \"obj_ref \\<Rightarrow> (word8 \\<Rightarrow> pte) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pt ptr pt \\<equiv> set_object ptr (ArchObj (PageTable pt))\"", "property": "Kernel Heap Accessors: Provide functions to access and manipulate page directory entries (PDEs) and page tables (PTs) in kernel memory. \n\nGet PDE: Retrieve the actual PDE from a given pointer to a PDE in kernel memory.\nStore PDE: Store a given PDE at a specified location in kernel memory.\nGet PT: Retrieve the page table associated with a given pointer in kernel memory.\nSet PT: Set the page table associated with a given pointer in kernel memory.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PDE in kernel memory\n  and returns the actual PDE."}
{"spec": "definition\n  get_pte :: \"obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\" where\n  \"get_pte ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pt_bits);\n     offset \\<leftarrow> return ((ptr && mask pt_bits) >> 2);\n     pt \\<leftarrow> get_pt base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pte :: \"obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pte p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pt_bits);\n    offset \\<leftarrow> return ((p && mask pt_bits) >> 2);\n    pt \\<leftarrow> get_pt base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pt base pt'\n  od\"", "property": "Kernel Heap Accessors: Access and modify page table entries (PTEs) in kernel memory. \n\nGet PTE: Retrieve the actual PTE from a given pointer to a PTE in kernel memory, using bitwise operations to extract the base address and offset.\n\nStore PTE: Update a PTE at a given pointer in kernel memory, using bitwise operations to extract the base address and offset, and then modifying the corresponding page table.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory\n  and returns the actual PTE."}
{"spec": "text \\<open>The kernel window is mapped into every virtual address space from the\n@{term kernel_base} pointer upwards. This function copies the mappings which\ncreate the kernel window into a new page directory object.\\<close>\ndefinition\ncopy_global_mappings :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"copy_global_mappings new_pd \\<equiv> do\n    global_pd \\<leftarrow> gets (arm_global_pd \\<circ> arch_state);\n    pde_bits \\<leftarrow> return 2;\n    pd_size \\<leftarrow> return (1 << (pd_bits - pde_bits));\n    mapM_x (\\<lambda>index. do\n        offset \\<leftarrow> return (index << pde_bits);\n        pde \\<leftarrow> get_pde (global_pd + offset);\n        store_pde (new_pd + offset) pde\n    od) [kernel_base >> 20  .e.  pd_size - 1]\nod\"", "property": "Copy Global Mappings: Duplicate the kernel window mappings from the global page directory into a new page directory, ensuring the kernel window is accessible in every virtual address space.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition\nlookup_pd_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\" where\n\"lookup_pd_slot pd vptr \\<equiv>\n    let pd_index = vptr >> 20\n    in pd + (pd_index << 2)\"", "property": "Compute PDE Pointer: Calculate the pointer to the Page Directory Entry (PDE) in kernel memory given a page-directory reference and a virtual address.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PDE in kernel memory"}
{"spec": "definition\nlookup_pt_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"lookup_pt_slot pd vptr \\<equiv> doE\n    pd_slot \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    (case pde of\n          PageTablePDE ptab _ _ \\<Rightarrow>   (doE\n            pt \\<leftarrow> returnOk (ptrFromPAddr ptab);\n            pt_index \\<leftarrow> returnOk ((vptr >> 12) && 0xff);\n            pt_slot \\<leftarrow> returnOk (pt + (pt_index << 2));\n            returnOk pt_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability 20)\nodE\"", "property": "Lookup Page Table Slot: Compute the pointer to the Page Table Entry (PTE) in kernel memory given a page-directory reference and a virtual address, failing if the virtual address is mapped on a section or super section. \n\nSubproperties:\n- The function first looks up the page directory slot using the page-directory reference and virtual address.\n- It then retrieves the Page Directory Entry (PDE) from the page directory slot.\n- If the PDE is a Page Table PDE, it extracts the page table address and calculates the page table index from the virtual address.\n- The function then computes the page table slot address using the page table address and index, and returns it.\n- If the PDE is not a Page Table PDE, the function throws a MissingCapability error.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PTE in kernel memory.\n  Note that the function fails if the virtual address is mapped on a section or\n  super section."}
{"spec": "definition\n  lookup_pt_slot_no_fail :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\"\nwhere\n  \"lookup_pt_slot_no_fail pt vptr \\<equiv>\n     let pt_index = ((vptr >> 12) && 0xff)\n     in pt + (pt_index << 2)\"\n\nend\n\nend", "property": "Lookup PT Slot: Calculate the address of a page table slot for a given virtual address and page table.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pt_slot} when the pd is already known"}
{"spec": "text \\<open>This definition ensures that the given pointer is aligned\nto the given page size.\\<close>\n\ndefinition\n  check_vp_alignment :: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $\n       throwError AlignmentError\"", "property": "Check Virtual Page Alignment: Ensures that a given virtual page pointer is aligned to the specified page size, throwing an AlignmentError if it is not.", "title": "./spec/abstract/ARM/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "definition\n  label_to_flush_type :: \"invocation_label \\<Rightarrow> flush_type\"\nwhere\n  \"label_to_flush_type label \\<equiv> case label of\n       ArchInvocationLabel ARMPDClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPageClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPDInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPageInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPDCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPageCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPDUnify_Instruction \\<Rightarrow> Unify\n     | ArchInvocationLabel ARMPageUnify_Instruction \\<Rightarrow> Unify\"", "property": "Architecture-specific System Call Decoding: Maps user-supplied invocation labels to specific flush types, determining the method to invoke for various architecture-specific system calls. \n\nFlush Type Mapping: Maps invocation labels to flush types, including Clean, Invalidate, CleanInvalidate, and Unify, to facilitate the execution of architecture-specific system calls.", "title": "./spec/abstract/ARM/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": "This definition converts a user-supplied argument into an\ninvocation label, used to determine the method to invoke.\n"}
{"spec": "text \\<open>This definition decodes architecture-specific invocations.\n\\<close>\n\ndefinition\n  page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\nwhere\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"\n\n\ndefinition\n  arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n\"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n\n  PageDirectoryCap _ _ \\<Rightarrow>\n    if isPDFlushLabel (invocation_type label) then\n    if length args > 1\n    then let start = args ! 0;\n             end = args ! 1\n    in doE\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            whenE (start \\<ge> kernel_base \\<or> end > kernel_base) $ throwError IllegalOperation;\n            (pd,asid) \\<leftarrow> (case cap of\n                    PageDirectoryCap pd (Some asid) \\<Rightarrow> returnOk (pd,asid)\n                  | _ \\<Rightarrow> throwError $ InvalidCapability 0);\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 0;\n            frame_info \\<leftarrow> liftE $ resolve_vaddr pd start;\n            case frame_info of\n                None \\<Rightarrow> returnOk $ InvokePageDirectory PageDirectoryNothing\n              | Some (frame_size, frame_base) \\<Rightarrow>\n                    let base_start = page_base start frame_size;\n                        base_end = page_base (end - 1) frame_size;\n                        offset = start && mask (pageBitsForSize frame_size);\n                        pstart = frame_base + offset\n                    in doE\n                        whenE (base_start \\<noteq> base_end) $ throwError $\n                            RangeError start (base_start + mask (pageBitsForSize frame_size));\n                        returnOk $ InvokePageDirectory $\n                            PageDirectoryFlush (label_to_flush_type (invocation_type label))\n                            start (end - 1) pstart pd asid\n                    odE\n    odE\n    else throwError TruncatedMessage\n    else throwError IllegalOperation\n\n| PageTableCap p mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageTableMap then\n    if length args > 1 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             attr = args ! 1;\n             pd_cap = fst (extra_caps ! 0)\n    in doE\n            whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            whenE (vaddr \\<ge> kernel_base) $ throwError $ InvalidArgument 0;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            pd_index \\<leftarrow> returnOk (shiftr vaddr 20);\n            vaddr' \\<leftarrow> returnOk (vaddr && ~~ mask 20);\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << 2));\n            oldpde \\<leftarrow> liftE $ get_master_pde pd_slot;\n            unlessE (oldpde = InvalidPDE) $ throwError DeleteFirst;\n            pde \\<leftarrow> returnOk (PageTablePDE (addrFromPPtr p)\n                               (attribs_from_word attr \\<inter> {ParityEnabled}) 0);\n            returnOk $ InvokePageTable $\n                PageTableMap\n                (ArchObjectCap $ PageTableCap p (Some (asid, vaddr')))\n                cte pde pd_slot\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageTableUnmap\n    then doE\n            final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n            unlessE final $ throwError RevokeFirst;\n            returnOk $ InvokePageTable $ PageTableUnmap (ArchObjectCap cap) cte\n    odE\n    else throwError IllegalOperation\n\n| PageCap dev p R pgsz mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageMap then\n    if length args > 2 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             rights_mask = args ! 1;\n             attr = args ! 2;\n             pd_cap = fst (extra_caps ! 0)\n        in doE\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            case mapped_address of\n              Some (asid', vaddr') \\<Rightarrow> doE\n                whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n                whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0)\n              odE\n            | None \\<Rightarrow> doE\n                vtop \\<leftarrow> returnOk (vaddr + (1 << (pageBitsForSize pgsz)) - 1);\n                whenE (vtop \\<ge> kernel_base) $ throwError $ InvalidArgument 0\n              odE;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            vm_rights \\<leftarrow> returnOk (mask_vm_rights R (data_to_rights rights_mask));\n            check_vp_alignment pgsz vaddr;\n            entries \\<leftarrow> create_mapping_entries (addrFromPPtr p)\n                                              vaddr pgsz vm_rights\n                                              (attribs_from_word attr) pd;\n            ensure_safe_mapping entries;\n            returnOk $ InvokePage $ PageMap asid\n                (ArchObjectCap $ PageCap dev p R pgsz (Some (asid, vaddr)))\n                cte entries\n        odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageUnmap\n    then  returnOk $ InvokePage $ PageUnmap cap cte\n    else if isPageFlushLabel (invocation_type label) then\n        if length args > 1\n        then let start = args ! 0;\n                 end = args ! 1\n        in doE\n            (asid, vaddr) \\<leftarrow> (case mapped_address of\n                Some a \\<Rightarrow> returnOk a\n              | _ \\<Rightarrow> throwError IllegalOperation);\n            pd \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            page_size \\<leftarrow> returnOk $ 1 << pageBitsForSize pgsz;\n            whenE (start \\<ge> page_size \\<or> end > page_size) $ throwError $ InvalidArgument 0;\n            returnOk $ InvokePage $ PageFlush\n                (label_to_flush_type (invocation_type label)) (start + vaddr)\n                (end + vaddr - 1) (addrFromPPtr p + start) pd asid\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageGetAddress\n    then returnOk $ InvokePage $ PageGetAddr p\n  else  throwError IllegalOperation\n\n| ASIDControlCap \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMASIDControlMakePool then\n    if length args > 1 \\<and> length extra_caps > 1\n    then let index = args ! 0;\n             depth = args ! 1;\n             (untyped, parent_slot) = extra_caps ! 0;\n             root = fst (extra_caps ! 1)\n         in doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            free_set \\<leftarrow> returnOk (- dom asid_table \\<inter> {x. x \\<le> 2 ^ asid_high_bits - 1});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n            base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n            (p,n) \\<leftarrow> (case untyped of UntypedCap False p n f \\<Rightarrow> returnOk (p,n)\n                                    | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            frame \\<leftarrow> (if n = pageBits\n                      then doE\n                        ensure_no_children parent_slot;\n                        returnOk p\n                      odE\n                      else  throwError $ InvalidCapability 1);\n            dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n            ensure_empty dest_slot;\n            returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n        odE\n    else  throwError TruncatedMessage\n    else  throwError IllegalOperation\n\n| ASIDPoolCap p base \\<Rightarrow>\n  if invocation_type label = ArchInvocationLabel ARMASIDPoolAssign then\n  if length extra_caps > 0\n  then\n    let (pd_cap, pd_cap_slot) = extra_caps ! 0\n     in case pd_cap of\n          ArchObjectCap (PageDirectoryCap _ None) \\<Rightarrow> doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n            whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n            whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n            pool \\<leftarrow> liftE $ get_asid_pool p;\n            free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n            returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pd_cap_slot\n          odE\n        | _ \\<Rightarrow>  throwError $ InvalidCapability 1\n  else  throwError TruncatedMessage\n  else  throwError IllegalOperation\"\n\n\ndefinition\n  arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\" where\n \"arch_data_to_obj_type n \\<equiv>\n  if n = 0 then Some PageDirectoryObj\n  else if n = 1 then Some SmallPageObj\n  else if n = 2 then Some LargePageObj\n  else if n = 3 then Some SectionObj\n  else if n = 4 then Some SuperSectionObj\n  else if n = 5 then Some PageTableObj\n  else None\"\n\ndefinition\n  arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"arch_check_irq irq \\<equiv> whenE (irq > maxIRQ) $ throwError (RangeError 0 maxIRQ)\"\n\ndefinition arch_decode_irq_control_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list \\<Rightarrow> (arch_irq_control_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_irq_control_invocation label args src_slot cps \\<equiv>\n    (if invocation_type label = ArchInvocationLabel ARMIRQIssueIRQHandler\n      then if length args \\<ge> 4 \\<and> length cps \\<ge> 1\n        then let irq_word = args ! 0;\n                 trigger = args ! 1;\n                 index = args ! 2;\n                 depth = args ! 3;\n                 cnode = cps ! 0;\n                 irq = ucast irq_word\n        in doE\n          arch_check_irq irq_word;\n          irq_active \\<leftarrow> liftE $ is_irq_active irq;\n          whenE irq_active $ throwError RevokeFirst;\n\n          dest_slot \\<leftarrow> lookup_target_slot cnode (data_to_cptr index) (unat depth);\n          ensure_empty dest_slot;\n\n          returnOk $ ArchIRQControlIssue irq dest_slot src_slot (trigger \\<noteq> 0)\n        odE\n      else throwError TruncatedMessage\n    else throwError IllegalOperation)\"\n\nend\n\nend", "property": "Architecture-specific System Call Decoding: Decodes architecture-specific invocations, handling various system calls such as page directory and page table management (flushing, mapping, unmapping), ASID control and pool management (making pools, assigning ASIDs), and IRQ control (issuing IRQ handlers).\n\nSubproperties:\n\n* Page Directory Management: Handles page directory invocations, including flushing and mapping operations.\n* Page Table Management: Handles page table invocations, including mapping and unmapping operations.\n* ASID Control and Pool Management: Handles ASID control and pool management invocations, including making pools and assigning ASIDs.\n* IRQ Control: Handles IRQ control invocations, including issuing IRQ handlers.", "title": "./spec/abstract/ARM/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "datatype flush_type = Clean | Invalidate | CleanInvalidate | Unify\n\ndatatype page_directory_invocation =\n    PageDirectoryFlush (pd_flush_type: flush_type) (pd_flush_start: vspace_ref)\n                       (pd_flush_end: vspace_ref) (pd_flush_pstart: word32)\n                       (pd_flush_pd: obj_ref) (pd_flush_asid: asid)\n  | PageDirectoryNothing\n\ndatatype page_table_invocation =\n    PageTableMap cap cslot_ptr pde obj_ref\n  | PageTableUnmap cap cslot_ptr\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation\n     = PageMap\n         (page_map_asid: asid)\n         (page_map_cap: cap)\n         (page_map_ct_slot: cslot_ptr)\n         (page_map_entries: \"pte \\<times> (obj_ref list) + pde \\<times> (obj_ref list)\")\n     | PageUnmap\n         (page_unmap_cap: arch_cap)\n         (page_unmap_cap_slot: cslot_ptr)\n     | PageFlush\n         (page_flush_type: flush_type)\n         (page_flush_start: vspace_ref)\n         (page_flush_end: vspace_ref)\n         (page_flush_pstart: word32)\n         (page_flush_pd: obj_ref)\n         (page_flush_asid: asid)\n     | PageGetAddr\n         (page_get_paddr: obj_ref)\n\ndatatype arch_invocation\n     = InvokePageTable page_table_invocation\n     | InvokePageDirectory page_directory_invocation\n     | InvokePage page_invocation\n     | InvokeASIDControl asid_control_invocation\n     | InvokeASIDPool asid_pool_invocation\n\ndatatype arch_copy_register_sets = ARMNoExtraRegisters\n\ndefinition \"ArchDefaultExtraRegisters \\<equiv> ARMNoExtraRegisters\"\n\ndatatype arch_irq_control_invocation =\n    ArchIRQControlIssue irq cslot_ptr cslot_ptr bool\n\nend\n\nend", "property": "ARM-Specific System Call Arguments: Define the arguments for various ARM-specific system calls, including page directory, page table, ASID control, ASID pool, page, and IRQ control invocations. These arguments specify the necessary parameters for each system call, ensuring that the kernel can correctly manage memory, interrupts, and other ARM-specific features.\n\nSubproperties:\n- Page Directory Invocation: Specify the type of flush operation, start and end addresses, page directory, and ASID for page directory flush operations.\n- Page Table Invocation: Define the parameters for mapping and unmapping page tables, including the capability, slot pointer, and object reference.\n- ASID Control Invocation: Specify the parameters for creating an ASID pool, including the object reference, slot pointers, and ASID.\n- ASID Pool Invocation: Define the parameters for assigning an ASID to a pool, including the ASID, object reference, and slot pointer.\n- Page Invocation: Specify the parameters for page operations, including mapping, unmapping, flushing, and getting the physical address of a page.\n- IRQ Control Invocation: Define the parameters for issuing an IRQ, including the IRQ number, slot pointers, and a boolean flag.", "title": "./spec/abstract/ARM/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the various possible\nARM-specific system calls. Selectors are defined for various fields\nfor convenience elsewhere."}
{"spec": "text \\<open>An ASID is simply a word.\\<close>\ntype_synonym asid = \"word32\"\n\ndatatype vm_attribute = ParityEnabled | PageCacheable | Global | XNever\ntype_synonym vm_attributes = \"vm_attribute set\"", "property": "ARM-Specific Data Types: Define architecture-specific data types for the ARM architecture, including the ASID (Application-Specific ID) type as a 32-bit word and VM (Virtual Memory) attributes as a set of flags (ParityEnabled, PageCacheable, Global, XNever).", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific capabilities", "comment": ""}
{"spec": "text \\<open>The ARM kernel supports capabilities for ASID pools and an ASID controller capability,\nalong with capabilities for page directories, page tables, and page mappings.\\<close>\n\ndatatype arch_cap =\n   ASIDPoolCap obj_ref asid\n | ASIDControlCap\n | PageCap bool obj_ref cap_rights vmpage_size \"(asid * vspace_ref) option\"\n | PageTableCap obj_ref \"(asid * vspace_ref) option\"\n | PageDirectoryCap obj_ref \"asid option\"\n\nlemmas arch_cap_cases =\n  arch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P, simplified, rule_format]\n\nlemmas arch_cap_cases_asm =\narch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n  simplified, rule_format, rotated -1]\n\ndefinition\n  is_page_cap :: \"arch_cap \\<Rightarrow> bool\" where\n  \"is_page_cap c \\<equiv> \\<exists>x0 x1 x2 x3 x4. c = PageCap x0 x1 x2 x3 x4\"", "property": "ARM-Specific Capability Types: Supports capabilities for ASID pools, ASID controllers, page directories, page tables, and page mappings, providing the necessary data structures for managing memory and virtualization in the ARM architecture.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "text \\<open>This section gives the types and auxiliary definitions for the\narchitecture-specific objects: a page directory entry (@{text \"pde\"})\ncontains either an invalid entry, a page table reference, a section\nreference, or a super-section reference; a page table entry contains\neither an invalid entry, a large page, or a small page mapping;\nfinally, an architecture-specific object is either an ASID pool, a\npage table, a page directory, or a data page used to model user\nmemory.\n\\<close>\n\ndatatype pde =\n   InvalidPDE\n | PageTablePDE obj_ref vm_attributes machine_word\n | SectionPDE obj_ref vm_attributes machine_word cap_rights\n | SuperSectionPDE obj_ref vm_attributes cap_rights\n\ndatatype pte =\n   InvalidPTE\n | LargePagePTE obj_ref vm_attributes cap_rights\n | SmallPagePTE obj_ref vm_attributes cap_rights\n\ndatatype arch_kernel_obj =\n   ASIDPool \"10 word \\<rightharpoonup> obj_ref\"\n | PageTable \"word8 \\<Rightarrow> pte\"\n | PageDirectory \"12 word \\<Rightarrow> pde\"\n | DataPage bool vmpage_size\n\nlemmas arch_kernel_obj_cases =\n  arch_kernel_obj.induct[where arch_kernel_obj=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P,\n                         simplified, rule_format]\n\nlemmas arch_kernel_obj_cases_asm =\n  arch_kernel_obj.induct[where arch_kernel_obj=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n                         simplified, rule_format, rotated -1]\n\ndefinition cte_level_bits :: nat where\n  \"cte_level_bits \\<equiv> 4\"\n\nprimrec\n  arch_obj_size :: \"arch_cap \\<Rightarrow> nat\"\nwhere\n  \"arch_obj_size (ASIDPoolCap p as) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (PageCap dev x rs sz as4) = pageBitsForSize sz\"\n| \"arch_obj_size (PageDirectoryCap x as2) = 14\"\n| \"arch_obj_size (PageTableCap x as3) = 10\"\n\nprimrec\n  arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_cap_is_device (PageCap dev x rs sz as4) = dev\"\n| \"arch_cap_is_device ASIDControlCap = False\"\n| \"arch_cap_is_device (ASIDPoolCap p as) = False\"\n| \"arch_cap_is_device (PageTableCap x as3) = False\"\n| \"arch_cap_is_device (PageDirectoryCap x as2) = False\"\n\ndefinition tcb_bits :: nat where\n  \"tcb_bits \\<equiv> 9\"\n\ndefinition endpoint_bits :: nat where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat where\n  \"ntfn_bits \\<equiv> 4\"\n\ndefinition untyped_min_bits :: nat where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat where\n  \"untyped_max_bits \\<equiv> 29\"\n\nprimrec\n  arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\"\nwhere\n  \"arch_kobj_size (ASIDPool p) = pageBits\"\n| \"arch_kobj_size (PageTable pte) = 10\"\n| \"arch_kobj_size (PageDirectory pde) = 14\"\n| \"arch_kobj_size (DataPage dev sz) = pageBitsForSize sz\"\n\nprimrec\n  aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\"\nwhere\n  \"aobj_ref (ASIDPoolCap p as) = Some p\"\n| \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref (PageCap dev x rs sz as4) = Some x\"\n| \"aobj_ref (PageDirectoryCap x as2) = Some x\"\n| \"aobj_ref (PageTableCap x as3) = Some x\"\n\nprimrec (nonexhaustive)\n  acap_rights :: \"arch_cap \\<Rightarrow> cap_rights\"\nwhere\n \"acap_rights (PageCap dev x rs sz as) = rs\"\n\ndefinition\n  acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\" where\n \"acap_rights_update rs ac \\<equiv> case ac of\n    PageCap dev x rs' sz as \\<Rightarrow> PageCap dev x (validate_vm_rights rs) sz as\n  | _                   \\<Rightarrow> ac\"", "property": "ARM-Specific Data Types and Architecture-Specific Objects: Define the types and structures for ARM-specific data, including page directory entries (PDEs), page table entries (PTEs), and architecture-specific kernel objects (ASID pools, page tables, page directories, and data pages). These definitions provide the foundation for managing memory and virtualization in the ARM architecture.\n\nSubproperties:\n- PDE and PTE Structures: Specify the formats for PDEs and PTEs, including invalid entries, page table references, section references, super-section references, large page mappings, and small page mappings.\n- Architecture-Specific Kernel Objects: Define the types of architecture-specific kernel objects, including ASID pools, page tables, page directories, and data pages, each with its own set of attributes and properties.\n- Object Sizes and Attributes: Define functions to calculate the sizes of architecture-specific objects and to extract attributes such as device status and capability rights from these objects.\n- Capability Rights Management: Provide functions to update capability rights for architecture-specific capabilities, ensuring that the rights are validated and correctly managed.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "datatype\n  aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | SectionObj\n  | SuperSectionObj\n  | PageTableObj\n  | PageDirectoryObj\n  | ASIDPoolObj\n\ndefinition\n  arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\"\nwhere\n  \"arch_is_frame_type aobj \\<equiv> case aobj of\n         SmallPageObj \\<Rightarrow> True\n       | LargePageObj \\<Rightarrow> True\n       | SectionObj \\<Rightarrow> True\n       | SuperSectionObj \\<Rightarrow> True\n       | _ \\<Rightarrow> False\"\n\ndefinition\n  arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\" where\n \"arch_default_cap tp r n dev \\<equiv> case tp of\n  SmallPageObj \\<Rightarrow> PageCap dev r vm_read_write ARMSmallPage None\n  | LargePageObj \\<Rightarrow> PageCap dev r vm_read_write ARMLargePage None\n  | SectionObj \\<Rightarrow> PageCap dev r vm_read_write ARMSection None\n  | SuperSectionObj \\<Rightarrow> PageCap dev r vm_read_write ARMSuperSection None\n  | PageTableObj \\<Rightarrow> PageTableCap r None\n  | PageDirectoryObj \\<Rightarrow> PageDirectoryCap r None\n  | ASIDPoolObj \\<Rightarrow> ASIDPoolCap r 0\" (* unused *)\n\ndefinition\n  default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\" where\n \"default_arch_object tp dev n \\<equiv> case tp of\n    SmallPageObj \\<Rightarrow> DataPage dev ARMSmallPage\n  | LargePageObj \\<Rightarrow> DataPage dev ARMLargePage\n  | SectionObj \\<Rightarrow> DataPage dev ARMSection\n  | SuperSectionObj \\<Rightarrow> DataPage dev ARMSuperSection\n  | PageTableObj \\<Rightarrow> PageTable (\\<lambda>x. InvalidPTE)\n  | PageDirectoryObj \\<Rightarrow> PageDirectory (\\<lambda>x. InvalidPDE)\n  | ASIDPoolObj \\<Rightarrow> ASIDPool (\\<lambda>_. None)\"\n\ntype_synonym hw_asid = word8\n\ntype_synonym arm_vspace_region_uses = \"vspace_ref \\<Rightarrow> arm_vspace_region_use\"", "property": "ARM-Specific Data Types and Object Initialization: Define architecture-specific object types, determine if an object type is a frame, and initialize default capabilities and objects for various ARM-specific types (e.g., pages, page tables, page directories, ASID pools).\n\n Subproperties:\n- Frame Type Identification: Identify if an ARM-specific object type is a frame type.\n- Default Capability Initialization: Initialize default capabilities for ARM-specific objects, considering factors like device presence, memory access rights, and object size.\n- Default Object Initialization: Initialize default objects for ARM-specific types, including page tables, page directories, and ASID pools, with default attributes and settings.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "text \\<open>The architecture-specific state for the ARM model\nconsists of the first level of the ASID table (@{text \"arm_asid_table\"}), a\nmap from hardware ASIDs to seL4 ASIDs (@{text \"arm_hwasid_table\"}),\nthe next hardware ASID to preempt (@{text \"arm_next_asid\"}), the\ninverse map from seL4 ASIDs to hardware ASIDs (first component of\n@{text \"arm_asid_map\"}), and the address of the page directory and\npage tables mapping the shared address space, along with a description\nof this space (@{text \"arm_global_pd\"}, @{text \"arm_global_pts\"}, and\n@{text \"arm_kernel_vspace\"} respectively).\n\nHardware ASIDs are only ever associated with seL4 ASIDs that have a\ncurrently active page directory. The second component of\n@{text \"arm_asid_map\"} values is the address of that page directory.\n\\<close>\n\nend\n\nqualify ARM_A (in Arch)\n\nrecord arch_state =\n  arm_asid_table    :: \"7 word \\<rightharpoonup> obj_ref\"\n  arm_hwasid_table  :: \"ARM_A.hw_asid \\<rightharpoonup> ARM_A.asid\"\n  arm_next_asid     :: ARM_A.hw_asid\n  arm_asid_map      :: \"ARM_A.asid \\<rightharpoonup> (ARM_A.hw_asid \\<times> obj_ref)\"\n  arm_global_pd     :: obj_ref\n  arm_global_pts    :: \"obj_ref list\"\n  arm_kernel_vspace :: ARM_A.arm_vspace_region_uses\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  pd_bits :: \"nat\" where\n  \"pd_bits \\<equiv> pageBits + 2\"\n\ndefinition\n  pt_bits :: \"nat\" where\n  \"pt_bits \\<equiv> pageBits - 2\"", "property": "ARM Architecture State: Maintains the architecture-specific state for the ARM model, including the ASID table, hardware ASID to seL4 ASID mapping, next hardware ASID, inverse mapping from seL4 ASIDs to hardware ASIDs, and the shared address space mappings.\n\nSubproperties:\n- ASID Management: Manages the mapping between hardware ASIDs and seL4 ASIDs, ensuring that hardware ASIDs are only associated with active page directories.\n- Page Table Management: Maintains the page directory and page table addresses for the shared address space.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable\n  | APageDirectory\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\"\nwhere\n \"aa_type ao \\<equiv> (case ao of\n           PageTable pt             \\<Rightarrow> APageTable\n         | PageDirectory pd         \\<Rightarrow> APageDirectory\n         | DataPage dev sz          \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n         | ASIDPool f               \\<Rightarrow> AASIDPool)\"", "property": "ARM-Specific Data Type Classification: Classify ARM-specific kernel objects into distinct types, including ASID pool, page table, page directory, user data, and device data, based on their characteristics. \n\nSubproperties:\n- ASID Pool Classification: Identify ASID pool objects.\n- Page Table Classification: Identify page table objects.\n- Page Directory Classification: Identify page directory objects.\n- User Data Classification: Identify user data objects and their corresponding virtual memory page sizes.\n- Device Data Classification: Identify device data objects and their corresponding virtual memory page sizes.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "definition\n  badge_bits :: nat where\n  badge_bits_def [simp]: \"badge_bits \\<equiv> 28\"\nend", "property": "Badge Bits Definition: The badge word has a fixed number of bits, specifically 28.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": "For implementation reasons the badge word has differing amounts of bits"}
{"spec": "qualify ARM_A (in Arch)", "property": "ARM-Specific TCB Structure: Defines the architecture-specific components of a Thread Control Block (TCB) for ARM processors.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Arch-specific tcb", "comment": ""}
{"spec": "definition\n  arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\nwhere\n  \"arch_tcb_set_registers regs a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := UserContext regs \\<rparr>\"\n\ndefinition\n  arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\"\nwhere\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\n\nend", "property": "Arch-Specific TCB Accessors: Provide access to the user register part of the arch_tcb, allowing for the retrieval and modification of user registers within the tcb_context. \n\nRegister Access: Get and set user registers within the tcb_context of an arch_tcb.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Arch-specific tcb", "comment": "\n  Accessors for the user register part of the @{text \"arch_tcb\"}.\n  (Because @{typ \"register \\<Rightarrow> machine_word\"} might not be equal to @{typ user_context})."}
{"spec": "(*\nFunctions for fault handling.\n*)\n\nchapter \\<open>arch fault related functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\nwhere\n \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData) od\"\n\ndefinition\n  handle_arch_fault_reply :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"handle_arch_fault_reply vmf thread x y \\<equiv> return True\"\n\n\nend\n\nend", "property": "Arch Fault Handling: Provides functions for creating architecture-specific fault messages and handling replies to these faults, ensuring proper error handling and communication between threads in the event of a fault.\n\nMake Arch Fault Message: Creates an architecture-specific fault message for a given fault and thread, including the program counter, fault address, and architecture-specific data.\n\nHandle Arch Fault Reply: Handles the reply to an architecture-specific fault, currently simply returning True.", "title": "./spec/abstract/ARM/ArchFault_A.thy", "chapter": "arch fault related functions", "section": "", "comment": ""}
{"spec": "(*\nArch-specific functions for the abstract model of CSpace.\n*)\n\nchapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"sanitise_register t r v \\<equiv> case r of\n      CPSR \\<Rightarrow> (v && 0xf8000000) || 0x150\n    | _    \\<Rightarrow> v\"\n\n\ndefinition\n  arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\nwhere\n  \"arch_get_sanitise_register_info t \\<equiv> return False\"\n\ndefinition\n  arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\nwhere\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "TCB Register Management: Sanitizes and manages registers, ensuring that certain registers (e.g., CPSR) have specific values, while others remain unchanged. \n\nArch-specific Register Sanitization: Provides information for sanitizing registers, currently always returning False. \n\nPost-Register Modification: Performs any necessary actions after modifying registers, currently a no-op.", "title": "./spec/abstract/ARM/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "definition\n  update_cnode_cap_data :: \"data \\<Rightarrow> nat \\<times> data\" where\n \"update_cnode_cap_data w \\<equiv>\n    let\n      guard_bits = 18;\n      guard_size' = unat ((w >> cnode_padding_bits) && mask cnode_guard_size_bits);\n      guard'' = (w >> (cnode_padding_bits + cnode_guard_size_bits)) && mask guard_bits\n    in (guard_size', guard'')\"", "property": "Cnode Capability Modification: Extract new guard bits and guard from user-provided data for modifying a cnode capability.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "On a user request to modify a cnode capability, extract new guard bits and guard."}
{"spec": "definition\n  arch_is_physical :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_is_physical cap \\<equiv> case cap of ASIDControlCap \\<Rightarrow> False | _ \\<Rightarrow> True\"", "property": "Distinguish Physical Capabilities: Identify whether an architecture-specific capability refers to a physical object, with ASIDControlCap being the exception.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "For some purposes capabilities to physical objects are treated\ndifferently to others."}
{"spec": "fun\n  arch_same_region_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_same_region_as (PageCap dev r R s x) (PageCap dev' r' R' s' x') =\n   (let\n     topA = r + (1 << pageBitsForSize s) - 1;\n     topB = r' + (1 << pageBitsForSize s') - 1\n   in r \\<le> r' \\<and> topA \\<ge> topB \\<and> r' \\<le> topB)\"\n| \"arch_same_region_as (PageTableCap r x) (PageTableCap r' x') = (r' = r)\"\n| \"arch_same_region_as (PageDirectoryCap r x) (PageDirectoryCap r' x') = (r' = r)\"\n| \"arch_same_region_as ASIDControlCap ASIDControlCap = True\"\n| \"arch_same_region_as (ASIDPoolCap r a) (ASIDPoolCap r' a') = (r' = r)\"\n| \"arch_same_region_as _ _ = False\"", "property": "Architectural Capability Region Check: Determine if two architectural capabilities refer to the same object or if one is contained within the region of the other, ensuring proper management of memory and resources. \n\nSubproperties:\n- Page Capabilities: Check if two page capabilities overlap in their memory regions.\n- Page Table and Directory Capabilities: Verify if two page table or directory capabilities refer to the same object.\n- ASID Control Capabilities: Always consider ASID control capabilities to be in the same region.\n- ASID Pool Capabilities: Check if two ASID pool capabilities refer to the same object.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether the second capability is to the same object or an object\ncontained in the region of the first one."}
{"spec": "definition\n  same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n \"same_aobject_as cp cp' \\<equiv>\n   (case (cp, cp') of\n      (PageCap dev ref _ pgsz _,PageCap dev' ref' _ pgsz' _)\n          \\<Rightarrow> (dev, ref, pgsz) = (dev', ref', pgsz')\n              \\<and> ref \\<le> ref + 2 ^ pageBitsForSize pgsz - 1\n    | _ \\<Rightarrow> arch_same_region_as cp cp')\"", "property": "Arch Capability Equivalence: Two architecture-specific capabilities are considered equivalent if they refer to the same object, which is determined by matching device, reference, and page size attributes for page capabilities, or by using architecture-specific region comparison for other capability types.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "declare same_aobject_as_def[simp]\n\ndefinition\n  arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"arch_is_cap_revocable c c' \\<equiv> False\"\n\nend\nend", "property": "Architectural Capability Revocability: No architectural capabilities are revocable.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": " Proofs don't want to see this definition "}
{"spec": "type_synonym obj_ref            = machine_word\ntype_synonym vspace_ref         = machine_word\n\ntype_synonym data               = machine_word\ntype_synonym cap_ref            = \"bool list\"\ntype_synonym length_type        = machine_word\n\ntype_synonym asid_low_len       = 10\ntype_synonym asid_low_index    = \"asid_low_len word\"\n\ntype_synonym asid_high_len      = 7\ntype_synonym asid_high_index    = \"asid_high_len word\"", "property": "Type Instantiation: Map abstract type names to concrete types for the ARM architecture, defining the representation of object references, virtual space references, data, capability references, and other types. \n\nSubproperties:\n- Object Reference Representation: Use a machine word to represent object references.\n- Data Representation: Use a machine word to represent data.\n- Capability Reference Representation: Use a list of boolean values to represent capability references.\n- Length Type Representation: Use a machine word to represent length types.\n- Address Space Identifier Representation: Define the length and index types for low and high parts of the address space identifier.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object\n  references, user pointers, word-based data, cap references, and so\n  on. This theory provides an instantiation of these names to concrete\n  types for the ARM architecture. Other architectures may have slightly\n  different instantiations.\n"}
{"spec": "type_synonym asid_len           = 17\ntype_synonym asid_rep_len       = machine_word_len\ntype_synonym asid               = \"asid_rep_len word\"", "property": "ASID Representation: ASIDs are represented as machine words with a fixed length, ensuring that the extra bits beyond the required 17 bits are always zero.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": " Making asid a machine_word means that we need invariants that the extra bits are zero. "}
{"spec": "definition\n  oref_to_data   :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_oref   :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition\n  vref_to_data   :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_vref   :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition\n  nat_to_len     :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition\n  data_to_nat    :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition\n  data_to_16     :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition\n  data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition\n  combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition\n  combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Provide functions for converting between different data types, including object references, virtual space references, natural numbers, length types, and capability pointers, to facilitate data manipulation and exchange in the system.\n\nSubproperties:\n- Identity Conversions: Define identity functions for converting between abstract type names, such as object references and data, and virtual space references and data.\n- Numeric Conversions: Specify functions for converting between natural numbers and length types, as well as between data and natural numbers.\n- Bitwise Conversions: Define functions for converting between data and 16-bit words using unsigned casting.\n- Capability Pointer Conversions: Provide a function for converting data to capability pointers using bit list representation.\n- Notification Combinations: Define functions for combining notification badges and messages using bitwise OR operations.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "With the definitions above, most conversions between abstract\ntype names boil down to just the identity function, some convert from\n@{text word} to @{typ nat} and others between different word sizes\nusing @{const ucast}."}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversions: Define conversions between different data types, including object references, virtual references, lengths, and capability pointers, to facilitate automatic unfolding in proofs.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition\n  slot_bits :: nat where\n  \"slot_bits \\<equiv> 4\"\n\ndefinition\n  msg_label_bits :: nat where\n  [simp]: \"msg_label_bits \\<equiv> 20\"\n\ndefinition\n  new_context :: \"user_context\" where\n  \"new_context \\<equiv> UserContext ((\\<lambda>r. 0) (CPSR := 0x150))\"", "property": "Architecture-Dependent Sizes: Define the sizes specific to the underlying machine architecture, including the slot size and message label size. \n\nInitial User Context: Provide an initial user context with default register values and a specific CPSR value.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "The following definitions provide architecture-dependent sizes\n  such as the standard page size and capability size of the underlying\n  machine.\n"}
{"spec": "definition\n  kernel_base :: \"vspace_ref\" where\n  \"kernel_base \\<equiv> 0xe0000000\"\n\ndefinition\n  idle_thread_ptr :: vspace_ref where\n  \"idle_thread_ptr = kernel_base + 0x1000\"\n\nend\n\narch_requalify_consts (A) kernel_base idle_thread_ptr\n\ncontext Arch begin arch_global_naming (A)", "property": "Kernel Window Base Address: The kernel reserves virtual addresses from a fixed base address (0xe0000000) upwards in every virtual address space, providing a consistent and protected region for kernel operations. \n\nSubproperty: Idle Thread Pointer: The idle thread pointer is offset from the kernel base address by 0x1000, providing a specific location for idle thread management within the kernel's reserved virtual address space.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "The lowest virtual address in the kernel window. The kernel reserves the\nvirtual addresses from here up in every virtual address space."}
{"spec": "definition\n  nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\" where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len)\n                           (to_bl (of_nat n :: machine_word))\"\n\ndefinition\n \"msg_info_register \\<equiv> msgInfoRegister\"\ndefinition\n \"msg_registers \\<equiv> msgRegisters\"\ndefinition\n \"cap_register \\<equiv> capRegister\"\ndefinition\n \"badge_register \\<equiv> badgeRegister\"\ndefinition\n \"frame_registers \\<equiv> frameRegisters\"\ndefinition\n \"gp_registers \\<equiv> gpRegisters\"\ndefinition\n \"exception_message \\<equiv> exceptionMessage\"\ndefinition\n \"syscall_message \\<equiv> syscallMessage\"\n\ndatatype arch_fault\n    = VMFault vspace_ref \"machine_word list\"\n\nend\n\nend", "property": "Constant Definitions: Define various constants used in modelling machine operations, including register names, message types, and fault types. \n\nSubproperties:\n- Register Names: Specify the names of various registers, such as msg_info_register, msg_registers, cap_register, badge_register, frame_registers, and gp_registers.\n- Message Types: Define the types of messages, including exception_message and syscall_message.\n- Fault Types: Define the types of faults, including VMFault for virtual memory faults, which includes a vspace_ref and a list of machine words.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "Miscellaneous definitions of constants used in modelling machine\noperations."}
{"spec": "arch_requalify_consts\n  maxIRQ\n\nend", "property": "Maximum IRQ Value: The maximum IRQ value is defined, either manually for X64 architectures or through Kernel_Config for Arm architectures, to establish a limit for interrupt requests.", "title": "./spec/abstract/X64/ArchInterrupt_A.thy", "chapter": "", "section": "", "comment": " On Arm architectures, maxIRQ is defined in Kernel_Config. On X64 it is defined manually. "}
{"spec": "definition\n  arch_switch_to_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_switch_to_thread t \\<equiv> set_vm_root t\"\n\ndefinition\n   arch_switch_to_idle_thread :: \"(unit,'z::state_ext) s_monad\" where\n   \"arch_switch_to_idle_thread \\<equiv> do\n     thread \\<leftarrow> gets idle_thread;\n     set_vm_root thread\n   od\"\n\ndefinition\n  arch_activate_idle_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_activate_idle_thread t \\<equiv> return ()\"\n\ndefinition\n  \"store_asid_pool_entry pool_ptr asid pml4base \\<equiv> do\n    pool \\<leftarrow> get_asid_pool pool_ptr;\n    pool' \\<leftarrow> return (pool(asid_low_bits_of asid := pml4base));\n    set_asid_pool pool_ptr pool'\n  od\"", "property": "Virtual Address Space Context Switching: Switch to a thread's virtual address space context by setting the virtual machine root. \n\nSubproperties:\n- Set the virtual machine root for a given thread.\n- Switch to the idle thread's virtual address space context by getting the idle thread and setting its virtual machine root.\n- Activate the idle thread without performing any specific actions.\n- Store an ASID pool entry by updating the ASID pool with the given PML4 base address for the specified ASID.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "Switch to a thread's virtual address space context."}
{"spec": "definition\nperform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_control_invocation iv \\<equiv> case iv of\n  MakePool frame slot parent base \\<Rightarrow> do\n    delete_objects frame page_bits;\n    pcap \\<leftarrow> get_cap parent;\n    set_cap (max_free_index_update pcap) parent;\n    retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n    cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n    assert (asid_low_bits_of base = 0);\n    asid_table \\<leftarrow> gets (x64_asid_table \\<circ> arch_state);\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n    modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>x64_asid_table := asid_table'\\<rparr>\\<rparr>)\nod\"", "property": "ASID Control Invocation: Create a new ASID pool object, provide a capability to it, and connect it to the global virtual ASID table. \n\nSubproperties:\n- Delete objects in the specified frame.\n- Update the maximum free index of the parent capability.\n- Retype the specified region to an ASID pool object.\n- Insert a new capability for the ASID pool into the parent slot.\n- Update the ASID table with the new ASID pool.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDControl capability confers the authority to create a new ASID\npool object. This operation creates the new ASID pool, provides a capability\nto it and connects it to the global virtual ASID table."}
{"spec": "definition\nperform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_pool_invocation iv \\<equiv> case iv of Assign asid pool_ptr ct_slot \\<Rightarrow>\ndo\n    pml4_cap \\<leftarrow> get_cap ct_slot;\n    case pml4_cap of\n      ArchObjectCap (PML4Cap pml4_base _) \\<Rightarrow> do\n        set_cap (ArchObjectCap $ PML4Cap pml4_base (Some asid)) ct_slot;\n        store_asid_pool_entry pool_ptr asid (Some pml4_base)\n      od\n    | _ \\<Rightarrow> fail\nod\"\n\n\ndefinition\n  pte_check_if_mapped :: \"obj_ref \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pte_check_if_mapped slot \\<equiv> do\n     pt \\<leftarrow> get_pte slot;\n     return (pt \\<noteq> InvalidPTE)\n  od\"\n\ndefinition\n  pde_check_if_mapped :: \"obj_ref \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pde_check_if_mapped slot \\<equiv> do\n     pd \\<leftarrow> get_pde slot;\n     return (pd \\<noteq> InvalidPDE)\n  od\"\n\ndefinition\n  perform_page_invocation_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"perform_page_invocation_unmap cap ct_slot \\<equiv>\n      (case cap\n         of PageCap dev base rights map_type sz mapped \\<Rightarrow> do\n            case mapped of Some (asid, vaddr) \\<Rightarrow> unmap_page sz asid vaddr base\n                          | None \\<Rightarrow> return ();\n            cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n            set_cap (ArchObjectCap $ update_map_data cap None (Some VMNoMap)) ct_slot\n          od\n      | _ \\<Rightarrow> fail)\"", "property": "ASID Pool Management: Assign a virtual ASID to a page directory, updating the PML4 capability and storing the ASID pool entry.\nPage Mapping Management: Check if a page table entry (PTE) or page directory entry (PDE) is mapped, and unmap a page if it is mapped, updating the corresponding capability.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign a virtual ASID\nto a page directory."}
{"spec": "definition\nperform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n\"perform_page_invocation iv \\<equiv> case iv of\n    PageMap cap ct_slot entries vspace \\<Rightarrow> do\n      set_cap cap ct_slot;\n      case entries of\n          (VMPTE pte, slot) \\<Rightarrow> store_pte slot pte\n        | (VMPDE pde, slot) \\<Rightarrow> store_pde slot pde\n        | (VMPDPTE pdpte, slot) \\<Rightarrow> store_pdpte slot pdpte;\n      asid \\<leftarrow> case cap of\n                  ArchObjectCap (PageCap _ _ _ _ _ (Some (as, _))) \\<Rightarrow> return as\n                | _ \\<Rightarrow> fail;\n      invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid;\n      return []\n    od\n  | PageUnmap cap ct_slot \\<Rightarrow>\n      (case cap of\n        PageCap dev base rights map_type sz mapped \\<Rightarrow> do\n            case mapped of\n              Some _ \\<Rightarrow> (case map_type of\n                          VMVSpaceMap \\<Rightarrow> perform_page_invocation_unmap cap ct_slot\n                        | _ \\<Rightarrow> fail)\n            | None \\<Rightarrow> return ();\n            return []\n        od\n      | _ \\<Rightarrow> fail)\n\\<^cancel>\\<open>| PageIOMap asid cap ct_slot entries \\<Rightarrow> undefined\\<close>\n  | PageGetAddr ptr \\<Rightarrow>\n      return [addrFromPPtr ptr]\"", "property": "Page Invocation Actions: Allow the management of memory pages, including mapping, unmapping, and flushing, while ensuring the correct handling of page table entries, invalidation of page structure caches, and retrieval of page addresses.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "The Page capability confers the authority to map, unmap and flush the\n  memory page."}
{"spec": "definition\nperform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_page_table_invocation iv \\<equiv>\ncase iv of PageTableMap cap ct_slot pde pd_slot vspace \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pde pd_slot pde;\n    asid <- case cap of ArchObjectCap (PageTableCap  _ (Some (as, _))) \\<Rightarrow> return as\n            | _ \\<Rightarrow> fail;\n    invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n  od\n  | PageTableUnmap (ArchObjectCap (PageTableCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_page_table asid vaddr p;\n      pte_bits \\<leftarrow> return word_size_bits;\n      slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + (1 <<  pt_bits) - 1];\n      mapM_x (swp store_pte InvalidPTE) slots\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"", "property": "Page Table Invocation: Authorize page table mapping and unmapping operations, ensuring the correct configuration of page tables and the maintenance of valid memory mappings.\n\nSubproperties:\n- Map Page Table: Set a page table capability, store a page directory entry, and invalidate the page structure cache for the specified address space identifier.\n- Unmap Page Table: Unmap a page table, clear the mapped page table entries, and update the capability with the unmapped data.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page tables."}
{"spec": "definition\nperform_page_directory_invocation :: \"page_directory_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_page_directory_invocation iv \\<equiv>\ncase iv of PageDirectoryMap cap ct_slot pdpte pdpt_slot vspace \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pdpte pdpt_slot pdpte;\n    asid <- case cap of ArchObjectCap (PageDirectoryCap _ (Some (as, _))) \\<Rightarrow> return as\n            | _ \\<Rightarrow> fail;\n    invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n  od\n  | PageDirectoryUnmap (ArchObjectCap (PageDirectoryCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_pd asid vaddr p;\n      pde_bits \\<leftarrow> return word_size_bits;\n      slots \\<leftarrow> return [p, p + (1 << pde_bits) .e. p + (1 << pd_bits) - 1];\n      mapM_x (swp store_pde InvalidPDE) slots\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"", "property": "Page Directory Invocation: Authorize page directory operations, including mapping and unmapping page tables, updating page directory entries, and invalidating page structure caches. Ensure that page directory capabilities are used to manage memory mappings and optimize memory access. \n\nMapping: Set the capability, store the page directory pointer table entry, and invalidate the page structure cache for the specified address space identifier.\n\nUnmapping: Unmap the page directory, clear the page directory entries, and update the capability with the unmapped data.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageDirectory capabilities confer the authority to map and unmap page\ntables."}
{"spec": "definition\nperform_pdpt_invocation :: \"pdpt_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_pdpt_invocation iv \\<equiv>\ncase iv of PDPTMap cap ct_slot pml4e pml4_slot vspace \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pml4e pml4_slot pml4e;\n    asid <- case cap of ArchObjectCap (PDPointerTableCap _ (Some (as, _))) \\<Rightarrow> return as\n            | _ \\<Rightarrow> fail;\n    invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n  od\n  | PDPTUnmap (ArchObjectCap (PDPointerTableCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_pdpt asid vaddr p;\n      pdept_bits \\<leftarrow> return word_size_bits;\n      slots \\<leftarrow> return [p, p + (1 << pdept_bits) .e. p + (1 << pdpt_bits) - 1];\n      mapM_x (swp store_pdpte InvalidPDPTE) slots\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"\n\ndefinition\n  port_out :: \"('a word \\<Rightarrow> unit machine_monad) \\<Rightarrow> ('a word) \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"port_out f w = do\n    do_machine_op $ f w;\n    return []\n  od\"\n\ndefinition\n  port_in :: \"(data machine_monad) \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"port_in f = do\n    res \\<leftarrow> do_machine_op f;\n    return [res]\n  od\"\n\ndefinition\n  perform_io_port_invocation :: \"io_port_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"perform_io_port_invocation i \\<equiv> (\n    case i of (IOPortInvocation port port_data) \\<Rightarrow> (\n      case port_data of\n        IOPortIn8 \\<Rightarrow> port_in (in8 port)\n      | IOPortIn16 \\<Rightarrow> port_in (in16 port)\n      | IOPortIn32 \\<Rightarrow> port_in (in32 port)\n      | IOPortOut8 w \\<Rightarrow> port_out (out8 port) w\n      | IOPortOut16 w \\<Rightarrow> port_out (out16 port) w\n      | IOPortOut32 w \\<Rightarrow> port_out (out32 port) w\n    )\n    )\"\n\ndefinition\n  perform_ioport_control_invocation :: \"io_port_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"perform_ioport_control_invocation i \\<equiv>\n    case i of (IOPortControlInvocation f l dest_slot control_slot) \\<Rightarrow> do\n      set_ioport_mask f l True;\n      c \\<leftarrow> return $ ArchObjectCap $ IOPortCap f l;\n      cap_insert (ArchObjectCap (IOPortCap f l)) control_slot dest_slot\n    od\"\n\nabbreviation\n  arch_no_return :: \"(unit, 'z::state_ext) s_monad \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\nwhere\n  \"arch_no_return oper \\<equiv> do oper; return [] od\"", "property": "Page Directory Management: Map and unmap page tables using PageDirectory capabilities, ensuring proper page structure cache invalidation and updating mapped addresses.\n\nIO Port Management: Perform input/output operations on IO ports, including reading and writing data of various sizes (8-bit, 16-bit, 32-bit).\n\nIO Port Control: Set IO port masks and insert IO port capabilities into control slots, enabling or disabling access to specific IO ports.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageDirectory capabilities confer the authority to map and unmap page\ntables."}
{"spec": "definition\n  arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\" where\n  \"arch_perform_invocation i \\<equiv> liftE $\n    case i of\n          InvokePageTable oper \\<Rightarrow> arch_no_return $ perform_page_table_invocation oper\n        | InvokePageDirectory oper \\<Rightarrow> arch_no_return $ perform_page_directory_invocation oper\n        | InvokePDPT oper \\<Rightarrow> arch_no_return $ perform_pdpt_invocation oper\n        | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n        | InvokeASIDControl oper \\<Rightarrow> arch_no_return $ perform_asid_control_invocation oper\n        | InvokeASIDPool oper \\<Rightarrow> arch_no_return $ perform_asid_pool_invocation oper\n        | InvokeIOPort oper \\<Rightarrow> perform_io_port_invocation oper\n        | InvokeIOPortControl oper \\<Rightarrow> arch_no_return $ perform_ioport_control_invocation oper\"\n\nend\nend", "property": "X64 System Call Dispatch: Dispatches x64-specific system calls to their corresponding invocation handlers, covering various operations such as page table, page directory, PDPT, page, ASID control, ASID pool, I/O port, and I/O port control invocations.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call despatcher for all x64-specific system calls."}
{"spec": "chapter \"Handle Hyperviser Fault Event\"\n\ntheory Hypervisor_A\nimports Exceptions_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"machine_word \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n\"handle_hypervisor_fault thread X64NoHypFaults = return ()\"\n\n\nend\nend", "property": "Handle Hypervisor Fault Event: Ignore X64NoHypFaults type faults.", "title": "./spec/abstract/X64/Hypervisor_A.thy", "chapter": "Handle Hyperviser Fault Event", "section": "", "comment": ""}
{"spec": "definition\n  reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Memory Region Reservation: Reserve a memory region with the specified pointer, byte length, and kernel flag, currently a no-op placeholder for potential future extension to explicitly tag kernel data regions in memory.", "title": "./spec/abstract/X64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory."}
{"spec": "definition\n  init_arch_objects :: \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list\n   \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs\n    \\<equiv> when (new_type = ArchObject PML4Obj) (mapM_x copy_global_mappings refs)\"\n\ndefinition\n  empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0) (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context \\<rparr>\"\n\nend\nend", "property": "Architecture-Specific Object Initialization: Initialize architecture-specific objects, including PML4 objects, by copying global mappings for the provided references. \n\nSubproperties:\n- PML4 Object Initialization: Copy global mappings for the provided references when initializing a PML4 object.\n- Empty Context Initialization: Initialize an empty user context with all registers set to 0.\n- Architecture-Specific TCB Initialization: Initialize an architecture-specific TCB with an empty context.", "title": "./spec/abstract/X64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition\n  arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arch_post_cap_deletion ac \\<equiv> case ac of\n       IOPortCap f l \\<Rightarrow> free_ioport_range f l\n     | _ \\<Rightarrow> return ()\"", "property": "Post-Capability Deletion Actions: Perform necessary cleanup actions after a capability is deleted, such as freeing I/O port ranges for IOPortCap capabilities.", "title": "./spec/abstract/X64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = IOPortRef io_port\n\ndefinition\n  arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\"\nwhere\n  \"arch_gen_obj_refs ac \\<equiv> case ac of\n      IOPortCap f l \\<Rightarrow> IOPortRef ` {f}\n    | _ \\<Rightarrow> {}\"\n\ndefinition\n  arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_cap_cleanup_opt ac \\<equiv> case ac of IOPortCap f l \\<Rightarrow> ArchObjectCap (IOPortCap f l) | _ \\<Rightarrow> NullCap\"\n\nend\nend", "property": "Arch Specific Generic Object References: Define architecture-specific generic object references not covered by generic references, including IOPortRef for I/O ports. \n\nArch Specific Capability Cleanup: Clean up architecture-specific capabilities by converting them to a standardized form, specifically IOPortCap is preserved while others are replaced with NullCap.", "title": "./spec/abstract/X64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition\n  init_irq_node_ptr :: obj_ref where\n  \"init_irq_node_ptr = kernel_base + 0x2000\"", "property": "IRQ Node Initialization: The IRQ node pointer is initialized to a fixed address (kernel_base + 0x2000), ensuring a consistent starting point for interrupt handling.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " 8KiB "}
{"spec": "definition\n  init_global_pml4 :: obj_ref where\n  \"init_global_pml4 = kernel_base + 0x4000\"", "property": "Initialization of Global PML4: The global PML4 is initialized at a specific address offset from the kernel base.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " 4KiB "}
{"spec": "definition\n  init_global_pdpt :: obj_ref where\n  \"init_global_pdpt = kernel_base + 0x5000\"", "property": "Initialization of Global Page Directory Pointer Table (PDPT): The global PDPT is initialized at a fixed address, 0x5000 offset from the kernel base, with a size of 4KiB.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " 4KiB "}
{"spec": "definition\n  init_global_pd :: obj_ref where\n  \"init_global_pd = kernel_base + 0x6000\"\n\ndefinition\n  \"init_arch_state \\<equiv> \\<lparr>\n    x64_asid_table = Map.empty,\n    x64_global_pml4 = init_global_pml4,\n    x64_kernel_vspace =\n      \\<lambda>ref. if ref \\<in> {pptr_base .. pptr_base + mask pml4_shift_bits}\n              then X64VSpaceKernelWindow\n              else X64VSpaceInvalidRegion,\n    x64_global_pts = [],\n    x64_global_pdpts = [init_global_pdpt],\n    x64_global_pds = [init_global_pd],\n    x64_current_cr3 = cr3 0 0,\n    x64_allocated_io_ports = \\<lambda>_. False,\n    x64_num_ioapics = 1,\n    x64_ioapic_nirqs = \\<lambda>_. ucast ioapicIRQLines,\n    x64_irq_state = K IRQFree\n   \\<rparr>\"\n\ndefinition [simp]:\n  \"global_pml4 \\<equiv> (\\<lambda>_ :: 9 word. InvalidPML4E)\n    (0x1FF := PDPointerTablePML4E (addrFromPPtr init_global_pdpt) {} {})\"", "property": "Initialization of Architecture State: The architecture state is initialized with an empty ASID table, a global PML4, kernel virtual space mapping, and other essential structures such as page tables, page directories, and interrupt controllers.\n\nSubproperties:\n- ASID Table Initialization: The ASID table is initialized as an empty map.\n- Global PML4 Initialization: The global PML4 is initialized with a specific configuration, including a PD pointer table entry.\n- Kernel Virtual Space Mapping: The kernel virtual space is mapped to a specific range of physical addresses.\n- Page Tables and Directories Initialization: The global page tables and directories are initialized with specific values.\n- Interrupt Controllers Initialization: The interrupt controllers are initialized with a specific configuration, including the number of IOAPICs and IRQ lines.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " 4KiB "}
{"spec": "definition [simp]:\n  \"global_pdpt \\<equiv> (\\<lambda> i :: 9 word. HugePagePDPTE (ucast i << 30) {} {})\n                    (0x1FF := PageDirectoryPDPTE (addrFromPPtr init_global_pd) {} {})\"", "property": "Global Page Table Mapping: The kernel maps all physical memory using huge page mappings in the global PDPT, except for the upper-most entry, which maps to the global page directory.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " The kernel uses huge page mappings in the global PDPT to get a view of all physical memory.\n   The exception is the upper-most PDPT entry, which maps to the global page directory. "}
{"spec": "definition [simp]:\n  \"global_pd \\<equiv> (\\<lambda> i :: 9 word. LargePagePDE (0x03FE00 + ucast i << 21) {} {})\"\n\ndefinition\n  \"init_kheap \\<equiv>\n    (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n           then Some (CNode 0 (empty_cnode 0))\n           else None)\n    (idle_thread_ptr \\<mapsto>\n       TCB \\<lparr>\n         tcb_ctable = NullCap,\n         tcb_vtable = NullCap,\n         tcb_reply = NullCap,\n         tcb_caller = NullCap,\n         tcb_ipcframe = NullCap,\n         tcb_state = IdleThreadState,\n         tcb_fault_handler = replicate word_bits False,\n         tcb_ipc_buffer = 0,\n         tcb_fault = None,\n         tcb_bound_notification = None,\n         tcb_mcpriority = minBound,\n         tcb_arch = init_arch_tcb\n         \\<rparr>,\n     init_global_pml4 \\<mapsto> ArchObj (PageMapL4 global_pml4),\n     init_global_pdpt \\<mapsto> ArchObj (PDPointerTable global_pdpt),\n     init_global_pd \\<mapsto> ArchObj (PageDirectory global_pd)\n    )\"\n\ndefinition\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. Structures_A.IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\nend", "property": "Kernel Initialization: The kernel is initialized with a defined memory layout, including a global page directory, page tables, and a heap with specific objects such as the idle thread, global page tables, and an empty capability derivation tree. The initial kernel state is defined, including the current thread, idle thread, machine state, interrupt handlers, and architecture-specific state.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " C kernel initialisation refines this down to small pages for devices, but we'll stop here. "}
{"spec": "definition\n  \"attr_mask = {Global,Dirty,PTAttr Accessed,PTAttr ExecuteDisable}\"\n\ndefinition\n  \"attr_mask' = attr_mask \\<union> {PAT}\"", "property": "Page Attribute Masks: Define masks for page attributes, specifically the attr_mask and attr_mask', which include attributes such as Global, Dirty, Accessed, ExecuteDisable, and PAT, to control page mapping and access. \n\nSubproperties:\n- attr_mask: Includes attributes Global, Dirty, Accessed, and ExecuteDisable.\n- attr_mask': Extends attr_mask by including the PAT attribute.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  These attributes are always set to @{const False} when pages are mapped.\n"}
{"spec": "primrec create_mapping_entries ::\n  \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vm_rights \\<Rightarrow> frame_attrs \\<Rightarrow> obj_ref \\<Rightarrow>\n  (vm_page_entry * obj_ref,'z::state_ext) se_monad\"\nwhere\n  \"create_mapping_entries base vptr X64SmallPage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ (VMPTE (SmallPagePTE base (attrib - attr_mask) vm_rights), p)\n  odE\"\n\n| \"create_mapping_entries base vptr X64LargePage vm_rights attrib pdpt =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pd_slot pdpt vptr;\n    returnOk $ (VMPDE (LargePagePDE base (attrib - attr_mask) vm_rights), p)\n  odE\"\n\n| \"create_mapping_entries base vptr X64HugePage vm_rights attrib pml4 =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pdpt_slot pml4 vptr;\n    returnOk $ (VMPDPTE (HugePagePDPTE base (attrib - attr_mask') vm_rights), p)\n  odE\"", "property": "Create Mapping Entries: Generate the entries required to map frames of various sizes at a given virtual address in a page table or page directory, ensuring correct attribute masking and rights assignment. \n\nSubproperties:\n- Small Page Mapping: Create a small page mapping entry with the correct page table entry attributes and rights.\n- Large Page Mapping: Create a large page mapping entry with the correct page directory entry attributes and rights.\n- Huge Page Mapping: Create a huge page mapping entry with the correct page directory pointer table entry attributes and rights.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Save the set of entries that would be inserted into a page table or\npage directory to map various different sizes of frame at a given virtual\naddress."}
{"spec": "fun ensure_safe_mapping ::\n  \"(vm_page_entry * obj_ref) \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n\"ensure_safe_mapping (VMPTE InvalidPTE, _) = returnOk ()\"\n|\n\"ensure_safe_mapping (VMPDE InvalidPDE, _) = returnOk ()\"\n|\n\"ensure_safe_mapping (VMPDPTE InvalidPDPTE, _) = returnOk ()\"\n|\n\"ensure_safe_mapping (VMPTE (SmallPagePTE _ _ _), pt_slot) = returnOk ()\"\n|\n\"ensure_safe_mapping (VMPDE (LargePagePDE _ _ _), pd_slot) =\n    doE\n        pde \\<leftarrow> liftE $ get_pde pd_slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | LargePagePDE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst)\n    odE\"\n|\n\"ensure_safe_mapping (VMPDPTE (HugePagePDPTE _ _ _), pdpt_slot) =\n    doE\n        pdpt \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n        (case pdpt of\n              InvalidPDPTE \\<Rightarrow> returnOk ()\n            | HugePagePDPTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst)\n    odE\"\n|\n\"ensure_safe_mapping (VMPDE (PageTablePDE _ _ _), _) = fail\"\n|\n\"ensure_safe_mapping (VMPDPTE (PageDirectoryPDPTE _ _ _), _) = fail\"", "property": "Ensure Safe Mapping: Verify that given page table entries are either invalid (for unmapping) or replace invalid entries (for mapping), ensuring that valid mappings are not overwritten and invalid entries are properly handled. \n\nSubproperties:\n- Allow mapping of small pages without additional checks.\n- For large and huge pages, check that the target slot is either invalid or already contains a similar page mapping.\n- Prevent mapping of page tables and directories.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "This function checks that given entries are either invalid entries (for unmapping)\nor replace invalid entries (for mapping)."}
{"spec": "definition\nlookup_ipc_buffer :: \"bool \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\" where\n\"lookup_ipc_buffer is_receiver thread \\<equiv> do\n    buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n    buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n    buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n    (case buffer_cap of\n      ArchObjectCap (PageCap _ p R _ vms _) \\<Rightarrow>\n        if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n        then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n        else return None\n    | _ \\<Rightarrow> return None)\nod\"", "property": "Lookup IPC Buffer: Retrieve a thread's IPC buffer and verify the thread's authority to read or write to it, ensuring that the buffer's access rights match the requested operation. \n\nBuffer Access Rights: The buffer's access rights must include either read-write or read-only permissions, depending on whether the operation is a receive or not.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Look up a thread's IPC buffer and check that the thread has the right\nauthority to read or (in the receiver case) write to it."}
{"spec": "definition\nfind_vspace_for_asid :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"find_vspace_for_asid asid \\<equiv> doE\n    assertE (asid > 0);\n    asid_table \\<leftarrow> liftE $ gets (x64_asid_table \\<circ> arch_state);\n    pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of asid));\n    pool \\<leftarrow> (case pool_ptr of\n               Some ptr \\<Rightarrow> liftE $ get_asid_pool ptr\n             | None \\<Rightarrow> throwError InvalidRoot);\n    pml4 \\<leftarrow> returnOk (pool (asid_low_bits_of asid));\n    (case pml4 of\n          Some ptr \\<Rightarrow> returnOk ptr\n        | None \\<Rightarrow> throwError InvalidRoot)\nodE\"", "property": "Find Virtual Space for ASID: Locate the page directory associated with a given virtual ASID, ensuring the ASID is valid and retrieving the corresponding page directory pointer from the ASID table and pool. \n\nASID Validation: The ASID must be greater than 0. \n\nPage Directory Retrieval: The page directory pointer is retrieved from the ASID table and pool using the high and low bits of the ASID. \n\nError Handling: If the ASID is invalid or the page directory pointer is not found, an InvalidRoot error is thrown.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory associated with a given virtual ASID."}
{"spec": "definition\nfind_vspace_for_asid_assert :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) s_monad\" where\n\"find_vspace_for_asid_assert asid \\<equiv> do\n   pml4 \\<leftarrow> find_vspace_for_asid asid <catch> K fail;\n   get_pml4 pml4;\n   return pml4\n od\"", "property": "Find Page Directory for ASID: Locate the page directory associated with a given ASID, ensuring the process succeeds and returns a valid page directory pointer. \n\nSubproperties: \n- The search for the page directory must be successful.\n- The returned pointer must correspond to a real page directory.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory and check that this process succeeds and\nreturns a pointer to a real page directory."}
{"spec": "definition\nhandle_vm_fault :: \"obj_ref \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n\"handle_vm_fault thread fault_type = doE\n    addr \\<leftarrow> liftE $ do_machine_op getFaultAddress;\n    fault \\<leftarrow> liftE $ as_user thread $ getRegister ErrorRegister;\n    case fault_type of\n        X64DataFault \\<Rightarrow> throwError $ ArchFault $ VMFault addr [0, fault && mask 5]\n      | X64InstructionFault \\<Rightarrow> throwError $ ArchFault $ VMFault addr [1, fault && mask 5]\nodE\"\n\ndefinition\n  get_current_cr3 :: \"(cr3, 'z::state_ext) s_monad\"\nwhere\n  \"get_current_cr3 \\<equiv> gets (x64_current_cr3 \\<circ> arch_state)\"\n\ndefinition\n  set_current_cr3 :: \"cr3 \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_current_cr3 c \\<equiv>\n     modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>x64_current_cr3 := c\\<rparr>\\<rparr>)\"\n\ndefinition\n  invalidate_page_structure_cache_asid :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"invalidate_page_structure_cache_asid vspace asid \\<equiv>\n     do_machine_op $ invalidateLocalPageStructureCacheASID vspace (ucast asid)\"\n\ndefinition\n  getCurrentVSpaceRoot :: \"(obj_ref, 'z::state_ext) s_monad\"\nwhere\n  \"getCurrentVSpaceRoot \\<equiv> do\n      cur \\<leftarrow> get_current_cr3;\n      return $ cr3_base_address cur\n   od\"\n\ndefinition\n  \"cr3_addr_mask \\<equiv> mask pml4_shift_bits << asid_bits\"\n\ndefinition\n  make_cr3 :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> cr3\"\nwhere\n  \"make_cr3 vspace asid \\<equiv> cr3 (vspace && cr3_addr_mask) asid\"\n\ndefinition\n  set_current_vspace_root :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"set_current_vspace_root vspace asid \\<equiv> set_current_cr3 $ make_cr3 vspace asid\"", "property": "VM Fault Handling: Formats a VM fault message to be passed to a thread's supervisor after encountering a page fault, providing the fault address and relevant error information.\n\nPage Table Management: Provides functions to manage the current CR3 (page table root), including getting and setting its value, invalidating the page structure cache for a given ASID, and constructing a new CR3 value from a given virtual space address and ASID.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Format a VM fault message to be passed to a thread's supervisor after\nit encounters a page fault."}
{"spec": "definition\n  set_vm_root :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"set_vm_root tcb \\<equiv> do\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    (case thread_root of\n       ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> doE\n           pml4' \\<leftarrow> find_vspace_for_asid asid;\n           whenE (pml4 \\<noteq> pml4') $ throwError InvalidRoot;\n           cur_cr3 \\<leftarrow> liftE $ get_current_cr3;\n           whenE (cur_cr3 \\<noteq> make_cr3 (addrFromPPtr pml4) asid) $\n              liftE $ set_current_cr3 $ make_cr3 (addrFromPPtr pml4) asid\n       odE\n     | _ \\<Rightarrow> throwError InvalidRoot) <catch>\n    (\\<lambda>_. do\n       global_pml4 \\<leftarrow> gets (x64_global_pml4 \\<circ> arch_state);\n       set_current_vspace_root (addrFromKPPtr global_pml4) 0\n    od)\nod\"", "property": "Set Virtual Memory Root: Switch into the address space of a given thread by setting its virtual memory root, or fall back to the global address space if the thread's address space is not correctly configured. \n\nSubproperties:\n- Validate Thread Root: Verify that the thread's root capability is a valid PML4 capability with a matching address space identifier (ASID).\n- Update Current CR3: Update the current CR3 register with the address of the thread's PML4 table if it has changed.\n- Fall Back to Global PML4: If setting the thread's address space fails, fall back to the global PML4 table.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch into the address space of a given thread or the global address\nspace if none is correctly configured."}
{"spec": "definition\nhw_asid_invalidate :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"hw_asid_invalidate asid vspace \\<equiv>\n  do_machine_op $ invalidateASID vspace (ucast asid)\"\n\ndefinition\ndelete_asid_pool :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid_pool base ptr \\<equiv> do\n  assert (asid_low_bits_of base = 0);\n  asid_table \\<leftarrow> gets (x64_asid_table \\<circ> arch_state);\n  when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n    pool \\<leftarrow> get_asid_pool ptr;\n    mapM (\\<lambda>offset. (when (pool (ucast offset) \\<noteq> None) $\n                          hw_asid_invalidate (base + offset) (the (pool (ucast offset)))))\n                    [0 .e. (1 << asid_low_bits) - 1];\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> x64_asid_table := asid_table' \\<rparr>\\<rparr>);\n    tcb \\<leftarrow> gets cur_thread;\n    set_vm_root tcb\n  od\nod\"", "property": "ASID Pool Deletion: Remove the specified ASID pool, invalidating all virtual to physical mappings associated with the ASID and updating the ASID table. Ensure the current thread's VM root is updated after the deletion. \n\nSubproperties:\n- ASID Table Update: Update the ASID table by removing the entry corresponding to the deleted ASID pool.\n- Mapping Invalidation: Invalidate all virtual to physical mappings associated with the deleted ASID pool.\n- VM Root Update: Update the current thread's VM root after the ASID pool deletion.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove virtual to physical mappings in either direction involving this\nvirtual ASID."}
{"spec": "definition\ndelete_asid :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid asid pml4 \\<equiv> do\n  asid_table \\<leftarrow> gets (x64_asid_table \\<circ> arch_state);\n  case asid_table (asid_high_bits_of asid) of\n    None \\<Rightarrow> return ()\n  | Some pool_ptr \\<Rightarrow>  do\n     pool \\<leftarrow> get_asid_pool pool_ptr;\n     when (pool (asid_low_bits_of asid) = Some pml4) $ do\n                hw_asid_invalidate asid pml4;\n                pool' \\<leftarrow> return (pool (asid_low_bits_of asid := None));\n                set_asid_pool pool_ptr pool';\n                tcb \\<leftarrow> gets cur_thread;\n                set_vm_root tcb\n            od\n    od\nod\"\n\ndefinition\n  flush_all :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"flush_all vspace asid \\<equiv> do_machine_op $ invalidateASID vspace (ucast asid)\"\n\nabbreviation\n  flush_pdpt :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"flush_pdpt \\<equiv> flush_all\"\n\nabbreviation\n  flush_pd :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"flush_pd \\<equiv> flush_all\"", "property": "ASID Management: Ensure proper deactivation and flushing of page map levels when deleting or modifying ASID-related structures, maintaining the integrity of the virtual memory system.\n\nSubproperties:\n- Deactivate Page Map Level 4: When deleting a page map level 4 from an ASID pool, deactivate it to prevent unauthorized access.\n- Flush ASID-Related Structures: Flush all relevant structures (e.g., page directories, page directory pointer tables) when modifying ASID-related information to ensure consistency and prevent stale data.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "When deleting a page map level 4 from an ASID pool we must deactivate\nit."}
{"spec": "definition\nflush_table :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_table pml4_ref vptr pt_ref asid \\<equiv> do\n    assert (vptr && mask (ptTranslationBits + pageBits) = 0);\n           pt \\<leftarrow> get_pt pt_ref;\n           forM_x [0 .e. (-1::9 word)] (\\<lambda>index. do\n             pte \\<leftarrow> return $ pt index;\n             case pte of\n               InvalidPTE \\<Rightarrow> return ()\n             | _ \\<Rightarrow> do_machine_op $ invalidateTranslationSingleASID (vptr + (ucast index << pageBits)) (ucast asid)\n           od)\nod\"", "property": "Flush Table Mappings: Flush the mappings associated with a page table by iterating over each page table entry and invalidating the translation for the corresponding virtual address and ASID if the entry is valid.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a page table."}
{"spec": "definition\nunmap_pdpt :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_pdpt asid vaddr pdpt \\<equiv> doE\n  vspace \\<leftarrow> find_vspace_for_asid asid;\n  pm_slot \\<leftarrow> returnOk $ lookup_pml4_slot vspace vaddr;\n  pml4e \\<leftarrow> liftE $ get_pml4e pm_slot;\n  case pml4e of\n    PDPointerTablePML4E pt' _ _ \\<Rightarrow>\n      if pt' = addrFromPPtr pdpt then returnOk () else throwError InvalidRoot\n    | _ \\<Rightarrow> throwError InvalidRoot;\n  liftE $ do\n    flush_pdpt vspace asid;\n    store_pml4e pm_slot InvalidPML4E\n  od\nodE <catch> (K $ return ())\"", "property": "Unmap Page Directory Pointer Table: Remove the mapping of a Page Directory Pointer Table (PDPT) from a PML4 for a given address space identifier (ASID) and virtual address. Ensure that the PDPT being unmapped is the one currently mapped in the PML4, and handle any errors that may occur during the unmap operation. \n\nError Handling: Handle cases where the PDPT is not the one currently mapped in the PML4 or where the PML4 entry is invalid, and catch any exceptions that occur during the unmap operation to ensure system stability.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a Page Directory Pointer Table from a PML4."}
{"spec": "definition\nunmap_pd :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_pd asid vaddr pd \\<equiv> doE\n  vspace \\<leftarrow> find_vspace_for_asid asid;\n  pdpt_slot \\<leftarrow> lookup_pdpt_slot vspace vaddr;\n  pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n  case pdpte of\n    PageDirectoryPDPTE pd' _ _ \\<Rightarrow>\n      if pd' = addrFromPPtr pd then returnOk () else throwError InvalidRoot\n    | _ \\<Rightarrow> throwError InvalidRoot;\n  liftE $ do\n    flush_pd vspace asid;\n    store_pdpte pdpt_slot InvalidPDPTE;\n    invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n  od\nodE <catch> (K $ return ())\"", "property": "Unmap Page Directory: Unmap a Page Directory from a Page Directory Pointer Table for a given ASID and virtual address, ensuring that the Page Directory is correctly removed from the Page Directory Pointer Table and the relevant caches are invalidated. \n\nSubproperties:\n- Validate the Page Directory Pointer Table Entry (PDPTE) for the given virtual address.\n- Check that the Page Directory to be unmapped matches the expected address.\n- Flush the Page Directory and store an Invalid PDPTE in the Page Directory Pointer Table slot.\n- Invalidate the page structure cache for the given ASID.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a Page Directory from a Page Directory Pointer Table."}
{"spec": "definition\nunmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page_table asid vaddr pt \\<equiv> doE\n    vspace \\<leftarrow> find_vspace_for_asid asid;\n    pd_slot \\<leftarrow> lookup_pd_slot vspace vaddr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    case pde of\n      PageTablePDE addr _ _ \\<Rightarrow>\n        if addrFromPPtr pt = addr then returnOk () else throwError InvalidRoot\n      | _ \\<Rightarrow> throwError InvalidRoot;\n    liftE $ do\n      flush_table vspace vaddr pt asid;\n      store_pde pd_slot InvalidPDE;\n      invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n    od\nodE <catch> (K $ return ())\"", "property": "Unmap Page Table: Unmap a page table from its page directory, ensuring that the page table is correctly removed and the page directory is updated. \n\nSubproperties:\n- Validate Page Table: Verify that the page table to be unmapped is valid and correctly referenced by the page directory entry.\n- Flush and Invalidate: Flush the page table and invalidate the page structure cache for the affected address space identifier (ASID).", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a page table from its page directory."}
{"spec": "definition\ncheck_mapping_pptr :: \"machine_word \\<Rightarrow> vm_page_entry \\<Rightarrow> bool\" where\n\"check_mapping_pptr pptr entry \\<equiv> case entry of\n   VMPTE (SmallPagePTE base _ _) \\<Rightarrow> base = addrFromPPtr pptr\n | VMPDE (LargePagePDE base _ _) \\<Rightarrow> base = addrFromPPtr pptr\n | VMPDPTE (HugePagePDPTE base _ _) \\<Rightarrow> base = addrFromPPtr pptr\n | _ \\<Rightarrow> False\"", "property": "Frame Mapping Validation: Verify that a given frame is correctly mapped by a specific mapping entry, ensuring the base address of the mapping entry matches the physical address of the frame. \n\nMapping Entry Types: Distinguish between different types of mapping entries (SmallPagePTE, LargePagePDE, HugePagePDPTE) to determine the correct base address for comparison.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Check that a given frame is mapped by a given mapping entry."}
{"spec": "definition\nunmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page pgsz asid vptr pptr \\<equiv> doE\n    vspace \\<leftarrow> find_vspace_for_asid asid;\n    case pgsz of\n          X64SmallPage \\<Rightarrow> doE\n            pt_slot \\<leftarrow> lookup_pt_slot vspace vptr;\n            pte \\<leftarrow> liftE $ get_pte pt_slot;\n            unlessE (check_mapping_pptr pptr (VMPTE pte)) $ throwError InvalidRoot;\n            liftE $ store_pte pt_slot InvalidPTE\n          odE\n        | X64LargePage \\<Rightarrow> doE\n            pd_slot \\<leftarrow> lookup_pd_slot vspace vptr;\n            pde \\<leftarrow> liftE $ get_pde pd_slot;\n            unlessE (check_mapping_pptr pptr (VMPDE pde)) $ throwError InvalidRoot;\n            liftE $ store_pde pd_slot InvalidPDE\n          odE\n        | X64HugePage \\<Rightarrow> doE\n            pdpt_slot \\<leftarrow> lookup_pdpt_slot vspace vptr;\n            pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n            unlessE (check_mapping_pptr pptr (VMPDPTE pdpte)) $ throwError InvalidRoot;\n            liftE $ store_pdpte pdpt_slot InvalidPDPTE\n          odE;\n    liftE $ do_machine_op $ invalidateTranslationSingleASID vptr (ucast asid)\nodE <catch> (K $ return ())\"", "property": "Unmap Page: Unmap a mapped page if the given mapping details are still current, by updating the page table entry, page directory entry, or page directory pointer table entry accordingly, and then invalidating the translation for the given virtual address and ASID. \n\nSubproperties:\n- Check Mapping: Verify that the given mapping details match the current mapping before unmapping the page.\n- Invalidate Translation: Invalidate the translation for the given virtual address and ASID after unmapping the page.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition\n  arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\"\nwhere\n  \"arch_derive_cap c \\<equiv> case c of\n     PageTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageTableCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageDirectoryCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageDirectoryCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PDPointerTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PDPointerTableCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PML4Cap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PML4Cap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageCap dev r R mt pgs x \\<Rightarrow> returnOk $ ArchObjectCap (PageCap dev r R VMNoMap pgs None)\n   | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n   | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\n\\<^cancel>\\<open>FIXME x64-vtd:\n   | IOSpaceCap _ _ \\<Rightarrow> returnOk c\n   | IOPageTableCap _ _ _ \\<Rightarrow> returnOk c\\<close>\n   | IOPortCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\n   | IOPortControlCap \\<Rightarrow> returnOk NullCap\"", "property": "Architectural Capability Derivation: Derive an architectural capability from a given capability, ensuring that page table structure capabilities have a virtual ASID and location assigned before they can be copied, to prevent multiple current virtual ASIDs and sharing between address spaces or virtual locations. \n\nSubproperties:\n- Allow derivation for page table structure capabilities with assigned virtual ASID and location.\n- Prevent derivation for page table structure capabilities without assigned virtual ASID and location.\n- Allow derivation for other types of architectural capabilities.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Page table structure capabilities cannot be copied until they\nhave a virtual ASID and location assigned. This is because they\ncannot have multiple current virtual ASIDs and cannot be shared\nbetween address spaces or virtual locations."}
{"spec": "definition\n  arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "Architectural Capability Update: Updating x64-specific capabilities does not modify user-modifiable data.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in x64-specific capabilities."}
{"spec": "definition\n  arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n    (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n    delete_asid_pool b ptr;\n    return (NullCap, NullCap)\n    od\n  | (PML4Cap ptr (Some a), True) \\<Rightarrow> do\n    delete_asid a ptr;\n    return (NullCap, NullCap)\n  od\n  | (PDPointerTableCap ptr (Some (a,v)), True) \\<Rightarrow> do\n    unmap_pdpt a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageDirectoryCap ptr (Some (a,v)), True) \\<Rightarrow> do\n    unmap_pd a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageTableCap ptr (Some (a, v)), True) \\<Rightarrow> do\n    unmap_page_table a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageCap _ ptr _ _ s (Some (a, v)), _) \\<Rightarrow> do\n     unmap_page s a v ptr;\n     return (NullCap, NullCap)\n  od\n  | (IOPortCap f l, True) \\<Rightarrow> return (NullCap, (ArchObjectCap (IOPortCap f l)))\n  \\<comment> \\<open>FIXME x64-vtd: IOSpaceCap and IOPageTableCap for @{text arch_finalise_cap}\\<close>\n  | _ \\<Rightarrow> return (NullCap, NullCap)\"", "property": "X64 Capability Finalisation: Ensure that x64-specific capabilities are properly finalised by deleting or unmapping relevant architecture-specific objects, such as ASID pools, page tables, and page directories, when they are no longer needed.\n\nSubproperties:\n- ASID Pool Deletion: Delete ASID pools when their corresponding capability is finalised.\n- Page Table and Directory Unmapping: Unmap page tables, page directories, and PDPTs when their corresponding capability is finalised.\n- Page Unmapping: Unmap pages when their corresponding capability is finalised, considering the page size.\n- IOPort Capability Preservation: Preserve IOPort capabilities when finalising, returning the same capability.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of x64-specific\ncapabilities."}
{"spec": "definition\n  is_valid_vtable_root :: \"cap \\<Rightarrow> bool\" where\n  \"is_valid_vtable_root c \\<equiv> \\<exists>r a. c = ArchObjectCap (PML4Cap r (Some a))\"\n\ndefinition\ncheck_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n\"check_valid_ipc_buffer vptr c \\<equiv> case c of\n  (ArchObjectCap (PageCap False _ _ _ _ _)) \\<Rightarrow> doE\n    whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError;\n    returnOk ()\n  odE\n| _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Valid IPC Buffer Capability: Ensure the capability for a thread's IPC buffer is valid by checking its alignment and type. Specifically, verify the capability is an architecture object capability of a mapped PML4 or a page capability with proper alignment.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A thread's virtual address space capability must be to a mapped PML4 (page map level 4)\nto be valid on the x64 architecture."}
{"spec": "definition\nattribs_from_word :: \"machine_word \\<Rightarrow> frame_attrs\" where\n\"attribs_from_word w \\<equiv>\n  let V = (if w !!0 then {PTAttr WriteThrough} else {});\n      V' = (if w!!1 then insert (PTAttr CacheDisabled) V else V)\n  in if w!!2 then insert PAT V' else V'\"", "property": "Decode VM Attributes: Extract virtual memory attributes from a user-provided machine word, determining properties such as write-through, cache disabled, and page attribute table (PAT) settings.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Decode a user argument word describing the kind of VM attributes a\nmapping is to have."}
{"spec": "definition\n  update_map_data :: \"arch_cap \\<Rightarrow> (asid \\<times> vspace_ref) option \\<Rightarrow> vmmap_type option \\<Rightarrow> arch_cap\" where\n  \"update_map_data cap m mt \\<equiv> case cap of\n     PageCap dev p R _ sz _ \\<Rightarrow> PageCap dev p R (the mt) sz m\n   | PageTableCap p _ \\<Rightarrow> PageTableCap p m\n   | PageDirectoryCap p _ \\<Rightarrow> PageDirectoryCap p m\n   | PDPointerTableCap p _ \\<Rightarrow> PDPointerTableCap p m\"", "property": "Update Mapping Data: Update the mapping data saved in a page or page table capability with new ASID, virtual space reference, and virtual memory map type. \n\nSubproperties:\n- Page capability: Update the mapping data with the new virtual memory map type and ASID, virtual space reference pair.\n- Page table, page directory, and PD pointer table capabilities: Update the mapping data with the new ASID, virtual space reference pair.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Update the mapping data saved in a page or page table capability."}
{"spec": "definition\n  in_user_frame :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n  \"in_user_frame p s \\<equiv>\n   \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) =\n        Some (ArchObj (DataPage False sz))\"\n\ndefinition\n  fpu_thread_delete :: \"obj_ref \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"fpu_thread_delete thread_ptr \\<equiv> do\n    using_fpu \\<leftarrow> do_machine_op (nativeThreadUsingFPU thread_ptr);\n    when using_fpu $ do_machine_op (switchFpuOwner 0 0)\n  od\"\n\ndefinition\n  prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"prepare_thread_delete thread_ptr \\<equiv> fpu_thread_delete thread_ptr\"", "property": "Check Pointer in User Frame: Determine if a given pointer is within a user frame by checking if its top bits point to a DataPage.\n\nFPU Thread Deletion Preparation: Prepare for thread deletion by checking if the thread is using the FPU and switching the FPU owner if necessary.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A pointer is inside a user frame if its top bits point to a @{text DataPage}.\n"}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\nend\nend", "property": "Message Alignment: The message alignment value is made visible through the msg_align_bits constant, ensuring proper alignment of messages in memory.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition\n  asid_high_bits_of :: \"asid \\<Rightarrow> asid_high_index\" where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"", "property": "Virtual ASID High Bits Extraction: Extract the high bits of a virtual ASID by shifting the ASID to the right by the number of low bits and then casting the result to an ASID high index.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "definition\n  asid_low_bits_of :: \"asid \\<Rightarrow> asid_low_index\" where\n  \"asid_low_bits_of asid \\<equiv> ucast asid\"\n\nlemmas asid_bits_of_defs =\n  asid_high_bits_of_def asid_low_bits_of_def", "property": "ASID Low Bits Extraction: Extract the low bits of a virtual ASID.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The low bits of a virtual ASID."}
{"spec": "text \\<open>Manipulate ASID pools, page directories and page tables in the kernel\nheap.\\<close>", "property": "Kernel Heap Access: Provide access to ASID pools, page directories, and page tables within the kernel heap, enabling manipulation of these critical data structures for efficient memory management.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\"\n  where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"\n\ndefinition\n  get_asid_pool :: \"obj_ref \\<Rightarrow> (asid_low_index \\<rightharpoonup> obj_ref, 'z::state_ext) s_monad\" where\n  \"get_asid_pool ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (ASIDPool pool) \\<Rightarrow> return pool\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_asid_pool :: \"obj_ref \\<Rightarrow> (asid_low_index \\<rightharpoonup> obj_ref) \\<Rightarrow> (unit, 'z::state_ext) s_monad\" where\n \"set_asid_pool ptr pool \\<equiv> set_object ptr (ArchObj (ASIDPool pool))\"\n\ndefinition\n  get_pd :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pde,'z::state_ext) s_monad\" where\n  \"get_pd ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageDirectory pd) \\<Rightarrow> return pd\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pd :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pde) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pd ptr pd \\<equiv> set_object ptr (ArchObj (PageDirectory pd))\"", "property": "Accessing the x64 VSpace: Kernel Heap Accessors provide functions to retrieve and modify ASID pools, page directories, and their entries, ensuring controlled access to the kernel's virtual memory space.\n\nSubproperties:\n- Get ASID Pool: Retrieve the ASID pool associated with a given object reference.\n- Set ASID Pool: Update the ASID pool for a specific object reference.\n- Get Page Directory: Fetch the page directory for a given object reference.\n- Set Page Directory: Modify the page directory associated with a specific object reference.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": " declared in Arch as workaround for VER-1099 "}
{"spec": "definition\n  get_pde :: \"obj_ref \\<Rightarrow> (pde,'z::state_ext) s_monad\" where\n  \"get_pde ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pd_bits);\n     offset \\<leftarrow> return ((ptr && mask pd_bits) >> word_size_bits);\n     pd \\<leftarrow> get_pd base;\n     return $ pd (ucast offset)\n   od\"\n\ndefinition\n  store_pde :: \"obj_ref \\<Rightarrow> pde \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pde p pde \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pd_bits);\n    offset \\<leftarrow> return ((p && mask pd_bits) >> word_size_bits);\n    pd \\<leftarrow> get_pd base;\n    pd' \\<leftarrow> return $ pd (ucast offset := pde);\n    set_pd base pd'\n  od\"\n\n\ndefinition\n  get_pt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pte,'z::state_ext) s_monad\" where\n  \"get_pt ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageTable pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pte) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pt ptr pt \\<equiv> set_object ptr (ArchObj (PageTable pt))\"", "property": "Kernel Heap Accessors: Provide functions to access and manipulate page directory entries (PDEs) and page tables (PTs) in kernel memory. \n\nGet PDE: Retrieve the actual PDE from a given pointer to a PDE in kernel memory.\nStore PDE: Store a given PDE at a specified location in kernel memory.\nGet PT: Retrieve the page table associated with a given pointer in kernel memory.\nSet PT: Set the page table associated with a given pointer in kernel memory.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PDE in kernel memory\n  and returns the actual PDE."}
{"spec": "definition\n  get_pte :: \"obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\" where\n  \"get_pte ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pt_bits);\n     offset \\<leftarrow> return ((ptr && mask pt_bits) >> word_size_bits);\n     pt \\<leftarrow> get_pt base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pte :: \"obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pte p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pt_bits);\n    offset \\<leftarrow> return ((p && mask pt_bits) >> word_size_bits);\n    pt \\<leftarrow> get_pt base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pt base pt'\n  od\"\n\ndefinition\n  get_pdpt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pdpte,'z::state_ext) s_monad\" where\n  \"get_pdpt ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PDPointerTable pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pdpt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pdpte) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pdpt ptr pt \\<equiv> set_object ptr (ArchObj (PDPointerTable pt))\"", "property": "Kernel Heap Accessors: Provide functions to access and manipulate page tables and page directory pointer tables in kernel memory. \n\nGet PTE: Retrieve the page table entry (PTE) at a given pointer in kernel memory by calculating the base address and offset, then returning the PTE at the calculated offset.\n\nStore PTE: Update the page table entry (PTE) at a given pointer in kernel memory by calculating the base address and offset, then storing the new PTE at the calculated offset.\n\nGet PDPT: Retrieve the page directory pointer table (PDPT) at a given pointer in kernel memory, returning the PDPT if the object is a valid PDPT, or failing otherwise.\n\nSet PDPT: Update the page directory pointer table (PDPT) at a given pointer in kernel memory by setting the object to the new PDPT.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory\n  and returns the actual PTE."}
{"spec": "definition\n  get_pdpte :: \"obj_ref \\<Rightarrow> (pdpte,'z::state_ext) s_monad\" where\n  \"get_pdpte ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pdpt_bits);\n     offset \\<leftarrow> return ((ptr && mask pdpt_bits) >> word_size_bits);\n     pt \\<leftarrow> get_pdpt base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pdpte :: \"obj_ref \\<Rightarrow> pdpte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pdpte p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pdpt_bits);\n    offset \\<leftarrow> return ((p && mask pdpt_bits) >> word_size_bits);\n    pt \\<leftarrow> get_pdpt base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pdpt base pt'\n  od\"\n\ndefinition\n  get_pml4 :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pml4e,'z::state_ext) s_monad\" where\n  \"get_pml4 ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageMapL4 pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pml4 :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pml4e) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pml4 ptr pt \\<equiv> set_object ptr (ArchObj (PageMapL4 pt))\"", "property": "Kernel Heap Accessors: Provide functions to access and modify page directory pointer table entries (PDPTEs) and page map level 4 (PML4) entries in kernel memory.\n\nGet PDPTE and PML4: Retrieve the actual PDPTE or PML4 entry from kernel memory given a pointer.\n\nStore PDPTE: Store a PDPTE at a given location in kernel memory.\n\nSet PML4: Set the PML4 entry for a given pointer in kernel memory.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PDPTE in kernel memory\n  and returns the actual PDPTE."}
{"spec": "definition\n  get_pml4e :: \"obj_ref \\<Rightarrow> (pml4e,'z::state_ext) s_monad\" where\n  \"get_pml4e ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pml4_bits);\n     offset \\<leftarrow> return ((ptr && mask pml4_bits) >> word_size_bits);\n     pt \\<leftarrow> get_pml4 base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pml4e :: \"obj_ref \\<Rightarrow> pml4e \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pml4e p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pml4_bits);\n    offset \\<leftarrow> return ((p && mask pml4_bits) >> word_size_bits);\n    pt \\<leftarrow> get_pml4 base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pml4 base pt'\n  od\"", "property": "Kernel Heap Accessors: Access and modify PML4 entries in kernel memory. \n\nPML4 Entry Retrieval: Retrieve the actual PML4 entry from kernel memory given a pointer to it. \n\nPML4 Entry Update: Update a PML4 entry in kernel memory given a pointer to it and the new entry value.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PML4E in kernel memory\n  and returns the actual PML4E."}
{"spec": "definition\nget_pt_index :: \"vspace_ref \\<Rightarrow> machine_word\" where\n\"get_pt_index vptr \\<equiv> (vptr >> pt_shift_bits) && mask ptTranslationBits\"\n\ndefinition\nget_pd_index :: \"vspace_ref \\<Rightarrow> machine_word\" where\n\"get_pd_index vptr \\<equiv> (vptr >> (pd_shift_bits)) && mask ptTranslationBits\"\n\ndefinition\nget_pdpt_index :: \"vspace_ref \\<Rightarrow> machine_word\" where\n\"get_pdpt_index vptr \\<equiv> (vptr >> (pdpt_shift_bits)) && mask ptTranslationBits\"\n\ndefinition\nget_pml4_index :: \"vspace_ref \\<Rightarrow> machine_word\" where\n\"get_pml4_index vptr \\<equiv> (vptr >> pml4_shift_bits) && mask ptTranslationBits\"", "property": "VSpace Index Retrieval: Extract indices for page tables, page directories, page directory pointer tables, and page map level 4 tables from a virtual address in the x64 VSpace.\n\nSubproperties:\n- Get Page Table Index: Extract the page table index from a virtual address.\n- Get Page Directory Index: Extract the page directory index from a virtual address.\n- Get Page Directory Pointer Table Index: Extract the page directory pointer table index from a virtual address.\n- Get Page Map Level 4 Index: Extract the page map level 4 index from a virtual address.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition\ncopy_global_mappings :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"copy_global_mappings new_pm \\<equiv> do\n    global_pm \\<leftarrow> gets (x64_global_pml4 \\<circ> arch_state);\n    base \\<leftarrow> return $ get_pml4_index pptr_base;\n    pme_bits \\<leftarrow> return word_size_bits;\n    pm_size \\<leftarrow> return (1 << ptTranslationBits);\n    mapM_x (\\<lambda>index. do\n        offset \\<leftarrow> return (index << pme_bits);\n        pme \\<leftarrow> get_pml4e (global_pm + offset);\n        store_pml4e (new_pm + offset) pme\n    od) [base  .e.  pm_size - 1]\n  od\"", "property": "Copy Global Mappings: Duplicate the kernel window mappings in a new page directory object, ensuring that the kernel's virtual address space is accessible from the new page directory. \n\nKernel Window Mapping: The kernel window is mapped into every virtual address space from the pptr_base pointer upwards.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "The kernel window is mapped into every virtual address space from the\n@{term pptr_base} pointer upwards. This function copies the mappings which\ncreate the kernel window into a new page directory object."}
{"spec": "definition\nlookup_pml4_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\" where\n\"lookup_pml4_slot pm vptr \\<equiv> let pm_index = get_pml4_index vptr\n                             in pm + (pm_index << word_size_bits)\"\n\ndefinition\nlookup_pdpt_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"lookup_pdpt_slot pd vptr \\<equiv> doE\n    pml4_slot \\<leftarrow> returnOk (lookup_pml4_slot pd vptr);\n    pml4e \\<leftarrow> liftE $ get_pml4e pml4_slot;\n    (case pml4e of\n          PDPointerTablePML4E tab _ _ \\<Rightarrow> (doE\n            pd \\<leftarrow> returnOk (ptrFromPAddr tab);\n            pd_index \\<leftarrow> returnOk (get_pdpt_index vptr);\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << word_size_bits));\n            returnOk pd_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability pml4_shift_bits)\n odE\"", "property": "x64 VSpace Access: Walk the page directories and tables in software to perform memory management operations, ensuring that the correct page tables and directories are accessed and updated.\n\nLookup PML4 Slot: Calculate the PML4 slot address for a given virtual address by shifting the PML4 index and adding it to the base address.\n\nLookup PDPT Slot: Retrieve the PDPT slot address for a given virtual address by walking the PML4 table, resolving the PDPT table address, and calculating the PDPT slot address. Handle errors if the PML4 entry is not a PDPointerTablePML4E.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "Walk the page directories and tables in software."}
{"spec": "definition\n  lookup_pdpt_slot_no_fail :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\"\nwhere\n  \"lookup_pdpt_slot_no_fail pdpt vptr \\<equiv>\n     pdpt + (get_pdpt_index vptr << word_size_bits)\"", "property": "Lookup PDPT Slot: Calculate the physical address of a PDPT slot from a given PDPT and virtual address.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pdpt_slot} when the pml4 is already known"}
{"spec": "definition\nlookup_pd_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"lookup_pd_slot pd vptr \\<equiv> doE\n    pdpt_slot \\<leftarrow> lookup_pdpt_slot pd vptr;\n    pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n    (case pdpte of\n          PageDirectoryPDPTE tab _ _ \\<Rightarrow> (doE\n            pd \\<leftarrow> returnOk (ptrFromPAddr tab);\n            pd_index \\<leftarrow> returnOk (get_pd_index vptr);\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << word_size_bits));\n            returnOk pd_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability pdpt_shift_bits)\n odE\"", "property": "Lookup Page Directory Slot: Compute the pointer to the Page Directory Entry (PDE) in kernel memory given a page-directory reference and a virtual address. \n\nSubproperties:\n- Retrieve the PDPT slot for the given page-directory reference and virtual address.\n- Get the PDPT entry from the PDPT slot.\n- If the PDPT entry is a Page Directory PDPTE, extract the page directory pointer, calculate the PD index from the virtual address, and compute the PD slot address.\n- If the PDPT entry is not a Page Directory PDPTE, throw a MissingCapability error.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PDE in kernel memory"}
{"spec": "definition\n  lookup_pd_slot_no_fail :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\"\nwhere\n  \"lookup_pd_slot_no_fail pd vptr \\<equiv>\n     pd + (get_pd_index vptr << word_size_bits)\"", "property": "Non-Failing Page Directory Slot Lookup: Calculate the page directory slot address for a given virtual space reference and page directory object reference without failing.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pd_slot} when the pdpt is already known"}
{"spec": "definition\nlookup_pt_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"lookup_pt_slot vspace vptr \\<equiv> doE\n    pd_slot \\<leftarrow> lookup_pd_slot vspace vptr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    (case pde of\n          PageTablePDE ptab _ _ \\<Rightarrow>   (doE\n            pt \\<leftarrow> returnOk (ptrFromPAddr ptab);\n            pt_index \\<leftarrow> returnOk (get_pt_index vptr);\n            pt_slot \\<leftarrow> returnOk (pt + (pt_index << word_size_bits));\n            returnOk pt_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability pd_shift_bits)\n   odE\"", "property": "Lookup Page Table Slot: Compute the pointer to the Page Table Entry (PTE) in kernel memory for a given virtual address and page-directory reference, failing if the virtual address is mapped on a section or super section. \n\nSubproperties:\n- Retrieve the page directory slot for the given virtual address.\n- Get the Page Directory Entry (PDE) from the page directory slot.\n- If the PDE is a Page Table PDE, calculate the page table index and slot.\n- Return the page table slot if successful, or throw an error if the PDE is not a Page Table PDE.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PTE in kernel memory.\n  Note that the function fails if the virtual address is mapped on a section or\n  super section."}
{"spec": "definition\n  lookup_pt_slot_no_fail :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\"\nwhere\n  \"lookup_pt_slot_no_fail pt vptr \\<equiv>\n     pt + (get_pt_index vptr << word_size_bits)\"\n\n\n\n\nend\nend", "property": "Non-Failing Page Table Slot Lookup: Given a page table and a virtual space reference, calculate the physical address of the corresponding page table slot without failing.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pt_slot} when the pd is already known"}
{"spec": "text \\<open>This definition ensures that the given pointer is aligned\nto the given page size.\\<close>\n\ndefinition\n  check_vp_alignment :: \"vmpage_size \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $\n       throwError AlignmentError\"", "property": "Check Virtual Page Alignment: Ensures that a given virtual page pointer is aligned to the specified page size, throwing an AlignmentError if it is not.", "title": "./spec/abstract/X64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "text \\<open>This definition decodes architecture-specific invocations.\n\\<close>\n\ndefinition\n  page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\nwhere\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"\n\n\n\n*)\n\ndefinition\ndecode_page_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap\n                            \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_page_invocation label args cte cap extra_caps \\<equiv> (case cap of\n  PageCap dev p R map_type pgsz mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel X64PageMap then\n    if length args > 2 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             rights_mask = args ! 1;\n             attr = args ! 2;\n             vspace_cap = fst (extra_caps ! 0)\n         in doE\n             (vspace, asid) \\<leftarrow> (case vspace_cap of\n                                   ArchObjectCap (PML4Cap pm (Some asid)) \\<Rightarrow>\n                                         returnOk (pm, asid)\n                                 | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n             case mapped_address of\n               Some (asid', vaddr') \\<Rightarrow> doE\n                 whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n                 whenE (map_type \\<noteq> VMVSpaceMap) $ throwError IllegalOperation;\n                 whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0)\n               odE\n             | None \\<Rightarrow> doE\n                 vtop \\<leftarrow> returnOk $ vaddr + bit (pageBitsForSize pgsz);\n                 whenE (vaddr > user_vtop \\<or> vtop > user_vtop) $ throwError $ InvalidArgument 0\n               odE;\n             vspace' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n             whenE (vspace' \\<noteq> vspace) $ throwError $ InvalidCapability 1;\n             vm_rights \\<leftarrow> returnOk $ mask_vm_rights R $ data_to_rights rights_mask;\n             check_vp_alignment pgsz vaddr;\n             entries \\<leftarrow> create_mapping_entries (addrFromPPtr p) vaddr pgsz vm_rights\n                                               (attribs_from_word attr) vspace;\n             ensure_safe_mapping entries;\n             returnOk $ InvokePage $ PageMap\n               (ArchObjectCap $ PageCap dev p R VMVSpaceMap pgsz (Some (asid,vaddr))) cte entries vspace\n          odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel X64PageUnmap then\n             \\<^cancel>\\<open>case map_type of\n                 VMIOSpaceMap \\<Rightarrow> decode_io_unmap_invocation label args cte cap extra_caps\n               | _ \\<Rightarrow>\\<close> returnOk $ InvokePage $ PageUnmap cap cte\n    \\<^cancel>\\<open>FIXME x64-vtd:\n    else if invocation_type label = ArchInvocationLabel X64PageMapIO\n    then decode_io_map_invocation label args cte cap extra_caps \\<close>\n    else if invocation_type label = ArchInvocationLabel X64PageGetAddress\n    then returnOk $ InvokePage $ PageGetAddr p\n  else throwError IllegalOperation\n | _ \\<Rightarrow> fail)\"\n\ndefinition filter_frame_attrs :: \"frame_attrs \\<Rightarrow> table_attrs\"\nwhere\n  \"filter_frame_attrs attrs \\<equiv> {s. \\<exists>s' \\<in> attrs. s' = PTAttr s}\"\n\ndefinition\n  decode_page_table_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow>\n                                  (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_page_table_invocation label args cte cap extra_caps \\<equiv> (case cap of\n    PageTableCap p mapped_address \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64PageTableMap then\n      if length args > 1 \\<and> length extra_caps > 0\n      then let vaddr = args ! 0;\n               attr = args ! 1;\n               pml4_cap = fst (extra_caps ! 0)\n      in doE\n               whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n               vaddr' \\<leftarrow> returnOk $ vaddr && ~~ mask pd_shift_bits;\n               (pml4, asid) \\<leftarrow> (case pml4_cap of\n                   ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> returnOk (pml4, asid)\n                   | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               whenE (user_vtop < vaddr') $ throwError $ InvalidArgument 0;\n               pml4' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n               whenE (pml4' \\<noteq> pml4) $ throwError $ InvalidCapability 1;\n               pd_slot \\<leftarrow> lookup_error_on_failure False $ lookup_pd_slot pml4 vaddr';\n               old_pde \\<leftarrow> liftE $ get_pde pd_slot;\n               unlessE (old_pde = InvalidPDE) $ throwError DeleteFirst;\n               pde \\<leftarrow> returnOk (PageTablePDE (addrFromPPtr p)\n                                  (filter_frame_attrs $ attribs_from_word attr) vm_read_write);\n               cap' <- returnOk $ ArchObjectCap $ PageTableCap p $ Some (asid, vaddr');\n               returnOk $ InvokePageTable $ PageTableMap cap' cte pde pd_slot pml4\n            odE\n      else throwError TruncatedMessage\n      else if invocation_type label = ArchInvocationLabel X64PageTableUnmap then doE\n               final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n               unlessE final $ throwError RevokeFirst;\n               returnOk $ InvokePageTable $ PageTableUnmap (ArchObjectCap cap) cte\n        odE\n      else throwError IllegalOperation\n  | _ \\<Rightarrow> fail)\"\n\ndefinition\n  decode_page_directory_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow>\n                                      (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_page_directory_invocation label args cte cap extra_caps \\<equiv> (case cap of\n    PageDirectoryCap p mapped_address \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64PageDirectoryMap then\n      if length args > 1 \\<and> length extra_caps > 0\n      then let vaddr = args ! 0;\n               attr = args ! 1;\n               pml4_cap = fst (extra_caps ! 0)\n      in doE\n               whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n               vaddr' \\<leftarrow> returnOk $ vaddr && ~~ mask pdpt_shift_bits;\n               (pml4, asid) \\<leftarrow> (case pml4_cap of\n                       ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> returnOk (pml4, asid)\n                       | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               whenE (user_vtop < vaddr') $ throwError $ InvalidArgument 0;\n               pml4' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n               whenE (pml4' \\<noteq> pml4) $ throwError $ InvalidCapability 1;\n               pdpt_slot \\<leftarrow> lookup_error_on_failure False $ lookup_pdpt_slot pml4 vaddr';\n               old_pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n               unlessE (old_pdpte = InvalidPDPTE) $ throwError DeleteFirst;\n               pdpte \\<leftarrow> returnOk (PageDirectoryPDPTE (addrFromPPtr p)\n                          (filter_frame_attrs $ attribs_from_word attr) vm_read_write);\n               cap' <- returnOk $ ArchObjectCap $ PageDirectoryCap p $ Some (asid, vaddr');\n               returnOk $ InvokePageDirectory $ PageDirectoryMap cap' cte pdpte pdpt_slot pml4\n        odE\n      else throwError TruncatedMessage\n      else if invocation_type label = ArchInvocationLabel X64PageDirectoryUnmap then doE\n               final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n               unlessE final $ throwError RevokeFirst;\n               returnOk $ InvokePageDirectory $ PageDirectoryUnmap (ArchObjectCap cap) cte\n            odE\n      else throwError IllegalOperation\n  | _ \\<Rightarrow> fail)\"\n\ndefinition\n  decode_pdpt_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow>\n                                      (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_pdpt_invocation label args cte cap extra_caps \\<equiv> (case cap of\n    PDPointerTableCap p mapped_address \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64PDPTMap then\n      if length args > 1 \\<and> length extra_caps > 0\n      then let vaddr = args ! 0;\n               attr = args ! 1;\n               pml4_cap = fst (extra_caps ! 0)\n      in doE\n               whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n               vaddr' \\<leftarrow> returnOk $ vaddr && ~~ mask pml4_shift_bits;\n               (pml4 ,asid) \\<leftarrow> (case pml4_cap of\n                       ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> returnOk (pml4, asid)\n                       | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               whenE (user_vtop < vaddr') $ throwError $ InvalidArgument 0;\n               pml4' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid (asid);\n               whenE (pml4' \\<noteq> pml4) $ throwError $ InvalidCapability 1;\n               pml_slot \\<leftarrow> returnOk $ lookup_pml4_slot pml4 vaddr';\n               old_pml4e \\<leftarrow> liftE $ get_pml4e pml_slot;\n               unlessE (old_pml4e = InvalidPML4E) $ throwError DeleteFirst;\n               pml4e \\<leftarrow> returnOk (PDPointerTablePML4E (addrFromPPtr p)\n                          (filter_frame_attrs $ attribs_from_word attr) vm_read_write);\n               cap' <- returnOk $ ArchObjectCap $ PDPointerTableCap p $ Some (asid, vaddr');\n               returnOk $ InvokePDPT $ PDPTMap cap' cte pml4e pml_slot pml4\n            odE\n      else throwError TruncatedMessage\n      else if invocation_type label = ArchInvocationLabel X64PDPTUnmap then doE\n               final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n               unlessE final $ throwError RevokeFirst;\n               returnOk $ InvokePDPT $ PDPTUnmap (ArchObjectCap cap) cte\n         odE\n      else throwError IllegalOperation\n  | _ \\<Rightarrow> fail)\"\n\ndefinition\n  arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n    PDPointerTableCap _ _ \\<Rightarrow> decode_pdpt_invocation label args cte cap extra_caps\n  | PageDirectoryCap _ _ \\<Rightarrow> decode_page_directory_invocation label args cte cap extra_caps\n  | PageTableCap _ _ \\<Rightarrow> decode_page_table_invocation label args cte cap extra_caps\n  | PageCap _ _ _ _ _ _ \\<Rightarrow> decode_page_invocation label args cte cap extra_caps\n  | ASIDControlCap \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64ASIDControlMakePool then\n      if length args > 1 \\<and> length extra_caps > 1\n      then let index = args ! 0;\n               depth = args ! 1;\n               (untyped, parent_slot) = extra_caps ! 0;\n               root = fst (extra_caps ! 1)\n      in doE\n               asid_table \\<leftarrow> liftE $ gets (x64_asid_table \\<circ> arch_state);\n               free_set \\<leftarrow> returnOk (- dom asid_table);\n               whenE (free_set = {}) $ throwError DeleteFirst;\n               free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n               base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n               (p,n) \\<leftarrow> (case untyped of UntypedCap False p n f \\<Rightarrow> returnOk (p,n)\n                                        | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               frame \\<leftarrow> (if n = pageBits\n                        then doE\n                            ensure_no_children parent_slot;\n                            returnOk p\n                          odE\n                        else  throwError $ InvalidCapability 1);\n               dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n               ensure_empty dest_slot;\n               returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n           odE\n   else throwError TruncatedMessage\n   else throwError IllegalOperation\n\n  | ASIDPoolCap p base \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64ASIDPoolAssign then\n      if length extra_caps > 0\n      then let (pd_cap, pd_cap_slot) = extra_caps ! 0 in\n            case pd_cap of\n               ArchObjectCap (PML4Cap _ None) \\<Rightarrow> doE\n                  asid_table \\<leftarrow> liftE $ gets (x64_asid_table \\<circ> arch_state);\n                  pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n                  whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n                  whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n                  pool \\<leftarrow> liftE $ get_asid_pool p;\n                  free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n                  whenE (free_set = {}) $ throwError DeleteFirst;\n                  offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n                  returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pd_cap_slot\n              odE\n            | _ \\<Rightarrow> throwError $ InvalidCapability 1\n      else throwError TruncatedMessage\n      else throwError IllegalOperation\n\n  | IOPortCap f l \\<Rightarrow> decode_port_invocation label args (IOPortCap f l)\n  | IOPortControlCap \\<Rightarrow> decode_ioport_control_invocation label args cte cap (map fst extra_caps)\n  | PML4Cap a b \\<Rightarrow> throwError IllegalOperation\"\n\ndefinition\n  arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\" where\n \"arch_data_to_obj_type n \\<equiv>\n  if      n = 0 then Some PDPTObj\n  else if n = 1 then Some PML4Obj\n  else if n = 2 then Some HugePageObj\n  else if n = 3 then Some SmallPageObj\n  else if n = 4 then Some LargePageObj\n  else if n = 5 then Some PageTableObj\n  else if n = 6 then Some PageDirectoryObj\n  else None\"\n\ndefinition\n  arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"arch_check_irq irq \\<equiv> throwError IllegalOperation\"\n\nend (* context Arch *)\n\nend", "property": "Architecture-specific System Call Decoding: Decodes invocations specific to the architecture, handling various page-related operations (map, unmap, get address), ASID control (make pool, assign), and IO port control.\n\nSubproperties:\n- Page-related Operations: Handles page mapping, unmapping, and getting page addresses, ensuring correct page table and directory updates.\n- ASID Control Operations: Manages ASID pool creation and assignment, ensuring correct ASID table updates and pool management.\n- IO Port Control Operations: Decodes IO port control invocations, handling IO port capability management.\n- Error Handling: Throws errors for invalid operations, truncated messages, and other exceptional conditions.", "title": "./spec/abstract/X64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "datatype pdpt_invocation =\n    PDPTMap cap cslot_ptr pml4e obj_ref obj_ref\n  | PDPTUnmap cap cslot_ptr\n\ndatatype page_directory_invocation =\n    PageDirectoryMap cap cslot_ptr pdpte obj_ref obj_ref\n  | PageDirectoryUnmap cap cslot_ptr\n\ndatatype page_table_invocation =\n    PageTableMap cap cslot_ptr pde obj_ref obj_ref\n  | PageTableUnmap cap cslot_ptr\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation\n     = PageMap\n         (page_map_cap: cap)\n         (page_map_ct_slot: cslot_ptr)\n         (page_map_entries: \"vm_page_entry \\<times> obj_ref\")\n         (page_map_vspace: obj_ref)\n     | PageUnmap\n         (page_unmap_cap: arch_cap)\n         (page_unmap_cap_slot: cslot_ptr)", "property": "X64-Specific System Call Arguments: Define the arguments for various x64-specific system calls, including page directory, page table, and ASID control operations. These arguments specify the necessary parameters for mapping and unmapping pages, as well as assigning and managing ASIDs.\n\nSubproperties:\n- Page Mapping and Unmapping: Specify the arguments for mapping and unmapping pages, including the capability, slot pointer, and object references.\n- ASID Control and Assignment: Define the arguments for making an ASID pool and assigning an ASID to a specific object reference.\n- Page Directory and Table Operations: Specify the arguments for mapping and unmapping page directories and tables, including the capability, slot pointer, and object references.", "title": "./spec/abstract/X64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the various possible\nx64-specific system calls. Selectors are defined for various fields\nfor convenience elsewhere."}
{"spec": "| PageGetAddr\n         (page_get_paddr: obj_ref)\n\ndatatype io_port_invocation_data\n  = IOPortIn8 | IOPortIn16 | IOPortIn32\n  | IOPortOut8 \"8 word\" | IOPortOut16 \"16 word\" | IOPortOut32 \"32 word\"\n\ndatatype io_port_invocation = IOPortInvocation io_port io_port_invocation_data\n\ndatatype io_port_control_invocation = IOPortControlInvocation io_port io_port cslot_ptr cslot_ptr", "property": "Page I/O Map Invocation: Allows for the mapping of a page for I/O operations, involving a page I/O map capability, a C slot pointer, an ASID, and page I/O map entries. It enables the kernel to manage page I/O mappings effectively.\n\nSubproperties:\n- Page Get Address: Retrieves the physical address of a page.\n- I/O Port Invocation: Invokes I/O port operations (in or out) with specific data sizes (8, 16, or 32 bits).\n- I/O Port Control Invocation: Controls I/O port operations, involving source and destination C slot pointers.", "title": "./spec/abstract/X64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "     | PageIOMap\n         (page_iomap_cap: cap)\n         (page_iomap_ct_clot: cslot_ptr)\n         (page_iomap_asid: iopte)\n         (page_iomap_entries: \"obj_ref\") "}
{"spec": "datatype arch_invocation\n     = InvokePageTable page_table_invocation\n     | InvokePageDirectory page_directory_invocation\n     | InvokePDPT pdpt_invocation\n     | InvokePage page_invocation\n     | InvokeASIDControl asid_control_invocation\n     | InvokeASIDPool asid_pool_invocation\n     | InvokeIOPort io_port_invocation\n     | InvokeIOPortControl io_port_control_invocation", "property": "Arch Invocation Types: Supports various architecture-specific invocations, including page table, page directory, PDPT, page, ASID control, ASID pool, I/O port, and I/O port control invocations, allowing for efficient management of hardware resources and virtual memory.", "title": "./spec/abstract/X64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "\ndatatype io_pt_invocation\n     = IOPageTableMapContext cap cslot_ptr iocte obj_ref\n     | IOPageTableMap cap cslot_ptr iopte obj_ref\n     | IOPageTableUnmap cap cslot_ptr "}
{"spec": "datatype arch_copy_register_sets = X64NoExtraRegisters\n\ndefinition \"ArchDefaultExtraRegisters \\<equiv> X64NoExtraRegisters\"\n\ndatatype arch_irq_control_invocation\n  = IssueIRQHandlerIOAPIC irq cslot_ptr cslot_ptr\n      machine_word machine_word machine_word machine_word machine_word\n  | IssueIRQHandlerMSI irq cslot_ptr cslot_ptr\n      machine_word machine_word machine_word machine_word\n\nend\nend", "property": "Invoke I/O Page Table: Handle invocations related to I/O page tables, including issuing IRQ handlers for IOAPIC and MSI interrupts.", "title": "./spec/abstract/X64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "| InvokeIOPT io_pt_invocation"}
{"spec": "type_synonym io_port = \"16 word\"\ntype_synonym io_asid = \"16 word\"", "property": "Architecture-Specific Capability Types: Define specific data types for x64 architecture capabilities, including io_port and io_asid, which are both 16-word types.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific capabilities", "comment": ""}
{"spec": "text \\<open>The x64 kernel supports capabilities for ASID pools and an ASID controller capability,\nalong with capabilities for IO ports and spaces, as well as virtual memory mappings.\\<close>\n\ndatatype arch_cap =\n   ASIDPoolCap (acap_asid_pool : obj_ref) (acap_asid_base : asid)\n | ASIDControlCap\n | IOPortCap (acap_io_port_first_port : io_port) (acap_io_port_last_port : io_port)\n | IOPortControlCap\n\n | PageCap bool obj_ref (acap_rights : cap_rights) vmmap_type vmpage_size \"(asid * vspace_ref) option\"\n | PageTableCap obj_ref \"(asid * vspace_ref) option\"\n | PageDirectoryCap obj_ref \"(asid * vspace_ref) option\"\n | PDPointerTableCap obj_ref \"(asid * vspace_ref) option\"\n | PML4Cap obj_ref \"asid option\"", "property": "x64 Architecture-Specific Capabilities: Supports capabilities for ASID pools, ASID controllers, IO ports, IO port controllers, and virtual memory mappings, including page, page table, page directory, PD pointer table, and PML4 capabilities. \n\nSubproperties:\n- ASID Pool Capabilities: Specify the ASID pool and base ASID for the capability.\n- IO Port Capabilities: Define the range of IO ports for the capability.\n- Virtual Memory Mapping Capabilities: Include page, page table, page directory, PD pointer table, and PML4 capabilities, specifying the object reference, rights, mapping type, size, and optional ASID and vspace reference.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "datatype cr3 = cr3 obj_ref asid\n\nprimrec\n  cr3_base_address :: \"cr3 \\<Rightarrow> obj_ref\"\nwhere\n  \"cr3_base_address (cr3 addr _) = addr\"\n\nprimrec\n  cr3_pcid :: \"cr3 \\<Rightarrow> asid\"\nwhere\n  \"cr3_pcid (cr3 _ pcid) = pcid\"", "property": "CR3 Data Type: Represents a control register 3 (CR3) data structure, containing a base address and a PCID (Process Context Identifier), which are essential for managing memory and process contexts in x64 architecture. \n\nBase Address Extraction: Extracts the base address from a given CR3 data structure.\nPCID Extraction: Extracts the PCID from a given CR3 data structure.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific objects", "comment": " cr3 Stuff "}
{"spec": "datatype table_attr = Accessed | CacheDisabled | WriteThrough | ExecuteDisable\ntype_synonym table_attrs = \"table_attr set\"\n\ndatatype frame_attr = PTAttr table_attr | Global | PAT | Dirty\ntype_synonym frame_attrs = \"frame_attr set\"\n\ndatatype pml4e\n     = InvalidPML4E\n     | PDPointerTablePML4E\n         (pml4_table : obj_ref)\n         (pml4e_attrs : table_attrs)\n         (pml4e_rights : vm_rights)\n\ndatatype pdpte\n     = InvalidPDPTE\n     | PageDirectoryPDPTE\n         (pdpt_table : obj_ref)\n         (pdpt_table_attrs : table_attrs)\n         (pdpt_rights : vm_rights)\n     | HugePagePDPTE\n         (pdpt_frame : obj_ref)\n         (pdpt_frame_attrs : frame_attrs)\n         (pdpt_rights : vm_rights)\n\ndatatype pde\n      = InvalidPDE\n      | PageTablePDE\n         obj_ref\n         (pt_attrs : table_attrs)\n         (pde_rights : cap_rights)\n      | LargePagePDE\n         obj_ref\n         (pde_page_attrs : frame_attrs)\n         (pde_rights: cap_rights)\n\ndatatype pte\n      = InvalidPTE\n      | SmallPagePTE\n         (pte_frame: obj_ref)\n         (pte_frame_attrs : frame_attrs)\n         (pte_rights : cap_rights)\n\n\ndatatype vm_page_entry = VMPTE pte | VMPDE pde | VMPDPTE pdpte\n\ndatatype translation_type = NotTranslated | Translated\n\ndatatype iocte =\n   InvalidIOCTE\n | VTDCTE\n   (domain_id : word16)\n   (res_mem_reg: bool)\n   (address_width: nat)\n   (next_level_ptr: obj_ref)\n   (translation_type: translation_type)\n   (iocte_present : bool)\n\ndatatype iopte =\n   InvalidIOPTE\n | VTDPTE\n   (frame_ptr : obj_ref)\n   (io_pte_rights  : vm_rights)\n\ndatatype iorte =\n   InvalidIORTE\n | VTDRTE\n   (context_table : obj_ref)\n   (iorte_present : bool)\n\ndatatype arch_kernel_obj =\n   ASIDPool \"9 word \\<rightharpoonup> obj_ref\"\n | PageTable \"9 word \\<Rightarrow> pte\"\n | PageDirectory \"9 word \\<Rightarrow> pde\"\n | PDPointerTable \"9 word \\<Rightarrow> pdpte\"\n | PageMapL4 \"9 word \\<Rightarrow> pml4e\"\n | DataPage bool vmpage_size\n\n\ndefinition table_size :: nat where\n  \"table_size = ptTranslationBits + word_size_bits\"\n\ndefinition iotable_size :: nat where\n  \"iotable_size = ptTranslationBits + 2*word_size_bits\"\n\ndefinition cte_level_bits :: nat where\n  \"cte_level_bits \\<equiv> 5\"\n\nprimrec\n  arch_obj_size :: \"arch_cap \\<Rightarrow> nat\"\nwhere\n  \"arch_obj_size (ASIDPoolCap _ _) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (IOPortCap _ _) = 0\"\n| \"arch_obj_size IOPortControlCap = 0\"\n\n| \"arch_obj_size (PageCap _ _ _ _ sz _) = pageBitsForSize sz\"\n| \"arch_obj_size (PageTableCap _ _) = table_size\"\n| \"arch_obj_size (PageDirectoryCap _ _) = table_size\"\n| \"arch_obj_size (PDPointerTableCap _ _) = table_size\"\n| \"arch_obj_size (PML4Cap _ _) = table_size\"\n\nprimrec\n  arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_cap_is_device (ASIDPoolCap _ _) = False\"\n| \"arch_cap_is_device ASIDControlCap = False\"\n| \"arch_cap_is_device (IOPortCap _ _) = False\"\n| \"arch_cap_is_device IOPortControlCap = False\"\n\n| \"arch_cap_is_device (PageCap is_dev _ _ _ _ _) = is_dev\"\n| \"arch_cap_is_device (PageTableCap _ _) = False\"\n| \"arch_cap_is_device (PageDirectoryCap _ _) = False\"\n| \"arch_cap_is_device (PDPointerTableCap _ _) = False\"\n| \"arch_cap_is_device (PML4Cap _ _) = False\"\n\ndefinition tcb_bits :: nat where\n  \"tcb_bits \\<equiv> 11\"\n\ndefinition endpoint_bits :: nat where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat where\n  \"ntfn_bits \\<equiv> 5\"\n\ndefinition untyped_min_bits :: nat where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat where\n  \"untyped_max_bits \\<equiv> 47\"\n\nprimrec\n  arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\"\nwhere\n  \"arch_kobj_size (ASIDPool _) = pageBits\"\n| \"arch_kobj_size (PageTable _) = table_size\"\n| \"arch_kobj_size (PageDirectory _) = table_size\"\n| \"arch_kobj_size (PDPointerTable _) = table_size\"\n| \"arch_kobj_size (PageMapL4 _) = table_size\"\n| \"arch_kobj_size (DataPage _ sz) = pageBitsForSize sz\"\n\nprimrec\n  aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\"\nwhere\n  \"aobj_ref (ASIDPoolCap x _) = Some x\"\n| \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref (IOPortCap _ _) = None\"\n| \"aobj_ref IOPortControlCap = None\"\n\n| \"aobj_ref (PageCap _ x _ _ _ _) = Some x\"\n| \"aobj_ref (PageDirectoryCap x _) = Some x\"\n| \"aobj_ref (PageTableCap x _) = Some x\"\n| \"aobj_ref (PDPointerTableCap x _) = Some x\"\n| \"aobj_ref (PML4Cap x _) = Some x\"\n\n\ndefinition\n  acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\" where\n \"acap_rights_update rs ac \\<equiv> case ac of\n    PageCap dev x rs' m sz as \\<Rightarrow> PageCap dev x (validate_vm_rights rs) m sz as\n  | _                   \\<Rightarrow> ac\"", "property": "x64-Specific Data Types and Architecture-specific objects: Define the structure and attributes of various x64-specific data types and architecture-specific objects, including table entries, page entries, and capability rights, to ensure proper management and validation of memory and capabilities in the x64 architecture.\n\nSubproperties:\n- Table and Page Entry Structure: Define the structure and attributes of table entries (pml4e, pdpte, pde, pte) and page entries (vm_page_entry) to ensure proper memory management and translation.\n- Capability Rights Validation: Validate capability rights (acap_rights_update) to ensure that they conform to the required format and permissions.\n- Architecture-specific Object Sizes: Define the sizes of architecture-specific objects (arch_obj_size, arch_kobj_size) to ensure proper memory allocation and management.\n- Device Capability Identification: Identify device capabilities (arch_cap_is_device) to ensure proper management and validation of device-related capabilities.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "datatype\n  aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | HugePageObj\n  | PageTableObj\n  | PageDirectoryObj\n  | PDPTObj\n  | PML4Obj\n  | ASIDPoolObj\n\ndatatype X64IRQState =\n   IRQFree\n | IRQReserved\n | IRQMSI\n      (MSIBus : machine_word)\n      (MSIDev : machine_word)\n      (MSIFunc : machine_word)\n      (MSIHandle : machine_word)\n | IRQIOAPIC\n      (IRQioapic : machine_word)\n      (IRQPin : machine_word)\n      (IRQLevel : machine_word)\n      (IRQPolarity : machine_word)\n      (IRQMasked : bool)\n\ndefinition\n  arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\"\nwhere\n  \"arch_is_frame_type aobj \\<equiv> case aobj of\n         SmallPageObj \\<Rightarrow> True\n       | LargePageObj \\<Rightarrow> True\n       | HugePageObj \\<Rightarrow> True\n       | _ \\<Rightarrow> False\"\n\ndefinition\n  arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\" where\n \"arch_default_cap tp r n dev \\<equiv> case tp of\n    SmallPageObj \\<Rightarrow> PageCap dev r vm_read_write VMNoMap X64SmallPage None\n  | LargePageObj \\<Rightarrow> PageCap dev r vm_read_write VMNoMap X64LargePage None\n  | HugePageObj \\<Rightarrow> PageCap dev r vm_read_write VMNoMap X64HugePage None\n  | PageTableObj \\<Rightarrow> PageTableCap r None\n  | PageDirectoryObj \\<Rightarrow> PageDirectoryCap r None\n  | PDPTObj \\<Rightarrow> PDPointerTableCap r None\n  | PML4Obj \\<Rightarrow> PML4Cap r None\n  | ASIDPoolObj \\<Rightarrow> ASIDPoolCap r 0\" (* unused *)\n\ndefinition\n  default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\" where\n \"default_arch_object tp dev n \\<equiv> case tp of\n    SmallPageObj \\<Rightarrow> DataPage dev X64SmallPage\n  | LargePageObj \\<Rightarrow> DataPage dev X64LargePage\n  | HugePageObj \\<Rightarrow> DataPage dev X64HugePage\n  | PageTableObj \\<Rightarrow> PageTable (\\<lambda>x. InvalidPTE)\n  | PageDirectoryObj \\<Rightarrow> PageDirectory (\\<lambda>x. InvalidPDE)\n  | PDPTObj \\<Rightarrow> PDPointerTable (\\<lambda>x. InvalidPDPTE)\n  | PML4Obj \\<Rightarrow> PageMapL4 (\\<lambda>x. InvalidPML4E)\n  | ASIDPoolObj \\<Rightarrow> ASIDPool (\\<lambda>_. None)\"\n\ntype_synonym x64_vspace_region_uses = \"vspace_ref \\<Rightarrow> x64vspace_region_use\"\n\nend\n\nqualify X64_A (in Arch)", "property": "Architecture-Specific Object Types and Default Objects: Defines various x64-specific object types, including page objects, table objects, and interrupt objects, along with their default capabilities and kernel objects. It provides a way to identify frame types and create default objects for different architectures.\n\nSubproperties:\n- x64 Object Types: Enumerates the different types of objects specific to the x64 architecture, including page objects, table objects, and interrupt objects.\n- Default Capabilities: Defines the default capabilities for each object type, including page capabilities, table capabilities, and ASID pool capabilities.\n- Default Kernel Objects: Specifies the default kernel objects for each object type, including data pages, page tables, and interrupt objects.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "record arch_state =\n  x64_asid_table            :: \"3 word \\<rightharpoonup> obj_ref\"\n  x64_global_pml4           :: obj_ref\n  x64_kernel_vspace         :: X64_A.x64_vspace_region_uses\n  x64_global_pts            :: \"obj_ref list\"\n  x64_global_pdpts          :: \"obj_ref list\"\n  x64_global_pds            :: \"obj_ref list\"\n  x64_current_cr3           :: \"X64_A.cr3\"\n  x64_allocated_io_ports    :: \"X64_A.io_port \\<Rightarrow> bool\"\n  x64_num_ioapics           :: \"64 word\"\n  x64_ioapic_nirqs          :: \"machine_word \\<Rightarrow> 8 word\"\n  x64_irq_state             :: \"8 word \\<Rightarrow> X64_A.X64IRQState\"\n\n\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  pd_shift_bits :: \"nat\" where\n  \"pd_shift_bits \\<equiv> pageBits + ptTranslationBits\"\n\ndefinition\n  pt_shift_bits :: \"nat\" where\n  \"pt_shift_bits \\<equiv> pageBits\"\n\ndefinition\n  pdpt_shift_bits :: \"nat\" where\n  \"pdpt_shift_bits \\<equiv> pageBits + ptTranslationBits + ptTranslationBits\"\n\ndefinition\n  pml4_shift_bits :: \"nat\" where\n  \"pml4_shift_bits \\<equiv> pageBits + ptTranslationBits + ptTranslationBits + ptTranslationBits\"\n\ndefinition\n  pt_bits :: \"nat\" where\n  \"pt_bits \\<equiv> table_size\"\n\ndefinition\n  pd_bits :: \"nat\" where\n  \"pd_bits \\<equiv> table_size\"\n\ndefinition\n  pdpt_bits :: \"nat\" where\n  \"pdpt_bits \\<equiv> table_size\"\n\ndefinition\n  pml4_bits :: \"nat\" where\n  \"pml4_bits \\<equiv> table_size\"\n\ndefinition\n  iopt_bits :: \"nat\" where\n  \"iopt_bits \\<equiv> iotable_size\"\n\ndefinition\n  vtd_cte_size_bits :: \"nat\" where\n  \"vtd_cte_size_bits \\<equiv> 8\"\n\ndefinition\n  vtd_pt_bits :: \"nat\" where\n  \"vtd_pt_bits \\<equiv> iotable_size\"\n\ndefinition\n  x64_num_io_pt_levels :: \"nat\" where\n  \"x64_num_io_pt_levels \\<equiv> 4\"", "property": "x64 Architecture State: Defines the architecture-specific state for x64, including the ASID table, global PML4, kernel virtual space, global page tables, and I/O port management. It provides a set of definitions for various bit shifts and sizes used in the x64 architecture, such as page directory shifts, page table shifts, and I/O port table sizes.\n\nSubproperties:\n- ASID Table Management: Manages the x64 ASID table, which maps ASIDs to object references.\n- Global Page Table Management: Manages the global PML4, page directories, and page tables for the x64 architecture.\n- I/O Port Management: Manages the allocated I/O ports, I/O APICs, and IRQ states for the x64 architecture.\n- Bit Shift and Size Definitions: Defines various bit shifts and sizes used in the x64 architecture, such as page directory shifts, page table shifts, and I/O port table sizes.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable\n  | APageDirectory\n  | APDPointerTable\n  | APageMapL4\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\"\nwhere\n \"aa_type ao \\<equiv> (case ao of\n           PageTable pt             \\<Rightarrow> APageTable\n         | PageDirectory pd         \\<Rightarrow> APageDirectory\n         | DataPage dev sz          \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n         | ASIDPool f               \\<Rightarrow> AASIDPool\n         | PDPointerTable pdpt      \\<Rightarrow> APDPointerTable\n         | PageMapL4 pm             \\<Rightarrow> APageMapL4)\"", "property": "x64-Specific Data Types Classification: Classify x64-specific kernel objects into distinct types, including ASID pool, page table, page directory, PD pointer table, page map L4, user data, and device data, to ensure accurate and efficient management of these objects within the kernel.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "definition\n  badge_bits :: nat where\n  \"badge_bits \\<equiv> 64\"\n\nend", "property": "Badge Bits Definition: The badge word has a fixed size of 64 bits.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": "For implementation reasons the badge word has differing amounts of bits"}
{"spec": "qualify X64_A (in Arch)", "property": "Arch-specific TCB: Define architecture-specific data types for the Thread Control Block (TCB) on the x64 architecture.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Arch-specific TCB", "comment": ""}
{"spec": "record arch_tcb =\n  tcb_context :: user_context\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  default_arch_tcb :: arch_tcb where\n  \"default_arch_tcb \\<equiv> \\<lparr>tcb_context = new_context\\<rparr>\"", "property": "Arch-Specific TCB Structure: The arch-specific part of a TCB contains a field for the user context, which is initialized with a new context in the default arch TCB.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Arch-specific TCB", "comment": " Arch-specific part of a TCB: this must have at least a field for user context. "}
{"spec": "definition\n  arch_tcb_context_set :: \"user_context \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\nwhere\n  \"arch_tcb_context_set uc a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := uc \\<rparr>\"\n\ndefinition\n  arch_tcb_context_get :: \"arch_tcb \\<Rightarrow> user_context\"\nwhere\n  \"arch_tcb_context_get a_tcb \\<equiv> tcb_context a_tcb\"", "property": "Arch TCB Context Accessors: Provide access to the user context within the architecture-specific TCB, enabling compatibility with user monad operations. \n\n Arch TCB Context Setter: Set the user context within the architecture-specific TCB.\n Arch TCB Context Getter: Retrieve the user context from the architecture-specific TCB.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Arch-specific TCB", "comment": " Accessors for @{text \"tcb_context\"} inside @{text \"arch_tcb\"}.\n  These are later used to implement @{text as_user}, i.e.\\ need to be\n  compatible with @{text user_monad}."}
{"spec": "definition\n  arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\nwhere\n  \"arch_tcb_set_registers regs a_tcb \\<equiv>\n    a_tcb \\<lparr> tcb_context := UserContext (fpu_state (tcb_context a_tcb)) regs \\<rparr>\"\n\ndefinition\n  arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\"\nwhere\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\n\nend", "property": "Arch-Specific TCB Accessors: Provide access to the user register part of the arch_tcb, enabling getting and setting of registers while maintaining the integrity of the tcb_context.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n Accessors for the user register part of the @{text \"arch_tcb\"}.\n (Because @{typ \"register \\<Rightarrow> machine_word\"} may not be equal to @{typ user_context}).\n"}
{"spec": "(*\nFunctions for fault handling.\n*)\n\nchapter \\<open>arch fault related functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\nwhere\n \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData) od\"\n\ndefinition\n  handle_arch_fault_reply :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"handle_arch_fault_reply vmf thread x y \\<equiv> return True\"\n\n\nend\n\nend", "property": "Arch Fault Handling: Provides functions for creating architecture-specific fault messages and handling replies to these faults, ensuring proper error handling and communication between threads in the event of a fault.\n\nMake Arch Fault Message: Creates an architecture-specific fault message for a given fault and thread, including the program counter, fault address, and architecture-specific data.\n\nHandle Arch Fault Reply: Handles the reply to an architecture-specific fault, currently simply returning True.", "title": "./spec/abstract/X64/ArchFault_A.thy", "chapter": "arch fault related functions", "section": "", "comment": ""}
{"spec": "(*\nArch-specific functions for the abstract model of CSpace.\n*)\n\nchapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  sanitise_or_flags :: machine_word\nwhere\n  \"sanitise_or_flags \\<equiv> bit 1 || bit 9\"\n\ndefinition\n  sanitise_and_flags :: machine_word\nwhere\n  \"sanitise_and_flags \\<equiv> mask 12 && ~~ bit 8 && ~~ bit 3 && ~~ bit 5\"\n\ndefinition\n  sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"sanitise_register t r v \\<equiv>\n    let val = (if r = FaultIP \\<or> r = NextIP \\<or> r = FS_BASE \\<or> r = GS_BASE\n               then if v > 0x00007fffffffffff \\<and> v < 0xffff800000000000 then 0 else v\n               else v)\n    in\n      if r = FLAGS then (val || sanitise_or_flags) && sanitise_and_flags else val\"\n\ndefinition\n  arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\nwhere\n  \"arch_get_sanitise_register_info t \\<equiv> return False\"\n\ndefinition\n  arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\nwhere\n  \"arch_post_modify_registers cur t \\<equiv> when (t \\<noteq> cur) $ as_user t $ setRegister ErrorRegister 0\"\n\nend\nend", "property": "TCB Register Management: Sanitizes and manages register values for threads, ensuring that certain registers are modified or cleared according to architecture-specific rules, and that register values are valid and correctly formatted.\n\nSubproperties:\n- Sanitizes register values based on specific conditions and rules.\n- Clears the ErrorRegister for threads other than the current thread after modifying registers.", "title": "./spec/abstract/X64/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "| \"arch_same_region_as (IOPortCap frst lst) c' =\n   (\\<exists>frst' lst'. c' = IOPortCap frst' lst' \\<and> frst' = frst \\<and> lst' = lst)\"\n| \"arch_same_region_as IOPortControlCap c' = (c' = IOPortControlCap \\<or> (\\<exists>f l. c' = IOPortCap f l))\"", "property": "IOPort Capability Region Equivalence: Determine if two IOPort capabilities refer to the same region. \n\n- IOPortCap Equivalence: Two IOPortCap capabilities are equivalent if their first and last port numbers match.\n- IOPortControlCap Equivalence: An IOPortControlCap capability is equivalent to another IOPortControlCap capability or any IOPortCap capability.", "title": "./spec/abstract/X64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n \"same_aobject_as cp cp' \\<equiv>\n   (case (cp, cp') of\n      (PageCap dev ref _ _ pgsz _, PageCap dev' ref' _ _ pgsz' _)\n          \\<Rightarrow> (dev, ref, pgsz) = (dev', ref', pgsz')\n              \\<and> ref \\<le> ref + 2 ^ pageBitsForSize pgsz - 1\n    | (IOPortControlCap, IOPortCap f' l') \\<Rightarrow> False\n    | _ \\<Rightarrow> arch_same_region_as cp cp')\"\n\ndeclare same_aobject_as_def[simp]\n\ndefinition\n  arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"arch_is_cap_revocable new_cap src_cap \\<equiv>\n           if \\<exists>f l. new_cap = ArchObjectCap (IOPortCap f l)\n             then src_cap = ArchObjectCap IOPortControlCap\n             else False\"\n\nend\nend", "property": "Arch Capability Comparison: Compare two architecture-specific capabilities to determine if they refer to the same object, considering factors such as device, reference, and page size for page capabilities, and checking for revocability in the case of I/O port capabilities.\n\n Arch Capability Revocability: Determine if a new capability can be revoked based on its type and the source capability, specifically checking if the new capability is an I/O port capability and the source capability is an I/O port control capability.", "title": "./spec/abstract/X64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "type_synonym obj_ref            = machine_word\ntype_synonym vspace_ref         = machine_word\n\ntype_synonym data               = machine_word\ntype_synonym cap_ref            = \"bool list\"\ntype_synonym length_type        = machine_word\n\ntype_synonym asid_low_len      = 9\ntype_synonym asid_low_index    = \"asid_low_len word\"\n\ntype_synonym asid_high_len      = 3\ntype_synonym asid_high_index    = \"asid_high_len word\"", "property": "Type Instantiation: Define concrete types for abstract type names in the specification for the x64 architecture, including object references, virtual space references, data, capability references, and length types. \n\n Subproperties:\n- Object Reference Type: obj_ref is instantiated as machine_word.\n- Virtual Space Reference Type: vspace_ref is instantiated as machine_word.\n- Data Type: data is instantiated as machine_word.\n- Capability Reference Type: cap_ref is instantiated as a list of boolean values.\n- Length Type: length_type is instantiated as machine_word.\n- ASID Low Length: asid_low_len is set to 9.\n- ASID Low Index Type: asid_low_index is instantiated as a 9-bit word.\n- ASID High Length: asid_high_len is set to 3.\n- ASID High Index Type: asid_high_index is instantiated as a 3-bit word.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object\n  references, user pointers, word-based data, cap references, and so\n  on. This theory provides an instantiation of these names to concrete\n  types for the x64 architecture. Other architectures may have slightly\n  different instantiations.\n"}
{"spec": "type_synonym asid_len           = 12\ntype_synonym asid_rep_len       = machine_word_len\ntype_synonym asid               = \"asid_rep_len word\"", "property": "ASID Representation: ASIDs are represented as machine words with a fixed length, ensuring that the extra bits beyond the required 12 bits are zero.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": " Making asid a machine_word means that we need invariants that the extra bits are zero. "}
{"spec": "definition\n  oref_to_data   :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_oref   :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition\n  vref_to_data   :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_vref   :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition\n  nat_to_len     :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition\n  data_to_nat    :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition\n  data_to_16     :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition\n  data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition\n  combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition\n  combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Provide functions for converting between different data types, including object references, virtual space references, natural numbers, length types, and capability pointers, to facilitate data manipulation and exchange in the system.\n\nSubproperties:\n- Identity Conversions: Define identity functions for converting between abstract type names, such as object references and data, and virtual space references and data.\n- Numeric Conversions: Specify functions for converting between natural numbers and length types, as well as between data and natural numbers.\n- Bitwise Conversions: Define functions for converting between data and 16-bit words using unsigned casting.\n- Capability Pointer Conversions: Provide a function for converting data to capability pointers using bit list representation.\n- Notification Combinations: Define functions for combining notification badges and messages using bitwise OR operations.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "With the definitions above, most conversions between abstract\ntype names boil down to just the identity function, some convert from\n@{text word} to @{typ nat} and others between different word sizes\nusing @{const ucast}."}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversions: Define conversions between different data types, including object references, virtual references, lengths, and capability pointers, to facilitate automatic unfolding in proofs.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition\n  slot_bits :: nat where\n  \"slot_bits \\<equiv> 5\"\n\ndefinition\n  msg_label_bits :: nat where\n  [simp]: \"msg_label_bits \\<equiv> 52\"\n\ndefinition\n  new_context :: \"user_context\" where\n  \"new_context \\<equiv> UserContext FPUNullState ((\\<lambda>r. 0)(CS := selCS3, SS := selDS3, FLAGS := 0x202))\"\n\ndefinition\n  pptr_base :: \"machine_word\" where\n  \"pptr_base = Platform.X64.pptrBase\"", "property": "Architecture-Dependent Sizes and Constants: Define various architecture-dependent sizes and constants, including the slot size, message label size, initial user context, and physical pointer base address. \n\nSubproperties:\n- Slot Size: The slot size is fixed at 5 bits.\n- Message Label Size: The message label size is fixed at 52 bits.\n- Initial User Context: The initial user context is defined with specific register settings.\n- Physical Pointer Base Address: The physical pointer base address is set to a platform-specific value.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "The following definitions provide architecture-dependent sizes\n  such as the standard page size and capability size of the underlying\n  machine.\n"}
{"spec": "definition\n  user_vtop :: \"machine_word\" where\n  \"user_vtop = Platform.X64.pptrUserTop\"", "property": "User Virtual Address Space: Defines the maximum virtual address available to users.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": " Virtual address space available to users. "}
{"spec": "definition\n  kernel_base :: \"vspace_ref\" where\n  \"kernel_base \\<equiv> 0xffffffff80000000\"\n\ndefinition\n  idle_thread_ptr :: vspace_ref where\n  \"idle_thread_ptr = kernel_base + 0x1000\"\n\nend\n\narch_requalify_consts (A) idle_thread_ptr\n\ncontext Arch begin arch_global_naming (A)", "property": "Kernel Window Base Address: The kernel reserves virtual addresses from a fixed base address (0xffffffff80000000) upwards in every virtual address space, providing a consistent and protected region for kernel operations. \n\nIdle Thread Pointer: The idle thread pointer is offset from the kernel base address by 0x1000, providing a fixed location for the idle thread in the kernel's virtual address space.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "The lowest virtual address in the kernel window. The kernel reserves the\nvirtual addresses from here up in every virtual address space."}
{"spec": "definition\n  nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\" where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len)\n                           (to_bl (of_nat n :: machine_word))\"\ndefinition\n \"msg_info_register \\<equiv> msgInfoRegister\"\ndefinition\n \"msg_registers \\<equiv> msgRegisters\"\ndefinition\n \"cap_register \\<equiv> capRegister\"\ndefinition\n \"badge_register \\<equiv> badgeRegister\"\ndefinition\n \"frame_registers \\<equiv> frameRegisters\"\ndefinition\n \"gp_registers \\<equiv> gpRegisters\"\ndefinition\n \"exception_message \\<equiv> exceptionMessage\"\ndefinition\n \"syscall_message \\<equiv> syscallMessage\"\n\ndatatype arch_fault\n  = VMFault vspace_ref \"machine_word list\"\n\nend\nend", "property": "Architecture-Specific Capability Reference Conversion: The conversion of a natural number to a capability reference is architecture-specific. It involves dropping the most significant bits of the binary representation of the natural number to obtain the capability reference. \n\nArchitecture-Specific Definitions: Various architecture-specific definitions are provided for message information, message registers, capability registers, badge registers, frame registers, general-purpose registers, exception messages, and system call messages. \n\nArchitecture-Specific Faults: The architecture-specific faults include virtual memory faults, which are represented by a reference to the virtual space and a list of machine words.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": " is nat_to_cref arch specific ? "}
{"spec": "arch_requalify_consts\n  maxIRQ\n\nend", "property": "Maximum IRQ Value: The maximum IRQ value is defined as a constant, which is architecture-dependent, ensuring that the kernel is configured to handle the correct range of interrupt requests for the specific architecture.", "title": "./spec/abstract/RISCV64/ArchInterrupt_A.thy", "chapter": "", "section": "", "comment": " On Arm architectures, maxIRQ is defined in Kernel_Config. On RISCV64 it is defined manually. "}
{"spec": "definition perform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_asid_control_invocation iv \\<equiv> case iv of\n     MakePool frame slot parent base \\<Rightarrow> do\n       delete_objects frame pageBits;\n       pcap \\<leftarrow> get_cap parent;\n       set_cap (max_free_index_update pcap) parent;\n       retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n       cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n       assert (asid_low_bits_of base = 0);\n       asid_table \\<leftarrow> gets (riscv_asid_table \\<circ> arch_state);\n       asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n       modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>riscv_asid_table := asid_table'\\<rparr>\\<rparr>)\n     od\"", "property": "ASID Control Invocation: Create a new ASID pool object, provide a capability to it, and connect it to the global virtual ASID table. \n\nSubproperties:\n- Delete objects in the specified frame.\n- Update the maximum free index of the parent capability.\n- Retype the specified region to an ASID pool object.\n- Insert a new capability for the ASID pool object into the parent slot.\n- Update the ASID table with the new ASID pool object.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "\n  The ASIDControl capability confers the authority to create a new ASID pool object. This\n  operation creates the new ASID pool, provides a capability to it and connects it to the global\n  virtual ASID table.\n"}
{"spec": "definition perform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_asid_pool_invocation iv \\<equiv> case iv of\n     Assign asid pool_ptr ct_slot \\<Rightarrow> do\n       pt_cap \\<leftarrow> get_cap ct_slot;\n       assert $ is_ArchObjectCap pt_cap;\n       acap \\<leftarrow> return $ the_arch_cap pt_cap;\n       assert $ is_PageTableCap acap;\n       set_cap (ArchObjectCap $ update_map_data acap $ Some (asid,0)) ct_slot;\n       pt_base \\<leftarrow> return $ acap_obj acap;\n       copy_global_mappings pt_base;\n       store_asid_pool_entry pool_ptr asid (Some pt_base)\n     od\"\n\ndefinition perform_pg_inv_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_pg_inv_unmap cap ct_slot \\<equiv> do\n     assert $ is_FrameCap cap;\n     case acap_map_data cap of\n       Some (asid, vaddr) \\<Rightarrow> unmap_page (acap_fsize cap) asid vaddr (acap_obj cap)\n     | _ \\<Rightarrow> return ();\n     old_cap \\<leftarrow> get_cap ct_slot;\n     set_cap (ArchObjectCap $ update_map_data (the_arch_cap old_cap) None) ct_slot\n   od\"\n\ndefinition perform_pg_inv_map :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> pte \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_pg_inv_map cap ct_slot pte slot \\<equiv> do\n     set_cap (ArchObjectCap cap) ct_slot;\n     store_pte slot pte;\n     do_machine_op sfence\n   od\"\n\ndefinition perform_pg_inv_get_addr :: \"obj_ref \\<Rightarrow> (data list,'z::state_ext) s_monad\"\n  where\n  \"perform_pg_inv_get_addr ptr \\<equiv> return [addrFromPPtr ptr]\"", "property": "ASID Pool and Page Table Management: \n- Assign ASID: Assign an ASID to a top-level page table, updating the capability and storing the ASID pool entry.\n- Unmap Page: Unmap a page from a frame, updating the capability and removing the mapping.\n- Map Page: Map a page to a frame, setting the capability, storing the page table entry, and performing a machine operation to ensure visibility.\n- Get Address: Retrieve the physical address corresponding to a given pointer.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign an ASID to a top-level page table."}
{"spec": "definition perform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\"\n  where\n  \"perform_page_invocation iv \\<equiv> case iv of\n     PageMap cap ct_slot (pte,slot) \\<Rightarrow> do perform_pg_inv_map cap ct_slot pte slot; return [] od\n   | PageUnmap cap ct_slot \\<Rightarrow> do perform_pg_inv_unmap cap ct_slot; return [] od\n   | PageGetAddr ptr \\<Rightarrow> perform_pg_inv_get_addr ptr\"\n\n\ndefinition perform_pt_inv_map :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> pte \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_pt_inv_map cap ct_slot pte slot = do\n     set_cap (ArchObjectCap cap) ct_slot;\n     store_pte slot pte;\n     do_machine_op sfence\n   od\"\n\ndefinition perform_pt_inv_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_pt_inv_unmap cap ct_slot = do\n     assert $ is_PageTableCap cap;\n     case acap_map_data cap of\n       Some (asid, vaddr) \\<Rightarrow> do\n         p \\<leftarrow> return $ acap_obj cap;\n         unmap_page_table asid vaddr p;\n         slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + (1 << pt_bits) - 1];\n         mapM_x (swp store_pte InvalidPTE) slots\n       od\n     | _ \\<Rightarrow> return ();\n     old_cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n     set_cap (ArchObjectCap $ update_map_data old_cap None) ct_slot\n   od\"", "property": "Frame Capability Actions: Authorize mapping and unmapping of memory pages, allowing for the allocation and deallocation of memory resources. \n\nMemory Mapping: Set the capability, store the page table entry, and perform a machine operation to ensure memory consistency. \n\nMemory Unmapping: Unmap the page table, invalidate the page table entries, and update the capability to reflect the changes.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "The Frame capability confers the authority to map and unmap memory."}
{"spec": "definition perform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_page_table_invocation iv \\<equiv> case iv of\n     PageTableMap cap ct_slot pte slot \\<Rightarrow> perform_pt_inv_map cap ct_slot pte slot\n   | PageTableUnmap cap ct_slot \\<Rightarrow> perform_pt_inv_unmap cap ct_slot\"\n\nlocale_abbrev arch_no_return :: \"(unit, 'z::state_ext) s_monad \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\n  where\n  \"arch_no_return oper \\<equiv> do oper; return [] od\"", "property": "Page Table Invocation Actions: Allow mapping and unmapping of page tables, conferring the authority to manage page table capabilities. \n\nMapping: Map a page table into a capability table slot with a specified page table entry.\nUnmapping: Unmap a page table from a capability table slot.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page tables."}
{"spec": "definition arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\n  where\n  \"arch_perform_invocation i \\<equiv> liftE $ case i of\n     InvokePageTable oper \\<Rightarrow> arch_no_return $ perform_page_table_invocation oper\n   | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n   | InvokeASIDControl oper \\<Rightarrow> arch_no_return $ perform_asid_control_invocation oper\n   | InvokeASIDPool oper \\<Rightarrow> arch_no_return $ perform_asid_pool_invocation oper\"\n\nend\nend", "property": "RISCV64 System Call Dispatch: Dispatch RISCV64-specific system calls to their corresponding handlers, including page table, page, ASID control, and ASID pool invocations, ensuring proper execution of architecture-specific operations.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call dispatcher for all RISCV64-specific system calls."}
{"spec": "chapter \"Handle Hypervisor Fault Events\"\n\ntheory Hypervisor_A\nimports Exceptions_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"machine_word \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\n  where\n  \"handle_hypervisor_fault thread RISCVNoHypFaults = return ()\"\n\nend\nend", "property": "Handle Hypervisor Fault Events: Handle hypervisor fault events based on the fault type, ensuring proper response and management of faults in the system.", "title": "./spec/abstract/RISCV64/Hypervisor_A.thy", "chapter": "Handle Hypervisor Fault Events", "section": "", "comment": ""}
{"spec": "definition reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Memory Region Reservation: Reserve a memory region with the specified pointer, byte length, and kernel designation, currently implemented as a no-op placeholder.", "title": "./spec/abstract/RISCV64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "\n  This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory.\n"}
{"spec": "definition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv> return ()\"\n\ndefinition empty_context :: user_context\n  where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb\n  where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context \\<rparr>\"\n\nend\nend", "property": "Architecture-Specific Object Initialization: Initialize architecture-specific objects, including setting up an empty user context and initializing architecture-specific TCB components. \n\nInitialization of Architecture-Specific TCB Components: Set the TCB context to an empty user context.", "title": "./spec/abstract/RISCV64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\n  where\n  \"arch_post_cap_deletion ac \\<equiv> return ()\"", "property": "Post-Capability Deletion: No specific actions are taken after a capability is deleted.", "title": "./spec/abstract/RISCV64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = unit\n\ndefinition arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\"\n  where\n  \"arch_gen_obj_refs ac \\<equiv> {}\"\n\ndefinition arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\"\n  where\n  \"arch_cap_cleanup_opt ac \\<equiv> NullCap\"\n\nend\nend", "property": "Architectural Generic Object References: Provide empty set of architectural generic object references for each architectural capability, and map each architectural capability to a null capability for cleanup.", "title": "./spec/abstract/RISCV64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition riscv_global_pt_ptr :: obj_ref\n  where\n  \"riscv_global_pt_ptr = pptr_base + 0x2000\"", "property": "Global Page Table Pointer: The global page table pointer is set to a fixed, sufficiently aligned address for one page, at offset 0x2000 from the base physical address.", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " Some address sufficiently aligned address for one page "}
{"spec": "definition init_irq_node_ptr :: obj_ref\n  where\n  \"init_irq_node_ptr = pptr_base + 0x3000\"", "property": "IRQ Node Pointer Initialization: The IRQ node pointer is initialized to a sufficiently aligned address, ensuring proper alignment for IRQ type and CTE level bits.", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " Sufficiently aligned for irq type + cte_level_bits "}
{"spec": "definition canonical_user :: \"vspace_ref\" where\n  \"canonical_user \\<equiv> mask canonical_bit\"", "property": "Canonical User Address: The highest user-level virtual address that is still canonical, ensuring valid page table mappings.", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " The highest user-level virtual address that is still canonical.\n   It can be larger than user_vtop, which is the highest address we allow to be mapped.\n   We need canonical_user, because the page tables have to have valid mappings there. "}
{"spec": "definition kernel_window_bits :: nat where\n  \"kernel_window_bits \\<equiv> 22\"\n\ndefinition init_vspace_uses :: \"vspace_ref \\<Rightarrow> riscvvspace_region_use\"\n  where\n  \"init_vspace_uses p \\<equiv>\n     if p \\<in> {pptr_base ..< pptr_base + (1 << kernel_window_bits)} then RISCVVSpaceKernelWindow\n     else if p \\<in> {kernel_elf_base ..< kernel_elf_base + (1 << pageBits)} then RISCVVSpaceKernelELFWindow\n     else if p \\<le> canonical_user then RISCVVSpaceUserRegion\n     else RISCVVSpaceInvalidRegion\"\n\ndefinition init_arch_state :: arch_state\n  where\n  \"init_arch_state \\<equiv> \\<lparr>\n     riscv_asid_table = Map.empty,\n     riscv_global_pts = (\\<lambda>level. if level = max_pt_level then {riscv_global_pt_ptr} else {}),\n     riscv_kernel_vspace = init_vspace_uses\n   \\<rparr>\"\n\ndefinition toplevel_bits :: nat\n  where\n  \"toplevel_bits = pt_bits_left max_pt_level\"\n\ndefinition elf_index :: pt_index\n  where\n  \"elf_index = ucast (pt_index max_pt_level kernel_elf_base)\"", "property": "Kernel Window and ELF Region Initialization: The kernel window and ELF region are initialized to be covered by a single max_pt_level entry each, with sizes of 4M physical memory and one page, respectively. The kernel window and ELF region are defined within specific address ranges, and the initialization ensures that the invariants are consistent.\n\nSubproperties:\n- Kernel Window Size: The kernel window size is set to 4M physical memory (1 << 22).\n- ELF Region Size: The ELF region size is set to one page (1 << pageBits).\n- Address Range Definitions: The kernel window and ELF region are defined within specific address ranges (pptr_base to pptr_base + (1 << kernel_window_bits) and kernel_elf_base to kernel_elf_base + (1 << pageBits), respectively).", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " Kernel and ELF window are constructed so that they can be covered with one max_pt_level entry\n   each. This is not the layout the real kernel uses, but we are only trying to show that\n   the invariants are consistent.\n\n   The values we pick here for the size of these regions constrain pptr_base and kernel_elf_base in\n   real kernel configurations, so we pick relatively small values that are reasonable lower bounds\n   for real platforms and that are still large enough to work for the examples. In particular, the\n   InfoFlow example gives a constraint that the kernel window is at least large enough to contain a\n   RISCVLargePage and a minimal set of other objects. This leads to picking values of:\n   4M physical memory (1 << 22) and one page (1 << pageBits) for the kernel elf region. "}
{"spec": "definition global_pte :: \"pt_index \\<Rightarrow> pte\"\n  where\n  \"global_pte idx \\<equiv>\n     if idx = 0x100\n     then PagePTE ((ucast (idx && mask (ptTranslationBits - 1)) << ptTranslationBits * size max_pt_level))\n                  {} vm_kernel_only\n     else if idx = elf_index\n     then PagePTE (ucast ((kernelELFPAddrBase && ~~mask toplevel_bits) >> pageBits)) {} vm_kernel_only\n     else InvalidPTE\"\n\ndefinition init_global_pt :: kernel_object\n  where\n  \"init_global_pt \\<equiv> ArchObj $ PageTable (\\<lambda>idx. if idx \\<in> kernel_mapping_slots\n                                                then global_pte idx\n                                                else InvalidPTE)\"\n\ndefinition init_kheap :: kheap\n  where\n  \"init_kheap \\<equiv>\n    (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n           then Some (CNode 0 (empty_cnode 0))\n           else None)\n    (idle_thread_ptr \\<mapsto>\n       TCB \\<lparr>\n         tcb_ctable = NullCap,\n         tcb_vtable = NullCap,\n         tcb_reply = NullCap,\n         tcb_caller = NullCap,\n         tcb_ipcframe = NullCap,\n         tcb_state = IdleThreadState,\n         tcb_fault_handler = replicate word_bits False,\n         tcb_ipc_buffer = 0,\n         tcb_fault = None,\n         tcb_bound_notification = None,\n         tcb_mcpriority = minBound,\n         tcb_arch = init_arch_tcb\n         \\<rparr>,\n      riscv_global_pt_ptr \\<mapsto> init_global_pt\n    )\"\n\ndefinition init_cdt :: cdt\n  where\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition init_ioc :: \"cslot_ptr \\<Rightarrow> bool\"\n  where\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition init_A_st :: \"'z::state_ext state\"\n  where\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\nend", "property": "Initialization of Kernel State: The kernel's initial state is defined, including the global page table, kernel heap, capability derivation tree, and I/O controller. The global page table is constructed with specific page table entries for the kernel window and ELF index. The kernel heap is initialized with the idle thread, global page table, and interrupt nodes. The capability derivation tree is empty, and the I/O controller is defined based on the kernel heap and capability derivation. The initial state also includes the current thread, idle thread, machine state, interrupt IRQ node, interrupt states, architecture state, and extended state. \n\nSubproperties:\n- Global Page Table: Maps specific indices to page table entries for the kernel window and ELF index, with all other indices mapped to invalid page table entries.\n- Kernel Heap: Initializes the kernel heap with the idle thread, global page table, and interrupt nodes.\n- Capability Derivation Tree: The capability derivation tree is initially empty.\n- I/O Controller: Defines the I/O controller based on the kernel heap and capability derivation.", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " {pptr_base ..< pptr_base + (1 << kernel_window_bits)} is pt index 0x100 at max_pt_level,\n   {kernel_elf_base ..< kernel_elf_base + (1 << pageBits)} comes out to elf_index.\n   The rest is constructed such that the translation lines up with what the invariants want. "}
{"spec": "definition lookup_ipc_buffer :: \"bool \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\"\n  where\n  \"lookup_ipc_buffer is_receiver thread \\<equiv> do\n     buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n     buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n     buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n     case buffer_cap of\n       ArchObjectCap (FrameCap p R vms False _) \\<Rightarrow>\n         if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n         then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n         else return None\n     | _ \\<Rightarrow> return None\n   od\"\n\ndefinition pool_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> obj_ref option\"\n  where\n  \"pool_for_asid asid \\<equiv> \\<lambda>s. riscv_asid_table (arch_state s) (asid_high_bits_of asid)\"\n\ndefinition vspace_for_pool :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (obj_ref \\<rightharpoonup> asid_pool) \\<Rightarrow> obj_ref option\"\n  where\n  \"vspace_for_pool pool_ptr asid \\<equiv> do {\n     pool \\<leftarrow> oapply pool_ptr;\n     K $ pool (asid_low_bits_of asid)\n   }\"\n\ndefinition vspace_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> obj_ref option\"\n  where\n  \"vspace_for_asid asid = do {\n     oassert (0 < asid);\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     vspace_for_pool pool_ptr asid \\<circ> asid_pools_of\n   }\"", "property": "Thread IPC Buffer Lookup: Retrieve a thread's IPC buffer and verify the thread's authority to read or write to it, ensuring that the buffer's frame has the required read or write permissions.\n\nSubproperties:\n- Buffer Frame Retrieval: Get the thread's IPC buffer pointer and the corresponding frame slot.\n- Buffer Frame Permissions: Check that the buffer frame has the necessary read or write permissions.\n- Buffer Address Calculation: Calculate the buffer's address based on the frame's base address, the buffer pointer, and the page size.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up a thread's IPC buffer and check that the thread has the authority to read or (in the\n  receiver case) write to it.\n"}
{"spec": "definition find_vspace_for_asid :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\"\n  where\n  \"find_vspace_for_asid asid \\<equiv> doE\n    vspace_opt \\<leftarrow> liftE $ gets $ vspace_for_asid asid;\n    throw_opt InvalidRoot vspace_opt\n  odE\"", "property": "Find Top-Level Page Table: Locate the top-level page table associated with a given virtual ASID, returning an error if the ASID is invalid.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the top-level page table associated with a given virtual ASID."}
{"spec": "definition handle_vm_fault :: \"obj_ref \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\n  where\n  \"handle_vm_fault thread fault_type = doE\n    addr \\<leftarrow> liftE $ do_machine_op read_stval;\n    let\n      loadf = (\\<lambda>a. throwError $ ArchFault $ VMFault a [0, vmFaultTypeFSR RISCVLoadAccessFault]);\n      storef = (\\<lambda>a. throwError $ ArchFault $ VMFault a [0, vmFaultTypeFSR RISCVStoreAccessFault]);\n      instrf = (\\<lambda>a. throwError $ ArchFault $ VMFault a [1, vmFaultTypeFSR RISCVInstructionAccessFault])\n    in\n      case fault_type of\n        RISCVLoadPageFault \\<Rightarrow> loadf addr\n      | RISCVLoadAccessFault \\<Rightarrow> loadf addr\n      | RISCVStorePageFault \\<Rightarrow> storef addr\n      | RISCVStoreAccessFault \\<Rightarrow> storef addr\n      | RISCVInstructionPageFault \\<Rightarrow> instrf addr\n      | RISCVInstructionAccessFault \\<Rightarrow> instrf addr\n  odE\"", "property": "VM Fault Handling: Format a VM fault message to be passed to a thread's supervisor after it encounters a page fault, providing specific fault information based on the fault type (load, store, or instruction access/page fault).", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Format a VM fault message to be passed to a thread's supervisor after it encounters a page fault.\n"}
{"spec": "definition set_vm_root :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"set_vm_root tcb \\<equiv> do\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    (case thread_root of\n       ArchObjectCap (PageTableCap pt (Some (asid, _))) \\<Rightarrow> doE\n           pt' \\<leftarrow> find_vspace_for_asid asid;\n           whenE (pt \\<noteq> pt') $ throwError InvalidRoot;\n           liftE $ do_machine_op $ setVSpaceRoot (addrFromPPtr pt) (ucast asid)\n       odE\n     | _ \\<Rightarrow> throwError InvalidRoot) <catch>\n    (\\<lambda>_. do\n       global_pt \\<leftarrow> gets global_pt;\n       do_machine_op $ setVSpaceRoot (addrFromKPPtr global_pt) 0\n    od)\n  od\"\n\n\ndefinition delete_asid_pool :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"delete_asid_pool base ptr \\<equiv> do\n     assert (asid_low_bits_of base = 0);\n     asid_table \\<leftarrow> gets (riscv_asid_table \\<circ> arch_state);\n     when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n       pool \\<leftarrow> get_asid_pool ptr;\n       asid_table' \\<leftarrow> return $ asid_table (asid_high_bits_of base:= None);\n       modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> riscv_asid_table := asid_table' \\<rparr>\\<rparr>);\n       tcb \\<leftarrow> gets cur_thread;\n       set_vm_root tcb\n     od\n   od\"\n\n\ndefinition delete_asid :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"delete_asid asid pt \\<equiv> do\n     asid_table \\<leftarrow> gets (riscv_asid_table \\<circ> arch_state);\n     case asid_table (asid_high_bits_of asid) of\n       None \\<Rightarrow> return ()\n     | Some pool_ptr \\<Rightarrow> do\n         pool \\<leftarrow> get_asid_pool pool_ptr;\n         when (pool (asid_low_bits_of asid) = Some pt) $ do\n           do_machine_op $ hwASIDFlush (ucast asid);\n           pool' \\<leftarrow> return $ pool (asid_low_bits_of asid := None);\n           set_asid_pool pool_ptr pool';\n           tcb \\<leftarrow> gets cur_thread;\n           set_vm_root tcb\n         od\n       od\n   od\"\n\ndefinition unmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"unmap_page_table asid vaddr pt \\<equiv> doE\n     top_level_pt \\<leftarrow> find_vspace_for_asid asid;\n     pt_slot \\<leftarrow> pt_lookup_from_level max_pt_level top_level_pt vaddr pt;\n     liftE $ store_pte pt_slot InvalidPTE;\n     liftE $ do_machine_op sfence\n   odE <catch> (K $ return ())\"", "property": "Address Space Management: Switch into the address space of a given thread or the global address space if none is correctly configured, ensuring that the thread's root page table is correctly set and that any necessary address space identifier (ASID) updates are performed.\n\nSubproperties:\n- Set VM Root: Set the virtual machine root for a given thread, ensuring that the thread's root page table is correctly configured and that any necessary ASID updates are performed.\n- Delete ASID Pool: Delete an ASID pool, updating the ASID table and ensuring that any necessary VM root updates are performed for the current thread.\n- Delete ASID: Delete an ASID, flushing the hardware ASID and updating the ASID pool and VM root as necessary for the current thread.\n- Unmap Page Table: Unmap a page table from an ASID, updating the page table entry and performing any necessary synchronization operations.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Switch into the address space of a given thread or the global address space if none is correctly\n  configured.\n"}
{"spec": "definition vs_lookup_table :: \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"vs_lookup_table bot_level asid vptr \\<equiv> do {\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     if bot_level = asid_pool_level\n     then oreturn (asid_pool_level, pool_ptr)\n     else do {\n       top_level_pt \\<leftarrow> vspace_for_pool pool_ptr asid \\<circ> asid_pools_of;\n       pt_walk max_pt_level bot_level top_level_pt vptr \\<circ> ptes_of\n     }\n   }\"", "property": "Virtual Space Lookup: Look up an address space identifier (ASID) and virtual space reference down to a provided level in the page table, returning a pointer to a table at the returned level, which may be higher than the provided level if the lookup terminates early due to a page or invalid entry.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up an @{text \"asid+vspace_ref\"} down to the provided level in the page table.\n  For level @{term bot_level}, return a pointer to a table at the returned level.\n  The level can be higher than @{term bot_level} if the lookup terminates early because\n  it hit a page or an invalid entry.\n"}
{"spec": "definition vs_lookup_slot :: \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"vs_lookup_slot bot_level asid vref \\<equiv> do {\n     (level', table) \\<leftarrow> vs_lookup_table bot_level asid vref;\n     if level' = asid_pool_level then\n       oreturn (level', table)\n     else\n       oreturn (level', pt_slot_offset level' table vref)\n   }\"", "property": "Virtual Space Lookup Slot: Given a virtual machine level, an address space identifier (ASID), and a virtual space reference, return the level and a pointer to the slot in the table at that level. If the bottom level is the ASID pool level, return the pointer to the ASID pool itself.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Same as @{const vs_lookup_table}, but return a pointer to a slot in a table at the returned level.\n  For @{prop \"bot_level = asid_pool_level\"}, still return the pointer to the ASID pool (not a slot\n  inside it, since there are no slot functions for ASID pools).\n"}
{"spec": "definition unmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"unmap_page pgsz asid vptr pptr \\<equiv> doE\n     top_level_pt \\<leftarrow> find_vspace_for_asid asid;\n     (lev, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot top_level_pt vptr \\<circ> ptes_of;\n     unlessE (pt_bits_left lev = pageBitsForSize pgsz) $ throwError InvalidRoot;\n     pte \\<leftarrow> liftE $ get_pte slot;\n     unlessE (is_PagePTE pte \\<and> pptr_from_pte pte = pptr) $ throwError InvalidRoot;\n     liftE $ store_pte slot InvalidPTE;\n     liftE $ do_machine_op sfence\n   odE <catch> (K $ return ())\"", "property": "Unmap Page: Unmap a page from a virtual address space if the given mapping details are still current, ensuring that the page table entry is updated and the TLB is flushed. \n\nSubproperties:\n- Check Mapping Details: Verify that the given mapping details (page size, ASID, virtual address, and physical address) are still current before attempting to unmap the page.\n- Update Page Table Entry: Update the page table entry to reflect that the page is no longer mapped.\n- Flush TLB: Flush the Translation Lookaside Buffer (TLB) to ensure that the unmapping is propagated to the hardware.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\"\n  where\n  \"arch_derive_cap c \\<equiv>\n     case c of\n       PageTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n     | PageTableCap _ None \\<Rightarrow> throwError IllegalOperation\n     | FrameCap r R sz dev mp \\<Rightarrow> returnOk $ ArchObjectCap (FrameCap r R sz dev None)\n     | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n     | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\"", "property": "Derive Architecture-Specific Capability: Allow deriving a new capability from an existing architecture-specific capability, with the restriction that page table capabilities must have an assigned ASID and location to be copied.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Page table structure capabilities cannot be copied until they have an ASID and location\n  assigned. This is because they cannot have multiple current ASIDs and cannot be shared between\n  address spaces or virtual locations.\n"}
{"spec": "definition arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\"\n  where\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "RISCV64 Capability Modification: RISCV64-specific capabilities do not store user-modifiable data, ensuring their integrity and preventing unauthorized modifications.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in RISCV64-specific capabilities."}
{"spec": "definition arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\n  where\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n     (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n       delete_asid_pool b ptr;\n       return (NullCap, NullCap)\n     od\n   | (PageTableCap ptr (Some (a, v)), True) \\<Rightarrow> do\n       doE\n         vroot \\<leftarrow> find_vspace_for_asid a;\n         if vroot = ptr then liftE $ delete_asid a ptr else throwError InvalidRoot\n       odE <catch>\n       (\\<lambda>_. unmap_page_table a v ptr);\n       return (NullCap, NullCap)\n     od\n   | (FrameCap ptr _ sz _ (Some (a, v)), _) \\<Rightarrow> do\n       unmap_page sz a v ptr;\n       return (NullCap, NullCap)\n     od\n   | _ \\<Rightarrow> return (NullCap, NullCap)\"", "property": "RISCV64 Capability Finalisation: Ensure that RISCV64-specific capabilities are properly cleaned up upon finalisation, including deleting ASID pools, unmapping page tables and frames, and handling any necessary exceptions to maintain a consistent and secure capability state.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of RISCV64-specific capabilities."}
{"spec": "definition is_valid_vtable_root :: \"cap \\<Rightarrow> bool\"\n  where\n  \"is_valid_vtable_root c \\<equiv>\n     case c of ArchObjectCap (PageTableCap _ (Some _)) \\<Rightarrow> True | _ \\<Rightarrow> False\"", "property": "Valid Virtual Address Space Capability: A thread's virtual address space capability is valid if it refers to a mapped page table. \n\nSubproperty: Mapped Page Table Requirement: The capability must be an ArchObjectCap of type PageTableCap with a non-empty mapping (i.e., Some _) to be considered valid.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A thread's virtual address space capability must be to a mapped page table to be valid on\n  the RISCV64 architecture.\n"}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\ndefinition check_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\"\n  where\n  \"check_valid_ipc_buffer vptr c \\<equiv>\n     case c of\n       ArchObjectCap (FrameCap _ _ _ False _) \\<Rightarrow>\n         whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError\n     | _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Valid IPC Buffer Alignment: Ensure that the IPC buffer is properly aligned according to the message alignment bits for frame capability without device memory, throwing an alignment error if not aligned and an illegal operation error for other capability types.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "definition in_user_frame :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\"\n  where\n  \"in_user_frame p s \\<equiv>\n     \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) = Some (ArchObj (DataPage False sz))\"\n\ndefinition prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"prepare_thread_delete thread_ptr \\<equiv> return ()\"\n\nend\nend", "property": "User Frame Containment: A pointer is considered to be inside a user frame if its top bits point to a DataPage object in the kernel heap.\n\nThread Deletion Preparation: Prepare for thread deletion by performing a no-operation action, effectively doing nothing.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A pointer is inside a user frame if its top bits point to a @{const DataPage}."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition asid_high_bits_of :: \"asid \\<Rightarrow> asid_high_index\"\n  where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"", "property": "Virtual ASID High Bits Extraction: Extract the high bits of a virtual ASID by shifting the ASID to the right by the number of low bits and then casting the result to an ASID high index.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "definition asid_low_bits_of :: \"asid \\<Rightarrow> asid_low_index\"\n  where\n  \"asid_low_bits_of asid \\<equiv> ucast asid\"\n\nlemmas asid_bits_of_defs = asid_high_bits_of_def asid_low_bits_of_def\n\nlocale_abbrev\n  \"asid_table \\<equiv> \\<lambda>s. riscv_asid_table (arch_state s)\"", "property": "Virtual ASID Low Bits Extraction: Extract the low bits of a virtual ASID.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": "The low bits of a virtual ASID."}
{"spec": "(* declared in Arch as workaround for VER-1099 *)\nlocale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\"\n  where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"", "property": "Accessing the RISCV64 VSpace: Kernel Heap Accessors provide a mapping from object references to architecture-specific kernel objects in the kernel heap.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev asid_pools_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> asid_pool\"\n  where\n  \"asid_pools_of \\<equiv> \\<lambda>s. aobjs_of s |> asid_pool_of\"\n\nlocale_abbrev get_asid_pool :: \"obj_ref \\<Rightarrow> (asid_low_index \\<rightharpoonup> obj_ref, 'z::state_ext) s_monad\"\n  where\n  \"get_asid_pool \\<equiv> gets_map asid_pools_of\"\n\ndefinition set_asid_pool :: \"obj_ref \\<Rightarrow> (asid_low_index \\<rightharpoonup> obj_ref) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"set_asid_pool ptr pool \\<equiv> do\n     get_asid_pool ptr;\n     set_object ptr (ArchObj (ASIDPool pool))\n   od\"\n\nlocale_abbrev pts_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> pt\"\n  where\n  \"pts_of \\<equiv> \\<lambda>s. aobjs_of s |> pt_of\"\n\nlocale_abbrev get_pt :: \"obj_ref \\<Rightarrow> (pt_index \\<Rightarrow> pte,'z::state_ext) s_monad\"\n  where\n  \"get_pt \\<equiv> gets_map pts_of\"\n\ndefinition set_pt :: \"obj_ref \\<Rightarrow> (pt_index \\<Rightarrow> pte) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"set_pt ptr pt \\<equiv> do\n     get_pt ptr;\n     set_object ptr (ArchObj (PageTable pt))\n   od\"", "property": "Kernel Heap Accessors: Provide functions to manipulate ASID pools, page directories, and page tables in the kernel heap, allowing for the retrieval and modification of these data structures to manage the RISCV64 virtual space.\n\nASID Pool Management: Get and set the ASID pool for a given object reference, enabling the management of ASID pools within the kernel heap.\n\nPage Table Management: Get and set the page table for a given object reference, facilitating the management of page tables within the kernel heap.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": "Manipulate ASID pools, page directories and page tables in the kernel heap."}
{"spec": "locale_abbrev table_base :: \"obj_ref \\<Rightarrow> obj_ref\" where\n  \"table_base p \\<equiv> p && ~~mask pt_bits\"", "property": "Table Base Address Calculation: Calculate the base address of the table a page table entry at a given address is in, assuming alignment, by performing a bitwise AND operation with the negated mask of the page table bits.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": " The base address of the table a page table entry at p is in (assuming alignment) "}
{"spec": "locale_abbrev table_index :: \"obj_ref \\<Rightarrow> pt_index\" where\n  \"table_index p \\<equiv> ucast (p && mask pt_bits >> pte_bits)\"", "property": "Page Table Index Calculation: Calculate the index within the page table that a page table entry at a given address references, by extracting the relevant bits from the address.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": " The index within the page table that a page table entry at p addresses "}
{"spec": "definition pte_of :: \"obj_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pt) \\<rightharpoonup> pte\"\n  where\n  \"pte_of p \\<equiv> do {\n     oassert (is_aligned p pte_bits);\n     pt \\<leftarrow> oapply (table_base p);\n     oreturn $ pt (table_index p)\n   }\"\n\nlocale_abbrev ptes_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> pte\"\n  where\n  \"ptes_of s \\<equiv> \\<lambda>p. pte_of p (pts_of s)\"", "property": "PTE Access: Retrieve the page table entry (PTE) associated with a given address, ensuring the address is properly aligned and avoiding addresses between PTEs. \n\nSubproperties:\n- Address Alignment: The address must be aligned to the PTE bits.\n- PTE Retrieval: The PTE is retrieved from the page table using the table base and index of the address.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": " p is the address of the pte,\n   which consists of base (for the pt) and offset (for the index inside the pt).\n   We assert that we avoid addresses between ptes. "}
{"spec": "locale_abbrev get_pte :: \"obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\"\n  where\n  \"get_pte \\<equiv> gets_map ptes_of\"\n\ndefinition store_pte :: \"obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"store_pte p pte \\<equiv> do\n     assert (is_aligned p pte_bits);\n     base \\<leftarrow> return $ table_base p;\n     index \\<leftarrow> return $ table_index p;\n     pt \\<leftarrow> get_pt (table_base p);\n     pt' \\<leftarrow> return $ pt (index := pte);\n     set_pt base pt'\n   od\"", "property": "Kernel Heap Accessors: Provide functions to access and modify page table entries (PTEs) in kernel memory, ensuring correct alignment and indexing.\n\nGet PTE: Retrieve the PTE at a given kernel memory address.\n\nStore PTE: Update the PTE at a given kernel memory address, ensuring correct alignment and indexing.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory and returns the PTE."}
{"spec": "definition pt_bits_left :: \"vm_level \\<Rightarrow> nat\"\n  where\n  \"pt_bits_left level = ptTranslationBits * size level + pageBits\"\n\ndefinition pt_index :: \"vm_level \\<Rightarrow> vspace_ref \\<Rightarrow> machine_word\"\n  where\n  \"pt_index level vptr \\<equiv> (vptr >> pt_bits_left level) && mask ptTranslationBits\"", "property": "Virtual Address Translation: Calculate the page table index for a given virtual address and VM level, using bit shifts and masks to extract the relevant bits. \n\nPage Table Index Calculation: Extract the page table index from a virtual address by shifting and masking the address according to the VM level.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition riscv_global_pt :: \"arch_state \\<Rightarrow> obj_ref\"\n  where\n  \"riscv_global_pt s = the_elem (riscv_global_pts s max_pt_level)\"\n\nlocale_abbrev global_pt :: \"'z state \\<Rightarrow> obj_ref\"\n  where\n  \"global_pt s \\<equiv> riscv_global_pt (arch_state s)\"", "property": "Global Page Table Extraction: Extract the single top-level global page table from the architecture state.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": "Interface function to extract the single top-level global page table:"}
{"spec": "definition copy_global_mappings :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"copy_global_mappings new_pm \\<equiv> do\n    global_pt \\<leftarrow> gets global_pt;\n    base \\<leftarrow> return $ pt_index max_pt_level pptr_base;\n    pt_size \\<leftarrow> return $ 1 << ptTranslationBits;\n    mapM_x (\\<lambda>index. do\n        offset \\<leftarrow> return (index << pte_bits);\n        pme \\<leftarrow> get_pte (global_pt + offset);\n        store_pte (new_pm + offset) pme\n    od) [base  .e.  pt_size - 1]\n  od\"", "property": "Copy Global Mappings: Duplicate the kernel window mappings in a new top-level page table object, ensuring that the kernel's virtual address space is correctly replicated. \n\nSubproperties:\n- Retrieve the global page table and calculate the base index and size of the page table.\n- Iterate over the page table entries, copying each entry from the global page table to the new page table.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": "\n  The kernel window is mapped into every virtual address space from the @{term pptr_base}\n  pointer upwards. This function copies the mappings which create the kernel window into a new\n  top-level page table object.\n"}
{"spec": "definition pptr_from_pte :: \"pte \\<Rightarrow> vspace_ref\"\n  where\n  \"pptr_from_pte pte \\<equiv> ptrFromPAddr (addr_from_pte pte)\"\n\ndefinition pt_slot_offset :: \"vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\"\n  where\n  \"pt_slot_offset level pt_ptr vptr = pt_ptr + (pt_index level vptr << pte_bits)\"", "property": "Virtual Space Access: Provide basic operations to access and manipulate the RISCV64 virtual space, ensuring proper address alignment and calculation of page table slot offsets.\n\nAddress Calculation: Calculate the physical pointer from a page table entry (PTE) and compute the page table slot offset for a given virtual pointer and page table level.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " pte addresses will always be at least page aligned "}
{"spec": "fun pt_walk ::\n  \"vm_level \\<Rightarrow> vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pte) \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"pt_walk level bot_level pt_ptr vptr = do {\n     if bot_level < level\n     then do {\n       pte \\<leftarrow> oapply (pt_slot_offset level pt_ptr vptr);\n       if is_PageTablePTE pte\n         then pt_walk (level - 1) bot_level (pptr_from_pte pte) vptr\n         else oreturn (level, pt_ptr)\n     }\n     else oreturn (level, pt_ptr)\n   }\"\n\ndeclare pt_walk.simps[simp del]", "property": "Page Table Walk: Traverse the page table structure from a given level to a lower level, stopping at a specified bottom level or when a page is reached, and return the pointer to the page table where the walk stopped along with its level.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": "\n  This is the base function for walking a page table structure.\n  The walk proceeds from higher-level tables at the provided @{term level} (e.g. 2) to lower\n  level tables, down to @{term bot_level} (e.g. 0). It returns a pointer to the page table where\n  the walk stopped and the level of that table. The lookup stops when @{term bot_level} or a\n  page is reached.\n"}
{"spec": "definition pt_lookup_slot_from_level ::\n  \"vm_level \\<Rightarrow> vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pte) \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"pt_lookup_slot_from_level level bot_level pt_ptr vptr = do {\n     (level', pt_ptr') \\<leftarrow> pt_walk level bot_level pt_ptr vptr;\n     oreturn (level', pt_slot_offset level' pt_ptr' vptr)\n   }\"\n\ndefinition pt_lookup_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pte) \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"pt_lookup_slot = pt_lookup_slot_from_level max_pt_level 0\"", "property": "Page Table Lookup: Retrieve the level and object pointer of a slot in a page table structure corresponding to a given virtual space reference, starting from a specified or maximum page table level.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": "\n  Looking up a slot in a page table structure. The function returns a level and an object\n  pointer. The pointer is to a slot in a table at the returned level. If the returned level is 0,\n  this slot is either an @{const InvalidPTE} or a @{const PagePTE}. If the returned level is higher\n  the slot may also be a @{const PageTablePTE}.\n"}
{"spec": "fun pt_lookup_from_level ::\n  \"vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (machine_word, 'z::state_ext) lf_monad\"\n  where\n  \"pt_lookup_from_level level pt_ptr vptr target_pt_ptr s = (doE\n     unlessE (0 < level) $ throwError InvalidRoot;\n     slot <- returnOk $ pt_slot_offset level pt_ptr vptr;\n     pte <- liftE $ gets_the $ oapply slot o ptes_of;\n     unlessE (is_PageTablePTE pte) $ throwError InvalidRoot;\n     ptr <- returnOk (pptr_from_pte pte);\n     if ptr = target_pt_ptr\n       then returnOk slot\n       else pt_lookup_from_level (level - 1) ptr vptr target_pt_ptr\n   odE) s\"", "property": "Page Table Lookup: Recursively traverse the page table hierarchy from a given level and page table pointer to find the slot that points to a target page table pointer, ensuring validity of the root and intermediate page table entries. \n\nSubproperties:\n- Valid Root: The initial page table level must be greater than 0.\n- Valid Page Table Entries: Each intermediate page table entry must be a valid PageTablePTE.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " Returns the slot that points to target_pt_ptr "}
{"spec": "declare pt_lookup_from_level.simps[simp del]", "property": "No property can be extracted from the given code snippet as it is a declaration and does not contain any functional specification.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " We apply \"s\" to avoid a type variable warning, and increase in global freeindex counter,\n   which we would get without the application "}
{"spec": "schematic_goal pt_lookup_from_level_simps:\n  \"pt_lookup_from_level level pt_ptr vptr target_pt_ptr = ?rhs\"\n  by (rule ext, rule pt_lookup_from_level.simps)", "property": "Page Table Lookup: Perform a page table lookup from a given level, using a page table pointer and a virtual pointer to retrieve a target page table pointer.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " Recover simp rule without state applied: "}
{"spec": "definition kernel_mapping_slots :: \"pt_index set\" where\n  \"kernel_mapping_slots \\<equiv> {i. i \\<ge> ucast (pptr_base >> pt_bits_left max_pt_level)}\"\n\nend\nend", "property": "Kernel Mapping Slots: Define the set of top-level table slots for kernel mappings, which span from the pptr base to the top of virtual memory, covering the kernel window, kernel ELF window, and kernel device window.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " Kernel mappings go from pptr base to top of virtual memory. This definition encompasses\n   the kernel window, kernel ELF window, and kernel device window.\n   These indices identify the relevant top level table slots. "}
{"spec": "definition check_vp_alignment :: \"vmpage_size \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) se_monad\"\n  where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $ throwError AlignmentError\"\n\ndefinition page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\n  where\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"", "property": "Virtual Address Alignment and Page Base Calculation: Ensure that a virtual address is properly aligned according to the given page size, and calculate the base address of a page in a virtual address space. \n\nSubproperties:\n- Virtual Address Alignment: Verify that a virtual address is aligned to the required page size to prevent alignment errors.\n- Page Base Calculation: Calculate the base address of a page by masking the lower bits of the virtual address according to the page size.", "title": "./spec/abstract/RISCV64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture-specific Decode Functions", "comment": ""}
{"spec": "definition\n  arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"arch_check_irq irq \\<equiv> whenE (irq > ucast maxIRQ \\<or> irq = ucast irqInvalid) $\n                          throwError (RangeError 1 (ucast maxIRQ))\"\n\ndefinition arch_decode_irq_control_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list \\<Rightarrow> (arch_irq_control_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_irq_control_invocation label args src_slot cps \\<equiv>\n     (if invocation_type label = ArchInvocationLabel RISCVIRQIssueIRQHandler\n      then if length args \\<ge> 4 \\<and> length cps \\<ge> 1\n        then let irq_word = args ! 0;\n                 trigger = args ! 1;\n                 index = args ! 2;\n                 depth = args ! 3;\n                 cnode = cps ! 0;\n                 irq = ucast irq_word\n        in doE\n          arch_check_irq irq_word;\n          irq_active \\<leftarrow> liftE $ is_irq_active irq;\n          whenE irq_active $ throwError RevokeFirst;\n          dest_slot \\<leftarrow> lookup_target_slot cnode (data_to_cptr index) (unat depth);\n          ensure_empty dest_slot;\n          returnOk $ RISCVIRQControlInvocation irq dest_slot src_slot (trigger \\<noteq> 0)\n        odE\n      else throwError TruncatedMessage\n    else throwError IllegalOperation)\"\n\ndefinition attribs_from_word :: \"machine_word \\<Rightarrow> vm_attributes\"\n  where\n  \"attribs_from_word w \\<equiv> if \\<not> w!!0 then {Execute} else {}\"\n\ndefinition make_user_pte :: \"vspace_ref \\<Rightarrow> vm_attributes \\<Rightarrow> vm_rights \\<Rightarrow> pte\"\n  where\n  \"make_user_pte addr attr rights \\<equiv>\n    if rights = {} \\<and> attr = {}\n    then InvalidPTE\n    else PagePTE (ucast (addr >> pageBits)) (attr \\<union> {User}) rights\"\n\ndefinition check_slot :: \"obj_ref \\<Rightarrow> (pte \\<Rightarrow> bool) \\<Rightarrow> (unit,'z::state_ext) se_monad\"\n  where\n  \"check_slot slot test = doE\n     pte \\<leftarrow> liftE $ get_pte slot;\n     unlessE (test pte) $ throwError DeleteFirst\n   odE\"\n\ntype_synonym 'z arch_decoder =\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    (arch_invocation,'z) se_monad\"\n\ndefinition decode_fr_inv_map :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_fr_inv_map label args cte cap extra_caps \\<equiv> case cap of\n     FrameCap p R pgsz dev mapped_address \\<Rightarrow>\n       if length args > 2 \\<and> length extra_caps > 0\n       then let\n           vaddr = args ! 0;\n           rights_mask = args ! 1;\n           attr = args ! 2;\n           vspace_cap = fst (extra_caps ! 0)\n         in doE\n           (pt, asid) \\<leftarrow> case vspace_cap of\n                           ArchObjectCap (PageTableCap pt (Some (asid, _))) \\<Rightarrow> returnOk (pt, asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1;\n           pt' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n           whenE (pt' \\<noteq> pt) $ throwError $ InvalidCapability 1;\n           pg_bits \\<leftarrow> returnOk $ pageBitsForSize pgsz;\n           vtop \\<leftarrow> returnOk $ vaddr + mask (pageBitsForSize pgsz);\n           whenE (vtop \\<ge> user_vtop) $ throwError $ InvalidArgument 0;\n           check_vp_alignment pgsz vaddr;\n           (level, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot pt vaddr \\<circ> ptes_of;\n           unlessE (pt_bits_left level = pg_bits) $\n             throwError $ FailedLookup False $ MissingCapability $ pt_bits_left level;\n           case mapped_address of\n             Some (asid', vaddr') \\<Rightarrow> doE\n               whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n               whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0);\n               check_slot slot (Not \\<circ> is_PageTablePTE)\n             odE\n           | None \\<Rightarrow> check_slot slot ((=) InvalidPTE);\n           vm_rights \\<leftarrow> returnOk $ mask_vm_rights R (data_to_rights rights_mask);\n           attribs \\<leftarrow> returnOk $ attribs_from_word attr;\n           pte \\<leftarrow> returnOk $ make_user_pte (addrFromPPtr p) attribs vm_rights;\n           returnOk $ InvokePage $ PageMap (FrameCap p R pgsz dev (Some (asid,vaddr))) cte (pte,slot)\n         odE\n       else throwError TruncatedMessage\n     | _ \\<Rightarrow> fail\"\n\ndefinition decode_frame_invocation :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_frame_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel RISCVPageMap\n     then decode_fr_inv_map label args cte cap extra_caps\n     else if invocation_type label = ArchInvocationLabel RISCVPageUnmap\n     then returnOk $ InvokePage $ PageUnmap cap cte\n     else if invocation_type label = ArchInvocationLabel RISCVPageGetAddress\n     then returnOk $ InvokePage $ PageGetAddr (acap_obj cap)\n     else throwError IllegalOperation\"\n\ndefinition decode_pt_inv_map :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_pt_inv_map label args cte cap extra_caps \\<equiv> case cap of\n     PageTableCap p mapped_address \\<Rightarrow>\n       if length args > 1 \\<and> length extra_caps > 0\n       then let\n           vaddr = args ! 0;\n           attr = args ! 1;\n           vspace_cap = fst (extra_caps ! 0)\n         in doE\n           whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n           (pt, asid) \\<leftarrow> case vspace_cap of\n                           ArchObjectCap (PageTableCap pt (Some (asid,_))) \\<Rightarrow> returnOk (pt, asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1;\n           whenE (user_vtop \\<le> vaddr) $ throwError $ InvalidArgument 0;\n           pt' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n           whenE (pt' \\<noteq> pt) $ throwError $ InvalidCapability 1;\n           (level, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot pt vaddr \\<circ> ptes_of;\n           old_pte \\<leftarrow> liftE $ get_pte slot;\n           whenE (pt_bits_left level = pageBits \\<or> old_pte \\<noteq> InvalidPTE) $ throwError DeleteFirst;\n           pte \\<leftarrow> returnOk $ PageTablePTE (ucast (addrFromPPtr p >> pageBits)) {};\n           cap' <- returnOk $ PageTableCap p $ Some (asid, vaddr && ~~mask (pt_bits_left level));\n           returnOk $ InvokePageTable $ PageTableMap cap' cte pte slot\n         odE\n       else throwError TruncatedMessage\n     | _ \\<Rightarrow> fail\"\n\ndefinition decode_page_table_invocation :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_page_table_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel RISCVPageTableMap\n     then decode_pt_inv_map label args cte cap extra_caps\n     else if invocation_type label = ArchInvocationLabel RISCVPageTableUnmap\n     then doE\n       final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n       unlessE final $ throwError RevokeFirst;\n       case cap of\n         PageTableCap pt (Some (asid, _)) \\<Rightarrow> doE\n             \\<comment> \\<open>cannot invoke unmap on top level page table\\<close>\n             pt_opt \\<leftarrow> liftE $ gets $ vspace_for_asid asid;\n             whenE (pt_opt = Some pt) $ throwError RevokeFirst\n           odE\n       | _ \\<Rightarrow> returnOk ();\n       returnOk $ InvokePageTable $ PageTableUnmap cap cte\n     odE\n     else throwError IllegalOperation\"\n\ndefinition decode_asid_control_invocation :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_asid_control_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel RISCVASIDControlMakePool\n     then if length args > 1 \\<and> length extra_caps > 1\n     then let\n         index = args ! 0;\n         depth = args ! 1;\n         (untyped, parent_slot) = extra_caps ! 0;\n         root = fst (extra_caps ! 1)\n       in doE\n         asid_table \\<leftarrow> liftE $ gets (riscv_asid_table \\<circ> arch_state);\n         free_set \\<leftarrow> returnOk (- dom asid_table);\n         whenE (free_set = {}) $ throwError DeleteFirst;\n         free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n         base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n         (p,n) \\<leftarrow> case untyped of\n                    UntypedCap False p n _ \\<Rightarrow> returnOk (p,n)\n                  | _ \\<Rightarrow> throwError $ InvalidCapability 1;\n         frame \\<leftarrow> if n = pageBits then doE\n                    ensure_no_children parent_slot;\n                    returnOk p\n                  odE\n                  else throwError $ InvalidCapability 1;\n         dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n         ensure_empty dest_slot;\n         returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n       odE\n     else throwError TruncatedMessage\n     else throwError IllegalOperation\"\n\ndefinition decode_asid_pool_invocation :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_asid_pool_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel RISCVASIDPoolAssign\n     then if length extra_caps > 0\n     then let\n         (pt_cap, pt_cap_slot) = extra_caps ! 0;\n         p = acap_obj cap;\n         base = acap_asid_base cap\n       in case pt_cap of\n         ArchObjectCap (PageTableCap _ None) \\<Rightarrow> doE\n           asid_table \\<leftarrow> liftE $ gets (riscv_asid_table \\<circ> arch_state);\n           pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n           whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n           whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n           pool \\<leftarrow> liftE $ get_asid_pool p;\n           free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n           whenE (free_set = {}) $ throwError DeleteFirst;\n           offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n           returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pt_cap_slot\n         odE\n       | _ \\<Rightarrow> throwError $ InvalidCapability 1\n     else throwError TruncatedMessage\n     else throwError IllegalOperation\"\n\ndefinition arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n     PageTableCap _ _   \\<Rightarrow> decode_page_table_invocation label args cte cap extra_caps\n   | FrameCap _ _ _ _ _ \\<Rightarrow> decode_frame_invocation label args cte cap extra_caps\n   | ASIDControlCap     \\<Rightarrow> decode_asid_control_invocation label args cte cap extra_caps\n   | ASIDPoolCap _ _    \\<Rightarrow> decode_asid_pool_invocation label args cte cap extra_caps\"", "property": "Architectural Invocation Decoding: Decodes architecture-specific system calls, including IRQ control, page table and frame management, and ASID control and pool management, ensuring that the provided arguments and capabilities are valid and properly formatted.\n\nSubproperties:\n- IRQ Control Invocation: Decodes IRQ control invocations, checking the IRQ number and ensuring that the IRQ is not already active.\n- Page Table and Frame Management: Decodes page table and frame management invocations, including page table and frame mapping and unmapping, ensuring that the provided arguments and capabilities are valid and properly formatted.\n- ASID Control and Pool Management: Decodes ASID control and pool management invocations, including ASID pool creation and assignment, ensuring that the provided arguments and capabilities are valid and properly formatted.", "title": "./spec/abstract/RISCV64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Interface Functions used in Decode", "comment": ""}
{"spec": "definition arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\"\n  where\n  \"arch_data_to_obj_type n \\<equiv>\n     if      n = 0 then Some HugePageObj\n     else if n = 1 then Some SmallPageObj\n     else if n = 2 then Some LargePageObj\n     else if n = 3 then Some PageTableObj\n     else None\"\n\nend\nend", "property": "Architecture-specific Object Type Decoding: Map numeric values to architecture-specific object types, including HugePageObj, SmallPageObj, LargePageObj, and PageTableObj, while rejecting invalid values.", "title": "./spec/abstract/RISCV64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Interface Functions used in Decode", "comment": ""}
{"spec": "datatype page_table_invocation =\n    PageTableMap\n      (pt_inv_cap : arch_cap)\n      (pt_inv_cslot : cslot_ptr)\n      (pt_map_pte : pte)\n      (pt_map_slot : obj_ref)\n  | PageTableUnmap\n      (pt_inv_cap : arch_cap)\n      (pt_inv_cslot : cslot_ptr)\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation =\n    PageMap\n      (pg_inv_cap : arch_cap)\n      (pg_inv_cslot : cslot_ptr)\n      (pg_inv_entries : \"pte \\<times> obj_ref\")\n  | PageUnmap\n      (pg_inv_cap : arch_cap)\n      (pg_inv_cslot : cslot_ptr)\n  | PageGetAddr\n      (pg_get_paddr : obj_ref)\n\ndatatype arch_invocation =\n    InvokePageTable page_table_invocation\n  | InvokePage page_invocation\n  | InvokeASIDControl asid_control_invocation\n  | InvokeASIDPool asid_pool_invocation\n\ndatatype arch_copy_register_sets =\n    RISCVNoExtraRegisters\n\ndefinition ArchDefaultExtraRegisters :: arch_copy_register_sets\n  where\n  \"ArchDefaultExtraRegisters = RISCVNoExtraRegisters\"\n\ndatatype arch_irq_control_invocation =\n    RISCVIRQControlInvocation irq cslot_ptr cslot_ptr bool\n\nend\nend", "property": "RISCV64 System Call Arguments: Define the structure and content of arguments for RISCV64-specific system calls, including page table, ASID control, ASID pool, page, and IRQ control invocations, as well as the default extra registers for architecture-specific copy operations.\n\nSubproperties:\n- Page Table Invocation: Specifies the structure for page table map and unmap operations, including capability, slot, and page table entry information.\n- ASID Control Invocation: Encodes the arguments for making an ASID pool, including the object reference, capability slot, and ASID.\n- ASID Pool Invocation: Defines the structure for assigning an ASID to a pool, including the ASID, object reference, and capability slot.\n- Page Invocation: Specifies the structure for page map, unmap, and get address operations, including capability, slot, and page entry information.\n- IRQ Control Invocation: Encodes the arguments for IRQ control operations, including the IRQ, capability slots, and a boolean flag.", "title": "./spec/abstract/RISCV64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the various possible RISCV64-specific system calls.\nSelectors are defined for various fields for convenience elsewhere."}
{"spec": "text \\<open>\n  The RISCV64 kernel supports capabilities for ASID pools and an ASID controller capability,\n  along with capabilities for virtual memory mappings.\n\\<close>\n\ndatatype arch_cap =\n    ASIDPoolCap (acap_obj : obj_ref) (acap_asid_base : asid)\n  | ASIDControlCap\n  | FrameCap\n      (acap_obj : obj_ref)\n      (acap_rights : cap_rights)\n      (acap_fsize : vmpage_size)\n      (acap_is_device : bool)\n      (acap_map_data : \"(asid \\<times> vspace_ref) option\")\n  | PageTableCap (acap_obj : obj_ref) (acap_map_data : \"(asid \\<times> vspace_ref) option\")", "property": "RISCV64 Architecture-Specific Capabilities: Supports capabilities for ASID pools, ASID control, and virtual memory mappings (frame and page table capabilities), ensuring proper management of virtual memory and access control in the RISCV64 kernel.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "definition update_map_data :: \"arch_cap \\<Rightarrow> (asid \\<times> vspace_ref) option \\<Rightarrow> arch_cap\"\n  where\n  \"update_map_data cap m \\<equiv> case cap of\n     FrameCap p R sz dev _  \\<Rightarrow> FrameCap p R sz dev m\n   | PageTableCap p _ \\<Rightarrow> PageTableCap p m\"", "property": "Update Mapping Data: Update the mapping data saved in a frame or page table capability with a new ASID and virtual space reference. \n\nSubproperties:\n- Frame Capability Update: Update the mapping data of a frame capability while preserving its physical address, rights, size, and device attributes.\n- Page Table Capability Update: Update the mapping data of a page table capability while preserving its physical address.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific objects", "comment": "Update the mapping data saved in a frame or page table capability."}
{"spec": "(* This datatype does not match up with the executable spec directly:\n   This one here models all \"things\" one can set on a page or page table entry.\n   The attributes accessible to users are the ones returned by attribs_from_word. *)\ndatatype vm_attribute = Global | Execute | User\ntype_synonym vm_attributes = \"vm_attribute set\"", "property": "RISCV64-Specific Data Types: Defines the architecture-specific object types and default objects for RISCV64, including the vm_attribute datatype that represents the attributes that can be set on a page or page table entry, such as Global, Execute, and User.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "type_synonym pte_ppn_len = 52 (* machine_word_len - pt_bits *)\ntype_synonym pte_ppn = \"pte_ppn_len word\"\n\ndefinition ppn_len :: nat where\n  \"ppn_len \\<equiv> LENGTH(pte_ppn_len)\"\n\ndatatype pte =\n    InvalidPTE\n  | PagePTE (pte_ppn : pte_ppn) (pte_attr : vm_attributes) (pte_rights : vm_rights)\n  | PageTablePTE (pte_ppn : pte_ppn) (pte_attr : vm_attributes)\n\ntype_synonym pt_index_len = 9\ntype_synonym pt_index = \"pt_index_len word\"", "property": "RISCV64-Specific Data Types: Define architecture-specific data types for RISCV64, including page table entry (PTE) formats and associated types.\n\nPage Table Entry (PTE) Formats: Specify the structure of PTEs, which can be either invalid, page PTEs containing a page number (PPN), attributes, and rights, or page table PTEs containing a PPN and attributes.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " The address of the target object is stored shifted right by pt_bits and stored as a ppn (page\n   number). To get the address, use addr_from_pte "}
{"spec": "lemma \"LENGTH(pt_index_len) = ptTranslationBits\"\n  by (simp add: ptTranslationBits_def)\n\ntype_synonym asid_pool = \"asid_low_index \\<rightharpoonup> obj_ref\"\ntype_synonym pt = \"pt_index \\<Rightarrow> pte\"", "property": "RISCV64-Specific Data Types: Define architecture-specific object types, including the ASID pool and page table (PT), which are essential for managing memory and address translation in the RISCV64 architecture. \n\n Page Table Index Length: The length of the page table index is equal to the number of translation bits, ensuring proper address translation.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": "Sanity check:"}
{"spec": "datatype (discs_sels) arch_kernel_obj =\n    ASIDPool asid_pool\n  | PageTable pt\n  | DataPage bool vmpage_size\n\ndefinition asid_pool_of :: \"arch_kernel_obj \\<rightharpoonup> asid_pool\"\n  where\n  \"asid_pool_of ko \\<equiv> case ko of ASIDPool pool \\<Rightarrow> Some pool | _ \\<Rightarrow> None\"\n\ndefinition pt_of :: \"arch_kernel_obj \\<rightharpoonup> pt\"\n  where\n  \"pt_of ko \\<equiv> case ko of PageTable pt \\<Rightarrow> Some pt | _ \\<Rightarrow> None\"\n\ndefinition pte_bits :: nat\n  where\n  \"pte_bits = word_size_bits\"\n\ndefinition table_size :: nat\n  where\n  \"table_size = ptTranslationBits + pte_bits\"\n\ndefinition pt_bits :: \"nat\"\n  where\n  \"pt_bits \\<equiv> table_size\"\n\ndefinition addr_from_ppn :: \"pte_ppn \\<Rightarrow> paddr\"\n  where\n  \"addr_from_ppn ppn = ucast ppn << pt_bits\"\n\nabbreviation addr_from_pte :: \"pte \\<Rightarrow> paddr\"\n  where\n  \"addr_from_pte pte \\<equiv> addr_from_ppn (pte_ppn pte)\"\n\nprimrec arch_obj_size :: \"arch_cap \\<Rightarrow> nat\"\n  where\n  \"arch_obj_size (ASIDPoolCap _ _) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (FrameCap _ _ sz _ _) = pageBitsForSize sz\"\n| \"arch_obj_size (PageTableCap _ _ ) = table_size\"\n\nfun arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\"\n  where\n  \"arch_cap_is_device (FrameCap _ _ _ is_dev _) = is_dev\"\n| \"arch_cap_is_device _ = False\"\n\ndefinition cte_level_bits :: nat\n  where\n  \"cte_level_bits \\<equiv> 5\"\n\ndefinition tcb_bits :: nat\n  where\n  \"tcb_bits \\<equiv> 10\"\n\ndefinition endpoint_bits :: nat\n  where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat\n  where\n  \"ntfn_bits \\<equiv> 5\"\n\ndefinition untyped_min_bits :: nat\n  where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat\n  where\n  \"untyped_max_bits \\<equiv> 38\"\n\nprimrec arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\"\n  where\n  \"arch_kobj_size (ASIDPool _) = pageBits\"\n| \"arch_kobj_size (PageTable _) = table_size\"\n| \"arch_kobj_size (DataPage _ sz) = pageBitsForSize sz\"\n\nfun aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\"\n  where\n  \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref c = Some (acap_obj c)\"\n\ndefinition acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\"\n  where\n  \"acap_rights_update R acap \\<equiv>\n    case acap of\n      FrameCap ref cR sz dev as \\<Rightarrow> FrameCap ref (validate_vm_rights R) sz dev as\n    | _ \\<Rightarrow> acap\"", "property": "RISCV64-Specific Data Types and Object Sizes: Define architecture-specific object types, including ASID pools, page tables, and data pages, along with their respective sizes and properties. Provide functions to extract and manipulate these objects, such as retrieving ASID pools, page tables, and physical addresses from page table entries.\n\nObject Size Calculations: Calculate the sizes of various architecture-specific objects, including ASID pools, page tables, frames, and untyped objects, based on their respective bit sizes and properties.\n\nCapability Rights Updates: Update the rights of architecture-specific capabilities, such as frame capabilities, while validating the new rights against the existing ones.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " produce discriminators and selectors even though no field names are mentioned "}
{"spec": "lemma \"LENGTH(pte_ppn_len) = word_bits - pt_bits\"\n  by (simp add: pte_bits_def ptTranslationBits_def word_size_bits_def word_bits_def\n                pt_bits_def table_size_def)", "property": "Page Table Entry Property: The length of the physical page number (PPN) in a page table entry (PTE) is equal to the difference between the word size and the page table bits.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": "Sanity check:"}
{"spec": "datatype aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | HugePageObj\n  | PageTableObj\n  | ASIDPoolObj\n\ndefinition arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\"\n  where\n  \"arch_is_frame_type aobj \\<equiv> aobj \\<noteq> PageTableObj\"\n\ndefinition arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\"\n  where\n  \"arch_default_cap tp r n dev \\<equiv> case tp of\n     SmallPageObj \\<Rightarrow> FrameCap r vm_read_write RISCVSmallPage dev None\n   | LargePageObj \\<Rightarrow> FrameCap r vm_read_write RISCVLargePage dev None\n   | HugePageObj  \\<Rightarrow> FrameCap r vm_read_write RISCVHugePage dev None\n   | PageTableObj \\<Rightarrow> PageTableCap r None\n   | ASIDPoolObj  \\<Rightarrow> ASIDPoolCap r 0\" (* unused, but nicer properties when defined *)\n\ndefinition default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\"\n  where\n  \"default_arch_object tp dev n \\<equiv> case tp of\n     SmallPageObj \\<Rightarrow> DataPage dev RISCVSmallPage\n   | LargePageObj \\<Rightarrow> DataPage dev RISCVLargePage\n   | HugePageObj  \\<Rightarrow> DataPage dev RISCVHugePage\n   | PageTableObj \\<Rightarrow> PageTable (\\<lambda>_. InvalidPTE)\n   | ASIDPoolObj  \\<Rightarrow> ASIDPool Map.empty\"\n\ntype_synonym riscv_vspace_region_uses = \"vspace_ref \\<Rightarrow> riscvvspace_region_use\"", "property": "RISCV64-Specific Data Types and State: Define architecture-specific data types and state for RISCV64, including object types (e.g., page objects, page tables, ASID pools), capabilities (e.g., frame, page table, ASID pool), and default objects (e.g., data pages, page tables, ASID pools).\n\nSubproperties:\n- Object Types: Define the types of objects used in the RISCV64 architecture, including small, large, and huge page objects, page tables, and ASID pools.\n- Capability Definitions: Define the default capabilities for each object type, including frame capabilities for page objects, page table capabilities, and ASID pool capabilities.\n- Default Objects: Define the default objects for each object type, including data pages for page objects, page tables, and ASID pools.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "type_synonym vm_level = 4\n\ndefinition asid_pool_level :: vm_level\n  where\n  \"asid_pool_level = maxBound\"\n\ndefinition max_pt_level :: vm_level\n  where\n  \"max_pt_level = asid_pool_level - 1\"\n\nend\n\nqualify RISCV64_A (in Arch)", "property": "RISCV64 Virtual Memory Hierarchy: The architecture-specific state defines a 4-level virtual memory hierarchy, comprising an ASID pool level, and three page table levels. The ASID pool level is the topmost level, followed by the top-level page tables, level 1 page tables, and the bottom-level page tables containing InvalidPTEs or PagePTEs.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific state", "comment": "\n  The number of levels over all virtual memory tables.\n  For RISC-V, we have three page table levels plus the ASID pool level.\n\n  The top level (with the highest number) contains ASID pools, the next levels contain the\n  top-level page tables, and level 1 page tables. The bottom-level page tables (level 0)\n  contains only InvalidPTEs or PagePTEs.\n"}
{"spec": "record arch_state =\n  riscv_asid_table :: \"asid_high_index \\<rightharpoonup> obj_ref\"\n  riscv_global_pts :: \"RISCV64_A.vm_level \\<Rightarrow> obj_ref set\"\n  riscv_kernel_vspace :: \"obj_ref \\<Rightarrow> RISCV64_H.riscvvspace_region_use\"", "property": "RISCV64 Architecture State: Maintains architecture-specific state information, including the ASID table, global page tables, and kernel virtual space mappings. \n\nSubproperties:\n- ASID Table Management: Stores the mapping of ASID high indices to object references.\n- Global Page Table Management: Tracks the set of object references for each virtual machine level.\n- Kernel Virtual Space Mappings: Records the usage of RISCV64 virtual space regions for each object reference.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "end_qualify\n\ncontext Arch begin arch_global_naming (A)", "property": "RISCV64 Architecture State: Defines architecture-specific state, including global page tables, with constraints on table levels for kernel initialization and setup.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific state", "comment": "\n  The @{const riscv_global_pts} generalise the concept of global page tables.\n  The invariants will constrain the set of tables for @{term max_pt_level} to a\n  singleton, and for @{term asid_pool_level} to empty. All other levels may contain\n  multiple or no tables, depending on how kernel initialisation sets up the kernel window.\n"}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\"\n  where\n  \"aa_type ao \\<equiv> case ao of\n     PageTable pt    \\<Rightarrow> APageTable\n   | DataPage dev sz \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n   | ASIDPool f      \\<Rightarrow> AASIDPool\"\n\ndefinition badge_bits :: nat\n  where\n  \"badge_bits \\<equiv> 64\"\n\nend", "property": "RISCV64-Specific Data Types: Define architecture-specific data types for kernel objects, including AASIDPool, APageTable, AUserData, and ADeviceData, to categorize and manage different types of data in the RISCV64 architecture. \nData Type Classification: Classify kernel objects into their corresponding architecture-specific data types based on their properties and attributes. \nBadge Bits: Specify the number of badge bits as 64, determining the size and configuration of badges in the RISCV64 architecture.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "qualify RISCV64_A (in Arch)", "property": "RISCV64-Specific TCB Definition: Provides the architecture-specific definition for the Thread Control Block (TCB) on RISCV64 platforms, ensuring correct and efficient management of thread state and execution context.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Arch-specific TCB", "comment": ""}
{"spec": "record arch_tcb =\n  tcb_context :: user_context\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition default_arch_tcb :: arch_tcb\n  where\n  \"default_arch_tcb \\<equiv> \\<lparr>tcb_context = new_context\\<rparr>\"", "property": "Arch-Specific TCB Structure: The RISCV64-specific part of a TCB contains a field for the user context. \n\nDefault Arch-Specific TCB: The default arch-specific TCB has a user context initialized with a new context.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Arch-specific TCB", "comment": " Arch-specific part of a TCB: this must have at least a field for user context. "}
{"spec": "definition arch_tcb_context_set :: \"user_context \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\n  where\n  \"arch_tcb_context_set uc a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := uc \\<rparr>\"\n\ndefinition arch_tcb_context_get :: \"arch_tcb \\<Rightarrow> user_context\"\n  where\n  \"arch_tcb_context_get a_tcb \\<equiv> tcb_context a_tcb\"", "property": "Arch TCB Context Accessors: Provide access to the user context within the architecture-specific TCB, enabling compatibility with user monad operations. \n\n Arch TCB Context Setter: Set the user context within the architecture-specific TCB.\n Arch TCB Context Getter: Retrieve the user context from the architecture-specific TCB.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n  Accessors for @{text \"tcb_context\"} inside @{text \"arch_tcb\"}. These are later used to\n  implement @{text as_user}, i.e.\\ need to be compatible with @{text user_monad}.\n"}
{"spec": "definition arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\n  where\n  \"arch_tcb_set_registers regs a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := UserContext regs \\<rparr>\"\n\ndefinition arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\"\n  where\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\nend", "property": "Arch-Specific TCB Accessors: Provide access to the user register part of the architecture-specific TCB (Thread Control Block), allowing for getting and setting the registers within the TCB's user context.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n  Accessors for the user register part of the @{text \"arch_tcb\"}.\n  (Because @{typ \"register \\<Rightarrow> machine_word\"} might not be equal to @{typ user_context}).\n"}
{"spec": "chapter \\<open>Architecture-specific Fault-handling Functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\n  where\n  \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData)\n   od\"\n\ndefinition handle_arch_fault_reply ::\n  \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\n  where\n  \"handle_arch_fault_reply vmf thread x y \\<equiv> return True\"\n\nend\nend", "property": "Architecture-specific Fault Handling: Provides functions for constructing architecture-specific fault messages and handling replies to these faults, ensuring proper error handling and communication between threads in the system.\n\nSubproperties:\n- Construct Architecture-specific Fault Messages: Creates a fault message for a given architecture-specific fault, including the fault address and relevant data.\n- Handle Architecture-specific Fault Replies: Processes the reply to an architecture-specific fault, determining the course of action based on the fault type and reply data.", "title": "./spec/abstract/RISCV64/ArchFault_A.thy", "chapter": "Architecture-specific Fault-handling Functions", "section": "", "comment": ""}
{"spec": "chapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\n  where\n  \"sanitise_register t r v \\<equiv> v\"\n\ndefinition arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\n  where\n  \"arch_get_sanitise_register_info t \\<equiv> return False\"\n\ndefinition arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\n  where\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "Architecture-specific TCB Functions: Provide functions for sanitizing registers, retrieving sanitization information, and handling post-modification register actions, ensuring the integrity and security of architecture-specific thread state management.\n\nSanitization: Sanitize register values to prevent unauthorized or malicious data from being propagated.\n\nInformation Retrieval: Retrieve information necessary for sanitizing registers, ensuring that the correct sanitization policies are applied.\n\nPost-Modification Handling: Perform necessary actions after modifying registers to maintain the consistency and security of the thread state.", "title": "./spec/abstract/RISCV64/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "definition update_cnode_cap_data :: \"data \\<Rightarrow> nat \\<times> data\"\n  where\n  \"update_cnode_cap_data w \\<equiv>\n    let\n      guard_bits = 58;\n      guard_size' = unat ((w >> cnode_padding_bits) && mask cnode_guard_size_bits);\n      guard'' = (w >> (cnode_padding_bits + cnode_guard_size_bits)) && mask guard_bits\n    in (guard_size', guard'')\"", "property": "CNode Capability Modification: Extract new guard bits and guard from user-provided data to update a CNode capability. \n\nSubproperties:\n- Extract guard size from the data.\n- Extract guard from the data.", "title": "./spec/abstract/RISCV64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "On a user request to modify a CNode capability, extract new guard bits and guard."}
{"spec": "definition arch_is_physical :: \"arch_cap \\<Rightarrow> bool\"\n  where\n  \"arch_is_physical cap \\<equiv> case cap of ASIDControlCap \\<Rightarrow> False | _ \\<Rightarrow> True\"", "property": "Distinguish Physical Capabilities: Identify whether an architecture-specific capability is physical or not, with ASIDControlCap being treated as non-physical and all others as physical.", "title": "./spec/abstract/RISCV64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "For some purposes capabilities to physical objects are treated differently to others."}
{"spec": "fun arch_same_region_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\"\n  where\n  \"arch_same_region_as (FrameCap r _ sz _ _) c' =\n   (is_FrameCap c' \\<and>\n     (let\n        r' = acap_obj c';\n        sz' = acap_fsize c';\n        topA = r + (1 << pageBitsForSize sz) - 1;\n        topB = r' + (1 << pageBitsForSize sz') - 1\n      in r \\<le> r' \\<and> topA \\<ge> topB \\<and> r' \\<le> topB))\"\n| \"arch_same_region_as (PageTableCap r _) c' = (\\<exists>r' d'. c' = PageTableCap r' d' \\<and> r = r')\"\n| \"arch_same_region_as ASIDControlCap c' = (c' = ASIDControlCap)\"\n| \"arch_same_region_as (ASIDPoolCap r _) c' = (\\<exists>r' d'. c' = ASIDPoolCap r' d' \\<and> r = r')\"", "property": "Architectural Capability Region Check: Determine if two architectural capabilities refer to the same object or if one object is contained within the region of the other. \n\nSubproperties:\n- For frame capabilities, check if the second capability's object falls within the range of the first capability's object.\n- For page table capabilities, check if the objects of both capabilities are identical.\n- For ASID control capabilities, check if the second capability is also an ASID control capability.\n- For ASID pool capabilities, check if the objects of both capabilities are identical.", "title": "./spec/abstract/RISCV64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Check whether the second capability is to the same object or an object\n  contained in the region of the first one.\n"}
{"spec": "definition same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\"\n  where\n  \"same_aobject_as cap cap' \\<equiv>\n     case (cap, cap') of\n       (FrameCap ref _ sz dev _, FrameCap ref' _ sz' dev' _) \\<Rightarrow>\n         (dev, ref, sz) = (dev', ref', sz') \\<and> ref \\<le> ref + 2 ^ pageBitsForSize sz - 1\n     | _ \\<Rightarrow> arch_same_region_as cap cap'\"\n\ndeclare same_aobject_as_def[simp]\n\ndefinition arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\n  where\n  \"arch_is_cap_revocable new_cap src_cap \\<equiv> False\"\n\nend\nend", "property": "Arch Capability Equivalence: Two architecture-specific capabilities are considered equivalent if they refer to the same object, with matching device, reference, and size attributes, and the references fall within the same page range.\n\n Arch Capability Revocability: Architecture-specific capabilities are never revocable.", "title": "./spec/abstract/RISCV64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "type_synonym obj_ref         = machine_word\ntype_synonym vspace_ref      = machine_word\n\ntype_synonym data            = machine_word\ntype_synonym cap_ref         = \"bool list\"\ntype_synonym length_type     = machine_word\n\ntype_synonym asid_low_len    = 9\ntype_synonym asid_low_index  = \"asid_low_len word\"\n\ntype_synonym asid_high_len   = 7\ntype_synonym asid_high_index = \"asid_high_len word\"\n\ntype_synonym asid_len        = 16\ntype_synonym asid_rep_len    = asid_len\ntype_synonym asid            = \"asid_rep_len word\"", "property": "Type Instantiation: Define concrete types for abstract type names in the specification for the RISCV64 architecture, including object references, virtual space references, data, capability references, length types, and address space identifiers (ASIDs).", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object references, user pointers,\n  word-based data, cap references, and so on. This theory provides an instantiation of these names\n  to concrete types for the RISCV64 architecture. Other architectures may have slightly different\n  instantiations.\n"}
{"spec": "definition oref_to_data :: \"obj_ref \\<Rightarrow> data\"\n  where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition data_to_oref :: \"data \\<Rightarrow> obj_ref\"\n  where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition vref_to_data :: \"vspace_ref \\<Rightarrow> data\"\n  where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition data_to_vref :: \"data \\<Rightarrow> vspace_ref\"\n  where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition nat_to_len :: \"nat \\<Rightarrow> length_type\"\n  where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition data_to_nat :: \"data \\<Rightarrow> nat\"\n  where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition data_to_16 :: \"data \\<Rightarrow> 16 word\"\n  where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition data_to_cptr :: \"data \\<Rightarrow> cap_ref\"\n  where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\"\n  where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\"\n  where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Provide functions for converting between different data types, including object references, virtual space references, natural numbers, length types, and capability pointers, to facilitate seamless interactions between various system components.\n\nSubproperties:\n- Identity Conversions: Define identity functions for converting between abstract type names, such as object references and data, or virtual space references and data.\n- Word Conversions: Specify conversions between different word sizes using the ucast function, such as converting data to 16-word values.\n- Bitwise Operations: Define functions for combining notification badges and messages using bitwise OR operations.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  With the definitions above, most conversions between abstract type names boil down to just\n  the identity function, some convert from @{text word} to @{typ nat} and others between different\n  word sizes using @{const ucast}.\n"}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversions: Define conversions between different data types, including object references, virtual references, lengths, and capability pointers, to facilitate automatic unfolding in proofs.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition slot_bits :: nat\n  where\n  \"slot_bits \\<equiv> 5\"\n\ndefinition msg_label_bits :: nat\n  where\n  [simp]: \"msg_label_bits \\<equiv> 52\"\n\ndefinition new_context :: \"user_context\"\n  where\n  \"new_context \\<equiv> UserContext ((\\<lambda>_. 0) (SSTATUS := sstatusSPIE))\"", "property": "Architecture-Dependent Sizes: Define the sizes of various architecture-dependent components, including the slot size and message label size, to ensure compatibility with the underlying machine architecture.\nStandard Values: Establish standard values for user context, including the initial status register value with the SPIE bit set.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The following definitions provide architecture-dependent sizes such as the standard page\n  size and capability size of the underlying machine.\n"}
{"spec": "definition pptr_base :: \"machine_word\"\n  where\n  \"pptr_base = Platform.RISCV64.pptrBase\"\n\ntext \"Virtual address space available to users.\"\ndefinition user_vtop :: \"machine_word\"\n  where\n  \"user_vtop = Platform.RISCV64.pptrUserTop\"", "property": "Kernel Virtual Address Space: The kernel reserves a portion of the virtual address space, starting from a fixed base address (pptr_base) and extending upwards, in every virtual address space. \n\nUser Virtual Address Space: A portion of the virtual address space is available for use by users, up to a fixed top address (user_vtop).", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The lowest virtual address in the kernel window. The kernel reserves the virtual addresses\n  from here up in every virtual address space.\n"}
{"spec": "definition kdev_base :: \"machine_word\"\n  where\n  \"kdev_base = Platform.RISCV64.kdevBase\"", "property": "Kernel Device Mapping Region: The virtual address for the start of the kernel device mapping region is located in the highest 1GiB of memory.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  Virtual address for start of kernel device mapping region in highest 1GiB of memory.\n"}
{"spec": "definition kernel_elf_base :: \"vspace_ref\"\n  where\n  \"kernel_elf_base \\<equiv> Platform.RISCV64.kernelELFBase\"", "property": "Kernel ELF Base Address: The kernel's ELF (Executable and Linkable Format) base address is defined as a fixed virtual address in the system's address space.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The virtual address the kernel code is mapped.\n"}
{"spec": "definition idle_thread_ptr :: vspace_ref\n  where\n  \"idle_thread_ptr = pptr_base + 0x1000\"\n\n\ndefinition nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\"\n  where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len) (to_bl (of_nat n :: machine_word))\"\n\ndefinition msg_info_register :: register\n  where\n  \"msg_info_register \\<equiv> msgInfoRegister\"\n\ndefinition msg_registers :: \"register list\"\n  where\n  \"msg_registers \\<equiv> msgRegisters\"\n\ndefinition cap_register :: register\n  where\n  \"cap_register \\<equiv> capRegister\"\n\ndefinition badge_register :: register\n  where\n  \"badge_register \\<equiv> badgeRegister\"\n\ndefinition frame_registers :: \"register list\"\n  where\n  \"frame_registers \\<equiv> frameRegisters\"\n\ndefinition gp_registers :: \"register list\"\n  where\n  \"gp_registers \\<equiv> gpRegisters\"\n\ndefinition exception_message :: \"register list\"\n  where\n  \"exception_message \\<equiv> exceptionMessage\"\n\ndefinition syscall_message :: \"register list\"\n  where\n  \"syscall_message \\<equiv> syscallMessage\"\n\ndatatype arch_fault\n  = VMFault (vm_fault_address : vspace_ref) (vm_fault_arch_data : \"machine_word list\")\n\nend\n\narch_requalify_consts (A) idle_thread_ptr\n\nend", "property": "Constant Definitions: Define various constants for the system, including the idle thread pointer, register names, and fault data types, providing a foundation for the system's architecture and functionality.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  Currently an arbitrary aligned address for the idle thread.\n  Only has to exists, does not have to match up with the concrete value in C.\n"}
{"spec": "text \\<open>This is used by some decode functions. VCPU decode functions are the first that need to bounds\n  check IRQs from the user.\\<close>\ndefinition arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"arch_check_irq irq \\<equiv> whenE (irq > maxIRQ \\<or> irq < ucast minIRQ)\n                          $ throwError (RangeError (ucast minIRQ) maxIRQ)\"", "property": "IRQ Validation: Ensure that the IRQ value falls within the valid range, between the minimum and maximum IRQ values. If the IRQ value is outside this range, throw a RangeError exception.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "definition decode_vcpu_set_tcb ::\n  \"arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_set_tcb cap extras \\<equiv> case (cap, extras) of\n     (VCPUCap v, fs#_) \\<Rightarrow> (case fs of\n           (ThreadCap t, _) \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUSetTCB v t\n         | _ \\<Rightarrow> throwError IllegalOperation)\n   | (VCPUCap v, _) \\<Rightarrow> throwError TruncatedMessage\n   | _ \\<Rightarrow> throwError IllegalOperation\"", "property": "VCPU Invocation: Validate and decode the VCPU set TCB invocation, ensuring that the provided capability and extra arguments match the expected format for setting a TCB for a VCPU.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "definition read_vcpu_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n  \"read_vcpu_register vcpu_ptr reg \\<equiv> do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     (on_cur_vcpu, active) \\<leftarrow> return (case cur_vcpu of\n         Some (vcpu_ptr', a) \\<Rightarrow> (vcpu_ptr' = vcpu_ptr, a)\n       | _ \\<Rightarrow> (False, False));\n\n     if on_cur_vcpu\n       then if vcpuRegSavedWhenDisabled reg \\<and> \\<not>active\n              then vcpu_read_reg vcpu_ptr reg\n              else do_machine_op $ readVCPUHardwareReg reg\n       else vcpu_read_reg vcpu_ptr reg\n  od\"\n\ndefinition\n  write_vcpu_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"write_vcpu_register vcpu_ptr reg val \\<equiv>\n  do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu o arch_state);\n     (on_cur_vcpu, active) \\<leftarrow> return (case cur_vcpu of\n         Some (cv, a) \\<Rightarrow> (cv = vcpu_ptr, a)\n       | _ \\<Rightarrow> (False, False));\n\n     if on_cur_vcpu\n       then if vcpuRegSavedWhenDisabled reg \\<and> \\<not>active\n         then vcpu_write_reg vcpu_ptr reg val\n         else do_machine_op $ writeVCPUHardwareReg reg val\n       else vcpu_write_reg vcpu_ptr reg val\n  od\"\n\ndefinition decode_vcpu_read_register ::\n  \"machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_read_register args cap \\<equiv> case (args, cap) of\n      (reg#_, VCPUCap p) \\<Rightarrow> if fromEnum (maxBound::vcpureg) < unat reg\n                           then throwError (InvalidArgument 1)\n                           else returnOk $ InvokeVCPU $ VCPUReadRegister p $ toEnum (unat reg)\n    | (_, _) \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition decode_vcpu_write_register :: \"machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_write_register args cap \\<equiv> case (args, cap) of\n    (reg#val#_, VCPUCap p) \\<Rightarrow> if fromEnum (maxBound::vcpureg) < unat reg\n                              then throwError (InvalidArgument 1)\n                              else returnOk $ InvokeVCPU $ VCPUWriteRegister p (toEnum (unat reg)) val\n  | (_, _) \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_read_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\n  where\n  \"invoke_vcpu_read_register v reg \\<equiv> do\n     val \\<leftarrow> read_vcpu_register v reg;\n     return [val]\n   od\"\n\ndefinition\n  invoke_vcpu_write_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"invoke_vcpu_write_register v reg val \\<equiv>  write_vcpu_register v reg val\"", "property": "VCPU Register Access: Provides functions to read and write VCPU registers, handling both the current VCPU and other VCPUs, and considering whether the VCPU is active or not. \n\nSubproperties:\n- Read VCPU Register: Reads the value of a VCPU register, either from the VCPU's saved state or directly from the hardware if the VCPU is active.\n- Write VCPU Register: Writes a value to a VCPU register, either to the VCPU's saved state or directly to the hardware if the VCPU is active.\n- Decode VCPU Read/Write Register: Decodes the arguments for reading or writing a VCPU register, checking for valid register numbers and returning an error for invalid arguments.\n- Invoke VCPU Read/Write Register: Invokes the read or write operation on a VCPU register, returning the result or handling any errors.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "definition make_virq :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> virq\" where\n  \"make_virq grp prio irq \\<equiv>\n    let\n      groupShift = 30;\n      prioShift = 23;\n      irqPending = 1 << 28;\n      eoiirqen = 1 << 19\n    in ((grp && 1) << groupShift) || ((prio && 0x1F) << prioShift) || (irq && 0x3FF)\n       || irqPending || eoiirqen\"\n\ndefinition virq_type :: \"virq \\<Rightarrow> nat\" where\n  \"virq_type virq \\<equiv> unat ((virq >> 28) && 3)\"\n\ndefinition is_virq_active :: \"virq \\<Rightarrow> bool\" where\n  \"is_virq_active virq \\<equiv> virq_type virq = 2\"\n\ndefinition decode_vcpu_inject_irq ::\n  \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_inject_irq ptrs cap \\<equiv> case (ptrs, cap) of\n  (mr0 # _, VCPUCap p) \\<Rightarrow> doE\n     vid \\<leftarrow> returnOk (mr0 && 0xFFFF);\n     priority \\<leftarrow> returnOk ((mr0 >> 16) && 0xFF);\n     group \\<leftarrow> returnOk ((mr0 >> 24) && 0xFF);\n     index \\<leftarrow> returnOk ((mr0 >> 32) && 0xFF);\n     range_check vid 0 ((1 << 10) - 1);\n     range_check priority 0 31;\n     range_check group 0 1;\n     num_list_regs \\<leftarrow> liftE $ gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     whenE (index \\<ge> of_nat num_list_regs) $\n        (throwError $ RangeError 0 (of_nat num_list_regs - 1));\n\n     vcpu \\<leftarrow> liftE $ get_vcpu p;\n     vcpuLR \\<leftarrow> returnOk (vgic_lr $ vcpu_vgic $ vcpu);\n\n     whenE (is_virq_active (vcpuLR (unat index))) $ throwError DeleteFirst;\n\n     virq \\<leftarrow> returnOk (make_virq group priority vid);\n     returnOk $ InvokeVCPU $ VCPUInjectIRQ p (unat index) virq\n  odE\n| _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_inject_irq :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> virq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invoke_vcpu_inject_irq vr index virq \\<equiv> do\n    cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n    if (cur_v \\<noteq> None \\<and> fst (the cur_v) = vr)\n    then do_machine_op $ set_gic_vcpu_ctrl_lr (of_nat index) virq\n    else vgic_update_lr vr index virq\n   od\"", "property": "VCPU Injection: Inject an interrupt into a VCPU, setting the corresponding interrupt register. The injection process checks the validity of the interrupt parameters (ID, priority, group, and index) and ensures that the target VCPU is properly updated. If the VCPU is currently active, the injection is performed immediately; otherwise, the VCPU's interrupt register is updated.\n\nSubproperties:\n- Parameter Validation: Validate the interrupt parameters (ID, priority, group, and index) to ensure they are within the allowed ranges.\n- VCPU Interrupt Register Update: Update the VCPU's interrupt register with the new interrupt value.\n- Active VCPU Injection: If the VCPU is currently active, inject the interrupt immediately using a machine operation.\n- Inactive VCPU Update: If the VCPU is not active, update its interrupt register for later injection.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": " This following function does not correspond to exactly what the C does, but\n   it is the value that is stored inside of lr in the vgic  "}
{"spec": "definition decode_vcpu_ack_vppi ::\n  \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_ack_vppi mrs cap \\<equiv>\n     case (mrs, cap)\n       of (mr0 # _, VCPUCap vcpu_ptr) \\<Rightarrow> doE\n           arch_check_irq mr0;\n           (case irq_vppi_event_index (ucast mr0)\n            of None \\<Rightarrow> throwError $ InvalidArgument 0\n             | Some vppi \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUAckVPPI vcpu_ptr vppi)\n         odE\n       | _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_ack_vppi :: \"obj_ref \\<Rightarrow> vppievent_irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invoke_vcpu_ack_vppi vcpu_ptr vppi =\n     vcpu_update vcpu_ptr\n                 (\\<lambda>vcpu. vcpu\\<lparr> vcpu_vppi_masked := (vcpu_vppi_masked vcpu)(vppi := False) \\<rparr>)\"", "property": "VCPU Acknowledge VPPI: Allows the VCPU to acknowledge a VPPI (Virtual Platform Peripheral Interrupt) event by updating the VCPU's VPPI mask to indicate that the interrupt has been handled.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": "VCPU : acknowledge VPPI"}
{"spec": "definition\n  perform_vcpu_invocation :: \"vcpu_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"perform_vcpu_invocation iv \\<equiv> case iv of\n     VCPUSetTCB vcpu tcb \\<Rightarrow> do associate_vcpu_tcb vcpu tcb; return [] od\n   | VCPUReadRegister vcpu reg \\<Rightarrow> invoke_vcpu_read_register vcpu reg\n   | VCPUWriteRegister vcpu reg val \\<Rightarrow> do invoke_vcpu_write_register vcpu reg val; return [] od\n   | VCPUInjectIRQ vcpu index vir \\<Rightarrow> do invoke_vcpu_inject_irq vcpu index vir; return [] od\n   | VCPUAckVPPI vcpu vppi \\<Rightarrow> do invoke_vcpu_ack_vppi vcpu vppi; return [] od\"\n\ndefinition decode_vcpu_invocation ::\n  \"machine_word \\<Rightarrow> machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_invocation label args cap extras \\<equiv> case cap of\n  VCPUCap _ \\<Rightarrow> (case invocation_type label of\n      ArchInvocationLabel ARMVCPUSetTCB \\<Rightarrow> decode_vcpu_set_tcb cap extras\n    | ArchInvocationLabel ARMVCPUReadReg \\<Rightarrow> decode_vcpu_read_register args cap\n    | ArchInvocationLabel ARMVCPUWriteReg \\<Rightarrow> decode_vcpu_write_register args cap\n    | ArchInvocationLabel ARMVCPUInjectIRQ \\<Rightarrow> decode_vcpu_inject_irq args cap\n    | ArchInvocationLabel ARMVCPUAckVPPI \\<Rightarrow> decode_vcpu_ack_vppi args cap\n    |  _ \\<Rightarrow> throwError IllegalOperation)\n  | _ \\<Rightarrow> throwError IllegalOperation\"\n\nend\n\nend", "property": "VCPU Invocation Management: Perform and decode VCPU-related functions, including setting the TCB for a VCPU, reading and writing VCPU registers, injecting IRQs, and acknowledging VPPIs. This ensures that VCPUs can be managed and interacted with correctly, maintaining the integrity and performance of the system.\n\nSubproperties:\n- Set TCB for VCPU: Associate a TCB with a VCPU.\n- Read/Write VCPU Registers: Read and write registers of a VCPU.\n- Inject IRQs: Inject interrupts into a VCPU.\n- Acknowledge VPPIs: Acknowledge VPPIs for a VCPU.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": "VCPU perform and decode main functions"}
{"spec": "chapter \"Arch-specific Interrupts\"\n\ntheory ArchInterrupt_A\nimports Ipc_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition virqSetEOIIRQEN :: \"virq \\<Rightarrow> machine_word \\<Rightarrow> virq\" where\n  \"virqSetEOIIRQEN virq v \\<equiv>\n     if virq_type virq = 3\n     then virq\n     else (virq && ~~0x80000) || ((v << 19) && 0x80000)\"\n\ndefinition vgic_maintenance :: \"(unit,'z::state_ext) s_monad\" where\n  \"vgic_maintenance = do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     case cur_vcpu\n       of Some (vcpu_ptr, True) \\<Rightarrow> do\n            eisr0 \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_eisr0;\n            eisr1 \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_eisr1;\n            flags \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_misr;\n            vgic_misr_eoi \\<leftarrow> return $ vgicHCREN;\n            irq_idx \\<leftarrow> return (if eisr0 \\<noteq> 0 then word_ctz eisr0 else word_ctz eisr1 + 32);\n            gic_vcpu_num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs o arch_state);\n            fault \\<leftarrow> if flags && vgic_misr_eoi \\<noteq> 0\n                    then\n                      if eisr0 = 0 \\<and> eisr1 = 0 \\<or> irq_idx \\<ge> gic_vcpu_num_list_regs\n                      then return $ VGICMaintenance None\n                      else do\n                        virq <- do_machine_op $ get_gic_vcpu_ctrl_lr (of_nat irq_idx);\n                        virqen <- return $ virqSetEOIIRQEN virq 0;\n                        do_machine_op $ set_gic_vcpu_ctrl_lr (of_nat irq_idx) virqen;\n                        vgic_update_lr vcpu_ptr irq_idx virqen;\n                        return $ VGICMaintenance $ Some $ of_nat irq_idx\n                      od\n                    else return $ VGICMaintenance None;\n\n            ct \\<leftarrow> gets cur_thread;\n            st \\<leftarrow> get_thread_state ct;\n            \\<comment> \\<open>until a proof links active current vcpu to runnable current thread, we need this\n               check: @{term handle_fault} needs a runnable current thread\\<close>\n            when (runnable st) $ handle_fault ct $ ArchFault fault\n          od\n        | _ \\<Rightarrow> return ()\n   od\"\n\ndefinition vppi_event :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vppi_event irq = do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     case cur_vcpu\n       of Some (vcpu_ptr, True) \\<Rightarrow> do\n            do_machine_op $ maskInterrupt True irq;\n            vppi \\<leftarrow> return $ the $ irq_vppi_event_index irq;\n            vcpu_update vcpu_ptr\n                        (\\<lambda>vcpu. vcpu\\<lparr> vcpu_vppi_masked := (vcpu_vppi_masked vcpu)(vppi := True) \\<rparr>);\n            ct \\<leftarrow> gets cur_thread;\n            st \\<leftarrow> get_thread_state ct;\n            \\<comment> \\<open>until a proof links active current vcpu to runnable current thread, we need this\n               check: @{term handle_fault} needs a runnable current thread\\<close>\n            when (runnable st) $ handle_fault ct $ ArchFault $ VPPIEvent irq\n          od\n        | _ \\<Rightarrow> return ()\n   od\"\n\ndefinition handle_reserved_irq :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"handle_reserved_irq irq \\<equiv> do\n     when (irq = irqVGICMaintenance) vgic_maintenance;\n     when (irq_vppi_event_index irq \\<noteq> None) $ vppi_event irq\n   od\"\n\nfun arch_invoke_irq_handler :: \"irq_handler_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_invoke_irq_handler (ACKIrq irq) = (do_machine_op $ maskInterrupt False irq)\"\n| \"arch_invoke_irq_handler _ = return ()\"\n\ndefinition arch_mask_irq_signal :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_mask_irq_signal irq \\<equiv> do_machine_op $ maskInterrupt True irq\"\n\nend\n\nend", "property": "Arch-specific Interrupt Handling: Manage and handle interrupts specific to the architecture, including setting EOI (End of Interrupt) flags, handling VGIC (Virtual Generic Interrupt Controller) maintenance, VPPi (Virtual Programmable Peripheral Interrupt) events, and reserved IRQs (Interrupt Requests).\n\nSubproperties:\n- VGIC Maintenance: Perform maintenance tasks for the VGIC, including checking and handling EOI flags, updating interrupt registers, and handling faults.\n- VPPi Event Handling: Handle VPPi events by masking interrupts, updating VCPU (Virtual CPU) state, and handling faults.\n- Reserved IRQ Handling: Handle reserved IRQs, including VGIC maintenance and VPPi events.\n- IRQ Handler Invocation: Invoke IRQ handlers for specific IRQ handler invocations, including acknowledging IRQs and masking IRQ signals.", "title": "./spec/abstract/AARCH64/ArchInterrupt_A.thy", "chapter": "Arch-specific Interrupts", "section": "", "comment": ""}
{"spec": "definition perform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_asid_control_invocation iv \\<equiv> case iv of\n     MakePool frame slot parent base \\<Rightarrow> do\n       delete_objects frame pageBits;\n       pcap \\<leftarrow> get_cap parent;\n       set_cap (max_free_index_update pcap) parent;\n       retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n       cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n       assert (asid_low_bits_of base = 0);\n       asid_table \\<leftarrow> gets asid_table;\n       asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n       modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>arm_asid_table := asid_table'\\<rparr>\\<rparr>)\n     od\"", "property": "ASID Control Invocation: Create a new ASID pool object, provide a capability to it, and connect it to the global virtual ASID table. \n\nSubproperties:\n- Delete objects in the specified frame.\n- Update the parent capability with the maximum free index.\n- Retype the specified region to an ASID pool object.\n- Insert the new ASID pool capability into the specified slot.\n- Update the ASID table with the new ASID pool mapping.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "\n  The ASIDControl capability confers the authority to create a new ASID pool object. This\n  operation creates the new ASID pool, provides a capability to it and connects it to the global\n  virtual ASID table.\n"}
{"spec": "definition perform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_asid_pool_invocation iv \\<equiv> case iv of\n     Assign asid pool_ptr ct_slot \\<Rightarrow> do\n       pt_cap \\<leftarrow> get_cap ct_slot;\n       assert $ is_ArchObjectCap pt_cap;\n       acap \\<leftarrow> return $ the_arch_cap pt_cap;\n       assert $ is_PageTableCap acap;\n       set_cap (ArchObjectCap $ update_map_data acap $ Some (asid,0)) ct_slot;\n       pt_base \\<leftarrow> return $ acap_obj acap;\n       store_asid_pool_entry pool_ptr asid (Some (ASIDPoolVSpace None pt_base))\n     od\"\n\ndefinition perform_pg_inv_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_pg_inv_unmap cap ct_slot \\<equiv> do\n     assert $ is_FrameCap cap;\n     case acap_map_data cap of\n       Some (asid, vaddr) \\<Rightarrow> unmap_page (acap_fsize cap) asid vaddr (acap_obj cap)\n     | _ \\<Rightarrow> return ();\n     old_cap \\<leftarrow> get_cap ct_slot;\n     set_cap (ArchObjectCap $ update_map_data (the_arch_cap old_cap) None) ct_slot\n   od\"\n\ndefinition perform_pg_inv_map ::\n  \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> pte \\<Rightarrow> obj_ref \\<Rightarrow> vm_level \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_pg_inv_map cap ct_slot pte slot level \\<equiv> do\n     old_pte \\<leftarrow> get_pte level slot;\n     set_cap (ArchObjectCap cap) ct_slot;\n     store_pte level slot pte;\n     do_machine_op $ cleanByVA_PoU slot (addrFromPPtr slot);\n     when (old_pte \\<noteq> InvalidPTE) $ do\n        (asid, vaddr) \\<leftarrow> assert_opt $ acap_map_data cap;\n        invalidate_tlb_by_asid_va asid vaddr\n     od\n   od\"\n\ndefinition perform_pg_inv_get_addr ::\n  \"obj_ref \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"perform_pg_inv_get_addr ptr \\<equiv> return [addrFromPPtr ptr]\"\n\ndefinition do_flush :: \"flush_type \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\" where\n  \"do_flush type vstart vend pstart \\<equiv>\n     case type of\n       Clean \\<Rightarrow> cleanCacheRange_RAM vstart vend pstart\n     | Invalidate \\<Rightarrow> invalidateCacheRange_RAM vstart vend pstart\n     | CleanInvalidate \\<Rightarrow> cleanInvalidateCacheRange_RAM vstart vend pstart\n     | Unify \\<Rightarrow> do\n         cleanCacheRange_PoU vstart vend pstart;\n         dsb;\n         invalidateCacheRange_I vstart vend pstart;\n         isb\n       od\"", "property": "ASID Management: Assign an ASID to a top-level page table, update the corresponding capability, and store the ASID pool entry.\n\nPage Table Management: \n- Unmap a page from a page table, updating the capability and performing necessary unmap operations.\n- Map a page into a page table, updating the capability, storing the page table entry, and performing necessary cache and TLB operations.\n- Retrieve the address of a page table entry.\n- Perform cache flush operations on a range of virtual and physical addresses.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign an ASID to a top-level page table."}
{"spec": "definition perform_flush ::\n  \"flush_type \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> paddr \\<Rightarrow> obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_flush type vstart vend pstart space asid \\<equiv> do\n     start \\<leftarrow> return $ ptrFromPAddr pstart;\n     end \\<leftarrow> return $ start + (vend - vstart);\n     when (start < end) $ do_machine_op $ do_flush type start end pstart\n   od\"", "property": "Perform Flush Operation: Flush a range of memory pages or virtual space, depending on the flush type, from a specified start to end address, ensuring that the memory is correctly updated and synchronized. \n\nFlush Range Validation: Verify that the start address is less than the end address before performing the flush operation. \n\nFlush Operation Execution: Execute the flush operation using a machine operation, passing the flush type, start and end addresses, and the physical start address as parameters.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": " Used for both, vspace and page invocation; distinction is in the flush type "}
{"spec": "definition perform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"perform_page_invocation iv \\<equiv> case iv of\n     PageMap cap ct_slot (pte,slot,level) \\<Rightarrow> do\n       perform_pg_inv_map cap ct_slot pte slot level;\n       return []\n     od\n   | PageUnmap cap ct_slot \\<Rightarrow> do perform_pg_inv_unmap cap ct_slot; return [] od\n   | PageGetAddr ptr \\<Rightarrow> perform_pg_inv_get_addr ptr\n   | PageFlush type start end pstart space asid \\<Rightarrow> do\n       perform_flush type start end pstart space asid;\n       return []\n     od\"\n\n\ndefinition perform_pt_inv_map ::\n  \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> pte \\<Rightarrow> obj_ref \\<Rightarrow> vm_level \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_pt_inv_map cap ct_slot pte slot level = do\n     set_cap (ArchObjectCap cap) ct_slot;\n     store_pte level slot pte;\n     do_machine_op $ cleanByVA_PoU slot (addrFromPPtr slot)\n   od\"\n\ndefinition perform_pt_inv_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_pt_inv_unmap cap ct_slot = do\n     assert $ is_PageTableCap cap;\n     case acap_map_data cap of\n       Some (asid, vaddr) \\<Rightarrow> do\n         p \\<leftarrow> return $ acap_obj cap;\n         unmap_page_table asid vaddr p;\n         slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + mask (pt_bits (acap_pt_type cap))];\n         mapM_x (swp (store_pte (acap_pt_type cap)) InvalidPTE) slots;\n         do_machine_op $ cleanCacheRange_PoU p (p + mask (pt_bits (acap_pt_type cap)))\n                                             (addrFromPPtr p)\n       od\n     | _ \\<Rightarrow> return ();\n     old_cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n     set_cap (ArchObjectCap $ update_map_data old_cap None) ct_slot\n   od\"", "property": "Frame Capability Actions: Allow mapping and unmapping of memory, querying the physical address of a page, and flushing of memory regions. These actions ensure that memory can be effectively managed and accessed within the system.\n\nSubproperties:\n- Map Memory: Set the capability and store the page table entry, then clean the memory region.\n- Unmap Memory: Unmap the page table, invalidate the page table entries, and clean the cache range.\n- Query Physical Address: Retrieve the physical address of a page.\n- Flush Memory: Flush the specified memory region.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "\n  The Frame capability confers the authority to map and unmap memory, to query the physical\n  address of a page and to flush.\n"}
{"spec": "definition perform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_page_table_invocation iv \\<equiv> case iv of\n     PageTableMap cap ct_slot pte slot level \\<Rightarrow> perform_pt_inv_map cap ct_slot pte slot level\n   | PageTableUnmap cap ct_slot \\<Rightarrow> perform_pt_inv_unmap cap ct_slot\"", "property": "Page Table Invocation Actions: Allow mapping and unmapping of page tables, conferring authority to manage page table capabilities. \n\nMap Page Table: Map a page table into a capability table slot.\nUnmap Page Table: Unmap a page table from a capability table slot.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page tables."}
{"spec": "definition perform_vspace_invocation :: \"vspace_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_vspace_invocation iv \\<equiv> case iv of\n     VSpaceNothing \\<Rightarrow> return ()\n   | VSpaceFlush type start end pstart space asid \\<Rightarrow> perform_flush type start end pstart space asid\"\n\nlocale_abbrev arch_no_return :: \"(unit, 'z::state_ext) s_monad \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\n  where\n  \"arch_no_return oper \\<equiv> do oper; return [] od\"", "property": "VSpace Invocation: Authorizes the flushing of memory regions, ensuring that the virtual space is correctly updated and maintained. \n\nPerform VSpace Flush: Flush a specified memory region, defined by its type, start and end addresses, and page start, within a given virtual space and address space identifier (ASID).", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "VSpace capabilities confer the authority to flush."}
{"spec": "definition arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\n  where\n  \"arch_perform_invocation i \\<equiv> liftE $ case i of\n     InvokeVSpace oper \\<Rightarrow> arch_no_return $ perform_vspace_invocation oper\n   | InvokePageTable oper \\<Rightarrow> arch_no_return $ perform_page_table_invocation oper\n   | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n   | InvokeASIDControl oper \\<Rightarrow> arch_no_return $ perform_asid_control_invocation oper\n   | InvokeASIDPool oper \\<Rightarrow> arch_no_return $ perform_asid_pool_invocation oper\n   | InvokeVCPU oper \\<Rightarrow> perform_vcpu_invocation oper\"\n\nend\nend", "property": "AARCH64 System Call Dispatch: Dispatch AARCH64-specific system calls to their corresponding invocation handlers, covering various operations such as virtual space, page table, page, ASID control, ASID pool, and VCPU invocations.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call dispatcher for all AARCH64-specific system calls."}
{"spec": "chapter \\<open>Handle Hypervisor Fault Events\\<close>\n\ntheory Hypervisor_A\nimports Ipc_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"machine_word \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\n  where\n  \"handle_hypervisor_fault thread (ARMVCPUFault hsr) = do\n     fpu_enabled \\<leftarrow> do_machine_op isFpuEnable;\n     if \\<not>fpu_enabled\n     then fail\n     else if hsr = 0x2000000 \\<comment> \\<open>@{text UNKNOWN_FAULT}\\<close>\n          then do\n            esr \\<leftarrow> do_machine_op getESR;\n            handle_fault thread (UserException (esr && mask 32) 0)\n          od\n          else handle_fault thread (ArchFault $ VCPUFault (ucast hsr))\n   od\"\n\nend\nend", "property": "Handle Hypervisor Fault Events: Handle faults occurring in the hypervisor, specifically for ARMVCPUFault types, by checking FPU enablement, handling unknown faults, and routing other faults to the handle_fault function for further processing. \n\nSubproperties:\n- FPU Enablement Check: Verify if the FPU is enabled before proceeding with fault handling.\n- Unknown Fault Handling: Handle unknown faults by retrieving the ESR value and passing it to the handle_fault function as a UserException.\n- ArchFault Handling: Handle other faults by passing them to the handle_fault function as an ArchFault with the VCPUFault type.", "title": "./spec/abstract/AARCH64/Hypervisor_A.thy", "chapter": "Handle Hypervisor Fault Events", "section": "", "comment": ""}
{"spec": "definition reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Memory Region Reservation: Reserve a memory region with the specified pointer, byte length, and kernel designation, currently a no-op placeholder for potential future extension to explicitly tag kernel data regions in memory.", "title": "./spec/abstract/AARCH64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "\n  This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory.\n"}
{"spec": "definition vs_apiobj_size where\n  \"vs_apiobj_size ty \\<equiv>\n     case ty of\n       ArchObject SmallPageObj \\<Rightarrow> pageBitsForSize ARMSmallPage\n     | ArchObject LargePageObj \\<Rightarrow> pageBitsForSize ARMLargePage\n     | ArchObject HugePageObj \\<Rightarrow> pageBitsForSize ARMHugePage\n     | ArchObject PageTableObj \\<Rightarrow> table_size NormalPT_T\n     | ArchObject VSpaceObj \\<Rightarrow> table_size VSRootPT_T\"\n\ndefinition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv>\n     if \\<not>is_device \\<and>\n        new_type \\<in> {ArchObject SmallPageObj, ArchObject LargePageObj, ArchObject HugePageObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_RAM ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else if new_type \\<in> {ArchObject PageTableObj, ArchObject VSpaceObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_PoU ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else\n       return ()\"\n\ndefinition empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (FPUState (\\<lambda>_. 0) 0 0) (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context, tcb_vcpu = None \\<rparr>\"\n\nend\nend", "property": "Initialise Architecture-Specific Objects: Initialise architecture-specific objects, including page tables, virtual space objects, and page objects, by cleaning the cache range and setting up the object's size and references. \n\nSubproperties:\n- Cache Cleaning: Clean the cache range for the newly created objects to ensure data consistency.\n- Object Size and References: Set up the object's size and references according to the object type and architecture-specific requirements.\n- Architecture-Specific TCB Initialisation: Initialise the architecture-specific parts of the TCB, including the user context and virtual CPU state.", "title": "./spec/abstract/AARCH64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\" where\n  \"arch_post_cap_deletion ac \\<equiv> return ()\"", "property": "Post-Capability Deletion: No specific actions are taken after a capability is deleted.", "title": "./spec/abstract/AARCH64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = unit\n\ndefinition arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\" where\n  \"arch_gen_obj_refs ac \\<equiv> {}\"\n\ndefinition arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\" where\n  \"arch_cap_cleanup_opt ac \\<equiv> NullCap\"\n\nend\nend", "property": "Architectural Generic Object References: Provide empty set of architectural generic object references for each architectural capability, and map each architectural capability to a null capability for cleanup.", "title": "./spec/abstract/AARCH64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition arm_global_pt_ptr :: obj_ref where\n  \"arm_global_pt_ptr = pptr_base + 0x2000\"", "property": "Global Page Table Pointer Alignment: The global page table pointer is sufficiently aligned for a single page.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " Some address sufficiently aligned for one page "}
{"spec": "definition init_irq_node_ptr :: obj_ref where\n  \"init_irq_node_ptr = pptr_base + 0xc000\"", "property": "IRQ Node Initialization: The IRQ node pointer is initialized at a sufficiently aligned address, ensuring proper alignment for IRQ type and CTE level bits.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " Sufficiently aligned for irq type + cte_level_bits "}
{"spec": "definition canonical_user :: \"vspace_ref\" where\n  \"canonical_user \\<equiv> mask ipa_size\"", "property": "Canonical User Address: The highest user-virtual address that is still canonical, defining the upper limit of the canonical address space for users.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " The highest user-virtual address that is still canonical.\n   It can be larger than user_vtop, which is the highest address we allow to be mapped.\n   For AArch64-hyp, user-virtual addresses are IPAs and since there is no sign extension,\n   the value is the top of the entire IPA address space. "}
{"spec": "definition init_vspace_uses :: \"vspace_ref \\<Rightarrow> arm_vspace_region_use\" where\n  \"init_vspace_uses p \\<equiv>\n     if p \\<in> {pptr_base ..< pptr_base + (1 << 30)} then ArmVSpaceKernelWindow\n     else ArmVSpaceInvalidRegion\"\n\n\ndefinition init_arch_state :: arch_state where\n  \"init_arch_state \\<equiv> \\<lparr>\n     arm_asid_table = Map.empty,\n     arm_kernel_vspace = init_vspace_uses,\n     arm_vmid_table = Map.empty,\n     arm_next_vmid = 0,\n     arm_us_global_vspace = arm_global_pt_ptr,\n     arm_current_vcpu = None,\n     arm_gicvcpu_numlistregs = undefined\n   \\<rparr>\"", "property": "Initial Architecture State: The initial architecture state is defined with an empty ASID table, a kernel vspace mapping function, an empty VMID table, a next VMID of 0, a global vspace pointer, no current VCPU, and undefined GIC VCPU number list registers. \n\nKernel Vspace Mapping: Maps kernel-level page tables in hyp mode, distinguishing between the kernel window and invalid regions.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " This is not the layout the real kernel uses, but we are only trying to show that\n   the invariants are consistent. These apply to the mappings of the (separate) kernel-level\n   page table in hyp mode, not the user-level page tables, which have no kernel mappings. "}
{"spec": "definition global_pt_obj :: arch_kernel_obj where\n  \"global_pt_obj \\<equiv> PageTable (VSRootPT (\\<lambda>_. InvalidPTE))\"\n\ndefinition init_kheap :: kheap where\n  \"init_kheap \\<equiv>\n    (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n           then Some (CNode 0 (empty_cnode 0))\n           else None)\n    (idle_thread_ptr \\<mapsto>\n       TCB \\<lparr>\n         tcb_ctable = NullCap,\n         tcb_vtable = NullCap,\n         tcb_reply = NullCap,\n         tcb_caller = NullCap,\n         tcb_ipcframe = NullCap,\n         tcb_state = IdleThreadState,\n         tcb_fault_handler = replicate word_bits False,\n         tcb_ipc_buffer = 0,\n         tcb_fault = None,\n         tcb_bound_notification = None,\n         tcb_mcpriority = minBound,\n         tcb_arch = init_arch_tcb\n         \\<rparr>,\n     arm_global_pt_ptr \\<mapsto> ArchObj global_pt_obj\n    )\"\n\ndefinition init_cdt :: cdt where\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition init_ioc :: \"cslot_ptr \\<Rightarrow> bool\" where\n  \"init_ioc \\<equiv>\n     \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                    (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition init_A_st :: \"'z::state_ext state\"\n  where\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n \nend\nend", "property": "Initial State: The system starts with an empty global page table in hyp mode, and kernel-level mappings are separate and not modeled. The initial kernel heap contains mappings for IRQ nodes, the idle thread, and the global page table. The idle thread has a well-defined but minimal state, and the capability derivation tree is empty. The I/O controller is defined based on the initial kernel heap and capabilities. The system starts in a well-defined initial state with default values for various components. \n\nSubproperties:\n- Empty Global Page Table: The global page table in hyp mode is entirely empty.\n- Kernel Heap Structure: The initial kernel heap contains specific mappings for IRQ nodes, the idle thread, and the global page table.\n- Idle Thread State: The idle thread has a well-defined but minimal state with default values for its components.\n- Capability Derivation Tree: The capability derivation tree is initially empty.\n- I/O Controller: The I/O controller is defined based on the initial kernel heap and capabilities.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " The user-level global table in hyp mode is entirely empty.\n   Kernel-level mappings are in a separate kernel page table, which is not modeled here. "}
{"spec": "definition lookup_ipc_buffer :: \"bool \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\" where\n  \"lookup_ipc_buffer is_receiver thread \\<equiv> do\n     buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n     buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n     buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n     case buffer_cap of\n       ArchObjectCap (FrameCap p R vms False _) \\<Rightarrow>\n         if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n         then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n         else return None\n     | _ \\<Rightarrow> return None\n   od\"\n\ndefinition pool_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> obj_ref option\" where\n  \"pool_for_asid asid \\<equiv> \\<lambda>s. asid_table s (asid_high_bits_of asid)\"\n\ndefinition entry_for_pool :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (obj_ref \\<rightharpoonup> asid_pool) \\<Rightarrow> asid_pool_entry option\"\n  where\n  \"entry_for_pool pool_ptr asid \\<equiv> do {\n     pool \\<leftarrow> oapply pool_ptr;\n     K $ pool (asid_low_bits_of asid)\n   }\"\n\ndefinition vspace_for_pool :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (obj_ref \\<rightharpoonup> asid_pool) \\<Rightarrow> obj_ref option\" where\n  \"vspace_for_pool pool_ptr asid \\<equiv> do {\n     entry \\<leftarrow> entry_for_pool pool_ptr asid;\n     oreturn $ ap_vspace entry\n   }\"", "property": "Lookup IPC Buffer: Retrieve a thread's IPC buffer and verify the thread's authority to read or write to it, ensuring that the buffer's frame has the required read or write permissions.\n\nVSpace for Pool: Map an ASID to its corresponding vspace, involving a lookup in the ASID table and then in the ASID pool.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up a thread's IPC buffer and check that the thread has the authority to read or (in the\n  receiver case) write to it."}
{"spec": "definition entry_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> asid_pool_entry option\" where\n  \"entry_for_asid asid = do {\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     entry_for_pool pool_ptr asid \\<circ> asid_pools_of\n   }\"", "property": "ASID Mapping: Maps an ASID to its corresponding ASID pool entry, if it exists. \n\nSubproperty: \n- Retrieves the pool pointer for the given ASID.\n- Looks up the ASID pool entry for the given ASID in the retrieved pool.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": " this is what asid_map encodes in ARM/ARM_HYP; getASIDPoolEntry in Haskell "}
{"spec": "definition update_asid_pool_entry ::\n  \"(asid_pool_entry \\<rightharpoonup> asid_pool_entry) \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\" where\n  \"update_asid_pool_entry f asid \\<equiv> do\n     pool_ptr \\<leftarrow> gets_the $ pool_for_asid asid;\n     pool \\<leftarrow> get_asid_pool pool_ptr;\n     idx \\<leftarrow> return $ asid_low_bits_of asid;\n     entry \\<leftarrow> assert_opt $ pool idx;\n     set_asid_pool pool_ptr (pool (idx := f entry))\n   od\"\n\ndefinition vspace_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> obj_ref option\" where\n  \"vspace_for_asid asid = do {\n     oassert (0 < asid);\n     entry \\<leftarrow> entry_for_asid asid;\n     oreturn $ ap_vspace entry\n   }\"", "property": "ASID Map Updates: Update an entry in the ASID map by applying a given function to the existing entry. Ensure that the ASID is valid and retrieve the corresponding pool pointer, index, and entry, then update the entry in the pool.\n\nSubproperties:\n- ASID Validation: Verify that the provided ASID is valid (non-zero).\n- Pool and Entry Retrieval: Retrieve the pool pointer and index for the given ASID, and fetch the existing entry from the pool.\n- Entry Update: Apply the given function to the existing entry and update the pool with the new entry.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": " update an entry in the asid map "}
{"spec": "definition find_vspace_for_asid :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n  \"find_vspace_for_asid asid \\<equiv> doE\n     vspace_opt \\<leftarrow> liftE $ gets $ vspace_for_asid asid;\n     throw_opt InvalidRoot vspace_opt\n   odE\"\n\ndefinition load_vmid :: \"asid \\<Rightarrow> (vmid option, 'z::state_ext) s_monad\" where\n  \"load_vmid asid \\<equiv> do\n     entry \\<leftarrow> gets_the $ entry_for_asid asid;\n     return $ ap_vmid entry\n   od\"", "property": "Virtual ASID to Top-Level Page Table Mapping: Locate the top-level page table associated with a given virtual ASID, ensuring that the ASID is valid and the corresponding page table exists.\n\nSubproperties:\n- ASID Validation: Validate the given ASID by checking its existence and retrieving the associated top-level page table.\n- Page Table Retrieval: Retrieve the top-level page table for the given ASID, throwing an exception if it is invalid or non-existent.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the top-level page table associated with a given virtual ASID."}
{"spec": "definition store_vmid :: \"asid \\<Rightarrow> vmid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_vmid asid hw_asid \\<equiv> do\n     update_asid_pool_entry (\\<lambda>entry. Some $ ASIDPoolVSpace (Some hw_asid) (ap_vspace entry)) asid;\n     vmid_table \\<leftarrow> gets (arm_vmid_table \\<circ> arch_state);\n     vmid_table' \\<leftarrow> return $ vmid_table (hw_asid \\<mapsto> asid);\n     modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_vmid_table := vmid_table' \\<rparr>\\<rparr>)\n   od\"", "property": "Associate VMID with ASID: Maps a VMID to an ASID, updating the ASID pool entry and the VMID table to reflect the association.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associate a VMID with an ASID."}
{"spec": "definition invalidate_tlb_by_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_tlb_by_asid asid \\<equiv> do\n     maybe_vmid \\<leftarrow> load_vmid asid;\n     case maybe_vmid of\n       None \\<Rightarrow> return ()\n     | Some vmid \\<Rightarrow> do_machine_op $ invalidateTranslationASID (ucast vmid)\n   od\"", "property": "TLB Invalidation: Clear all TLB mappings associated with a given ASID, ensuring that any stale translations are removed and the translation table is updated accordingly. \n\nSubproperty: \n- If the ASID is not associated with a valid VMID, the operation has no effect.\n- If the ASID is associated with a valid VMID, the corresponding translation ASID is invalidated through a machine operation.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Clear all TLB mappings associated with this ASID."}
{"spec": "definition invalidate_tlb_by_asid_va :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_tlb_by_asid_va asid vaddr \\<equiv> do\n     maybe_vmid \\<leftarrow> load_vmid asid;\n     case maybe_vmid of\n       None \\<Rightarrow> return ()\n     | Some vmid \\<Rightarrow>\n         do_machine_op $\n           invalidateTranslationSingle $ (ucast vmid << word_bits-asid_bits) || (vaddr >> pageBits)\n   od\"", "property": "TLB Invalidation: Clear all TLB mappings associated with a specific ASID and virtual address, ensuring that the translation lookaside buffer is updated to reflect changes in virtual memory mappings. \n\nSubproperties:\n- Load the VMID associated with the given ASID.\n- If a VMID is found, perform a machine operation to invalidate the TLB entry corresponding to the VMID and virtual address.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Clear all TLB mappings associated with this ASID and virtual address."}
{"spec": "definition invalidate_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_asid asid \\<equiv>\n     update_asid_pool_entry (\\<lambda>entry. Some $ ASIDPoolVSpace None (ap_vspace entry)) asid\"", "property": "ASID Invalidity: Remove the mapping of a virtual ASID to a VMID, ensuring the ASID is no longer associated with a valid virtual machine identifier.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this virtual ASID to a VMID."}
{"spec": "definition invalidate_vmid_entry :: \"vmid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_vmid_entry vmid \\<equiv> do\n     vmid_table \\<leftarrow> gets (arm_vmid_table \\<circ> arch_state);\n     vmid_table' \\<leftarrow> return (vmid_table (vmid := None));\n     modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_vmid_table := vmid_table' \\<rparr>\\<rparr>)\n  od\"", "property": "VMID Entry Invalidation: Remove the mapping from a given VMID to an ASID in the VMID table.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this VMID to an ASID."}
{"spec": "definition invalidate_asid_entry :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_asid_entry asid \\<equiv> do\n     maybe_vmid \\<leftarrow> load_vmid asid;\n     when (maybe_vmid \\<noteq> None) $ invalidate_vmid_entry (the maybe_vmid);\n     invalidate_asid asid\n  od\"", "property": "ASID Entry Invalidation: Remove mappings associated with a given ASID in both directions, ensuring that the ASID is no longer valid for use. \n\nSubproperties:\n- VMID Entry Invalidation: If the ASID is associated with a VMID, invalidate the VMID entry.\n- ASID Invalidation: Invalidate the ASID itself, removing any remaining mappings.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove mappings in either direction involving this ASID."}
{"spec": "definition find_free_vmid :: \"(vmid,'z::state_ext) s_monad\" where\n  \"find_free_vmid \\<equiv> do\n     vmid_table \\<leftarrow> gets (arm_vmid_table \\<circ> arch_state);\n     next_vmid \\<leftarrow> gets (arm_next_vmid \\<circ> arch_state);\n     maybe_vmid \\<leftarrow> return $ find (\\<lambda>a. vmid_table a = None)\n                                 (take (length [minBound :: vmid .e. maxBound])\n                                       ([next_vmid .e. maxBound] @ [minBound .e. next_vmid]));\n     case maybe_vmid of\n       Some vmid \\<Rightarrow> return vmid\n     | None \\<Rightarrow> do\n         invalidate_asid $ the $ vmid_table next_vmid;\n         do_machine_op $ invalidateTranslationASID (ucast next_vmid);\n         invalidate_vmid_entry next_vmid;\n         modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_next_vmid := next_vmid + 1 \\<rparr>\\<rparr>);\n         return next_vmid\n       od\n   od\"", "property": "Find Free VMID: Locate an unused VMID, reclaiming one from an ASID if necessary, to ensure efficient allocation and reuse of VMIDs. \n\nSubproperties:\n- Search for an unused VMID within the range of possible VMIDs.\n- If no free VMID is found, reclaim the next VMID by invalidating its associated ASID, translation, and VMID entry.\n- Update the next VMID value to ensure proper allocation and reuse.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate a VMID that is not in use, if necessary by reclaiming one already assigned to an ASID."}
{"spec": "definition get_vmid :: \"asid \\<Rightarrow> (vmid, 'z::state_ext) s_monad\" where\n  \"get_vmid asid \\<equiv> do\n     maybe_vmid \\<leftarrow> load_vmid asid;\n     case maybe_vmid of\n       Some vmid \\<Rightarrow> return vmid\n     | None \\<Rightarrow>  do\n         new_hw_asid \\<leftarrow> find_free_vmid;\n         store_vmid asid new_hw_asid;\n         return new_hw_asid\n       od\n   od\"", "property": "VMID Retrieval and Assignment: Get the VMID associated with an ASID, assigning a new one if none is already assigned. \n\nSubproperties:\n- Load the VMID associated with the given ASID if it exists.\n- If no VMID is assigned, find a free VMID, store it for the ASID, and return it.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get the VMID associated with an ASID, assigning one if none is already assigned."}
{"spec": "definition handle_vm_fault :: \"obj_ref \\<Rightarrow> vmfault_type \\<Rightarrow> (unit, 'z::state_ext) f_monad\" where\n  \"handle_vm_fault thread fault \\<equiv> case fault of\n     ARMDataAbort \\<Rightarrow> doE\n       addr \\<leftarrow> liftE $ do_machine_op getFAR;\n       fault \\<leftarrow> liftE $ do_machine_op getESR;\n       cur_v \\<leftarrow> liftE $ gets (arm_current_vcpu \\<circ> arch_state);\n       addr \\<leftarrow> if (\\<exists>v. cur_v = Some (v, True)) \\<comment> \\<open>VCPU active\\<close>\n              then doE\n                  \\<comment> \\<open>address bits of PAR register after S1 translation\\<close>\n                  par_el1_mask \\<leftarrow> returnOk $ 0xfffffffff000;\n                  addr' \\<leftarrow> liftE $ do_machine_op $ addressTranslateS1 addr;\n                  returnOk $ (addr' && par_el1_mask) || (addr && mask pageBits)\n                odE\n              else returnOk addr;\n       \\<comment> \\<open>32 is the width of the FSR field in the C VMFault structure\\<close>\n       throwError $ ArchFault $ VMFault addr [0, fault && mask 32]\n     odE\n   | ARMPrefetchAbort \\<Rightarrow> doE\n       pc \\<leftarrow> liftE $ as_user thread $ getRestartPC;\n       fault \\<leftarrow> liftE $ do_machine_op getESR;\n       cur_v \\<leftarrow> liftE $ gets (arm_current_vcpu \\<circ> arch_state);\n       pc \\<leftarrow> if (\\<exists>v. cur_v = Some (v, True)) \\<comment> \\<open>VCPU active\\<close>\n            then doE\n                \\<comment> \\<open>address bits of PAR register after S1 translation\\<close>\n                par_el1_mask \\<leftarrow> returnOk $ 0xfffffffff000;\n                pc' \\<leftarrow> liftE $ do_machine_op $ addressTranslateS1 pc;\n                returnOk $ (pc' && par_el1_mask) || (pc && mask pageBits)\n              odE\n            else returnOk pc;\n       \\<comment> \\<open>32 is the width of the FSR field in the C VMFault structure\\<close>\n       throwError $ ArchFault $ VMFault pc [1, fault && mask 32]\n     odE\"", "property": "VM Fault Handling: Formats a VM fault message to be passed to a thread's supervisor after encountering a page fault, providing the fault address and relevant error information. \n\nSubproperties:\n- Data Abort Handling: Handles ARM data abort faults by retrieving the fault address and error status register (ESR) value, applying necessary address translations for VCPU, and throwing a VMFault exception.\n- Prefetch Abort Handling: Handles ARM prefetch abort faults by retrieving the faulting instruction address (PC) and ESR value, applying necessary address translations for VCPU, and throwing a VMFault exception.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Format a VM fault message to be passed to a thread's supervisor after it encounters a page fault."}
{"spec": "definition arm_context_switch :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arm_context_switch vspace asid = do\n     vmid <- get_vmid asid;\n     do_machine_op $ setVSpaceRoot (addrFromPPtr vspace) (ucast vmid)\n   od\"", "property": "Context Switch to Address Space: Switch to the given address space by retrieving the VMID associated with the provided ASID and setting the VSpace root to the specified address space using the retrieved VMID.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch to given address space, using VMID associated with provided ASID."}
{"spec": "definition set_global_user_vspace :: \"(unit,'z::state_ext) s_monad\" where\n  \"set_global_user_vspace = do\n     global <- gets (arm_us_global_vspace \\<circ> arch_state);\n     do_machine_op $ setVSpaceRoot (addrFromKPPtr global) 0\n   od\"", "property": "Set Global User Virtual Space: Switch to the global user address space by setting the virtual space root to the global user virtual space address with VMID 0.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch to global user address space, using VMID 0."}
{"spec": "definition set_vm_root :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_vm_root tcb \\<equiv> do\n     thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n     thread_root \\<leftarrow> get_cap thread_root_slot;\n     (case thread_root of\n        ArchObjectCap (PageTableCap pt VSRootPT_T (Some (asid, _))) \\<Rightarrow> doE\n          pt' \\<leftarrow> find_vspace_for_asid asid;\n          whenE (pt \\<noteq> pt') $ throwError InvalidRoot;\n          liftE $ arm_context_switch pt asid\n        odE\n      | _ \\<Rightarrow> throwError InvalidRoot) <catch> (\\<lambda>_. set_global_user_vspace)\n  od\"\n\n\ndefinition delete_asid_pool :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"delete_asid_pool base ptr \\<equiv> do\n     assert (asid_low_bits_of base = 0);\n     asid_table \\<leftarrow> gets asid_table;\n     when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n       pool \\<leftarrow> get_asid_pool ptr;\n       mapM (\\<lambda>offset. when (pool (ucast offset) \\<noteq> None) $ do\n                            invalidate_tlb_by_asid $ base + offset;\n                            invalidate_asid_entry $ base + offset\n                      od) [0  .e.  mask asid_low_bits];\n       asid_table' \\<leftarrow> return $ asid_table (asid_high_bits_of base:= None);\n       modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_table := asid_table' \\<rparr>\\<rparr>);\n       tcb \\<leftarrow> gets cur_thread;\n       set_vm_root tcb\n     od\n   od\"\n\n\ndefinition delete_asid :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"delete_asid asid pt \\<equiv> do\n     pool_ptr_op \\<leftarrow> gets (pool_for_asid asid);\n     case pool_ptr_op of\n       None \\<Rightarrow> return ()\n     | Some pool_ptr \\<Rightarrow> do\n         pool \\<leftarrow> get_asid_pool pool_ptr;\n         when (\\<exists>vmid. pool (asid_low_bits_of asid) = Some (ASIDPoolVSpace vmid pt)) $ do\n           invalidate_tlb_by_asid asid;\n           invalidate_asid_entry asid;\n           \\<comment> \\<open>re-read here, because @{text invalidate_asid_entry} changes the ASID pool:\\<close>\n           pool \\<leftarrow> get_asid_pool pool_ptr;\n           pool' \\<leftarrow> return $ pool (asid_low_bits_of asid := None);\n           set_asid_pool pool_ptr pool';\n           tcb \\<leftarrow> gets cur_thread;\n           set_vm_root tcb\n         od\n       od\n   od\"\n\n\ndefinition unmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"unmap_page_table asid vaddr pt \\<equiv> doE\n     top_level_pt \\<leftarrow> find_vspace_for_asid asid;\n     (pt_slot, level) \\<leftarrow> pt_lookup_from_level max_pt_level top_level_pt vaddr pt;\n     liftE $ store_pte (level_type level) pt_slot InvalidPTE;\n     liftE $ do_machine_op $ cleanByVA_PoU pt_slot (addrFromPPtr pt_slot);\n     liftE $ invalidate_tlb_by_asid asid\n   odE <catch> (K $ return ())\"", "property": "Address Space Management: Switch into the address space of a given thread or the global address space if none is correctly configured, ensuring that the thread's root page table is valid and properly configured.\n\nSubproperties:\n- Set VM Root: Set the virtual machine root for a given thread, ensuring that the thread's root page table is valid and properly configured.\n- Delete ASID Pool: Delete an ASID pool, invalidating all associated TLB entries and updating the ASID table.\n- Delete ASID: Delete an ASID, invalidating its TLB entry and updating the ASID pool.\n- Unmap Page Table: Unmap a page table from an ASID, invalidating its TLB entry and cleaning the page table's memory.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Switch into the address space of a given thread or the global address space if none is correctly\n  configured."}
{"spec": "definition vs_lookup_table ::\n  \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\" where\n  \"vs_lookup_table bot_level asid vptr \\<equiv> do {\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     if bot_level = asid_pool_level\n     then oreturn (asid_pool_level, pool_ptr)\n     else do {\n       top_level_pt \\<leftarrow> vspace_for_pool pool_ptr asid \\<circ> asid_pools_of;\n       pt_walk max_pt_level bot_level top_level_pt vptr \\<circ> ptes_of\n     }\n   }\"", "property": "Virtual Space Lookup: Look up an address space identifier (ASID) and virtual space reference down to a specified level in the page table, returning a pointer to a table at that level if found. The lookup may terminate early if it encounters a page or invalid entry, resulting in a level higher than the specified one.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up an @{text \"asid+vspace_ref\"} down to the provided level in the page table.\n  For level @{term bot_level}, return a pointer to a table at the returned level.\n  The level can be higher than @{term bot_level} if the lookup terminates early because\n  it hit a page or an invalid entry."}
{"spec": "definition vs_lookup_slot ::\n  \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\" where\n  \"vs_lookup_slot bot_level asid vref \\<equiv> do {\n     (level', table) \\<leftarrow> vs_lookup_table bot_level asid vref;\n     if level' = asid_pool_level then\n       oreturn (level', table)\n     else\n       oreturn (level', pt_slot_offset level' table vref)\n   }\"", "property": "Virtual Space Lookup Slot: Given a virtual machine level, an address space identifier (ASID), and a virtual space reference, return a pointer to a slot in a table at the returned level, or if at the ASID pool level, return the pointer to the ASID pool itself.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Same as @{const vs_lookup_table}, but return a pointer to a slot in a table at the returned level.\n  For @{prop \"bot_level = asid_pool_level\"}, still return the pointer to the ASID pool (not a slot\n  inside it, since there are no slot functions for ASID pools)."}
{"spec": "definition unmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"unmap_page pgsz asid vptr pptr \\<equiv> doE\n     top_level_pt \\<leftarrow> find_vspace_for_asid asid;\n     (lev, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot top_level_pt vptr \\<circ> ptes_of;\n     unlessE (pt_bits_left lev = pageBitsForSize pgsz) $ throwError InvalidRoot;\n     pte \\<leftarrow> liftE $ get_pte lev slot;\n     unlessE (is_PagePTE pte \\<and> pptr_from_pte pte = pptr) $ throwError InvalidRoot;\n     liftE $ store_pte lev slot InvalidPTE;\n     liftE $ do_machine_op $ cleanByVA_PoU slot (addrFromPPtr slot);\n     liftE $ invalidate_tlb_by_asid_va asid vptr\n   odE <catch> (K $ return ())\"", "property": "Unmap Page: Unmap a mapped page if the given mapping details are still current, ensuring that the page table entry is updated, the TLB is invalidated, and the cache is cleaned. \n\nSubproperties:\n- Verify Mapping Details: Check that the given mapping details (page size, ASID, virtual pointer, and physical pointer) are still current before attempting to unmap the page.\n- Update Page Table Entry: Update the page table entry to reflect the unmapping of the page, marking it as invalid.\n- Clean Cache and Invalidate TLB: Clean the cache and invalidate the TLB for the affected virtual address to ensure consistency.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\" where\n  \"arch_derive_cap c \\<equiv>\n     case c of\n       PageTableCap _ _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n     | PageTableCap _ _ None \\<Rightarrow> throwError IllegalOperation\n     | FrameCap r R sz dev mp \\<Rightarrow> returnOk $ ArchObjectCap (FrameCap r R sz dev None)\n     | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n     | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\n     | VCPUCap _ \\<Rightarrow> returnOk (ArchObjectCap c)\"", "property": "Derive Architecture-Specific Capability: Allow deriving a new capability from an existing architecture-specific capability, with the restriction that page table structure capabilities must have an assigned ASID and location to be copied.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Page table structure capabilities cannot be copied until they have an ASID and location\n  assigned. This is because they cannot have multiple current ASIDs and cannot be shared between\n  address spaces or virtual locations."}
{"spec": "definition arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\" where\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "AARCH64 Capability Update: Updating AARCH64-specific capabilities does not modify user-modifiable data, preserving the integrity of capability-based access control.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in AARCH64-specific capabilities."}
{"spec": "definition arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\" where\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n     (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n       delete_asid_pool b ptr;\n       return (NullCap, NullCap)\n     od\n   | (PageTableCap ptr VSRootPT_T (Some (a, v)), True) \\<Rightarrow> do\n       delete_asid a ptr;\n       return (NullCap, NullCap)\n     od\n   | (PageTableCap ptr NormalPT_T (Some (a, v)), True) \\<Rightarrow> do\n       unmap_page_table a v ptr;\n       return (NullCap, NullCap)\n     od\n   | (FrameCap ptr _ sz _ (Some (a, v)), _) \\<Rightarrow> do\n       unmap_page sz a v ptr;\n       return (NullCap, NullCap)\n     od\n   | (VCPUCap vcpu_ref, True) \\<Rightarrow> do\n      vcpu_finalise vcpu_ref;\n      return (NullCap, NullCap)\n     od\n   | _ \\<Rightarrow> return (NullCap, NullCap)\"", "property": "Architectural Capability Finalisation: Ensure that AARCH64-specific capabilities are properly cleaned up upon finalisation, including deleting ASID pools, unmapping page tables and frames, and finalising VCPUs, to maintain the integrity of the system's architectural state.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of AARCH64-specific capabilities."}
{"spec": "definition is_valid_vtable_root :: \"cap \\<Rightarrow> bool\" where\n  \"is_valid_vtable_root c \\<equiv>\n     case c of ArchObjectCap (PageTableCap _ VSRootPT_T (Some _)) \\<Rightarrow> True | _ \\<Rightarrow> False\"", "property": "Valid Virtual Address Space Capability: A thread's virtual address space capability is valid if it refers to a mapped page table with a VSRootPT_T attribute.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A thread's virtual address space capability must be to a mapped page table to be valid on\n  the AARCH64 architecture."}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\ndefinition check_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"check_valid_ipc_buffer vptr c \\<equiv>\n     case c of\n       ArchObjectCap (FrameCap _ _ _ False _) \\<Rightarrow>\n         whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError\n     | _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Valid IPC Buffer Alignment: Ensure that the IPC buffer's virtual pointer is aligned with the message alignment bits for frame capabilities, and reject other capability types as illegal operations.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "definition in_user_frame :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n  \"in_user_frame p s \\<equiv>\n     \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) = Some (ArchObj (DataPage False sz))\"\n\ndefinition fpu_thread_delete :: \"obj_ref \\<Rightarrow> (unit, 'z::state_ext) s_monad\" where\n  \"fpu_thread_delete thread_ptr \\<equiv> do_machine_op (fpuThreadDeleteOp thread_ptr)\"\n\ndefinition prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"prepare_thread_delete thread_ptr \\<equiv> do\n     fpu_thread_delete thread_ptr;\n     t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu thread_ptr;\n     case t_vcpu of\n       Some v \\<Rightarrow> dissociate_vcpu_tcb v thread_ptr\n     | None \\<Rightarrow> return ()\n   od\"\n\nend\nend", "property": "Thread Deletion Preparation: Ensure that a thread is properly prepared for deletion by removing its FPU state and dissociating it from any associated VCPU. \n\nThread Pointer Validation: Check if a given pointer is within a user frame by verifying that its top bits point to a DataPage object in the kernel heap.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A pointer is inside a user frame if its top bits point to a @{const DataPage}."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition asid_high_bits_of :: \"asid \\<Rightarrow> asid_high_index\" where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"", "property": "Virtual ASID High Bits Extraction: Extract the high bits of a virtual ASID by shifting the ASID to the right by the number of low bits and then casting the result to an ASID high index.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "definition asid_low_bits_of :: \"asid \\<Rightarrow> asid_low_index\" where\n  \"asid_low_bits_of asid \\<equiv> ucast asid\"\n\nlemmas asid_bits_of_defs = asid_high_bits_of_def asid_low_bits_of_def\n\nlocale_abbrev asid_table :: \"'z::state_ext state \\<Rightarrow> asid_high_index \\<rightharpoonup> obj_ref\" where\n  \"asid_table \\<equiv> \\<lambda>s. arm_asid_table (arch_state s)\"", "property": "Virtual ASID Decomposition: Decompose a virtual ASID into its low bits.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The low bits of a virtual ASID."}
{"spec": "(* declared in Arch as workaround for VER-1099 *)\nlocale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\" where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"", "property": "Kernel Heap Accessors: Provide access to the kernel heap, mapping object references to architecture-specific kernel objects.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev asid_pools_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> asid_pool\" where\n  \"asid_pools_of \\<equiv> \\<lambda>s. aobjs_of s |> asid_pool_of\"\n\nlocale_abbrev get_asid_pool :: \"obj_ref \\<Rightarrow> (asid_pool, 'z::state_ext) s_monad\" where\n  \"get_asid_pool \\<equiv> gets_map asid_pools_of\"\n\ndefinition set_asid_pool :: \"obj_ref \\<Rightarrow> asid_pool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_asid_pool ptr pool \\<equiv> do\n     get_asid_pool ptr;\n     set_object ptr (ArchObj (ASIDPool pool))\n   od\"\n\nlocale_abbrev pts_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> pt\" where\n  \"pts_of \\<equiv> \\<lambda>s. aobjs_of s |> pt_of\"\n\nlocale_abbrev get_pt :: \"obj_ref \\<Rightarrow> (pt,'z::state_ext) s_monad\" where\n  \"get_pt \\<equiv> gets_map pts_of\"\n\ndefinition set_pt :: \"obj_ref \\<Rightarrow> pt \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pt ptr pt \\<equiv> do\n     get_pt ptr;\n     set_object ptr (ArchObj (PageTable pt))\n   od\"", "property": "Kernel Heap Accessors: Provide functions to manipulate ASID pools, page directories, and page tables in the kernel heap, allowing for the retrieval and modification of these architectural objects.\n\nASID Pool Management: Get and set ASID pools, ensuring that the specified object reference is associated with a valid ASID pool.\n\nPage Table Management: Get and set page tables, ensuring that the specified object reference is associated with a valid page table.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "Manipulate ASID pools, page directories and page tables in the kernel heap."}
{"spec": "locale_abbrev table_base :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref\" where\n  \"table_base pt_t p \\<equiv> p && ~~mask (pt_bits pt_t)\"", "property": "Table Base Address Calculation: Calculate the base address of the table a page table entry at a given address is in, assuming alignment, by performing a bitwise AND operation with the negated mask of the page table type's bit size.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The base address of the table a page table entry at p is in (assuming alignment)"}
{"spec": "locale_abbrev table_index :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> machine_word\" where\n  \"table_index pt_t p \\<equiv> p && mask (pt_bits pt_t) >> pte_bits\"", "property": "Page Table Index Calculation: Extracts the index within a page table that a page table entry at a given address references, by applying a mask and shift operation to the address based on the page table type.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The index within the page table that a page table entry at p addresses. We return a\n  @{typ machine_word}, which is the slice of the provided address that represents the index in the\n  table of the specified table type."}
{"spec": "definition pt_apply :: \"pt \\<Rightarrow> machine_word \\<Rightarrow> pte\" where\n  \"pt_apply pt idx \\<equiv> case pt of NormalPT npt \\<Rightarrow> npt (ucast idx) | VSRootPT vs \\<Rightarrow> vs (ucast idx)\"", "property": "Page Table Application: Apply an index to a page table to retrieve a page table entry, ignoring bits higher than the table index width.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "Use an index computed by @{const table_index} and apply it to a page table. Bits higher than\n  the table index width will be ignored."}
{"spec": "definition level_pte_of :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pt) \\<rightharpoonup> pte\" where\n  \"level_pte_of pt_t p \\<equiv> do {\n      oassert (is_aligned p pte_bits);\n      pt \\<leftarrow> oapply (table_base pt_t p);\n      oassert (pt_type pt = pt_t);\n      oreturn $ pt_apply pt (table_index pt_t p)\n   }\"\n\ntype_synonym ptes_of = \"pt_type \\<Rightarrow> obj_ref \\<rightharpoonup> pte\"\n\nlocale_abbrev ptes_of :: \"'z::state_ext state \\<Rightarrow> ptes_of\" where\n  \"ptes_of s pt_t p \\<equiv> level_pte_of pt_t p (pts_of s)\"\n\nlemmas ptes_of_def = level_pte_of_def", "property": "Extract PTE from Page Table: Extract a page table entry (PTE) from the page table of a specific level, given a page table type and an object reference. Ensure the object reference is aligned to the PTE bits and the page table type matches the expected type. \n\nPage Table Entries Retrieval: Retrieve a PTE from the page table of a specific level in the current state, given a page table type and an object reference.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "Extract a PTE from the page table of a specific level"}
{"spec": "locale_abbrev get_pte :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\" where\n  \"get_pte pt_t \\<equiv> gets_map (swp ptes_of pt_t)\"", "property": "Kernel Memory Access: Retrieve the Page Table Entry (PTE) from kernel memory given a pointer to the PTE.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory and returns the PTE."}
{"spec": "definition pt_upd :: \"pt \\<Rightarrow> machine_word \\<Rightarrow> pte \\<Rightarrow> pt\" where\n  \"pt_upd pt idx pte \\<equiv> case pt of\n                         VSRootPT vs \\<Rightarrow> VSRootPT (vs(ucast idx := pte))\n                       | NormalPT pt \\<Rightarrow> NormalPT (pt(ucast idx := pte))\"\n\ndefinition store_pte :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pte pt_t p pte \\<equiv> do\n     assert (is_aligned p pte_bits);\n     base \\<leftarrow> return $ table_base pt_t p;\n     pt \\<leftarrow> get_pt base;\n     assert (pt_type pt = pt_t);\n     set_pt base (pt_upd pt (table_index pt_t p) pte)\n   od\"", "property": "Update Page Table Entry: Update a page table entry at a specific index in the page table, ensuring the correct page table type is used and the update is applied to the corresponding table.\n\nSubproperties:\n- Validate Page Table Alignment: Verify that the page table address is properly aligned to the page table entry size.\n- Retrieve Page Table Base: Get the base address of the page table based on its type and the given address.\n- Validate Page Table Type: Ensure that the type of the retrieved page table matches the expected type.\n- Update Page Table: Apply the update to the page table by modifying the entry at the computed index.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The update function that corresponds to @{const pt_apply}. Also expects an index computed\n  with @{const table_index} for the correct page table type."}
{"spec": "(* During pt_walk, we will only call this with level \\<le> max_pt_level, but in the invariants we\n   also make use of this function for level = asid_pool_level. *)\ndefinition pt_bits_left :: \"vm_level \\<Rightarrow> nat\" where\n  \"pt_bits_left level =\n    (if level = asid_pool_level\n     then ptTranslationBits VSRootPT_T + ptTranslationBits NormalPT_T * size max_pt_level\n     else ptTranslationBits NormalPT_T * size level)\n    + pageBits\"\n\ndefinition pt_index :: \"vm_level \\<Rightarrow> vspace_ref \\<Rightarrow> machine_word\" where\n  \"pt_index level vptr \\<equiv>\n     (vptr >> pt_bits_left level) && mask (ptTranslationBits level)\"\n\n\nlocale_abbrev global_pt :: \"'z state \\<Rightarrow> obj_ref\" where\n  \"global_pt s \\<equiv> arm_us_global_vspace (arch_state s)\"", "property": "Page Table Indexing: Calculate the index into a page table at a given level for a specific virtual address, ensuring correct navigation of the page table hierarchy.\n\nSubproperties:\n- Calculate Page Table Bits: Determine the number of bits left to navigate the page table hierarchy at a given level.\n- Extract Page Table Index: Extract the index into the page table at the specified level from a virtual address.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition pptr_from_pte :: \"pte \\<Rightarrow> vspace_ref\" where\n  \"pptr_from_pte pte \\<equiv> ptrFromPAddr (pte_base_addr pte)\"\n\ndefinition pt_slot_offset :: \"vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\" where\n  \"pt_slot_offset level pt_ptr vptr = pt_ptr + (pt_index level vptr << pte_bits)\"", "property": "Virtual Address Space Management: Provides basic operations for accessing and managing the AARCH64 virtual address space. \n\nAddress Translation: Extract the physical address from a page table entry (PTE).\n\nPage Table Slot Calculation: Calculate the offset of a page table slot for a given virtual address and page table level.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "fun pt_walk ::\n  \"vm_level \\<Rightarrow> vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> ptes_of \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"pt_walk level bot_level pt_ptr vptr = do {\n     if bot_level < level\n     then do {\n       pte \\<leftarrow> oapply2 (level_type level) (pt_slot_offset level pt_ptr vptr);\n       if is_PageTablePTE pte\n         then pt_walk (level - 1) bot_level (pptr_from_pte pte) vptr\n         else oreturn (level, pt_ptr)\n     }\n     else oreturn (level, pt_ptr)\n   }\"\n\ndeclare pt_walk.simps[simp del]", "property": "Page Table Walk: Traverse the page table structure from a given level to a lower level, stopping at a specified bottom level or when a page is reached, and return the pointer to the page table where the walk stopped along with its level. \n\nSubproperties:\n- The walk proceeds from higher-level tables to lower-level tables.\n- The lookup stops when the bottom level or a page is reached.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": "\n  This is the base function for walking a page table structure.\n  The walk proceeds from higher-level tables at the provided @{term level} (e.g. 2) to lower\n  level tables, down to @{term bot_level} (e.g. 0). It returns a pointer to the page table where\n  the walk stopped and the level of that table. The lookup stops when @{term bot_level} or a\n  page is reached.\n"}
{"spec": "definition pt_lookup_slot_from_level ::\n  \"vm_level \\<Rightarrow> vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> ptes_of \\<Rightarrow> (vm_level \\<times> obj_ref) option\" where\n  \"pt_lookup_slot_from_level level bot_level pt_ptr vptr = do {\n     (level', pt_ptr') \\<leftarrow> pt_walk level bot_level pt_ptr vptr;\n     oreturn (level', pt_slot_offset level' pt_ptr' vptr)\n   }\"\n\ndefinition pt_lookup_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> ptes_of \\<Rightarrow> (vm_level \\<times> obj_ref) option\" where\n  \"pt_lookup_slot = pt_lookup_slot_from_level max_pt_level 0\"", "property": "Page Table Lookup: Retrieve the level and object pointer of a slot in a page table structure corresponding to a given virtual space reference, starting from a specified or maximum page table level.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": "\n  Looking up a slot in a page table structure. The function returns a level and an object\n  pointer. The pointer is to a slot in a table at the returned level. If the returned level is 0,\n  this slot is either an @{const InvalidPTE} or a @{const PagePTE}. If the returned level is higher\n  the slot may also be a @{const PageTablePTE}.\n"}
{"spec": "fun pt_lookup_from_level ::\n  \"vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (machine_word \\<times> vm_level, 'z::state_ext) lf_monad\"\n  where\n  \"pt_lookup_from_level level pt_ptr vptr target_pt_ptr s = (doE\n     unlessE (0 < level) $ throwError InvalidRoot;\n     slot <- returnOk $ pt_slot_offset level pt_ptr vptr;\n     pte <- liftE $ gets_the $ oapply slot o swp ptes_of level;\n     unlessE (is_PageTablePTE pte) $ throwError InvalidRoot;\n     ptr <- returnOk (pptr_from_pte pte);\n     if ptr = target_pt_ptr\n       then returnOk (slot, level)\n       else pt_lookup_from_level (level - 1) ptr vptr target_pt_ptr\n   odE) s\"", "property": "Page Table Lookup: Find the slot that points to a target page table pointer by recursively traversing the page table hierarchy from a given level and virtual address.\n\nSubproperties:\n- Check if the current level is valid (greater than 0).\n- Calculate the slot offset for the current level and page table pointer.\n- Retrieve the page table entry (PTE) from the calculated slot.\n- Verify that the PTE is a valid page table pointer.\n- If the retrieved pointer matches the target, return the slot and level; otherwise, continue the lookup at the next level.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": "Returns the slot that points to @{text target_pt_ptr}"}
{"spec": "declare pt_lookup_from_level.simps[simp del]", "property": "Page Table Lookup: Access the AARCH64 virtual space by performing page table lookups, ensuring correct type handling and incrementing the global free index counter as necessary.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": " We apply \"s\" to avoid a type variable warning, and increase in global freeindex counter,\n   which we would get without the application "}
{"spec": "schematic_goal pt_lookup_from_level_simps:\n  \"pt_lookup_from_level level pt_ptr vptr target_pt_ptr = ?rhs\"\n  by (rule ext, rule pt_lookup_from_level.simps)\n\nend\nend", "property": "Page Table Lookup: Perform a page table lookup from a given level, using a page table pointer and a virtual pointer to retrieve the target page table pointer.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": " Recover simp rule without state applied: "}
{"spec": "definition check_vp_alignment :: \"vmpage_size \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) se_monad\"\n  where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $ throwError AlignmentError\"\n\ndefinition page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\" where\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"", "property": "Virtual Address Alignment and Page Base Calculation: Ensure that a virtual address is properly aligned according to the given page size, and calculate the base address of a page in a virtual address space. \n\nSubproperties:\n- Virtual Address Alignment: Verify that a virtual address is aligned to the required page size to prevent alignment errors.\n- Page Base Calculation: Calculate the base address of a page by masking the lower bits of the virtual address according to the page size.", "title": "./spec/abstract/AARCH64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture-specific Decode Functions", "comment": ""}
{"spec": "definition arch_decode_irq_control_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list \\<Rightarrow> (arch_irq_control_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_irq_control_invocation label args src_slot cps \\<equiv>\n     (if invocation_type label = ArchInvocationLabel ARMIRQIssueIRQHandlerTrigger\n      then if length args \\<ge> 4 \\<and> length cps \\<ge> 1\n        then let irq_word = args ! 0;\n                 trigger = args ! 1;\n                 index = args ! 2;\n                 depth = args ! 3;\n                 cnode = cps ! 0;\n                 irq = ucast irq_word\n        in doE\n          arch_check_irq irq_word;\n          irq_active \\<leftarrow> liftE $ is_irq_active irq;\n          whenE irq_active $ throwError RevokeFirst;\n          dest_slot \\<leftarrow> lookup_target_slot cnode (data_to_cptr index) (unat depth);\n          ensure_empty dest_slot;\n          returnOk $ ARMIRQControlInvocation irq dest_slot src_slot (trigger \\<noteq> 0)\n        odE\n      else throwError TruncatedMessage\n    else throwError IllegalOperation)\"\n\ndefinition attribs_from_word :: \"machine_word \\<Rightarrow> vm_attributes\" where\n  \"attribs_from_word w \\<equiv> {attr.  \\<not>w!!0 \\<and> attr = Device \\<or> \\<not>w !! 2 \\<and> attr = Execute}\"\n\ndefinition make_user_pte :: \"paddr \\<Rightarrow> vm_attributes \\<Rightarrow> vm_rights \\<Rightarrow> vmpage_size \\<Rightarrow> pte\" where\n  \"make_user_pte addr attr rights vm_size \\<equiv>\n     PagePTE addr (vm_size = ARMSmallPage) (attr - {Global}) rights\"\n\ndefinition check_vspace_root :: \"cap \\<Rightarrow> nat \\<Rightarrow> (obj_ref \\<times> asid, 'z) se_monad\" where\n  \"check_vspace_root cap arg_no \\<equiv>\n     case cap of\n       ArchObjectCap (PageTableCap pt VSRootPT_T (Some (asid, _))) \\<Rightarrow> returnOk (pt, asid)\n     | _ \\<Rightarrow> throwError $ InvalidCapability arg_no\"\n\ntype_synonym 'z arch_decoder =\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    (arch_invocation,'z) se_monad\"\n\ndefinition decode_fr_inv_map :: \"'z::state_ext arch_decoder\" where\n  \"decode_fr_inv_map label args cte cap extra_caps \\<equiv> case cap of\n     FrameCap p R pgsz dev mapped_address \\<Rightarrow>\n       if length args > 2 \\<and> length extra_caps > 0\n       then let\n           vaddr = args ! 0;\n           rights_mask = args ! 1;\n           attr = args ! 2;\n           vspace_cap = fst (extra_caps ! 0)\n         in doE\n           (pt, asid) \\<leftarrow> check_vspace_root vspace_cap 1;\n           pt' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n           whenE (pt' \\<noteq> pt) $ throwError $ InvalidCapability 1;\n           check_vp_alignment pgsz vaddr;\n           pg_bits \\<leftarrow> returnOk $ pageBitsForSize pgsz;\n           case mapped_address of\n             Some (asid', vaddr') \\<Rightarrow> doE\n               whenE (asid' \\<noteq> asid) $ throwError $ InvalidCapability 1;\n               whenE (vaddr' \\<noteq> vaddr) $ throwError $ InvalidArgument 0\n             odE\n           | None \\<Rightarrow> doE\n               vtop \\<leftarrow> returnOk $ vaddr + mask (pageBitsForSize pgsz);\n               whenE (vtop > user_vtop) $ throwError $ InvalidArgument 0\n             odE;\n           (level, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot pt vaddr \\<circ> ptes_of;\n           unlessE (pt_bits_left level = pg_bits) $\n             throwError $ FailedLookup False $ MissingCapability $ pt_bits_left level;\n           vm_rights \\<leftarrow> returnOk $ mask_vm_rights R (data_to_rights rights_mask);\n           attribs \\<leftarrow> returnOk $ attribs_from_word attr;\n           pte \\<leftarrow> returnOk $ make_user_pte (addrFromPPtr p) attribs vm_rights pgsz;\n           returnOk $ InvokePage $ PageMap (FrameCap p R pgsz dev (Some (asid,vaddr))) cte\n                                           (pte,slot,level)\n         odE\n       else throwError TruncatedMessage\n     | _ \\<Rightarrow> fail\"\n\ndefinition label_to_flush_type :: \"data \\<Rightarrow> flush_type\" where\n  \"label_to_flush_type label \\<equiv>\n     case invocation_type label of\n       ArchInvocationLabel ARMVSpaceClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPageClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMVSpaceInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPageInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMVSpaceCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPageCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMVSpaceUnify_Instruction \\<Rightarrow> Unify\n     | ArchInvocationLabel ARMPageUnify_Instruction \\<Rightarrow> Unify\"\n\ndefinition decode_fr_inv_flush :: \"'z::state_ext arch_decoder\" where\n  \"decode_fr_inv_flush label args cte cap extra_caps \\<equiv> case cap of\n     FrameCap p R pgsz dev mapped_address \\<Rightarrow>\n        if length args > 1\n        then let\n          start = args ! 0;\n          end = args ! 1\n        in doE\n          (asid, vaddr) \\<leftarrow> case mapped_address of\n                             Some a \\<Rightarrow> returnOk a\n                           | _ \\<Rightarrow> throwError IllegalOperation;\n          vspace \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n          whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n          page_size \\<leftarrow> returnOk $ 1 << pageBitsForSize pgsz;\n          whenE (start \\<ge> page_size \\<or> end > page_size) $ throwError $ InvalidArgument 0;\n          pstart \\<leftarrow> returnOk $ addrFromPPtr p + start;\n          \\<comment> \\<open>flush only inside the kernel window:\\<close>\n          whenE (pstart < paddrBase \\<or> ((end - start) + pstart > paddrTop)) $\n            throwError IllegalOperation;\n          returnOk $ InvokePage $\n            PageFlush (label_to_flush_type label)\n                      (vaddr + start) (vaddr + end - 1)\n                      pstart vspace asid\n        odE\n        else throwError TruncatedMessage\n   | _ \\<Rightarrow> fail\"\n\n\ndefinition decode_frame_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_frame_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel ARMPageMap\n     then decode_fr_inv_map label args cte cap extra_caps\n     else if invocation_type label = ArchInvocationLabel ARMPageUnmap\n     then returnOk $ InvokePage $ PageUnmap cap cte\n     else if invocation_type label = ArchInvocationLabel ARMPageGetAddress\n     then returnOk $ InvokePage $ PageGetAddr (acap_obj cap)\n     else if isPageFlushLabel (invocation_type label)\n     then decode_fr_inv_flush label args cte cap extra_caps\n     else throwError IllegalOperation\"\n\ndefinition decode_pt_inv_map :: \"'z::state_ext arch_decoder\" where\n  \"decode_pt_inv_map label args cte cap extra_caps \\<equiv> case cap of\n     PageTableCap p t mapped_address \\<Rightarrow>\n       if length args > 1 \\<and> length extra_caps > 0\n       then let\n           vaddr = args ! 0;\n           attr = args ! 1;\n           vspace_cap = fst (extra_caps ! 0)\n         in doE\n           whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n           (pt, asid) \\<leftarrow> check_vspace_root vspace_cap 1;\n           whenE (user_vtop < vaddr) $ throwError $ InvalidArgument 0;\n           pt' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n           whenE (pt' \\<noteq> pt) $ throwError $ InvalidCapability 1;\n           (level, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot pt vaddr \\<circ> ptes_of;\n           old_pte \\<leftarrow> liftE $ get_pte (level_type level) slot;\n           whenE (pt_bits_left level = pageBits \\<or> old_pte \\<noteq> InvalidPTE) $ throwError DeleteFirst;\n           pte \\<leftarrow> returnOk $ PageTablePTE (ppn_from_pptr p);\n           cap' <- returnOk $ PageTableCap p t $ Some (asid, vaddr && ~~mask (pt_bits_left level));\n           returnOk $ InvokePageTable $ PageTableMap cap' cte pte slot level\n         odE\n       else throwError TruncatedMessage\n     | _ \\<Rightarrow> fail\"\n\ndefinition decode_page_table_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_page_table_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel ARMPageTableMap\n     then decode_pt_inv_map label args cte cap extra_caps\n     else if invocation_type label = ArchInvocationLabel ARMPageTableUnmap\n     then doE\n       final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n       unlessE final $ throwError RevokeFirst;\n       returnOk $ InvokePageTable $ PageTableUnmap cap cte\n     odE\n     else throwError IllegalOperation\"\n\ndefinition level_of_vmsize :: \"vmpage_size \\<Rightarrow> vm_level\" where\n  \"level_of_vmsize vmsz \\<equiv>\n     case vmsz of\n       ARMSmallPage \\<Rightarrow> 0\n     | ARMLargePage \\<Rightarrow> 1\n     | ARMHugePage \\<Rightarrow> 2\"\n\ndefinition vmsize_of_level :: \"vm_level \\<Rightarrow> vmpage_size\" where\n  \"vmsize_of_level level \\<equiv>\n     if level = 0 then ARMSmallPage\n     else if level = 1 then ARMLargePage\n     else ARMHugePage\"\n\ndefinition lookup_frame :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> ptes_of \\<Rightarrow> (vmpage_size \\<times> paddr) option\" where\n  \"lookup_frame vspace vaddr = do {\n     (level, slot) \\<leftarrow> pt_lookup_slot vspace vaddr;\n     pte \\<leftarrow> oapply2 (level_type level) slot;\n     oassert (is_PagePTE pte);\n     oassert (level \\<le> 2);\n     oreturn (vmsize_of_level level, pte_base_addr pte)\n   }\"\n\ndefinition decode_vs_inv_flush :: \"'z::state_ext arch_decoder\" where\n  \"decode_vs_inv_flush label args cte cap extra_caps \\<equiv> case cap of\n     PageTableCap p VSRootPT_T mapped_address \\<Rightarrow>\n        if length args > 1\n        then let\n          start = args ! 0;\n          end = args ! 1\n        in doE\n          whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n          whenE (end > pptrUserTop) $ throwError $ IllegalOperation;\n          (vspace, asid) \\<leftarrow> check_vspace_root (ArchObjectCap cap) 0;\n          vspace' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n          whenE (vspace' \\<noteq> vspace) $ throwError $ InvalidCapability 0;\n          frame_info \\<leftarrow> liftE $ gets $ lookup_frame p start \\<circ> ptes_of;\n          case frame_info of\n            None \\<Rightarrow> returnOk $ InvokeVSpace VSpaceNothing\n          | Some (pgsz, paddr) \\<Rightarrow> doE\n              bits_left  \\<leftarrow> returnOk $ pt_bits_left (level_of_vmsize pgsz);\n              base_start \\<leftarrow> returnOk $ page_base start pgsz;\n              base_end \\<leftarrow> returnOk $ page_base (end - 1) pgsz;\n              whenE (base_start \\<noteq> base_end) $\n                throwError $ RangeError start (base_start + mask bits_left);\n              pstart \\<leftarrow> returnOk $ paddr + (start && mask bits_left);\n              returnOk $ InvokeVSpace $\n                VSpaceFlush (label_to_flush_type label) start (end - 1) pstart vspace asid\n            odE\n        odE\n        else throwError TruncatedMessage\n   | _ \\<Rightarrow> fail\"\n\ndefinition decode_vspace_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_vspace_invocation label args cte cap extra_caps \\<equiv>\n     if isVSpaceFlushLabel (invocation_type label)\n     then decode_vs_inv_flush label args cte cap extra_caps\n     else throwError IllegalOperation\"\n\ndefinition decode_asid_control_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_asid_control_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel ARMASIDControlMakePool\n     then if length args > 1 \\<and> length extra_caps > 1\n     then let\n         index = args ! 0;\n         depth = args ! 1;\n         (untyped, parent_slot) = extra_caps ! 0;\n         root = fst (extra_caps ! 1)\n       in doE\n         asid_table \\<leftarrow> liftE $ gets asid_table;\n         free_set \\<leftarrow> returnOk (- dom asid_table);\n         whenE (free_set = {}) $ throwError DeleteFirst;\n         free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n         base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n         (p,n) \\<leftarrow> case untyped of\n                    UntypedCap False p n _ \\<Rightarrow> returnOk (p,n)\n                  | _ \\<Rightarrow> throwError $ InvalidCapability 1;\n         frame \\<leftarrow> if n = pageBits then doE\n                    ensure_no_children parent_slot;\n                    returnOk p\n                  odE\n                  else throwError $ InvalidCapability 1;\n         dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n         ensure_empty dest_slot;\n         returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n       odE\n     else throwError TruncatedMessage\n     else throwError IllegalOperation\"\n\ndefinition decode_asid_pool_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_asid_pool_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel ARMASIDPoolAssign\n     then if length extra_caps > 0\n     then let\n         (pt_cap, pt_cap_slot) = extra_caps ! 0;\n         p = acap_obj cap;\n         base = acap_asid_base cap\n       in case pt_cap of\n         ArchObjectCap (PageTableCap _ VSRootPT_T None) \\<Rightarrow> doE\n           asid_table \\<leftarrow> liftE $ gets asid_table;\n           pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n           whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n           whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n           pool \\<leftarrow> liftE $ get_asid_pool p;\n           free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n           whenE (free_set = {}) $ throwError DeleteFirst;\n           offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n           returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pt_cap_slot\n         odE\n       | _ \\<Rightarrow> throwError $ InvalidCapability 1\n     else throwError TruncatedMessage\n     else throwError IllegalOperation\"\n\ndefinition arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n     PageTableCap _ VSRootPT_T _ \\<Rightarrow> decode_vspace_invocation label args cte cap extra_caps\n   | PageTableCap _ NormalPT_T _ \\<Rightarrow> decode_page_table_invocation label args cte cap extra_caps\n   | FrameCap _ _ _ _ _        \\<Rightarrow> decode_frame_invocation label args cte cap extra_caps\n   | ASIDControlCap            \\<Rightarrow> decode_asid_control_invocation label args cte cap extra_caps\n   | ASIDPoolCap _ _           \\<Rightarrow> decode_asid_pool_invocation label args cte cap extra_caps\n   | VCPUCap _                 \\<Rightarrow> decode_vcpu_invocation label args cap extra_caps\"", "property": "Architecture-specific System Call Decoding: Decodes the architecture-specific system calls for ARM, including IRQ control, page table and frame management, ASID control, and VCPU management, ensuring that the system calls are valid and properly formatted before invoking the corresponding kernel operations.\n\nSubproperties:\n- IRQ Control Invocation: Decodes IRQ control invocations, checking the IRQ word, trigger, index, and depth, and ensuring that the IRQ is not active before invoking the IRQ control operation.\n- Page Table and Frame Management: Decodes page table and frame management invocations, including page mapping, unmapping, and flushing, ensuring that the page table and frame operations are valid and properly formatted.\n- ASID Control and Pool Management: Decodes ASID control and pool management invocations, including making a pool, assigning an ASID, and ensuring that the ASID table and pool are properly updated.\n- VCPU Management: Decodes VCPU management invocations, ensuring that the VCPU operations are valid and properly formatted.", "title": "./spec/abstract/AARCH64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Interface Functions used in Decode", "comment": ""}
{"spec": "definition arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\" where\n  \"arch_data_to_obj_type n \\<equiv>\n     if      n = 0 then Some HugePageObj\n     else if n = 1 then Some VSpaceObj\n     else if n = 2 then Some SmallPageObj\n     else if n = 3 then Some LargePageObj\n     else if n = 4 then Some PageTableObj\n     else if n = 5 then Some VCPUObj\n     else None\"\n\nend\nend", "property": "Architecture-specific Object Type Decoding: Maps a numeric value to a specific architecture object type, such as HugePageObj, VSpaceObj, SmallPageObj, LargePageObj, PageTableObj, or VCPUObj, or returns None for unknown values.", "title": "./spec/abstract/AARCH64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Interface Functions used in Decode", "comment": ""}
{"spec": "locale_abbrev vcpus_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> vcpu\" where\n  \"vcpus_of \\<equiv> \\<lambda>s. aobjs_of s |> vcpu_of\"\n\ndefinition get_vcpu :: \"obj_ref \\<Rightarrow> (vcpu,'z::state_ext) s_monad\" where\n  \"get_vcpu \\<equiv> gets_map vcpus_of\"\n\ndefinition set_vcpu :: \"obj_ref \\<Rightarrow> vcpu \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_vcpu ptr vcpu \\<equiv> set_object ptr (ArchObj (VCPU vcpu))\"", "property": "VCPU Accessor Functions: Provide access to VCPU-related state and registers, enabling retrieval and modification of VCPU objects.\nGet VCPU: Retrieve the VCPU object associated with a given object reference.\nSet VCPU: Update the VCPU object associated with a given object reference.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": ""}
{"spec": "definition vcpu_update :: \"obj_ref \\<Rightarrow> (vcpu \\<Rightarrow> vcpu) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_update vr f \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    set_vcpu vr (f vcpu)\n  od\"\n\ndefinition vgic_update ::\n  \"obj_ref \\<Rightarrow> (gic_vcpu_interface \\<Rightarrow> gic_vcpu_interface) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vgic_update vr f \\<equiv> vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_vgic := f (vcpu_vgic vcpu) \\<rparr> )\"\n\ndefinition vgic_update_lr :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> virq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vgic_update_lr vr irq_idx virq \\<equiv>\n    vgic_update vr (\\<lambda>vgic. vgic \\<lparr> vgic_lr := (vgic_lr vgic)(irq_idx := virq) \\<rparr>)\"\n\ndefinition vcpu_save_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_save_reg vr reg \\<equiv> do\n    rval \\<leftarrow> do_machine_op (readVCPUHardwareReg reg);\n    vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_regs := (vcpu_regs vcpu)(reg := rval) \\<rparr> )\n  od\"\n\ndefinition vcpu_save_reg_range :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_save_reg_range vr from to \\<equiv> mapM_x (\\<lambda>reg. vcpu_save_reg vr reg) [from .e. to]\"\n\ndefinition vcpu_restore_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_restore_reg vr reg \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    do_machine_op (writeVCPUHardwareReg reg (vcpu_regs vcpu reg))\n  od\"\n\ndefinition vcpu_restore_reg_range :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"vcpu_restore_reg_range vr from to \\<equiv> mapM_x (\\<lambda>reg. vcpu_restore_reg vr reg) [from .e. to]\"\n\ndefinition vcpu_read_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (machine_word, 'z::state_ext) s_monad\" where\n  \"vcpu_read_reg vr reg \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    return (vcpu_regs vcpu reg)\n  od\"\n\ndefinition vcpu_write_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"vcpu_write_reg vr reg val \\<equiv>\n    vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_regs := (vcpu_regs vcpu)(reg := val) \\<rparr> )\"\n\ndefinition save_virt_timer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"save_virt_timer vcpu_ptr \\<equiv> do\n     vcpu_save_reg vcpu_ptr VCPURegCNTV_CTL;\n     do_machine_op $ writeVCPUHardwareReg VCPURegCNTV_CTL 0;\n     vcpu_save_reg vcpu_ptr VCPURegCNTV_CVAL;\n     vcpu_save_reg vcpu_ptr VCPURegCNTVOFF;\n     vcpu_save_reg vcpu_ptr VCPURegCNTKCTL_EL1;\n     do_machine_op check_export_arch_timer;\n     cntpct \\<leftarrow> do_machine_op read_cntpct;\n     vcpu_update vcpu_ptr (\\<lambda>vcpu. vcpu\\<lparr>vcpu_vtimer := VirtTimer cntpct \\<rparr>)\n   od\"\n\ndefinition irq_vppi_event_index :: \"irq \\<rightharpoonup> vppievent_irq\" where\n  \"irq_vppi_event_index irq \\<equiv>\n     if irq = irqVTimerEvent\n     then Some VPPIEventIRQ_VTimer\n     else None\"\n\ndefinition restore_virt_timer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"restore_virt_timer vcpu_ptr \\<equiv> do\n     vcpu_restore_reg vcpu_ptr VCPURegCNTV_CVAL;\n     vcpu_restore_reg vcpu_ptr VCPURegCNTKCTL_EL1;\n     current_cntpct \\<leftarrow> do_machine_op read_cntpct;\n     vcpu \\<leftarrow> get_vcpu vcpu_ptr;\n     last_pcount \\<leftarrow> return $ vtimerLastPCount $ vcpu_vtimer vcpu;\n     delta \\<leftarrow> return $ current_cntpct - last_pcount;\n     cntvoff \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTVOFF;\n     offset \\<leftarrow> return $ cntvoff + ucast delta;\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFF offset;\n     vcpu_restore_reg vcpu_ptr VCPURegCNTVOFF;\n     \\<comment> \\<open>read again, so we don't have to reason about @{const vcpu_write_reg} changes in CRefine\\<close>\n     vcpu \\<leftarrow> get_vcpu vcpu_ptr;\n     masked \\<leftarrow> return $ (vcpu_vppi_masked vcpu (the $ irq_vppi_event_index irqVTimerEvent));\n     \\<comment> \\<open>we do not know here that irqVTimerEvent is IRQReserved, therefore not IRQInactive,\n        so the only way to prove we don't unmask an inactive interrupt is to check\\<close>\n     safe_to_unmask \\<leftarrow> is_irq_active irqVTimerEvent;\n     when safe_to_unmask $ do_machine_op $ maskInterrupt masked irqVTimerEvent;\n     vcpu_restore_reg vcpu_ptr VCPURegCNTV_CTL\n   od\"", "property": "VCPU State Management: Provides functions to manipulate VCPU-related state and registers, including updating VCPU and VGIC state, saving and restoring VCPU registers, and managing virtual timers. These functions ensure that VCPU state is correctly managed and updated, maintaining the integrity and performance of the virtualization system.\n\nSubproperties:\n- VCPU State Update: Update VCPU and VGIC state, including updating VCPU registers and VGIC interface state.\n- VCPU Register Management: Save and restore VCPU registers, including saving and restoring register ranges.\n- Virtual Timer Management: Save and restore virtual timer state, including saving and restoring timer registers and managing timer events.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": ""}
{"spec": "definition vcpu_disable :: \"obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_disable vo \\<equiv> do\n    do_machine_op dsb;\n    case vo of\n      Some vr \\<Rightarrow> do\n        hcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_hcr;\n        vgic_update vr (\\<lambda>vgic. vgic\\<lparr> vgic_hcr := hcr \\<rparr>);\n        vcpu_save_reg vr VCPURegSCTLR;\n        vcpu_save_reg vr VCPURegCPACR; \\<comment> \\<open>since FPU enabled\\<close>\n        do_machine_op isb\n      od\n    | _ \\<Rightarrow> return ();\n    do_machine_op $ do\n        set_gic_vcpu_ctrl_hcr 0; \\<comment> \\<open>turn VGIC off\\<close>\n        isb;\n        setSCTLR sctlrDefault; \\<comment> \\<open>turn S1 MMU off\\<close>\n        isb;\n        setHCR hcrNative;\n        isb;\n        \\<comment> \\<open>allow FPU instructions in EL0 and EL1 for native threads\\<close>\n        enableFpuEL01\n      od;\n    case vo of\n      Some vr \\<Rightarrow> do\n          save_virt_timer vr;\n          do_machine_op $ maskInterrupt True irqVTimerEvent\n        od\n    | _ \\<Rightarrow> return ()\n    od\"", "property": "VCPU Mode Disable: Turn off VCPU mode on the hardware level by updating the VGIC control register, saving relevant VCPU registers, disabling the VGIC and S1 MMU, and configuring the HCR and FPU settings for native threads. Additionally, save the virtual timer state and mask the VTimer event interrupt if a VCPU object reference is provided.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Turn VPCU mode off on the hardware level."}
{"spec": "definition vcpu_enable :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_enable vr \\<equiv> do\n     vcpu_restore_reg vr VCPURegSCTLR;\n     vcpu \\<leftarrow> get_vcpu vr;\n     do_machine_op $ do\n        setHCR hcrVCPU;\n        isb;\n        set_gic_vcpu_ctrl_hcr (vgic_hcr $ vcpu_vgic vcpu)\n     od;\n     vcpu_restore_reg vr VCPURegCPACR; \\<comment> \\<open>FPU\\<close>\n     restore_virt_timer vr\n   od\"", "property": "VCPU Enable: Turn on VCPU mode at the hardware level by restoring specific registers, setting hardware control registers, and restoring the virtual timer.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Turn VCPU mode on, on the hardware level."}
{"spec": "definition vcpu_invalidate_active :: \"(unit,'z::state_ext) s_monad\" where\n  \"vcpu_invalidate_active \\<equiv> do\n    cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n    case cur_v of\n      Some (vr, True) \\<Rightarrow> vcpu_disable None\n    | _ \\<Rightarrow> return ();\n    modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := None \\<rparr>\\<rparr>)\n  od\"", "property": "VCPU Removal Preparation: Invalidate the current VCPU, disabling it if active, and reset the current VCPU pointer to None.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Prepare the current VCPU for removal."}
{"spec": "definition vcpu_save :: \"(obj_ref \\<times> bool) option \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_save vb \\<equiv>\n     case vb\n     of Some (vr, active) \\<Rightarrow> do\n          do_machine_op dsb;\n\n          when active $ do\n            vcpu_save_reg vr VCPURegSCTLR;\n            hcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_hcr;\n            vgic_update vr (\\<lambda>vgic. vgic\\<lparr> vgic_hcr := hcr \\<rparr>);\n            save_virt_timer vr\n          od;\n\n          vmcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_vmcr;\n          vgic_update vr (\\<lambda>vgic. vgic \\<lparr>vgic_vmcr := vmcr\\<rparr>);\n\n          apr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_apr;\n          vgic_update vr (\\<lambda>vgic. vgic \\<lparr>vgic_apr := apr\\<rparr>);\n\n          num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n          gicIndices \\<leftarrow> return [0..<num_list_regs];\n\n          mapM (\\<lambda>vreg. do\n                    val \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_lr (of_nat vreg);\n                    vgic_update_lr vr vreg val\n                  od)\n            gicIndices;\n\n          \\<comment> \\<open>armvVCPUSave\\<close>\n          vcpu_save_reg_range vr VCPURegTTBR0 VCPURegSPSR_EL1\n       od\n     | _ \\<Rightarrow> fail\"", "property": "VCPU State Save: Saves the state and registers of a VCPU, including SCTLR, HCR, VMCR, APR, and timer state, as well as the list registers, to ensure that the VCPU's context is preserved. \n\nSubproperties:\n- Save VCPU Registers: Saves specific VCPU registers, including SCTLR, HCR, VMCR, and APR.\n- Save VCPU Timer State: Saves the state of the virtual timer associated with the VCPU.\n- Save VCPU List Registers: Saves the list registers of the VCPU.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Register + context save for VCPUs"}
{"spec": "definition vcpu_restore :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_restore vr \\<equiv> do\n     do_machine_op $ set_gic_vcpu_ctrl_hcr 0;  \\<comment> \\<open>turn off VGIC\\<close>\n     do_machine_op $ isb;\n     vcpu \\<leftarrow> get_vcpu vr;  \\<comment> \\<open>restore GIC VCPU control state\\<close>\n     vgic \\<leftarrow> return (vcpu_vgic vcpu);\n     num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     gicIndices \\<leftarrow> return [0..<num_list_regs];\n     do_machine_op $ do\n         set_gic_vcpu_ctrl_vmcr (vgic_vmcr vgic);\n         set_gic_vcpu_ctrl_apr (vgic_apr vgic);\n         mapM (\\<lambda>p. set_gic_vcpu_ctrl_lr (of_nat (fst p)) (snd p))\n              (map (\\<lambda>i. (i, (vgic_lr vgic) i)) gicIndices)\n     od;\n    \\<comment> \\<open>restore banked VCPU registers except SCTLR (that's in VCPUEnable)\\<close>\n     vcpu_restore_reg_range vr VCPURegTTBR0 VCPURegSPSR_EL1;\n     vcpu_enable vr\n  od\"", "property": "VCPU Restore: Restore the VCPU-related state and registers, including the GIC VCPU control state and banked VCPU registers, and enable the VCPU.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Register + context restore for VCPUs"}
{"spec": "definition vcpu_switch :: \"obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_switch v \\<equiv> case v of\n     None \\<Rightarrow> do\n       cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n       (case cur_v of\n          None \\<Rightarrow> return () \\<comment> \\<open>both null, current cannot be active\\<close>\n        | Some (vr, active) \\<Rightarrow> do \\<comment> \\<open>switch to thread without vcpu\\<close>\n            when active $ do  \\<comment> \\<open> save state if not saved already\\<close>\n              vcpu_disable (Some vr);\n              modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (vr, False) \\<rparr>\\<rparr>)\n            od;\n            return ()\n          od)\n       od\n   | Some new \\<Rightarrow> do\n       cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n       (case cur_v of\n          None \\<Rightarrow> do \\<comment> \\<open>switch to the new vcpu with no current one\\<close>\n            vcpu_restore new;\n            modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n          od\n        | Some (vr, active) \\<Rightarrow> \\<comment> \\<open>switch from an existing vcpu\\<close>\n            (if vr \\<noteq> new\n            then do \\<comment> \\<open>different vcpu\\<close>\n              vcpu_save cur_v;\n              vcpu_restore new;\n              modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n            od\n            else \\<comment> \\<open>same vcpu\\<close>\n              when (\\<not> active) $ do\n                do_machine_op isb;\n                vcpu_enable new;\n                modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n              od))\n     od\"", "property": "VCPU Switching: Make a new VCPU the active/current VCPU, or mark the current VCPU as not active and disable VCPU mode if passed None, while caching the rest for potential future switches to the same VCPU. \n\nSubproperties:\n- Save the state of the current VCPU if it is active and not saved already.\n- Restore the state of the new VCPU when switching to it.\n- Enable the new VCPU if it is the same as the current one but not active.\n- Update the arch_state to reflect the new current VCPU.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "\n  Make a new VCPU the active/current VCPU. If passed None, will mark the current VCPU as\n  not active, and disable VCPU mode, but leave the rest intact caching for the case where\n  we switch back to the same VCPU soon."}
{"spec": "definition dissociate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"dissociate_vcpu_tcb vr t \\<equiv> do\n     t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n     v \\<leftarrow> get_vcpu vr;\n     assert (t_vcpu = Some vr \\<and> vcpu_tcb v = Some t); \\<comment> \\<open>make sure they were associated\\<close>\n     cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     when (\\<exists>a. cur_v = Some (vr,a)) vcpu_invalidate_active;\n     arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := None \\<rparr>) t;\n     set_vcpu vr (v\\<lparr> vcpu_tcb := None \\<rparr>);\n     as_user t $ do\n       sr \\<leftarrow> getRegister SPSR_EL1;\n       setRegister SPSR_EL1 $ sanitise_register False SPSR_EL1 sr\n     od\n   od\"", "property": "Dissociate VCPU from TCB: Remove the connection between a VCPU and a TCB, ensuring that the VCPU is invalidated if it is currently active, and update the TCB and VCPU states accordingly. \n\nSubproperties:\n- Validate the association between the VCPU and TCB before dissociation.\n- Invalidate the VCPU if it is currently active.\n- Update the TCB state to remove the VCPU reference.\n- Update the VCPU state to remove the TCB reference.\n- Sanitise the SPSR_EL1 register for the TCB.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Removing the connection between a TCB and VCPU:"}
{"spec": "definition associate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"associate_vcpu_tcb vcpu_ptr t \\<equiv> do\n     t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n     case t_vcpu of\n       Some p \\<Rightarrow> dissociate_vcpu_tcb p t\n     | _ \\<Rightarrow> return ();\n     v \\<leftarrow> get_vcpu vcpu_ptr;\n     case vcpu_tcb v of\n       Some p \\<Rightarrow> dissociate_vcpu_tcb vcpu_ptr p\n     | _ \\<Rightarrow> return ();\n     arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := Some vcpu_ptr \\<rparr>) t;\n     set_vcpu vcpu_ptr (v\\<lparr> vcpu_tcb := Some t \\<rparr>);\n     ct \\<leftarrow> gets cur_thread;\n     when (t = ct) $ vcpu_switch (Some vcpu_ptr)\n  od\"", "property": "Associate VCPU with TCB: Establish an association between a VCPU (Virtual CPU) and a TCB (Thread Control Block), ensuring exclusive connection by removing any existing VCPU-TCB associations.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Associating a TCB and VCPU, removing any potentially existing associations:"}
{"spec": "definition vcpu_finalise :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_finalise vr \\<equiv> do\n    v \\<leftarrow> get_vcpu vr;\n    case vcpu_tcb v of\n      Some t \\<Rightarrow> dissociate_vcpu_tcb vr t\n    | None \\<Rightarrow> return ()\n   od\"\n\nend\nend", "property": "VCPU Finalisation: Prepare a VCPU for removal by dissociating it from its associated TCB and cleaning up current VCPU state if necessary.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "\n  Prepare a given VCPU for removal: dissociate it, and clean up current VCPU state\n  if necessary."}
{"spec": "datatype vspace_invocation =\n    VSpaceNothing\n  | VSpaceFlush\n      (vs_flush_type : flush_type)\n      (vs_flush_start : vspace_ref)\n      (vs_flush_end : vspace_ref)\n      (vs_flush_pstart : paddr)\n      (vs_flush_space : obj_ref)\n      (vs_flush_asid : asid)\n\ndatatype page_table_invocation =\n    PageTableMap\n      (pt_inv_cap : arch_cap)\n      (pt_inv_cslot : cslot_ptr)\n      (pt_map_pte : pte)\n      (pt_map_slot : obj_ref)\n      (pt_map_level : vm_level)\n  | PageTableUnmap\n      (pt_inv_cap : arch_cap)\n      (pt_inv_cslot : cslot_ptr)\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation =\n    PageMap\n      (pg_inv_cap : arch_cap)\n      (pg_inv_cslot : cslot_ptr)\n      (pg_inv_entries : \"pte \\<times> obj_ref \\<times> vm_level\")\n  | PageUnmap\n      (pg_inv_cap : arch_cap)\n      (pg_inv_cslot : cslot_ptr)\n  | PageGetAddr\n      (pg_get_paddr : obj_ref)\n  | PageFlush\n      (pg_flush_type : flush_type)\n      (pg_flush_start : vspace_ref)\n      (pg_flush_end : vspace_ref)\n      (pg_flush_pStart : paddr)\n      (pg_flush_space : obj_ref)\n      (pg_flush_asid : asid)\n\ndatatype vcpu_invocation =\n    VCPUSetTCB\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_tcb : obj_ref)\n  | VCPUInjectIRQ\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_idx : nat)\n      (vcpu_inv_irq : virq)\n  | VCPUReadRegister\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_reg : vcpureg)\n  | VCPUWriteRegister\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_reg : vcpureg)\n      (vcpu_inv_val : machine_word)\n  | VCPUAckVPPI\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_eirq : vppievent_irq)\n\ndatatype arch_invocation =\n    InvokeVSpace vspace_invocation\n  | InvokePageTable page_table_invocation\n  | InvokePage page_invocation\n  | InvokeASIDControl asid_control_invocation\n  | InvokeASIDPool asid_pool_invocation\n  | InvokeVCPU vcpu_invocation\n\ndatatype arch_copy_register_sets =\n    ARMNoExtraRegisters\n\ndefinition ArchDefaultExtraRegisters :: arch_copy_register_sets where\n  \"ArchDefaultExtraRegisters = ARMNoExtraRegisters\"\n\ndatatype arch_irq_control_invocation =\n    ARMIRQControlInvocation irq cslot_ptr cslot_ptr bool\n\nend\nend", "property": "AARCH64-Specific System Calls: Provides various system call invocations for AARCH64 architecture, including virtual space management (flushing), page table management (mapping and unmapping), ASID control (making pools), ASID pool management (assigning), page management (mapping, unmapping, getting addresses, and flushing), and VCPU management (setting TCB, injecting IRQs, reading and writing registers, and acknowledging VPPIs).\n\nSubproperties:\n- Virtual Space Management: Flushes a range of virtual addresses in a specific address space.\n- Page Table Management: Maps or unmaps page tables to manage virtual memory.\n- ASID Control: Creates a new ASID pool for managing address space identifiers.\n- ASID Pool Management: Assigns an ASID from a pool to a specific object.\n- Page Management: Maps, unmaps, gets addresses, or flushes pages in virtual memory.\n- VCPU Management: Manages virtual CPU operations, including setting TCB, injecting IRQs, reading and writing registers, and acknowledging VPPIs.", "title": "./spec/abstract/AARCH64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "\n  These datatypes encode the arguments to the various possible AARCH64-specific system calls.\n  Selectors are defined for various fields for convenience elsewhere.\n"}
{"spec": "text \\<open>\n  The AARCH64 kernel supports capabilities for ASID pools and an ASID controller capability,\n  along with capabilities for virtual memory mappings.\n\\<close>\n\ndatatype arch_cap =\n    ASIDPoolCap\n      (acap_obj : obj_ref)\n      (acap_asid_base : asid)\n  | ASIDControlCap\n  | FrameCap\n      (acap_obj : obj_ref)\n      (acap_rights : cap_rights)\n      (acap_fsize : vmpage_size)\n      (acap_is_device : bool)\n      (acap_map_data : \"(asid \\<times> vspace_ref) option\")\n  | PageTableCap\n      (acap_obj : obj_ref)\n      (acap_pt_type : pt_type)\n      (acap_map_data : \"(asid \\<times> vspace_ref) option\")\n  | VCPUCap\n      (acap_obj : obj_ref)", "property": "AARCH64-Specific Capability Types: The AARCH64 kernel supports capabilities for ASID pools, ASID control, virtual memory mappings (frames and page tables), and VCPUs, each with specific attributes and data. \n\nSubproperties:\n- ASID Pool Capabilities: Represent an ASID pool with an object reference and an ASID base.\n- ASID Control Capabilities: Provide control over ASID allocation and management.\n- Frame Capabilities: Describe a frame of memory with attributes including object reference, access rights, frame size, device status, and mapping data.\n- Page Table Capabilities: Represent a page table with attributes including object reference, page table type, and mapping data.\n- VCPU Capabilities: Represent a VCPU with an object reference.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "definition update_map_data :: \"arch_cap \\<Rightarrow> (asid \\<times> vspace_ref) option \\<Rightarrow> arch_cap\" where\n  \"update_map_data cap m \\<equiv> case cap of\n     FrameCap p R sz dev _  \\<Rightarrow> FrameCap p R sz dev m\n   | PageTableCap p t _ \\<Rightarrow> PageTableCap p t m\"", "property": "Update Mapping Data: Update the mapping data saved in a frame or page table capability with new ASID and virtual space reference information. \n\nSubproperties:\n- Frame Capability Update: Update the mapping data of a frame capability.\n- Page Table Capability Update: Update the mapping data of a page table capability.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific objects", "comment": "Update the mapping data saved in a frame or page table capability."}
{"spec": "(* This datatype does not match up with the executable spec directly:\n   This one here models all \"things\" one can set on a page entry.\n   The attributes accessible to users are the ones returned by attribs_from_word. *)\ndatatype vm_attribute = Global | Execute | Device\ntype_synonym vm_attributes = \"vm_attribute set\"", "property": "Virtual Memory Attributes: Define the attributes that can be set on a page entry, including Global, Execute, and Device, which are used to describe the properties of virtual memory.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "value_type ppn_len = \"ipa_size - pageBits\"\ntype_synonym ppn = \"ppn_len word\"", "property": "Physical Page Number (PPN) Encoding: The base address of a next-level page table is a 48-bit word with the bottom 12 bits always set to 0, representing a 36-bit field-high value. The significant bits of the address range from ipa_size at the top to pageBits at the bottom, encoding both size and alignment invariants.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": "\n  The C field @{text base_addr} for next-level tables of @{text PagePTE}s is a 36 bit field-high\n  value, i.e., a 48-bit word with the bottom 12 bits always set to 0. (They must be 0 due to\n  alignment). Since Arm does not specify a name, we are re-using the RISC-V name @{text ppn}\n  (physical page number) for the concept of encoding only the significant bits of this address.\n\n  In addition to the bottom 12 bits being 0 (where 12 = @{const pageBits}), we also know that\n  the base address of the next level table is a physical address and therefore has the same width\n  as intermediate physical addresses (@{const ipa_size}). We can therefore be more precise in the\n  encoding here: the significant bits of the next-level page table address go from @{const ipa_size}\n  at the top to @{const pageBits} at the bottom. Similar to the ppn on RISC-V we store a word\n  of that size, and shift by @{const pageBits} to get the address. This encodes both a size invariant\n  and an alignment invariant in the type, which functions like @{text pt_walk} rely on.\n\n  To provide the same field name as in C, we define @{text pte_base_addr} as the main accessor\n  function."}
{"spec": "lemma ppn_len_def':\n  \"ppn_len = ipa_size - pageBits\"\n  by (simp add: ppn_len_val pageBits_def ipa_size_def Kernel_Config.config_ARM_PA_SIZE_BITS_40_def)\n\ndatatype pte =\n    InvalidPTE\n  | PagePTE\n      (pte_page_addr : paddr)\n      (pte_is_small_page : bool)\n      (pte_attr : vm_attributes)\n      (pte_rights : vm_rights)\n  | PageTablePTE\n      (pte_ppn : ppn)\n\ndefinition paddr_from_ppn :: \"ppn \\<Rightarrow> paddr\" where\n  \"paddr_from_ppn addr \\<equiv> ucast addr << pageBits\"\n\ndefinition pte_base_addr :: \"pte \\<Rightarrow> paddr\" where\n  \"pte_base_addr pte \\<equiv>\n    if is_PageTablePTE pte then paddr_from_ppn (pte_ppn pte) else pte_page_addr pte\"\n\ndefinition ppn_from_pptr :: \"obj_ref \\<Rightarrow> ppn\" where\n  \"ppn_from_pptr p = ucast (addrFromPPtr p >> pageBits)\"", "property": "Virtual Memory Addressing: Define the relationship between physical page numbers (PPNs) and physical addresses, and provide functions to convert between them, ensuring correct addressing and memory management in the AARCH64 architecture.\n\nSubproperties:\n- PPN Length: The length of a physical page number (PPN) is defined as the difference between the IPA size and the page bits.\n- PTE Structure: Page table entries (PTEs) are defined with specific fields for page addresses, attributes, and rights, allowing for efficient memory management.\n- Address Conversions: Functions are provided to convert between PPNs and physical addresses, ensuring accurate addressing and memory access.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": "This lemma encodes @{typ ppn_len} value above as a term, so we can use it generically:"}
{"spec": "lemma vs_index_ptTranslationBits:\n  \"ptTranslationBits VSRootPT_T = LENGTH(vs_index_len)\"\n  by (simp add: ptTranslationBits_def vs_index_bits_def)\n\nlemma pt_index_ptTranslationBits:\n  \"ptTranslationBits NormalPT_T = LENGTH(pt_index_len)\"\n  by (simp add: ptTranslationBits_def)", "property": "Page Table Type Sizes: Ensure that the page table type sizes for VSRootPT_T and NormalPT_T are correctly defined, specifically that ptTranslationBits matches the length of vs_index_len and pt_index_len respectively.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " Sanity check for page table type sizes -- ptTranslationBits not yet available at definition site "}
{"spec": "datatype asid_pool_entry = ASIDPoolVSpace (ap_vmid : \"vmid option\") (ap_vspace : obj_ref)\n\ntype_synonym asid_pool = \"asid_low_index \\<rightharpoonup> asid_pool_entry\"\n\ndatatype pt =\n    VSRootPT (the_vs : \"vs_index \\<Rightarrow> pte\")\n  | NormalPT (the_pt : \"pt_index \\<Rightarrow> pte\")\n\ndefinition pt_type :: \"pt \\<Rightarrow> pt_type\" where\n  \"pt_type pt \\<equiv> case pt of VSRootPT _ \\<Rightarrow> VSRootPT_T | NormalPT _ \\<Rightarrow> NormalPT_T\"", "property": "AARCH64-Specific Data Types: Define architecture-specific object types for AARCH64, including ASID pool entries and page tables (PTs), which can be either VSRootPT or NormalPT, each containing specific mappings. \n\nASID Pool Entry: Represent an entry in the ASID pool, containing a VMID and a reference to the associated virtual space object.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " This could also be a record, but we expect further alternatives to be added for SMMU "}
{"spec": "type_synonym virq = machine_word\n\nend\n\nqualify AARCH64_A (in Arch)\n\nrecord  gic_vcpu_interface =\n  vgic_hcr  :: word32\n  vgic_vmcr :: word32\n  vgic_apr  :: word32\n  vgic_lr   :: \"nat \\<Rightarrow> AARCH64_A.virq\"\n\nrecord vcpu =\n  vcpu_tcb  :: \"obj_ref option\"\n  vcpu_vgic :: \"gic_vcpu_interface\"\n  vcpu_regs :: \"vcpureg \\<Rightarrow> machine_word\"\n  vcpu_vppi_masked :: \"vppievent_irq \\<Rightarrow> bool\"\n  vcpu_vtimer :: virt_timer\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition \"vcpu_sctlr vcpu \\<equiv> vcpu_regs vcpu VCPURegSCTLR\"\n\ndefinition default_gic_vcpu_interface :: gic_vcpu_interface where\n  \"default_gic_vcpu_interface \\<equiv> \\<lparr>\n      vgic_hcr  = vgicHCREN,\n      vgic_vmcr = 0,\n      vgic_apr  = 0,\n      vgic_lr   = \\<lambda>_. 0\n   \\<rparr>\"\n\ndefinition\n  default_vcpu :: vcpu where\n  \"default_vcpu \\<equiv> \\<lparr>\n      vcpu_tcb    = None,\n      vcpu_vgic   = default_gic_vcpu_interface,\n      vcpu_regs   = (\\<lambda>_. 0) (VCPURegSCTLR := sctlrEL1VM),\n      vcpu_vppi_masked = (\\<lambda>_. False),\n      vcpu_vtimer = VirtTimer 0\n   \\<rparr>\"", "property": "AARCH64 VCPU Data Types: Define the architecture-specific data types for AARCH64 virtual CPUs (VCPU), including the GIC VCPU interface and VCPU records, which contain fields for the VCPU's TCB, VGIC, registers, VPPi masked events, and virtual timer.\n\nDefault VCPU Objects: Specify the default values for the GIC VCPU interface and VCPU objects, ensuring that VCPUs are initialized with a consistent and predictable state.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "datatype (discs_sels) arch_kernel_obj =\n    ASIDPool asid_pool\n  | PageTable pt\n  | DataPage bool vmpage_size\n  | VCPU vcpu\n\ndefinition asid_pool_of :: \"arch_kernel_obj \\<rightharpoonup> asid_pool\" where\n  \"asid_pool_of ko \\<equiv> case ko of ASIDPool pool \\<Rightarrow> Some pool | _ \\<Rightarrow> None\"\n\ndefinition pt_of :: \"arch_kernel_obj \\<rightharpoonup> pt\" where\n  \"pt_of ko \\<equiv> case ko of PageTable pt \\<Rightarrow> Some pt | _ \\<Rightarrow> None\"\n\ndefinition vcpu_of :: \"arch_kernel_obj \\<rightharpoonup> vcpu\" where\n  \"vcpu_of ko \\<equiv> case ko of VCPU vcpu \\<Rightarrow> Some vcpu | _ \\<Rightarrow> None\"\n\ndefinition pte_bits :: nat where\n  \"pte_bits = word_size_bits\"\n\ndefinition table_size :: \"pt_type \\<Rightarrow> nat\" where\n  \"table_size pt_t = ptTranslationBits pt_t + pte_bits\"\n\ndefinition pt_bits :: \"pt_type \\<Rightarrow> nat\" where\n  \"pt_bits pt_t \\<equiv> table_size pt_t\"", "property": "Architecture-Specific Object Types: Define various architecture-specific object types, including ASID pools, page tables, data pages, and VCPUs, along with their respective discriminators and selectors.\n\nSubproperties:\n- ASID Pool Management: Provide a function to extract the ASID pool from an architecture-specific kernel object.\n- Page Table Management: Provide a function to extract the page table from an architecture-specific kernel object.\n- VCPU Management: Provide a function to extract the VCPU from an architecture-specific kernel object.\n- Page Table Entry Bits: Define the number of bits in a page table entry.\n- Table Size Calculation: Calculate the size of a page table based on its type and the number of bits in a page table entry.\n- Page Table Bits Calculation: Calculate the number of bits in a page table based on its type.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " produce discriminators and selectors even though no field names are mentioned "}
{"spec": "lemma ppn_len:\n  \"LENGTH(ppn_len) = ipa_size - pt_bits NormalPT_T\"\n  by (simp add: pt_bits_def table_size_def ptTranslationBits_def pte_bits_def word_size_bits_def\n                ipa_size_def Kernel_Config.config_ARM_PA_SIZE_BITS_40_def)\n\nprimrec arch_obj_size :: \"arch_cap \\<Rightarrow> nat\" where\n  \"arch_obj_size (ASIDPoolCap _ _) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (FrameCap _ _ sz _ _) = pageBitsForSize sz\"\n| \"arch_obj_size (PageTableCap _ pt_t _ ) = table_size pt_t\"\n| \"arch_obj_size (VCPUCap _) = vcpuBits\"\n\nfun arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_cap_is_device (FrameCap _ _ _ is_dev _) = is_dev\"\n| \"arch_cap_is_device _ = False\"\n\ndefinition cte_level_bits :: nat where\n  \"cte_level_bits \\<equiv> 5\"\n\ndefinition tcb_bits :: nat where\n  \"tcb_bits \\<equiv> 11\"\n\ndefinition endpoint_bits :: nat where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat where\n  \"ntfn_bits \\<equiv> 5\"\n\ndefinition untyped_min_bits :: nat where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat where\n  \"untyped_max_bits \\<equiv> 47\"\n\nprimrec arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\" where\n  \"arch_kobj_size (ASIDPool _) = pageBits\"\n| \"arch_kobj_size (PageTable pt) = table_size (pt_type pt)\"\n| \"arch_kobj_size (DataPage _ sz) = pageBitsForSize sz\"\n| \"arch_kobj_size (VCPU _) = vcpuBits\"\n\nfun aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\" where\n  \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref c = Some (acap_obj c)\"\n\ndefinition acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\" where\n  \"acap_rights_update R acap \\<equiv>\n    case acap of\n      FrameCap ref cR sz dev as \\<Rightarrow> FrameCap ref (validate_vm_rights R) sz dev as\n    | _ \\<Rightarrow> acap\"", "property": "Architecture-Specific Object Properties: Define the properties and sizes of various architecture-specific objects, including ASID pools, page tables, frames, VCPUs, and capabilities. These properties ensure that the objects are correctly sized and configured for the AARCH64 architecture.\n\nObject Size Definitions: Define the sizes of various objects, including ASID pools, page tables, frames, VCPUs, TCBs, endpoints, notifications, and untyped objects. These definitions ensure that the objects are correctly sized and aligned for the architecture.\n\nCapability Properties: Define the properties of architecture-specific capabilities, including the rights update function for frame capabilities. These properties ensure that capabilities are correctly managed and updated for the architecture.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " sanity check "}
{"spec": "datatype aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | HugePageObj\n  | PageTableObj\n  | VSpaceObj\n  | ASIDPoolObj (* used internally, not on API level *)\n  | VCPUObj\n\ndefinition arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\" where\n  \"arch_is_frame_type aobj \\<equiv> case aobj of\n     SmallPageObj \\<Rightarrow> True\n   | LargePageObj \\<Rightarrow> True\n   | HugePageObj \\<Rightarrow> True\n   | _ \\<Rightarrow> False\"\n\ndefinition arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\" where\n  \"arch_default_cap tp r n dev \\<equiv> case tp of\n     SmallPageObj \\<Rightarrow> FrameCap r vm_read_write ARMSmallPage dev None\n   | LargePageObj \\<Rightarrow> FrameCap r vm_read_write ARMLargePage dev None\n   | HugePageObj  \\<Rightarrow> FrameCap r vm_read_write ARMHugePage dev None\n   | PageTableObj \\<Rightarrow> PageTableCap r NormalPT_T None\n   | VSpaceObj    \\<Rightarrow> PageTableCap r VSRootPT_T None\n   | VCPUObj      \\<Rightarrow> VCPUCap r\n   | ASIDPoolObj  \\<Rightarrow> ASIDPoolCap r 0\" (* unused, but nicer properties when defined *)\n\ndefinition default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\" where\n  \"default_arch_object tp dev n \\<equiv> case tp of\n     SmallPageObj \\<Rightarrow> DataPage dev ARMSmallPage\n   | LargePageObj \\<Rightarrow> DataPage dev ARMLargePage\n   | HugePageObj  \\<Rightarrow> DataPage dev ARMHugePage\n   | PageTableObj \\<Rightarrow> PageTable (NormalPT (\\<lambda>_. InvalidPTE))\n   | VSpaceObj    \\<Rightarrow> PageTable (VSRootPT (\\<lambda>_. InvalidPTE))\n   | VCPUObj \\<Rightarrow> VCPU default_vcpu\n   | ASIDPoolObj  \\<Rightarrow> ASIDPool Map.empty\"\n\ntype_synonym arm_vspace_region_uses = \"vspace_ref \\<Rightarrow> arm_vspace_region_use\"", "property": "AARCH64-Specific Data Types: Define architecture-specific data types for AARCH64, including object types, capability types, and default objects, to provide a foundation for managing architecture-specific state and resources.\n\n Arch-Specific Object Types: Define the various object types specific to the AARCH64 architecture, including page objects, page table objects, VSpace objects, ASID pool objects, and VCPU objects.\n\n Arch-Specific Capability Types: Define the default capabilities for each object type, including frame capabilities, page table capabilities, ASID pool capabilities, and VCPU capabilities.\n\n Arch-Specific Default Objects: Define the default objects for each object type, including data pages, page tables, VSpaces, and VCPUs.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "value_type vm_level = \"if config_ARM_PA_SIZE_BITS_40 then 4 else (5::int)\"\n\ndefinition asid_pool_level :: vm_level where\n  \"asid_pool_level = maxBound\"\n\ndefinition max_pt_level :: vm_level where\n  \"max_pt_level = asid_pool_level - 1\"\n\ndefinition level_type :: \"vm_level \\<Rightarrow> pt_type\" where\n  \"level_type level \\<equiv> if level = max_pt_level then VSRootPT_T else NormalPT_T\"\n\ndeclare [[coercion_enabled]]\ndeclare [[coercion level_type]]\n\nend\n\nqualify AARCH64_A (in Arch)", "property": "Virtual Memory Levels: Define the number of levels in the virtual memory tables for AARCH64 architecture, which is 4 or 5 depending on the configuration of ARM PA size bits. The levels are categorized into ASID pool level, top-level page tables, and bottom-level page tables containing InvalidPTEs or PagePTEs.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific state", "comment": "\n  The number of levels over all virtual memory tables.\n  For AARCH64 in hyp without @{const config_ARM_PA_SIZE_BITS_40}, we have four page table\n  levels plus the ASID pool level.\n\n  The top level (with the highest number) contains ASID pools, the next levels contain the\n  top-level page tables, and level 1 page tables. The bottom-level page tables (level 0)\n  contains only InvalidPTEs or PagePTEs.\n"}
{"spec": "record arch_state =\n  arm_asid_table :: \"asid_high_index \\<rightharpoonup> obj_ref\"\n  arm_kernel_vspace :: \"AARCH64_A.arm_vspace_region_uses\"\n  arm_vmid_table :: \"AARCH64_A.vmid \\<rightharpoonup> asid\"\n  arm_next_vmid :: AARCH64_A.vmid\n  arm_us_global_vspace :: \"obj_ref\"\n  arm_current_vcpu    :: \"(obj_ref \\<times> bool) option\"\n  arm_gicvcpu_numlistregs :: nat\n\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)", "property": "AARCH64 Architecture State: Maintains architecture-specific state information, including ASID table, kernel virtual space, VMID table, next VMID, user-space global virtual space, current VCPU state, and GIC VCPU number list registers.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable (a_pt_t : pt_type)\n  | AVCPU\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\" where\n  \"aa_type ao \\<equiv> case ao of\n     PageTable pt    \\<Rightarrow> APageTable (pt_type pt)\n   | DataPage dev sz \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n   | ASIDPool _      \\<Rightarrow> AASIDPool\n   | VCPU _          \\<Rightarrow> AVCPU\"\n\ndefinition badge_bits :: nat where\n  \"badge_bits \\<equiv> 64\"\n\nend", "property": "AArch64-Specific Data Types: Define data types specific to the AArch64 architecture, including types for ASID pools, page tables, VCPUs, user data, and device data, ensuring accurate representation and distinction of architectural objects.\nType Classification: Classify kernel objects into their respective AArch64-specific types based on their characteristics, such as page tables, data pages, ASID pools, and VCPUs, facilitating proper management and handling of these objects.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "qualify AARCH64_A (in Arch)", "property": "Arch-Specific TCB Properties: Define architecture-specific data types and structures for the AARCH64 architecture, including the VCPU (Virtual CPU) context within the Arch-specific TCB (Thread Control Block).", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Arch-specific TCB", "comment": ""}
{"spec": "record arch_tcb =\n  tcb_context :: user_context\n  tcb_vcpu    :: \"obj_ref option\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition default_arch_tcb :: arch_tcb where\n  \"default_arch_tcb \\<equiv> \\<lparr>tcb_context = new_context, tcb_vcpu = None\\<rparr>\"", "property": "Arch-Specific TCB Structure: The arch-specific part of a TCB contains fields for user context and an optional VCPU reference, ensuring that the TCB can manage user-level execution contexts and potentially associated VCPUs. \n\nDefault Arch-Specific TCB: The default arch-specific TCB has an initial user context and no associated VCPU.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Arch-specific TCB", "comment": " Arch-specific part of a TCB: this must have at least a field for user context. "}
{"spec": "definition arch_tcb_context_set :: \"user_context \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\" where\n  \"arch_tcb_context_set uc a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := uc \\<rparr>\"\n\ndefinition arch_tcb_context_get :: \"arch_tcb \\<Rightarrow> user_context\" where\n  \"arch_tcb_context_get a_tcb \\<equiv> tcb_context a_tcb\"", "property": "Arch TCB Context Accessors: Provide access to the user context within the architecture-specific TCB, enabling compatibility with user monad operations. \n\n Arch TCB Context Setter: Set the user context within the architecture-specific TCB.\n Arch TCB Context Getter: Retrieve the user context from the architecture-specific TCB.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n  Accessors for @{text \"tcb_context\"} inside @{text \"arch_tcb\"}. These are later used to\n  implement @{text as_user}, i.e.\\ need to be compatible with @{text user_monad}.\n"}
{"spec": "definition arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\" where\n  \"arch_tcb_set_registers regs a_tcb \\<equiv>\n    a_tcb \\<lparr> tcb_context := UserContext (fpu_state (tcb_context a_tcb)) regs \\<rparr>\"\n\ndefinition arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\" where\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\nend", "property": "Arch TCB Register Access: Provide access to the user register part of the arch_tcb, allowing for getting and setting the registers, while maintaining the integrity of the tcb_context and fpu_state.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n  Accessors for the user register part of the @{text \"arch_tcb\"}.\n  (Because @{typ \"register \\<Rightarrow> machine_word\"} might not be equal to @{typ user_context}).\n"}
{"spec": "chapter \\<open>Architecture-specific Fault-handling Functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\" where\n  \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData)\n   od\"\n| \"make_arch_fault_msg (VCPUFault hsr) thread = return (7, [hsr])\"\n| \"make_arch_fault_msg (VPPIEvent irq) thread = return (8, [ucast irq])\"\n| \"make_arch_fault_msg (VGICMaintenance archData) thread = do\n      msg \\<leftarrow> return $ (case archData of None \\<Rightarrow> [-1] | Some idx \\<Rightarrow> [idx]);\n      return (6, msg)\n   od\"\n\ndefinition handle_arch_fault_reply ::\n  \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\n  where\n  \"handle_arch_fault_reply vmf thread x y \\<equiv> return True\"\n\nend\nend", "property": "Architecture-specific Fault Handling: Provides functions for constructing architecture-specific fault messages and handling fault replies. The functions create messages with specific formats for different types of faults (VMFault, VCPUFault, VPPIEvent, VGICMaintenance) and allow for customized handling of fault replies.", "title": "./spec/abstract/AARCH64/ArchFault_A.thy", "chapter": "Architecture-specific Fault-handling Functions", "section": "", "comment": ""}
{"spec": "chapter \\<open>Architecture-specific TCB functions\\<close>\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\" where\n  \"sanitise_register b r v \\<equiv> case r of\n     SPSR_EL1 \\<Rightarrow> if b \\<and> v && 0x1f \\<in> {0,4,5} then v else v && 0xf0000000 || 0x140\n   | _ \\<Rightarrow> v\"\n\ndefinition arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\" where\n  \"arch_get_sanitise_register_info t \\<equiv> do\n     vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n     return (vcpu \\<noteq> None)\n   od\"\n\ndefinition arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\" where\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "TCB Register Management: Sanitizes and manages registers, including the SPSR_EL1 register, based on architecture-specific rules, ensuring the integrity and security of the system. \n\nSubproperties:\n- Sanitize Register: Modifies the SPSR_EL1 register value according to specific conditions, while leaving other registers unchanged.\n- Get Sanitise Register Info: Retrieves information about whether to sanitize registers based on the presence of a VCPU for a given thread.\n- Post Modify Registers: Performs any necessary actions after modifying registers, currently a no-op.", "title": "./spec/abstract/AARCH64/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "definition update_cnode_cap_data :: \"data \\<Rightarrow> nat \\<times> data\" where\n  \"update_cnode_cap_data w \\<equiv>\n     let\n       guard_bits = 58;\n       guard_size' = unat ((w >> cnode_padding_bits) && mask cnode_guard_size_bits);\n       guard'' = (w >> (cnode_padding_bits + cnode_guard_size_bits)) && mask guard_bits\n     in (guard_size', guard'')\"", "property": "CNode Capability Modification: Extract new guard bits and guard from user-provided data for modifying a CNode capability. \n\n Guard Size and Guard Extraction: Extract the guard size and guard from the user-provided data, considering the padding bits, guard size bits, and guard bits.", "title": "./spec/abstract/AARCH64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "On a user request to modify a CNode capability, extract new guard bits and guard."}
{"spec": "definition arch_is_physical :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_is_physical cap \\<equiv> case cap of ASIDControlCap \\<Rightarrow> False | _ \\<Rightarrow> True\"", "property": "Distinguish Physical Capabilities: Identify whether an architecture-specific capability is physical or not, with ASIDControlCap being treated as non-physical and all others as physical.", "title": "./spec/abstract/AARCH64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "For some purposes capabilities to physical objects are treated differently to others."}
{"spec": "fun arch_same_region_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n  \"arch_same_region_as (FrameCap r _ sz _ _) c' =\n   (is_FrameCap c' \\<and>\n     (let\n        r' = acap_obj c';\n        sz' = acap_fsize c';\n        topA = r + (1 << pageBitsForSize sz) - 1;\n        topB = r' + (1 << pageBitsForSize sz') - 1\n      in r \\<le> r' \\<and> topA \\<ge> topB \\<and> r' \\<le> topB))\"\n| \"arch_same_region_as (PageTableCap r pt_t _) c' = (\\<exists>r' d'. c' = PageTableCap r' pt_t d' \\<and> r = r')\"\n| \"arch_same_region_as ASIDControlCap c' = (c' = ASIDControlCap)\"\n| \"arch_same_region_as (ASIDPoolCap r _) c' = (\\<exists>r' d'. c' = ASIDPoolCap r' d' \\<and> r = r')\"\n| \"arch_same_region_as (VCPUCap r) c' = (\\<exists>r'. c' = VCPUCap r' \\<and> r = r')\"", "property": "Architectural Capability Region Check: Determine if two architectural capabilities refer to the same object or if one is contained within the region of the other, ensuring proper relationships between capabilities. \n\nSubproperties:\n- Frame Capabilities: Check if two frame capabilities overlap in their memory regions.\n- Page Table Capabilities: Verify if two page table capabilities refer to the same object.\n- ASID Control Capability: Check if the second capability is also an ASID control capability.\n- ASID Pool Capabilities: Verify if two ASID pool capabilities refer to the same object.\n- VCPU Capabilities: Check if two VCPU capabilities refer to the same object.", "title": "./spec/abstract/AARCH64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Check whether the second capability is to the same object or an object\n  contained in the region of the first one.\n"}
{"spec": "definition same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n  \"same_aobject_as cap cap' \\<equiv>\n     case (cap, cap') of\n       (FrameCap ref _ sz dev _, FrameCap ref' _ sz' dev' _) \\<Rightarrow>\n         (dev, ref, sz) = (dev', ref', sz') \\<and> ref \\<le> ref + 2 ^ pageBitsForSize sz - 1\n     | _ \\<Rightarrow> arch_same_region_as cap cap'\"\n\ndeclare same_aobject_as_def[simp]\n\ndefinition arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\" where\n  \"arch_is_cap_revocable new_cap src_cap \\<equiv> False\"\n\nend\nend", "property": "Arch Capability Equivalence: Two architecture-specific capabilities are considered equivalent if they refer to the same object, with matching device, reference, and size attributes for frame capabilities, and satisfying the same region condition for other capabilities. \n\nArch Capability Revocability: Architecture-specific capabilities are never considered revocable.", "title": "./spec/abstract/AARCH64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "type_synonym obj_ref         = machine_word\ntype_synonym vspace_ref      = machine_word\n\ntype_synonym data            = machine_word\ntype_synonym cap_ref         = \"bool list\"\ntype_synonym length_type     = machine_word\n\ntype_synonym asid_low_len    = 9\ntype_synonym asid_low_index  = \"asid_low_len word\"\n\ntype_synonym asid_high_len   = 7\ntype_synonym asid_high_index = \"asid_high_len word\"\n\ntype_synonym asid_len        = 16\ntype_synonym asid_rep_len    = asid_len\ntype_synonym asid            = \"asid_rep_len word\"\n\ntype_synonym vmid            = \"8 word\"", "property": "Type Instantiation for AARCH64 Architecture: \nType definitions for the AARCH64 architecture, including object references, virtual space references, data, capability references, length types, and address space identifiers (ASIDs), are instantiated to concrete types, such as machine words and word lists.\n\nSubproperties:\n- Object and Virtual Space References: Represented as machine words.\n- Data and Length Types: Also represented as machine words.\n- Capability References: Represented as lists of boolean values.\n- Address Space Identifiers (ASIDs): Comprise high and low indices, represented as words of specific lengths (7 and 9 bits respectively), and a full ASID represented as a 16-bit word.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object references, user pointers,\n  word-based data, cap references, and so on. This theory provides an instantiation of these names\n  to concrete types for the AARCH64 architecture. Other architectures may have slightly different\n  instantiations.\n"}
{"spec": "definition oref_to_data :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition data_to_oref :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition vref_to_data :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition data_to_vref :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition nat_to_len :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition data_to_nat :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition data_to_16 :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Provide identity conversions between abstract type names, and conversions from words to natural numbers, between different word sizes, and bit-wise operations for combining notification badges and messages.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  With the definitions above, most conversions between abstract type names boil down to just\n  the identity function, some convert from @{text word} to @{typ nat} and others between different\n  word sizes using @{const ucast}.\n"}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversions: Define conversions between different data types, including object references, virtual references, lengths, and capability pointers, to facilitate automatic unfolding in proofs.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition slot_bits :: nat where\n  \"slot_bits \\<equiv> 5\"\n\ndefinition msg_label_bits :: nat where\n  [simp]: \"msg_label_bits \\<equiv> 52\"\n\ndefinition new_context :: \"user_context\" where\n  \"new_context \\<equiv> UserContext (FPUState (\\<lambda>_. 0) 0 0) ((\\<lambda>_. 0) (SPSR_EL1 := pstateUser))\"", "property": "Architecture-Dependent Sizes: Define the sizes of various architecture-dependent components, including the slot size and message label size. \n\nSubproperties:\n- Slot Size: The slot size is fixed at 5 bits.\n- Message Label Size: The message label size is fixed at 52 bits.\n- Initial User Context: The initial user context is defined with default values for the FPU state and register values.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The following definitions provide architecture-dependent sizes such as the standard page\n  size and capability size of the underlying machine.\n"}
{"spec": "definition pptr_base :: \"machine_word\" where\n  \"pptr_base = Platform.AARCH64.pptrBase\"\n\ntext \"Virtual address space available to users.\"\ndefinition user_vtop :: \"machine_word\" where\n  \"user_vtop = Platform.AARCH64.pptrUserTop\"", "property": "Kernel Window Boundaries: Define the lowest virtual address in the kernel window and the upper limit of the virtual address space available to users.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The lowest virtual address in the kernel window. The kernel reserves the virtual addresses\n  from here up in every virtual address space.\n"}
{"spec": "definition kdev_base :: \"machine_word\" where\n  \"kdev_base = Platform.AARCH64.kdevBase\"", "property": "Kernel Device Mapping Region: The virtual address for the start of the kernel device mapping region is located in the highest 1GiB of memory.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  Virtual address for start of kernel device mapping region in highest 1GiB of memory.\n"}
{"spec": "definition kernel_elf_base :: \"vspace_ref\" where\n  \"kernel_elf_base \\<equiv> Platform.AARCH64.kernelELFBase\"", "property": "Kernel ELF Base Address: The kernel ELF base address is set to a specific virtual address, providing a fixed location for the kernel code in the virtual address space.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The virtual address the kernel code is mapped.\n"}
{"spec": "definition idle_thread_ptr :: vspace_ref where\n  \"idle_thread_ptr = pptr_base + 0x1000\"\n\n\ndefinition nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\" where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len) (to_bl (of_nat n :: machine_word))\"\n\ndefinition msg_info_register :: register where\n  \"msg_info_register \\<equiv> msgInfoRegister\"\n\ndefinition msg_registers :: \"register list\" where\n  \"msg_registers \\<equiv> msgRegisters\"\n\ndefinition cap_register :: register where\n  \"cap_register \\<equiv> capRegister\"\n\ndefinition badge_register :: register where\n  \"badge_register \\<equiv> badgeRegister\"\n\ndefinition frame_registers :: \"register list\" where\n  \"frame_registers \\<equiv> frameRegisters\"\n\ndefinition gp_registers :: \"register list\" where\n  \"gp_registers \\<equiv> gpRegisters\"\n\ndefinition exception_message :: \"register list\" where\n  \"exception_message \\<equiv> exceptionMessage\"\n\ndefinition syscall_message :: \"register list\" where\n  \"syscall_message \\<equiv> syscallMessage\"\n\ndatatype arch_fault\n  = VMFault (vm_fault_address : vspace_ref) (vm_fault_arch_data : \"machine_word list\")\n  | VCPUFault (vcpu_hsr : data)\n  | VPPIEvent (vppi_irq : irq)\n  | VGICMaintenance (vgic_maintenance_data : \"data option\")\n\n\nend\n\narch_requalify_consts (A) idle_thread_ptr\n\nend", "property": "Constant Definitions: Define various constants for the system, including the idle thread pointer, register names, and architectural fault types, providing a foundation for the system's configuration and behavior.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  Currently an arbitrary aligned address for the idle thread.\n  Only has to exist, does not have to match up with the concrete value in C.\n"}
{"spec": "consts\n  register_mask :: \"machine_word option\" (* no need for option? *)\n\n\ncontext Arch begin arch_global_naming (A)", "property": "Register Write Masking: Preserve specific bits in registers by masking them during write operations, ensuring that certain parts of the registers remain unchanged and cannot be modified by the user.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": "\n  Some parts of some registers cannot be written by the user.\n  Bits set in the mask will be preserved (used in vcpu\\_write\\_register).\n"}
{"spec": "text \\<open>\n  This is used by some decode functions. VCPU decode functions are the first that need to bounds\n  check IRQs from the user.\n  \\<close>\n\ndefinition\n  arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"arch_check_irq irq \\<equiv> whenE (irq > maxIRQ) $ throwError (RangeError 0 maxIRQ)\"", "property": "IRQ Validation: Ensure that the IRQ value is within the valid range (0 to maxIRQ). If the IRQ value exceeds the maximum allowed value, throw a RangeError.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition decode_vcpu_set_tcb :: \"arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere \"decode_vcpu_set_tcb cap extras \\<equiv> case (cap, extras) of\n  (VCPUCap v, fs#_) \\<Rightarrow> (case fs of\n        (ThreadCap t, _) \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUSetTCB v t\n      | _ \\<Rightarrow> throwError IllegalOperation)\n |(VCPUCap v, _) \\<Rightarrow> throwError TruncatedMessage\n | _ \\<Rightarrow> throwError IllegalOperation\"", "property": "VCPU Invocation Decoding: Validate and decode the VCPU set TCB invocation, ensuring that the provided capability and extra arguments match the expected format for setting a TCB for a VCPU.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  read_vcpu_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (machine_word,'z::state_ext) s_monad\"\nwhere\n  \"read_vcpu_register vcpu_ptr reg \\<equiv> do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     (on_cur_vcpu, active) \\<leftarrow> return (case cur_vcpu of\n         Some (vcpu_ptr', a) \\<Rightarrow> (vcpu_ptr' = vcpu_ptr, a)\n       | _ \\<Rightarrow> (False, False));\n\n     if on_cur_vcpu\n       then if vcpuRegSavedWhenDisabled reg \\<and> \\<not>active\n              then vcpu_read_reg vcpu_ptr reg\n              else do_machine_op $ readVCPUHardwareReg reg\n       else vcpu_read_reg vcpu_ptr reg\n  od\"\n\ndefinition\n  write_vcpu_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"write_vcpu_register vcpu_ptr reg val \\<equiv>\n  do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu o arch_state);\n     (on_cur_vcpu, active) \\<leftarrow> return (case cur_vcpu of\n         Some (cv, a) \\<Rightarrow> (cv = vcpu_ptr, a)\n       | _ \\<Rightarrow> (False, False));\n\n     if on_cur_vcpu\n       then if vcpuRegSavedWhenDisabled reg \\<and> \\<not>active\n         then vcpu_write_reg vcpu_ptr reg val\n         else do_machine_op $ writeVCPUHardwareReg reg val\n       else vcpu_write_reg vcpu_ptr reg val\n  od\"\n\ndefinition decode_vcpu_read_register :: \"machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_vcpu_read_register args cap \\<equiv> case (args, cap) of\n      (reg#_, VCPUCap p) \\<Rightarrow> if fromEnum (maxBound::vcpureg) < unat reg\n                           then throwError (InvalidArgument 1)\n                           else returnOk $ InvokeVCPU $ VCPUReadRegister p $ toEnum (unat reg)\n    | (_, _) \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition decode_vcpu_write_register :: \"machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_vcpu_write_register args cap \\<equiv> case (args, cap) of\n    (reg#val#_, VCPUCap p) \\<Rightarrow> if fromEnum (maxBound::vcpureg) < unat reg\n                              then throwError (InvalidArgument 1)\n                              else returnOk $ InvokeVCPU $ VCPUWriteRegister p (toEnum (unat reg)) val\n  | (_, _) \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_read_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\nwhere \"invoke_vcpu_read_register v reg \\<equiv> do\n   val \\<leftarrow> read_vcpu_register v reg;\n   return [val]\nod\"\n\ndefinition\n  invoke_vcpu_write_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"invoke_vcpu_write_register v reg val \\<equiv>  write_vcpu_register v reg val\"", "property": "VCPU Register Access: Provide controlled access to read and write VCPU registers, handling both the current VCPU and other VCPUs, with consideration for register state when the VCPU is disabled. \n\nSubproperties:\n- Read VCPU Register: Read a VCPU register, either from the VCPU state if it's the current VCPU and the register is saved when disabled, or directly from the hardware.\n- Write VCPU Register: Write to a VCPU register, either updating the VCPU state if it's the current VCPU and the register is saved when disabled, or directly writing to the hardware.\n- Decode VCPU Read/Write Register: Validate and decode the arguments for reading or writing a VCPU register, ensuring the register index is within bounds and returning an error for invalid arguments or truncated messages.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition make_virq :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> virq\" where\n  \"make_virq grp prio irq \\<equiv>\n  let\n    groupShift = 30;\n    prioShift = 23;\n    irqPending = 1 << 28;\n    eoiirqen = 1 << 19\n  in ((grp && 1) << groupShift) || ((prio && 0x1F) << prioShift) || (irq && 0x3FF) || irqPending || eoiirqen\"\n\n\ndefinition decode_vcpu_inject_irq :: \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_vcpu_inject_irq ptrs cap \\<equiv> case (ptrs, cap) of\n  (mr0 # mr1 # _, VCPUCap p) \\<Rightarrow> doE\n     vid \\<leftarrow> returnOk (mr0 && 0xFFFF);\n     priority \\<leftarrow> returnOk ((mr0 >> 16) && 0xFF);\n     group \\<leftarrow> returnOk ((mr0 >> 24) && 0xFF);\n     index \\<leftarrow> returnOk (mr1 && 0xFF);\n     range_check vid 0 ((1 << 10) - 1);\n     range_check priority 0 31;\n     range_check group 0 1;\n     num_list_regs \\<leftarrow> liftE $ gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     whenE (index \\<ge> of_nat num_list_regs) $\n        (throwError $ RangeError 0 (of_nat num_list_regs - 1));\n\n     vcpu \\<leftarrow> liftE $ get_vcpu p;\n     vcpuLR \\<leftarrow> returnOk (vgic_lr $ vcpu_vgic $ vcpu);\n\n     whenE (vcpuLR (unat index) && vgic_irq_mask = vgic_irq_active) $ throwError DeleteFirst;\n\n     virq \\<leftarrow> returnOk (make_virq group priority vid);\n     returnOk $ InvokeVCPU $ VCPUInjectIRQ p (unat index) virq\n  odE\n| _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition\n  invoke_vcpu_inject_irq :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> virq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"invoke_vcpu_inject_irq vr index virq \\<equiv> do\n    cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n    if (cur_v \\<noteq> None \\<and> fst (the cur_v) = vr)\n    then do_machine_op $ set_gic_vcpu_ctrl_lr (of_nat index) virq\n    else vgic_update_lr vr index virq\n   od\"", "property": "VCPU IRQ Injection: Inject a virtual IRQ into a VCPU, handling the injection process based on whether the VCPU is currently active. If the VCPU is active, directly set the GIC VCPU control register; otherwise, update the VCPU's LR register.\n\nSubproperties:\n- VCPU IRQ Construction: Construct a virtual IRQ value from group, priority, and IRQ number inputs, incorporating pending and enable flags.\n- VCPU IRQ Injection Validation: Validate the inputs for VCPU IRQ injection, ensuring that the index, priority, and group values are within valid ranges and that the target VCPU list register is not currently active.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": " This following function does not correspond to exactly what the C does, but\nit is the value that is stored inside of lr in the vgic  "}
{"spec": "definition decode_vcpu_ack_vppi ::\n  \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_ack_vppi mrs cap \\<equiv>\n     case (mrs, cap)\n       of (mr0 # _, VCPUCap vcpu_ptr) \\<Rightarrow> doE\n           arch_check_irq mr0;\n           (case irq_vppi_event_index (ucast mr0)\n            of None \\<Rightarrow> throwError $ InvalidArgument 0\n             | Some vppi \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUAckVPPI vcpu_ptr vppi)\n         odE\n       | _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_ack_vppi :: \"obj_ref \\<Rightarrow> vppievent_irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"invoke_vcpu_ack_vppi vcpu_ptr vppi =\n     vcpu_update vcpu_ptr\n                 (\\<lambda>vcpu. vcpu\\<lparr> vcpu_vppi_masked := (vcpu_vppi_masked vcpu)(vppi := False) \\<rparr>)\"", "property": "VCPU Acknowledge VPPI: Allows the VCPU to acknowledge a VPPI (Virtual Processor Pending Interrupt) event, updating the VCPU's VPPI mask to reflect the acknowledgement. \n\nSubproperty: Validate the VPPI event index, ensuring it is a valid interrupt request before proceeding with the acknowledgement.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": "VCPU : acknowledge VPPI"}
{"spec": "definition\nperform_vcpu_invocation :: \"vcpu_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n\"perform_vcpu_invocation iv \\<equiv> case iv of\n    VCPUSetTCB vcpu tcb \\<Rightarrow> do associate_vcpu_tcb vcpu tcb; return [] od\n  | VCPUReadRegister vcpu reg \\<Rightarrow> invoke_vcpu_read_register vcpu reg\n  | VCPUWriteRegister vcpu reg val \\<Rightarrow> do invoke_vcpu_write_register vcpu reg val; return [] od\n  | VCPUInjectIRQ vcpu index vir \\<Rightarrow> do invoke_vcpu_inject_irq vcpu index vir; return [] od\n  | VCPUAckVPPI vcpu vppi \\<Rightarrow> do invoke_vcpu_ack_vppi vcpu vppi; return [] od\"\n\n\ndefinition decode_vcpu_invocation ::\n\"machine_word \\<Rightarrow> machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_vcpu_invocation label args cap extras \\<equiv> case cap of\nVCPUCap _ \\<Rightarrow> (case invocation_type label of\n    ArchInvocationLabel ARMVCPUSetTCB \\<Rightarrow> decode_vcpu_set_tcb cap extras\n  | ArchInvocationLabel ARMVCPUReadReg \\<Rightarrow> decode_vcpu_read_register args cap\n  | ArchInvocationLabel ARMVCPUWriteReg \\<Rightarrow> decode_vcpu_write_register args cap\n  | ArchInvocationLabel ARMVCPUInjectIRQ \\<Rightarrow> decode_vcpu_inject_irq args cap\n  | ArchInvocationLabel ARMVCPUAckVPPI \\<Rightarrow> decode_vcpu_ack_vppi args cap\n  |  _ \\<Rightarrow> throwError IllegalOperation)\n| _ \\<Rightarrow> throwError IllegalOperation\"\n\nend\n\nend", "property": "VCPU Invocation Management: Perform and decode VCPU-related functions, including setting the TCB for a VCPU, reading and writing VCPU registers, injecting IRQs, and acknowledging VPPIs. Ensure that VCPU invocations are properly decoded and executed, maintaining the integrity and functionality of the VCPU. \n\nSubproperties:\n- Set TCB for VCPU: Associate a TCB with a VCPU, ensuring proper thread management.\n- Read/Write VCPU Registers: Perform read and write operations on VCPU registers, facilitating data exchange and VCPU management.\n- Inject IRQs: Inject interrupts into the VCPU, enabling interrupt handling and processing.\n- Acknowledge VPPIs: Acknowledge VCPU-specific events, ensuring proper event handling and VCPU operation.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": "VCPU perform and decode main functions"}
{"spec": "definition\n  virqSetEOIIRQEN :: \"virq \\<Rightarrow> 32 word \\<Rightarrow> virq\"\nwhere\n  \"virqSetEOIIRQEN virq v =\n    (if ((virq >> 28) && 3 = 3)\n    then virq\n    else (virq && ~~0x80000) || ((v << 19) && 0x80000))\"\n\ndefinition\n  vgic_maintenance :: \"(unit,'z::state_ext) s_monad\"\nwhere\n  \"vgic_maintenance = do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     case cur_vcpu\n       of Some (vcpu_ptr, True) \\<Rightarrow> do\n            eisr0 \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_eisr0;\n            eisr1 \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_eisr1;\n            flags \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_misr;\n            vgic_misr_eoi \\<leftarrow> return $ 1;\n            irq_idx \\<leftarrow> return (if eisr0 \\<noteq> 0 then word_ctz eisr0 else word_ctz eisr1 + 32);\n            gic_vcpu_num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs o arch_state);\n            fault \\<leftarrow> if flags && vgic_misr_eoi \\<noteq> 0\n                    then\n                      if eisr0 = 0 \\<and> eisr1 = 0 \\<or> irq_idx \\<ge> gic_vcpu_num_list_regs\n                      then return $ VGICMaintenance None\n                      else do\n                        virq <- do_machine_op $ get_gic_vcpu_ctrl_lr (of_nat irq_idx);\n                        virqen <- return $ virqSetEOIIRQEN virq 0;\n                        do_machine_op $ set_gic_vcpu_ctrl_lr (of_nat irq_idx) virqen;\n                        vgic_update_lr vcpu_ptr irq_idx virqen;\n                        return $ VGICMaintenance $ Some $ of_nat irq_idx\n                      od\n                    else return $ VGICMaintenance None;\n\n            ct \\<leftarrow> gets cur_thread;\n            st \\<leftarrow> get_thread_state ct;\n            \\<comment> \\<open>until a proof links active current vcpu to runnable current thread, we need this\n               check: @{term handle_fault} needs a runnable current thread\\<close>\n            when (runnable st) $ handle_fault ct $ ArchFault fault\n          od\n        | _ \\<Rightarrow> return ()\n   od\"\n\ndefinition vppi_event :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vppi_event irq = do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     case cur_vcpu\n       of Some (vcpu_ptr, True) \\<Rightarrow> do\n            do_machine_op $ maskInterrupt True irq;\n            vppi \\<leftarrow> return $ the $ irq_vppi_event_index irq;\n            vcpu_update vcpu_ptr\n                        (\\<lambda>vcpu. vcpu\\<lparr> vcpu_vppi_masked := (vcpu_vppi_masked vcpu)(vppi := True) \\<rparr>);\n            ct \\<leftarrow> gets cur_thread;\n            st \\<leftarrow> get_thread_state ct;\n            \\<comment> \\<open>until a proof links active current vcpu to runnable current thread, we need this\n               check: @{term handle_fault} needs a runnable current thread\\<close>\n            when (runnable st) $ handle_fault ct $ ArchFault $ VPPIEvent irq\n          od\n        | _ \\<Rightarrow> return ()\n   od\"\n\ndefinition\n  handle_reserved_irq :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_reserved_irq irq \\<equiv>\n     if irq = irqVGICMaintenance then vgic_maintenance\n     else if irq_vppi_event_index irq \\<noteq> None then vppi_event irq\n     else return ()\"\n\nfun arch_invoke_irq_handler :: \"irq_handler_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"arch_invoke_irq_handler (ACKIrq irq) = (do_machine_op $ maskInterrupt False irq)\"\n| \"arch_invoke_irq_handler _ = return ()\"\n\ndefinition arch_mask_irq_signal :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"arch_mask_irq_signal irq \\<equiv> do_machine_op $ maskInterrupt True irq\"\n\nend\n\nend", "property": "VGIC Maintenance: Perform maintenance operations for the Virtual Generic Interrupt Controller (VGIC), including handling EOI (End of Interrupt) and IRQ (Interrupt Request) events, updating the VGIC state, and notifying the current thread of faults.\n\nSubproperties:\n- Handle EOI events by updating the VGIC state and notifying the current thread of faults.\n- Handle IRQ events by updating the VGIC state, masking interrupts, and notifying the current thread of faults.\n- Perform VGIC maintenance operations only when the current VCPU is active.\n- Ensure that the current thread is runnable before handling faults.", "title": "./spec/abstract/ARM_HYP/ArchInterrupt_A.thy", "chapter": "", "section": "", "comment": "VGIC Maintenance"}
{"spec": "definition\n  arch_switch_to_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_switch_to_thread t \\<equiv> do\n     t' \\<leftarrow> gets_the $ get_tcb t;\n     vcpu_switch $ tcb_vcpu $ tcb_arch t';\n     set_vm_root t;\n     do_machine_op $ clearExMonitor\n   od\"", "property": "Thread Context Switching: Switch to a thread's virtual address space context, ensuring the correct virtual CPU and virtual machine root are set, and clear the load-exclusive monitor to maintain consistency and prevent data corruption.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "Switch to a thread's virtual address space context. Clear the load-exclusive monitor."}
{"spec": "definition\n   arch_switch_to_idle_thread :: \"(unit,'z::state_ext) s_monad\" where\n   \"arch_switch_to_idle_thread \\<equiv> do\n     vcpu_switch None;\n     t \\<leftarrow> gets idle_thread;\n     set_vm_root t\n   od\"\n\ndefinition\n  arch_activate_idle_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_activate_idle_thread t \\<equiv> return ()\"", "property": "Idle Thread Management: Ensure the idle thread is properly managed during architectural switches and activation. This involves switching to the idle thread, setting the virtual machine root, and activating the idle thread without requiring special handling on ARM architecture.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The idle thread does not need to be handled specially on ARM."}
{"spec": "definition\nperform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_control_invocation iv \\<equiv> case iv of\n  MakePool frame slot parent base \\<Rightarrow> do\n    delete_objects frame page_bits;\n    pcap \\<leftarrow> get_cap parent;\n    set_cap (max_free_index_update pcap) parent;\n    retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n    cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n    assert (base && mask asid_low_bits = 0);\n    asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n    modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>arm_asid_table := asid_table'\\<rparr>\\<rparr>)\nod\"", "property": "ASID Control Invocation: Create a new ASID pool object, provide a capability to it, and connect it to the global virtual ASID table. \n\nSubproperties:\n- Delete objects in the specified frame.\n- Update the parent capability with the maximum free index.\n- Retype the specified region to an ASID pool object.\n- Insert the new ASID pool capability into the specified slot.\n- Update the ASID table with the new ASID pool mapping.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDControl capability confers the authority to create a new ASID\npool object. This operation creates the new ASID pool, provides a capability\nto it and connects it to the global virtual ASID table."}
{"spec": "definition\nperform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_pool_invocation iv \\<equiv> case iv of Assign asid pool_ptr ct_slot \\<Rightarrow>\ndo\n    pd_cap \\<leftarrow> get_cap ct_slot;\n    case pd_cap of\n      ArchObjectCap (PageDirectoryCap pd_base _) \\<Rightarrow> do\n        pool \\<leftarrow> get_asid_pool pool_ptr;\n        pool' \\<leftarrow> return (pool (ucast asid \\<mapsto> pd_base));\n        set_cap (ArchObjectCap $ PageDirectoryCap pd_base (Some asid)) ct_slot;\n        set_asid_pool pool_ptr pool'\n      od\n    | _ \\<Rightarrow> fail\nod\"", "property": "ASID Pool Invocation: Assign a virtual ASID to a page directory, updating the ASID pool and the page directory capability accordingly. \n\nSubproperties:\n- Retrieve the page directory capability from the specified slot.\n- Update the ASID pool with the new assignment.\n- Set the page directory capability with the assigned ASID.\n- Update the ASID pool with the new mapping.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign a virtual ASID\nto a page directory."}
{"spec": "definition\n  perform_page_directory_invocation :: \"page_directory_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"perform_page_directory_invocation iv \\<equiv> case iv of\n       PageDirectoryFlush typ start end pstart pd asid \\<Rightarrow>\n         when (start < end) $ do\n           root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n           do_machine_op $ do_flush typ start end pstart;\n           when root_switched $ do\n             tcb \\<leftarrow> gets cur_thread;\n             set_vm_root tcb\n           od\n        od\n     | PageDirectoryNothing \\<Rightarrow> return ()\"\n\ndefinition\n  pte_check_if_mapped :: \"32 word \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pte_check_if_mapped slot \\<equiv> do\n     pt \\<leftarrow> get_master_pte slot;\n     return (pt \\<noteq> InvalidPTE)\n  od\"\n\ndefinition\n  pde_check_if_mapped :: \"32 word \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pde_check_if_mapped slot \\<equiv> do\n     pd \\<leftarrow> get_master_pde slot;\n     return (pd \\<noteq> InvalidPDE)\n  od\"", "property": "Page Directory Invocation: Flush cache entries associated with a page directory, ensuring cache consistency and coherence. \n\nCache Management: Check if a page table entry or page directory entry is mapped, verifying the validity of the memory mapping.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The PageDirectory capability confers the authority to flush cache entries\nassociated with that PD"}
{"spec": "definition\nperform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n\"perform_page_invocation iv \\<equiv> case iv of\n  PageMap asid cap ct_slot entries \\<Rightarrow> do\n    set_cap cap ct_slot;\n    case entries of\n          Inl (pte, slots) \\<Rightarrow> do\n            flush \\<leftarrow> pte_check_if_mapped (hd slots);\n            store_pte (hd slots) pte;\n            mapM (swp store_pte InvalidPTE) (tl slots);\n            do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pte (last slots))\n                                                (addrFromPPtr (hd slots));\n            if flush then (invalidate_tlb_by_asid asid) else return ()\n          od\n        | Inr (pde, slots) \\<Rightarrow> do\n            flush \\<leftarrow> pde_check_if_mapped (hd slots);\n            store_pde (hd slots) pde;\n            mapM (swp store_pde InvalidPDE) (tl slots);\n            do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pde (last slots))\n                                                (addrFromPPtr (hd slots));\n            if flush then (invalidate_tlb_by_asid asid) else return ()\n          od;\n    return []\n  od\n| PageUnmap cap ct_slot \\<Rightarrow>\n    (case cap of\n      PageCap dev p R vp_size vp_mapped_addr \\<Rightarrow> do\n        case vp_mapped_addr of\n            Some (asid, vaddr) \\<Rightarrow> unmap_page vp_size asid vaddr p\n          | None \\<Rightarrow> return ();\n        cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n        set_cap (ArchObjectCap $ update_map_data cap None) ct_slot;\n        return []\n      od\n    | _ \\<Rightarrow> fail)\n| PageFlush typ start end pstart pd asid \\<Rightarrow> do\n    when (start < end) $ do\n      root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n      do_machine_op $ do_flush typ start end pstart;\n      when root_switched $ do\n        tcb \\<leftarrow> gets cur_thread;\n        set_vm_root tcb\n      od\n    od;\n    return []\n  od\n| PageGetAddr ptr \\<Rightarrow>\n    return [addrFromPPtr ptr]\n  \"", "property": "Page Management: Authorize and perform actions on memory pages, including mapping, unmapping, and flushing, while maintaining cache and TLB consistency. \n\nSubproperties:\n- Page Mapping: Map a page into a virtual address space, handling PTE and PDE updates, cache cleaning, and TLB invalidation as necessary.\n- Page Unmapping: Unmap a page from a virtual address space, updating the page's mapped address and capability.\n- Page Flushing: Flush a range of pages, handling root switching, cache flushing, and TLB invalidation as necessary.\n- Page Address Retrieval: Retrieve the physical address of a page.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The Page capability confers the authority to map, unmap and flush the\n  memory page."}
{"spec": "definition\nperform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_page_table_invocation iv \\<equiv>\ncase iv of PageTableMap cap ct_slot pde pd_slot \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pde pd_slot pde;\n    do_machine_op $ cleanByVA_PoU pd_slot (addrFromPPtr pd_slot)\n  od\n  | PageTableUnmap (ArchObjectCap (PageTableCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_page_table asid vaddr p;\n      slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + (1 << pt_bits) - 1];\n      mapM_x (swp store_pte InvalidPTE) slots;\n      do_machine_op $ cleanCacheRange_PoU p (p + (1 << pt_bits) - 1)\n                                          (addrFromPPtr p)\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"", "property": "Page Table Invocation: Authorize page table mapping and unmapping operations, ensuring the correct configuration of page tables and the underlying memory. \n\nMap Page Table: Set the page table capability, store the page directory entry, and clean the cache for the affected virtual address range.\nUnmap Page Table: Remove the page table mapping, invalidate the page table entries, and clean the cache for the affected virtual address range.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page\ntables."}
{"spec": "definition\n  arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\" where\n  \"arch_perform_invocation i \\<equiv> liftE $\n    case i of\n          InvokePageTable oper \\<Rightarrow> do perform_page_table_invocation oper; return [] od\n        | InvokePageDirectory oper \\<Rightarrow> do perform_page_directory_invocation oper; return [] od\n        | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n        | InvokeASIDControl oper \\<Rightarrow> do perform_asid_control_invocation oper; return [] od\n        | InvokeASIDPool oper \\<Rightarrow> do perform_asid_pool_invocation oper; return [] od\n        | InvokeVCPU oper \\<Rightarrow> perform_vcpu_invocation oper\"\n\nend\n\nend", "property": "ARM-Specific System Call Dispatch: Dispatch ARM-specific system calls to their corresponding invocation handlers, including page table, page directory, page, ASID control, ASID pool, and VCPU invocations.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call despatcher for all ARM-specific system calls."}
{"spec": "chapter \"Handle Hypervisor Fault Event\"\n\ntheory Hypervisor_A\nimports Ipc_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"word32 \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n\"handle_hypervisor_fault thread (ARMVCPUFault hsr) =\n   handle_fault thread (ArchFault $ VCPUFault hsr)\"\n\n\nend\nend", "property": "Handle Hypervisor Fault Event: Handle a hypervisor fault event by converting it into an architecture-specific fault and then handling it as a regular fault.", "title": "./spec/abstract/ARM_HYP/Hypervisor_A.thy", "chapter": "Handle Hypervisor Fault Event", "section": "", "comment": ""}
{"spec": "definition\n  reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Memory Region Reservation: Reserve a memory region with the specified pointer, byte length, and kernel designation, currently a no-op placeholder for potential future extension to explicitly tag kernel data regions in memory.", "title": "./spec/abstract/ARM_HYP/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory."}
{"spec": "definition vs_apiobj_size where\n  \"vs_apiobj_size ty \\<equiv>\n     case ty of\n       ArchObject SmallPageObj \\<Rightarrow> pageBitsForSize ARMSmallPage\n     | ArchObject LargePageObj \\<Rightarrow> pageBitsForSize ARMLargePage\n     | ArchObject SectionObj \\<Rightarrow> pageBitsForSize ARMSection\n     | ArchObject SuperSectionObj \\<Rightarrow> pageBitsForSize ARMSuperSection\n     | ArchObject PageTableObj \\<Rightarrow> pt_bits\n     | ArchObject PageDirectoryObj \\<Rightarrow> pd_bits\"\n\ndefinition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv> do\n     when (new_type = ArchObject PageDirectoryObj) $ mapM_x copy_global_mappings refs;\n     if \\<not>is_device \\<and>\n        new_type \\<in> {ArchObject SmallPageObj, ArchObject LargePageObj,\n                    ArchObject SectionObj, ArchObject SuperSectionObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_RAM ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else if new_type \\<in> {ArchObject PageTableObj, ArchObject PageDirectoryObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_PoU ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else\n       return ()\n   od\"\n\ndefinition\n  empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context, tcb_vcpu = None \\<rparr>\"\n\nend\n\nend", "property": "Initialise Architecture-Specific Objects: \nInitialise architecture-specific objects, including page tables, page directories, and various types of page objects, ensuring correct configuration and cache management for these objects.\nSubproperties:\nCache Management: Clean the cache range for page objects and page tables/directories to ensure data consistency and prevent cache-related issues.\nPage Table/Directory Configuration: Copy global mappings for page directories and configure page tables/directories according to architecture-specific requirements.\nTCB Initialisation: Initialise the architecture-specific components of a TCB (Thread Control Block), including the user context and vcpu (virtual CPU) settings.", "title": "./spec/abstract/ARM_HYP/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition\n  arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arch_post_cap_deletion _ \\<equiv> return ()\"", "property": "Post-Capability Deletion: No specific actions are taken after a capability is deleted.", "title": "./spec/abstract/ARM_HYP/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = unit\n\ndefinition\n  arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\"\nwhere\n  \"arch_gen_obj_refs _ = {}\"\n\ndefinition\n  arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_cap_cleanup_opt ac \\<equiv> NullCap\"\n\nend\nend", "property": "Architectural Generic Object References: Provide an empty set of architectural generic object references for each architectural capability, indicating that no additional references are required beyond the generic references. \n\nArchitectural Capability Cleanup: Clean up architectural capabilities by replacing them with a null capability, effectively removing any architectural-specific information.", "title": "./spec/abstract/ARM_HYP/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition\n  init_tcb_ptr :: word32 where\n  \"init_tcb_ptr = kernel_base + 0x2000\"\n\ndefinition\n  init_irq_node_ptr :: word32 where\n  \"init_irq_node_ptr = kernel_base + 0x8000\"\n\ndefinition\n  init_globals_frame :: word32 where\n  \"init_globals_frame = kernel_base + 0x5000\"\n\ndefinition\n  \"us_global_pd_ptr = kernel_base + 0x60000\"\n\ndefinition\n  \"init_arch_state \\<equiv> \\<lparr>\n    arm_asid_table = Map.empty,\n    arm_hwasid_table = Map.empty,\n    arm_next_asid = 0,\n    arm_asid_map = Map.empty,\n    arm_current_vcpu = None,\n    arm_gicvcpu_numlistregs = undefined,\n    arm_kernel_vspace = (\\<lambda>ref.\n      if ref \\<in> {kernel_base .. kernel_base + mask 20}\n      then ArmVSpaceKernelWindow\n      else ArmVSpaceInvalidRegion),\n    arm_us_global_pd = us_global_pd_ptr\n  \\<rparr>\"\n\ndefinition [simp]: \"us_global_pd \\<equiv> ArchObj (PageDirectory (\\<lambda>_. InvalidPDE))\"\n\ndefinition\n  \"init_kheap \\<equiv>\n  (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n       then Some (CNode 0 (empty_cnode 0)) else None)\n  (idle_thread_ptr \\<mapsto> TCB \\<lparr>\n    tcb_ctable = NullCap,\n    tcb_vtable = NullCap,\n    tcb_reply = NullCap,\n    tcb_caller = NullCap,\n    tcb_ipcframe = NullCap,\n    tcb_state = IdleThreadState,\n    tcb_fault_handler = replicate word_bits False,\n    tcb_ipc_buffer = 0,\n    tcb_fault = None,\n    tcb_bound_notification = None,\n    tcb_mcpriority = minBound,\n    tcb_arch = init_arch_tcb\n  \\<rparr>,\n  us_global_pd_ptr \\<mapsto> us_global_pd)\"\n\ndefinition\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. Structures_A.IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\n\n\nend", "property": "Initialization Properties: \nKernel Objects Layout: The kernel objects, including the idle thread, initial TCB, IRQ node, and global frames, are placed at specific addresses within the kernel's base address space.\nInitial Kernel State: The initial kernel state is defined, including the kernel heap, capability derivation tree, original capability mapping, current thread, idle thread, machine state, interrupt node mappings, interrupt states, and architecture-specific state. This ensures that the kernel is properly initialized and ready for execution.", "title": "./spec/abstract/ARM_HYP/Init_A.thy", "chapter": "", "section": "", "comment": " Moved to Deterministic_A\ndefinition\n  idle_thread_ptr :: word32 where\n  \"idle_thread_ptr = kernel_base + 0x1000\"\n"}
{"spec": "definition largePagePTE_offsets :: \"obj_ref list\"\n  where\n  \"largePagePTE_offsets \\<equiv>\n    let pts = of_nat pte_bits\n    in [0, 2 ^ pts  .e.  (15 << pte_bits)]\"\n\ndefinition superSectionPDE_offsets :: \"obj_ref list\"\n  where\n  \"superSectionPDE_offsets \\<equiv>\n    let pts = of_nat pde_bits\n    in [0, 2 ^ pts  .e.  (15 << pde_bits)]\"\n\nfun create_mapping_entries ::\n  \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vm_rights \\<Rightarrow> vm_attributes \\<Rightarrow> word32 \\<Rightarrow>\n  ((pte * word32 list) + (pde * word32 list),'z::state_ext) se_monad\"\nwhere\n  \"create_mapping_entries base vptr ARMSmallPage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (SmallPagePTE base attrib vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMLargePage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (LargePagePTE base attrib vm_rights, map (\\<lambda>x. x + p) largePagePTE_offsets)\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SectionPDE base attrib vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSuperSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SuperSectionPDE base attrib vm_rights, map (\\<lambda>x. x + p) superSectionPDE_offsets)\n  odE\"\n\ndefinition get_master_pde :: \"word32 \\<Rightarrow> (pde,'z::state_ext)s_monad\"\n  where \"get_master_pde ptr \\<equiv> do\n    pde \\<leftarrow> (get_pde (ptr && ~~ mask 7));\n    (case pde of SuperSectionPDE _ _ _ \\<Rightarrow> return pde\n    | _ \\<Rightarrow> get_pde ptr)\n  od\"\n\ndefinition get_master_pte :: \"word32 \\<Rightarrow> (pte, 'z::state_ext)s_monad\"\n  where \"get_master_pte ptr \\<equiv> do\n    pte \\<leftarrow> (get_pte (ptr && ~~ mask 7));\n    (case pte of LargePagePTE _ _ _ \\<Rightarrow> return pte\n    | _ \\<Rightarrow> get_pte ptr)\n  od\"", "property": "Create Mapping Entries: Save the set of entries that would be inserted into a page table or page directory to map various different sizes of frames at a given virtual address, considering the page size, virtual address, rights, attributes, and page directory. \n\nGet Master Page Table/Directory Entry: Retrieve the master page directory or page table entry for a given virtual address, handling cases where the entry may be a super section or large page.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Save the set of entries that would be inserted into a page table or\npage directory to map various different sizes of frame at a given virtual\naddress."}
{"spec": "fun ensure_safe_mapping ::\n  \"(pte * word32 list) + (pde * word32 list) \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n\"ensure_safe_mapping (Inl (InvalidPTE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inl (SmallPagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda>slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | SmallPagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst)\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inl (LargePagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | LargePagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inr (InvalidPDE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inr (PageTablePDE _, _)) = fail\"\n|\n\"ensure_safe_mapping (Inr (SectionPDE _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SectionPDE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"\n|\n\"ensure_safe_mapping (Inr (SuperSectionPDE _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SuperSectionPDE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"", "property": "Ensure Safe Mapping: Verify that page table or directory entries being replaced are either invalid or have the same granularity as the new entry, preventing unsafe mappings that could compromise memory integrity. \n\nSubproperties:\n- Invalid entries can be safely replaced.\n- Entries with the same granularity (SmallPagePTE, LargePagePTE, SectionPDE, SuperSectionPDE) can be safely replaced.\n- Entries with different granularities cannot be replaced, throwing a DeleteFirst error. \n- PageTablePDE entries cannot be replaced, resulting in a failure.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Placing an entry which maps a frame within the set of entries that map a\nlarger frame is unsafe. This function checks that given entries replace either\ninvalid entries or entries of the same granularity."}
{"spec": "definition\nlookup_ipc_buffer :: \"bool \\<Rightarrow> word32 \\<Rightarrow> (word32 option,'z::state_ext) s_monad\" where\n\"lookup_ipc_buffer is_receiver thread \\<equiv> do\n    buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n    buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n    buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n    (case buffer_cap of\n      ArchObjectCap (PageCap _ p R vms _) \\<Rightarrow>\n        if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n        then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n        else return None\n    | _ \\<Rightarrow> return None)\nod\"", "property": "Lookup IPC Buffer: Retrieve the IPC buffer pointer for a given thread and verify that the thread has the necessary authority to read or write to it, depending on whether it is the receiver or sender. \n\nAuthority Verification: Check that the buffer's capability allows read-only access if the thread is not the receiver, or read-write access if it is the receiver.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Look up a thread's IPC buffer and check that the thread has the right\nauthority to read or (in the receiver case) write to it."}
{"spec": "definition\nfind_pd_for_asid :: \"asid \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"find_pd_for_asid asid \\<equiv> doE\n    assertE (asid > 0);\n    asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n    pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of asid));\n    pool \\<leftarrow> (case pool_ptr of\n               Some ptr \\<Rightarrow> liftE $ get_asid_pool ptr\n             | None \\<Rightarrow> throwError InvalidRoot);\n    pd \\<leftarrow> returnOk (pool (ucast asid));\n    (case pd of\n          Some ptr \\<Rightarrow> returnOk ptr\n        | None \\<Rightarrow> throwError InvalidRoot)\nodE\"", "property": "Find Page Directory for ASID: Locate the page directory associated with a given virtual ASID, ensuring the ASID is valid and retrieving the corresponding page directory pointer from the ASID table and pool. \n\nASID Validation: The ASID must be greater than 0. \n\nPage Directory Retrieval: The page directory pointer is retrieved from the ASID pool, and if not found, an InvalidRoot error is thrown.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory associated with a given virtual ASID."}
{"spec": "definition\nfind_pd_for_asid_assert :: \"asid \\<Rightarrow> (word32,'z::state_ext) s_monad\" where\n\"find_pd_for_asid_assert asid \\<equiv> do\n   pd \\<leftarrow> find_pd_for_asid asid <catch> K fail;\n   get_pde pd;\n   return pd\n od\"", "property": "Page Directory Location: Locate the page directory for a given ASID and verify its validity by successfully retrieving a page directory entry.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory and check that this process succeeds and\nreturns a pointer to a real page directory."}
{"spec": "fun\nhandle_vm_fault :: \"word32 \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n\"handle_vm_fault thread ARMDataAbort = doE\n    addr \\<leftarrow> liftE $ do_machine_op getHDFAR;\n    uaddr \\<leftarrow> liftE $ do_machine_op (addressTranslateS1 addr);\n    fault \\<leftarrow> liftE $ do_machine_op getHSR;\n    let faddr = (uaddr && complement (mask pageBits)) || (addr && mask pageBits)\n    in\n    throwError $ ArchFault $ VMFault faddr [0, fault && 0x3ffffff]\nodE\"\n|\n\"handle_vm_fault thread ARMPrefetchAbort = doE\n    pc \\<leftarrow> liftE $ as_user thread $ getRestartPC;\n    upc \\<leftarrow> liftE $ do_machine_op (addressTranslateS1 pc);\n    fault \\<leftarrow> liftE $ do_machine_op getHSR;\n    let faddr = (upc && complement (mask pageBits)) || (pc && mask pageBits)\n    in\n    throwError $ ArchFault $ VMFault faddr [1, fault && 0x3ffffff]\nodE\"", "property": "VM Fault Handling: Formats a VM fault message to be passed to a thread's supervisor after encountering a page fault, providing the fault address and relevant fault information. \n\nSubproperties:\n- Data Abort Handling: Handles ARM data aborts by retrieving the fault address, translating it, and constructing a VM fault message with the translated address and fault status.\n- Prefetch Abort Handling: Handles ARM prefetch aborts by retrieving the faulting instruction address, translating it, and constructing a VM fault message with the translated address and fault status.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Format a VM fault message to be passed to a thread's supervisor after\nit encounters a page fault."}
{"spec": "definition\nload_hw_asid :: \"asid \\<Rightarrow> (hardware_asid option,'z::state_ext) s_monad\" where\n\"load_hw_asid asid \\<equiv> do\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    return $ option_map fst $ asid_map asid\nod\"", "property": "Load Hardware ASID: Retrieve the optional hardware ASID associated with a given virtual ASID from the ASID map.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Load the optional hardware ASID currently associated with this virtual\nASID."}
{"spec": "definition\nstore_hw_asid :: \"asid \\<Rightarrow> hardware_asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"store_hw_asid asid hw_asid \\<equiv> do\n    pd \\<leftarrow> find_pd_for_asid_assert asid;\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    asid_map' \\<leftarrow> return (asid_map (asid \\<mapsto> (hw_asid, pd)));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_map := asid_map' \\<rparr>\\<rparr>);\n    hw_asid_map \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n    hw_asid_map' \\<leftarrow> return (hw_asid_map (hw_asid \\<mapsto> asid));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_hwasid_table := hw_asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Associate Hardware ASID with Virtual ASID: Map a hardware ASID to a virtual ASID, updating the ASID map and hardware ASID table to maintain the association between the two.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associate a hardware ASID with a virtual ASID."}
{"spec": "definition\ninvalidate_tlb_by_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_tlb_by_asid asid \\<equiv> do\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    (case maybe_hw_asid of\n          None \\<Rightarrow> return ()\n        | Some hw_asid \\<Rightarrow> do_machine_op $ invalidateLocalTLB_ASID hw_asid)\nod\"", "property": "TLB Invalidation: Clear all TLB mappings associated with a given virtual ASID, ensuring that any stale translations are removed and the TLB is updated accordingly. \n\nSubproperties:\n- Load the hardware ASID associated with the given virtual ASID.\n- If a hardware ASID is found, invalidate the local TLB entries for that ASID using a machine operation.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Clear all TLB mappings associated with this virtual ASID."}
{"spec": "definition\nflush_space :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_space asid \\<equiv> do\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    do_machine_op cleanCaches_PoU;\n    (case maybe_hw_asid of\n          None \\<Rightarrow> return ()\n        | Some hw_asid \\<Rightarrow> do_machine_op $ invalidateLocalTLB_ASID hw_asid)\nod\"", "property": "Flush Virtual ASID: Flush all cache and TLB entries associated with a given virtual ASID, ensuring that the corresponding hardware ASID is cleaned and invalidated. \n\nCache Cleaning: Clean the caches to the point of unification (PoU) to ensure consistency across the system.\n\nTLB Invalidation: Invalidate the local TLB entries for the given hardware ASID, if it exists, to prevent stale translations from being used.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush all cache and TLB entries associated with this virtual ASID."}
{"spec": "definition\ninvalidate_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_asid asid \\<equiv> do\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    asid_map' \\<leftarrow> return (asid_map (asid:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_map := asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Invalidate ASID Mapping: Remove the mapping from a virtual ASID to a hardware ASID, ensuring that the ASID is no longer associated with a hardware ASID.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this virtual ASID to a hardware ASID."}
{"spec": "definition\ninvalidate_hw_asid_entry :: \"hardware_asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_hw_asid_entry hw_asid \\<equiv> do\n  hw_asid_map \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n  hw_asid_map' \\<leftarrow> return (hw_asid_map (hw_asid:= None));\n  modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_hwasid_table := hw_asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Invalidate Hardware ASID Entry: Remove the mapping from a hardware ASID to a virtual ASID by updating the hardware ASID table.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this hardware ASID to a virtual ASID."}
{"spec": "definition\ninvalidate_asid_entry :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_asid_entry asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  when (maybe_hw_asid \\<noteq> None) $ invalidate_hw_asid_entry (the maybe_hw_asid);\n  invalidate_asid asid\nod\"", "property": "ASID Entry Invalidation: Remove virtual to physical mappings associated with a given virtual ASID in both directions. \n\nSubproperties:\n- If the ASID is mapped to a hardware ASID, invalidate the corresponding hardware ASID entry.\n- Invalidate the ASID itself.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove virtual to physical mappings in either direction involving this\nvirtual ASID."}
{"spec": "definition\nfind_free_hw_asid :: \"(hardware_asid,'z::state_ext) s_monad\" where\n\"find_free_hw_asid \\<equiv> do\n    hw_asid_table \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n    next_asid \\<leftarrow> gets (arm_next_asid \\<circ> arch_state);\n    maybe_asid \\<leftarrow> return (find (\\<lambda>a. hw_asid_table a = None)\n                    (take (length [minBound :: hardware_asid .e. maxBound])\n                        ([next_asid .e. maxBound] @ [minBound .e. next_asid])));\n    (case maybe_asid of\n       Some hw_asid \\<Rightarrow> return hw_asid\n     | None \\<Rightarrow>  do\n            invalidate_asid $ the $ hw_asid_table next_asid;\n            do_machine_op $ invalidateLocalTLB_ASID next_asid;\n            invalidate_hw_asid_entry next_asid;\n            new_next_asid \\<leftarrow> return (next_asid + 1);\n            modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_next_asid := new_next_asid \\<rparr>\\<rparr>);\n            return next_asid\n       od)\nod\"", "property": "Hardware ASID Allocation: Find an unused hardware ASID, and if none are available, reclaim one from another virtual ASID in a round-robin manner, ensuring that the reclaimed ASID is invalidated and the next ASID is updated.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate a hardware ASID that is not in use, if necessary by reclaiming\none from another virtual ASID in a round-robin manner."}
{"spec": "definition\nget_hw_asid :: \"asid \\<Rightarrow> (hardware_asid,'z::state_ext) s_monad\" where\n\"get_hw_asid asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  (case maybe_hw_asid of\n    Some hw_asid \\<Rightarrow> return hw_asid\n  | None \\<Rightarrow>  do\n      new_hw_asid \\<leftarrow> find_free_hw_asid;\n      store_hw_asid asid new_hw_asid;\n      return new_hw_asid\n  od)\nod\"\n\n\nabbreviation\n  \"arm_context_switch_hwasid pd hwasid \\<equiv> writeContextIDAndPD hwasid (addrFromPPtr pd)\"\n\ndefinition\n  arm_context_switch :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arm_context_switch pd asid \\<equiv> do\n    hwasid \\<leftarrow> get_hw_asid asid;\n    do_machine_op $ arm_context_switch_hwasid pd hwasid\n   od\"", "property": "Hardware ASID Management: Get the hardware ASID associated with a virtual ASID, assigning a new one if none is already assigned, and perform a context switch by writing the context ID and page directory to the hardware.\n\nSubproperties:\n- Hardware ASID Retrieval: Load the hardware ASID associated with a virtual ASID, and if none is assigned, find a free hardware ASID, store it, and return it.\n- Context Switch: Perform a context switch by writing the context ID and page directory to the hardware using the retrieved hardware ASID.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get the hardware ASID associated with a virtual ASID, assigning one if\nnone is already assigned."}
{"spec": "definition\n  vcpu_update :: \"obj_ref \\<Rightarrow> (vcpu \\<Rightarrow> vcpu) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_update vr f \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    set_vcpu vr (f vcpu)\n  od\"\n\ndefinition\n  vgic_update :: \"obj_ref \\<Rightarrow> (gic_vcpu_interface \\<Rightarrow> gic_vcpu_interface) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vgic_update vr f \\<equiv> vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_vgic := f (vcpu_vgic vcpu) \\<rparr> )\"\n\ndefinition\n  vgic_update_lr :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> virq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vgic_update_lr vr irq_idx virq \\<equiv>\n    vgic_update vr (\\<lambda>vgic. vgic \\<lparr> vgic_lr := (vgic_lr vgic)(irq_idx := virq) \\<rparr>)\"\n\ndefinition\n  vcpu_save_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_save_reg vr reg \\<equiv> do\n    rval \\<leftarrow> do_machine_op (readVCPUHardwareReg reg);\n    vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_regs := (vcpu_regs vcpu)(reg := rval) \\<rparr> )\n  od\"\n\ndefinition\n  vcpu_save_reg_range :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_save_reg_range vr from to \\<equiv> mapM_x (\\<lambda>reg. vcpu_save_reg vr reg) [from .e. to]\"\n\ndefinition\n  vcpu_restore_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_restore_reg vr reg \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    do_machine_op (writeVCPUHardwareReg reg (vcpu_regs vcpu reg))\n  od\"\n\ndefinition\n  vcpu_restore_reg_range :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_restore_reg_range vr from to \\<equiv> mapM_x (\\<lambda>reg. vcpu_restore_reg vr reg) [from .e. to]\"\n\ndefinition\n  vcpu_read_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (machine_word, 'z::state_ext) s_monad\"\nwhere\n  \"vcpu_read_reg vr reg \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    return (vcpu_regs vcpu reg)\n  od\"\n\ndefinition\n  vcpu_write_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_write_reg vr reg val \\<equiv>\n    vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_regs := (vcpu_regs vcpu)(reg := val) \\<rparr> )\"\n\ndefinition save_virt_timer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"save_virt_timer vcpu_ptr \\<equiv> do\n     vcpu_save_reg vcpu_ptr VCPURegCNTV_CTL;\n     do_machine_op $ writeVCPUHardwareReg VCPURegCNTV_CTL 0;\n     cval \\<leftarrow> do_machine_op get_cntv_cval_64;\n     cntvoff \\<leftarrow> do_machine_op get_cntv_off_64;\n     vcpu_write_reg vcpu_ptr VCPURegCNTV_CVALhigh (ucast (cval >> 32));\n     vcpu_write_reg vcpu_ptr VCPURegCNTV_CVALlow (ucast cval);\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFFhigh (ucast (cntvoff >> 32));\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFFlow (ucast cntvoff);\n     cntpct \\<leftarrow> do_machine_op read_cntpct;\n     vcpu_update vcpu_ptr (\\<lambda>vcpu. vcpu\\<lparr>vcpu_vtimer := VirtTimer cntpct \\<rparr>)\n   od\"\n\ndefinition irq_vppi_event_index :: \"irq \\<rightharpoonup> vppievent_irq\" where\n  \"irq_vppi_event_index irq \\<equiv>\n     if irq = irqVTimerEvent\n     then Some VPPIEventIRQ_VTimer\n     else None\"\n\ndefinition restore_virt_timer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"restore_virt_timer vcpu_ptr \\<equiv> do\n     cval_high \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTV_CVALhigh;\n     cval_low \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTV_CVALlow;\n     (cval :: 64 word) \\<leftarrow> return $ ((ucast cval_high) << 32) || ucast cval_low;\n     do_machine_op $ set_cntv_cval_64 cval;\n     current_cntpct \\<leftarrow> do_machine_op read_cntpct;\n     vcpu \\<leftarrow> get_vcpu vcpu_ptr;\n     last_pcount \\<leftarrow> return $ vtimerLastPCount $ vcpu_vtimer vcpu;\n     delta \\<leftarrow> return $ current_cntpct - last_pcount;\n     offs_high \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTVOFFhigh;\n     offs_low \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTVOFFlow;\n     (offset :: 64 word) \\<leftarrow> return $ (((ucast offs_high) << 32) || ucast offs_low) + delta;\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFFhigh (ucast (offset >> 32));\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFFlow (ucast offset);\n     do_machine_op $ set_cntv_off_64 offset;\n     masked \\<leftarrow> return $ (vcpu_vppi_masked vcpu (the $ irq_vppi_event_index irqVTimerEvent));\n     \\<comment> \\<open>we do not know here that irqVTimerEvent is IRQReserved, therefore not IRQInactive,\n        so the only way to prove we don't unmask an inactive interrupt is to check\\<close>\n     safe_to_unmask \\<leftarrow> is_irq_active irqVTimerEvent;\n     when safe_to_unmask $ do_machine_op $ maskInterrupt masked irqVTimerEvent;\n     vcpu_restore_reg vcpu_ptr VCPURegCNTV_CTL\n   od\"", "property": "VCPU State Management: Manipulate VCPU-related state and registers, including updating VCPU and VGIC state, saving and restoring VCPU registers, and managing virtual timers. This ensures that VCPU state is correctly managed and virtual timers are accurately updated, maintaining the integrity and performance of the virtualization system.\n\nSubproperties:\n- VCPU and VGIC State Updates: Update VCPU and VGIC state, including updating VCPU registers and VGIC interrupt lists.\n- VCPU Register Management: Save and restore VCPU registers, ensuring that VCPU state is correctly preserved and restored.\n- Virtual Timer Management: Manage virtual timers, including saving and restoring timer state, and updating timer values.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Manipulation of VCPU-related state and registers"}
{"spec": "definition\n  vcpu_disable :: \"obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_disable vo \\<equiv> do\n    do_machine_op dsb;\n    (case vo of\n      Some vr \\<Rightarrow> do\n        hcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_hcr;\n        vgic_update vr (\\<lambda>vgic. vgic\\<lparr> vgic_hcr := hcr \\<rparr>);\n        vcpu_save_reg vr VCPURegSCTLR;\n        do_machine_op isb\n      od\n    | _ \\<Rightarrow> return ());\n    do_machine_op $ do\n        set_gic_vcpu_ctrl_hcr 0; \\<comment> \\<open>turn VGIC off\\<close>\n        isb;\n        setSCTLR sctlrDefault; \\<comment> \\<open>turn SI MMU off\\<close>\n        setHCR hcrNative;\n        isb\n      od;\n    case vo of\n      Some vr \\<Rightarrow> do\n          save_virt_timer vr;\n          do_machine_op $ maskInterrupt True irqVTimerEvent\n        od\n      | _ \\<Rightarrow> return ()\n    od\"", "property": "VPCU Mode Disable: Turn off VPCU mode on the hardware level by updating the VGIC control register, saving the VCPU register, disabling the VGIC and SI MMU, and resetting the HCR. Additionally, save the virtual timer and mask the VTimer event interrupt if a VCPU object reference is provided.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Turn VPCU mode off on the hardware level."}
{"spec": "definition\n  vcpu_enable :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_enable vr \\<equiv> do\n     vcpu_restore_reg vr VCPURegSCTLR;\n     vcpu \\<leftarrow> get_vcpu vr;\n     do_machine_op $ do\n        setHCR hcrVCPU;\n        isb;\n        set_gic_vcpu_ctrl_hcr (vgic_hcr $ vcpu_vgic vcpu)\n     od;\n     restore_virt_timer vr\n   od\"", "property": "VCPU Enable: Turn on VCPU mode at the hardware level by restoring the SCTLR register, setting the HCR register, issuing an ISB instruction, configuring the GIC VCPU control register, and restoring the virtual timer.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Turn VCPU mode on, on the hardware level."}
{"spec": "definition\n  vcpu_invalidate_active :: \"(unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_invalidate_active \\<equiv> do\n    cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n    case cur_v of\n      Some (vr, True) \\<Rightarrow> vcpu_disable None\n    | _ \\<Rightarrow> return ();\n    modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := None \\<rparr>\\<rparr>)\n  od\"", "property": "VCPU Removal Preparation: Invalidate the current VCPU, disabling it if active, and reset the current VCPU pointer to None.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Prepare the current VCPU for removal.\n"}
{"spec": "definition dissociate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere \"dissociate_vcpu_tcb vr t \\<equiv> do\n  t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n  v \\<leftarrow> get_vcpu vr;\n  assert (t_vcpu = Some vr \\<and> vcpu_tcb v = Some t); \\<comment> \\<open>make sure they were associated\\<close>\n  cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n  when (\\<exists>a. cur_v = Some (vr,a)) vcpu_invalidate_active;\n  arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := None \\<rparr>) t;\n  set_vcpu vr (v\\<lparr> vcpu_tcb := None \\<rparr>);\n  as_user t $ do\n    cpsr \\<leftarrow> getRegister CPSR;\n    setRegister CPSR $ sanitise_register False CPSR cpsr\n  od\nod\"", "property": "TCB-VCPU Dissociation: Remove the connection between a TCB and a VCPU, ensuring that the VCPU is invalidated if it is currently active, and update the TCB and VCPU states accordingly. \n\nSubproperties:\n- Validate the association between the TCB and VCPU before dissociation.\n- Update the TCB state to remove the VCPU reference.\n- Update the VCPU state to remove the TCB reference.\n- Invalidate the VCPU if it is currently active.\n- Sanitise the CPSR register for the TCB.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Removing the connection between a TCB and VCPU:"}
{"spec": "definition\n  vcpu_save :: \"(obj_ref \\<times> bool) option \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_save vb \\<equiv>\n     case vb\n     of Some (vr, active) \\<Rightarrow> do\n          do_machine_op dsb;\n\n          when active $ do\n            vcpu_save_reg vr VCPURegSCTLR;\n            hcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_hcr;\n            vgic_update vr (\\<lambda>vgic. vgic\\<lparr> vgic_hcr := hcr \\<rparr>);\n            save_virt_timer vr\n          od;\n\n          vmcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_vmcr;\n          vgic_update vr (\\<lambda>vgic. vgic \\<lparr>vgic_vmcr := vmcr\\<rparr>);\n\n          apr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_apr;\n          vgic_update vr (\\<lambda>vgic. vgic \\<lparr>vgic_apr := apr\\<rparr>);\n\n          num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n          gicIndices \\<leftarrow> return [0..<num_list_regs];\n\n          mapM (\\<lambda>vreg. do\n                    val \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_lr (of_nat vreg);\n                    vgic_update_lr vr vreg val\n                  od)\n            gicIndices;\n\n          vcpu_save_reg_range vr VCPURegACTLR VCPURegSPSRfiq;\n          do_machine_op isb\n       od\n     | _ \\<Rightarrow> fail\"", "property": "VCPU Save: Saves the state of a VCPU, including registers and context, by performing a sequence of operations such as saving specific registers, updating the VGIC (Virtual Generic Interrupt Controller) state, and saving the virtual timer. \n\nSubproperties:\n- Save VCPU Registers: Saves specific VCPU registers, including SCTLR, ACTLR, and SPSR_fiq.\n- Update VGIC State: Updates the VGIC state by retrieving and storing the HCR, VMCR, and APR values.\n- Save Virtual Timer: Saves the state of the virtual timer for the VCPU.\n- Save GIC List Registers: Saves the state of the GIC list registers for the VCPU.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Register + context save for VCPUs"}
{"spec": "definition\n  vcpu_restore :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_restore vr \\<equiv> do\n     do_machine_op $ set_gic_vcpu_ctrl_hcr 0;  \\<comment> \\<open>turn off VGIC\\<close>\n     do_machine_op $ isb;\n     vcpu \\<leftarrow> get_vcpu vr;  \\<comment> \\<open>restore GIC VCPU control state\\<close>\n     vgic \\<leftarrow> return (vcpu_vgic vcpu);\n     num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     gicIndices \\<leftarrow> return [0..<num_list_regs];\n     do_machine_op $ do\n         set_gic_vcpu_ctrl_vmcr (vgic_vmcr vgic);\n         set_gic_vcpu_ctrl_apr (vgic_apr vgic);\n         mapM (\\<lambda>p. set_gic_vcpu_ctrl_lr (of_nat (fst p)) (snd p))\n              (map (\\<lambda>i. (i, (vgic_lr vgic) i)) gicIndices)\n     od;\n    \\<comment> \\<open>restore banked VCPU registers except SCTLR (that's in VCPUEnable)\\<close>\n     vcpu_restore_reg_range vr VCPURegACTLR VCPURegSPSRfiq;\n     vcpu_enable vr\n  od\"", "property": "VCPU Restore: Restore the state of a VCPU, including turning off VGIC, restoring GIC VCPU control state, and restoring banked VCPU registers, to prepare it for execution.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Register + context restore for VCPUs"}
{"spec": "definition vcpu_switch :: \"obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_switch v \\<equiv> case v of\n   None \\<Rightarrow> do\n     cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     (case cur_v of\n        None \\<Rightarrow> return () \\<comment> \\<open>both null, current cannot be active\\<close>\n      | Some (vr, active) \\<Rightarrow> do \\<comment> \\<open>switch to thread without vcpu\\<close>\n          when active $ do  \\<comment> \\<open> save state if not saved already\\<close>\n            vcpu_disable (Some vr);\n            modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (vr, False) \\<rparr>\\<rparr>)\n          od;\n          return ()\n        od)\n     od\n | Some new \\<Rightarrow> do\n     cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     (case cur_v of\n        None \\<Rightarrow> do \\<comment> \\<open>switch to the new vcpu with no current one\\<close>\n          vcpu_restore new;\n          modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n        od\n      | Some (vr, active) \\<Rightarrow> \\<comment> \\<open>switch from an existing vcpu\\<close>\n          (if vr \\<noteq> new\n          then do \\<comment> \\<open>different vcpu\\<close>\n            vcpu_save cur_v;\n            vcpu_restore new;\n            modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n          od\n          else \\<comment> \\<open>same vcpu\\<close>\n            when (\\<not> active) $ do\n              do_machine_op isb;\n              vcpu_enable new;\n              modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n            od))\n   od\"", "property": "VCPU Switching: Make a new VCPU the active/current VCPU, or mark the current VCPU as not active and disable VCPU mode if passed None, while caching the rest for potential quick switching back to the same VCPU. \n\nSubproperties:\n- If switching to no VCPU, save the current VCPU state if it is active, and then mark it as not active.\n- If switching to a new VCPU with no current VCPU, restore the new VCPU state and mark it as active.\n- If switching from an existing VCPU to a different one, save the current VCPU state, restore the new VCPU state, and mark the new one as active.\n- If switching to the same VCPU, enable it and mark it as active if it was not already.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Make a new VCPU the active/current VCPU. If passed None, will mark the current VCPU as\n  not active, and disable VCPU mode, but leave the rest intact caching for the case where\n  we switch back to the same VCPU soon.\n"}
{"spec": "definition associate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"associate_vcpu_tcb vr t \\<equiv> do\n    t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n    case t_vcpu of Some p \\<Rightarrow> dissociate_vcpu_tcb p t\n                 | _ \\<Rightarrow> return ();\n    v \\<leftarrow> get_vcpu vr;\n    case vcpu_tcb v of Some p \\<Rightarrow> dissociate_vcpu_tcb vr p\n                     | _ \\<Rightarrow> return ();\n    arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := Some vr \\<rparr>) t;\n    set_vcpu vr (v\\<lparr> vcpu_tcb := Some t \\<rparr>);\n    ct \\<leftarrow> gets cur_thread;\n    when (t = ct) $ vcpu_switch (Some vr)\n  od\"", "property": "TCB-VCPU Association: Associate a TCB with a VCPU, removing any existing associations between the TCB and another VCPU or the VCPU and another TCB, and update the TCB and VCPU data structures accordingly. If the TCB being updated is the current thread, switch to the newly associated VCPU.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associating a TCB and VCPU, removing any potentially existing associations:"}
{"spec": "definition vcpu_finalise :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_finalise vr \\<equiv> do\n    v \\<leftarrow> get_vcpu vr;\n    case vcpu_tcb v of\n      Some t \\<Rightarrow> dissociate_vcpu_tcb vr t\n    | None \\<Rightarrow> return ()\n   od\"", "property": "VCPU Removal Preparation: Dissociate a given VCPU and clean up its current state if necessary, ensuring it is properly prepared for removal. \n\nDissociation: If the VCPU is associated with a TCB, dissociate the VCPU from the TCB.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Prepare a given VCPU for removal: dissociate it, and clean up current VCPU state\n  if necessary.\n"}
{"spec": "definition\n  set_vm_root :: \"word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"set_vm_root tcb \\<equiv> do\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    (case thread_root of\n       ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow> doE\n           pd' \\<leftarrow> find_pd_for_asid asid;\n           whenE (pd \\<noteq> pd') $ throwError InvalidRoot;\n           liftE $ arm_context_switch pd asid\n       odE\n     | _ \\<Rightarrow> throwError InvalidRoot) <catch>\n    (\\<lambda>_. do\n       global_us_pd \\<leftarrow> gets (arm_us_global_pd o arch_state);\n       do_machine_op $ set_current_pd $ addrFromKPPtr global_us_pd\n    od)\nod\"", "property": "Set Virtual Memory Root: Switch into the address space of a given thread or the global address space if the thread's address space is not correctly configured. \n\nSubproperties:\n- Validate Thread Address Space: Check if the thread's address space is correctly configured by verifying the page directory and address space identifier.\n- Switch to Global Address Space: If the thread's address space is not correctly configured, switch to the global address space.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch into the address space of a given thread or the global address\nspace if none is correctly configured."}
{"spec": "definition\ndelete_asid_pool :: \"asid \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid_pool base ptr \\<equiv> do\n  assert (base && mask asid_low_bits = 0);\n  asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n  when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n    pool \\<leftarrow> get_asid_pool ptr;\n    mapM (\\<lambda>offset. (when (pool (ucast offset) \\<noteq> None) $ do\n                          flush_space $ base + offset;\n                          invalidate_asid_entry $ base + offset\n                    od)) [0  .e.  (1 << asid_low_bits) - 1];\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_table := asid_table' \\<rparr>\\<rparr>);\n    tcb \\<leftarrow> gets cur_thread;\n    set_vm_root tcb\n  od\nod\"", "property": "ASID Pool Deletion: Before deleting an ASID pool object, deactivate all page directories installed in it by flushing and invalidating their entries, updating the ASID table, and resetting the VM root for the current thread.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Before deleting an ASID pool object we must deactivate all page\ndirectories that are installed in it."}
{"spec": "definition\ndelete_asid :: \"asid \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid asid pd \\<equiv> do\n  asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n  (case asid_table (asid_high_bits_of asid) of\n    None \\<Rightarrow> return ()\n  | Some pool_ptr \\<Rightarrow>  do\n     pool \\<leftarrow> get_asid_pool pool_ptr;\n     when (pool (ucast asid) = Some pd) $ do\n                flush_space asid;\n                invalidate_asid_entry asid;\n                pool' \\<leftarrow> return (pool (ucast asid := None));\n                set_asid_pool pool_ptr pool';\n                tcb \\<leftarrow> gets cur_thread;\n                set_vm_root tcb\n            od\n    od)\nod\"", "property": "ASID Deletion: When deleting a page directory from an ASID pool, deactivate it by flushing the address space, invalidating the ASID entry, updating the ASID pool, and resetting the VM root for the current thread.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "When deleting a page directory from an ASID pool we must deactivate\nit."}
{"spec": "definition\nset_vm_root_for_flush :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n\"set_vm_root_for_flush pd asid \\<equiv> do\n    tcb \\<leftarrow> gets cur_thread;\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    not_is_pd \\<leftarrow> (case thread_root of\n                    ArchObjectCap (PageDirectoryCap cur_pd (Some _)) \\<Rightarrow> return (cur_pd \\<noteq> pd)\n                  | _ \\<Rightarrow> return True);\n    (if not_is_pd then do\n        arm_context_switch pd asid;\n        return True\n    od\n    else return False)\nod\"\n\ndefinition\ndo_flush :: \"flush_type \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\" where\n\"do_flush flush_type vstart vend pstart \\<equiv>\n    let vstart' = ptrFromPAddr pstart;\n        vend'  = vstart' + (vend - vstart)\n    in\n    (case flush_type of\n       Clean \\<Rightarrow> cleanCacheRange_RAM vstart' vend' pstart\n     | Invalidate \\<Rightarrow> invalidateCacheRange_RAM vstart' vend' pstart\n     | CleanInvalidate \\<Rightarrow> cleanInvalidateCacheRange_RAM vstart' vend' pstart\n     | Unify \\<Rightarrow> do\n         cleanCacheRange_PoU vstart' vend' pstart;\n         dsb;\n         invalidateCacheRange_I vstart' vend' pstart;\n         branchFlushRange vstart' vend' pstart;\n         isb\n     od)\"", "property": "Cache Flush Operations: Perform cache flush operations (clean, invalidate, clean and invalidate, unify) on a specified address range, ensuring cache coherence and consistency.\n\nAddress Space Switching for Flush: Switch to a particular address space to perform a flush operation, updating the current thread's root slot and performing an ARM context switch if necessary.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch to a particular address space in order to perform a flush\noperation."}
{"spec": "definition\nflush_table :: \"word32 \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_table pd asid vptr pt \\<equiv> do\n    assert (vptr && mask (pageBitsForSize ARMSection) = 0);\n    root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    when (maybe_hw_asid \\<noteq> None) $ do\n      hw_asid \\<leftarrow> return (the maybe_hw_asid);\n      do_machine_op $ invalidateLocalTLB_ASID hw_asid;\n      when root_switched $ do\n        tcb \\<leftarrow> gets cur_thread;\n        set_vm_root tcb\n      od\n    od\nod\"", "property": "Flush Table Mappings: Flush the mappings associated with a page table, ensuring that the virtual memory root is set correctly and the local TLB is invalidated for the specified ASID. \n\nSubproperties:\n- Validate the virtual pointer alignment.\n- Set the virtual memory root for flushing.\n- Load the hardware ASID.\n- Invalidate the local TLB for the specified ASID.\n- Conditionally set the virtual memory root for the current thread.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a page table."}
{"spec": "definition\nflush_page :: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_page page_size pd asid vptr\\<equiv> do\n    assert (vptr && mask pageBits = 0);\n    root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    when (maybe_hw_asid \\<noteq> None) $ do\n      hw_asid \\<leftarrow> return (the maybe_hw_asid);\n      do_machine_op $ invalidateLocalTLB_VAASID (vptr || ucast hw_asid);\n      when root_switched $ do\n          tcb \\<leftarrow> gets cur_thread;\n          set_vm_root tcb\n      od\n   od\nod\"", "property": "Flush Page Mappings: Flush the mappings associated with a given page, ensuring that the virtual memory is correctly updated and the hardware's translation lookaside buffer (TLB) is invalidated for the specified address space identifier (ASID) and virtual pointer (vptr). \n\nSubproperties:\n- Validate the virtual pointer alignment.\n- Set the virtual memory root for flushing.\n- Load the hardware ASID.\n- Invalidate the local TLB for the specified virtual address and ASID.\n- Restore the virtual memory root if necessary.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a given page."}
{"spec": "definition\npage_table_mapped :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\" where\n\"page_table_mapped asid vaddr pt \\<equiv> doE\n    pd \\<leftarrow> find_pd_for_asid asid;\n    pd_slot \\<leftarrow> returnOk $ lookup_pd_slot pd vaddr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    case pde of\n      PageTablePDE addr \\<Rightarrow> returnOk $\n             if addrFromPPtr pt = addr then Some pd else None\n    | _ \\<Rightarrow> returnOk None\nodE <catch> (K $ return None)\"", "property": "Page Table Mapping: Return the optional page directory that a page table is mapped in, based on the address space identifier, virtual address, and page table object reference. \n\nSubproperties:\n- Find the page directory for the given address space identifier.\n- Determine the page directory slot for the virtual address.\n- Retrieve the page directory entry for the slot.\n- Check if the page directory entry matches the page table object reference and return the page directory if it does.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Return the optional page directory a page table is mapped in."}
{"spec": "definition\nunmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page_table asid vaddr pt \\<equiv> do\n    pdOpt \\<leftarrow> page_table_mapped asid vaddr pt;\n    case pdOpt of\n      None \\<Rightarrow> return ()\n    | Some pd \\<Rightarrow> do\n        pd_slot \\<leftarrow> return $ lookup_pd_slot pd vaddr;\n        store_pde pd_slot InvalidPDE;\n        do_machine_op $ cleanByVA_PoU pd_slot (addrFromPPtr pd_slot);\n        flush_table pd asid vaddr pt\n    od\nod\"", "property": "Unmap Page Table: Remove the mapping of a page table from its page directory, ensuring that the corresponding page directory entry is invalidated and the translation lookaside buffer (TLB) is updated to reflect the change. \n\nSubproperties:\n- Invalidate Page Directory Entry: Mark the page directory entry as invalid to prevent further accesses.\n- Clean and Flush: Clean the page directory entry and flush the TLB to ensure consistency between the page tables and the TLB.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a page table from its page directory."}
{"spec": "definition\ncheck_mapping_pptr :: \"obj_ref \\<Rightarrow> vmpage_size \\<Rightarrow> (obj_ref + obj_ref) \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n\"check_mapping_pptr pptr pgsz tablePtr \\<equiv> case tablePtr of\n   Inl ptePtr \\<Rightarrow> do\n     pte \\<leftarrow> get_pte ptePtr;\n     return $ case pte of\n       SmallPagePTE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSmallPage\n     | LargePagePTE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMLargePage\n     | _ \\<Rightarrow> False\n   od\n | Inr pdePtr \\<Rightarrow> do\n     pde \\<leftarrow> get_pde pdePtr;\n     return $ case pde of\n       SectionPDE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSection\n     | SuperSectionPDE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSuperSection\n     | _ \\<Rightarrow> False\n   od\"\n\n\ndefinition\n  \"last_byte_pte x \\<equiv> x + ((1 << pte_bits) - 1)\"\n\ndefinition\n  \"last_byte_pde x \\<equiv> x + ((1 << pde_bits) - 1)\"", "property": "Check Mapping Physical Pointer: Verify that a given frame is mapped by a specific mapping entry, ensuring the frame's physical address and page size match the mapping entry's attributes. \n\nMapping Entry Attributes: Distinguish between different types of mapping entries (PTE and PDE) and their corresponding page sizes (SmallPage, LargePage, Section, and SuperSection). \n\nFrame Address Validation: Validate the frame's physical address against the mapping entry's address, considering the page size and type.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Check that a given frame is mapped by a given mapping entry."}
{"spec": "definition\nunmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page pgsz asid vptr pptr \\<equiv> doE\n    pd \\<leftarrow> find_pd_for_asid asid;\n    (case pgsz of\n          ARMSmallPage \\<Rightarrow> doE\n            p \\<leftarrow> lookup_pt_slot pd vptr;\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inl p);\n            liftE $ do\n                store_pte p InvalidPTE;\n                do_machine_op $ cleanByVA_PoU p (addrFromPPtr p)\n            od\n          odE\n        | ARMLargePage \\<Rightarrow> doE\n            p \\<leftarrow> lookup_pt_slot pd vptr;\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inl p);\n            liftE $ do\n                assert $ p && mask 7 = 0;\n                slots \\<leftarrow> return (map (\\<lambda>x. x + p) largePagePTE_offsets);\n                mapM (swp store_pte InvalidPTE) slots;\n                do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pte (last slots))\n                                                    (addrFromPPtr (hd slots))\n            od\n          odE\n        | ARMSection \\<Rightarrow> doE\n            p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inr p);\n            liftE $ do\n                store_pde p InvalidPDE;\n                do_machine_op $ cleanByVA_PoU p (addrFromPPtr p)\n            od\n          odE\n        | ARMSuperSection \\<Rightarrow> doE\n            p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inr p);\n            liftE $ do\n                assert $ p && mask 7 = 0;\n                slots \\<leftarrow> return (map (\\<lambda>x. x + p) superSectionPDE_offsets);\n                mapM (swp store_pde InvalidPDE) slots;\n                do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pde (last slots))\n                                                    (addrFromPPtr (hd slots))\n            od\n          odE);\n    liftE $ flush_page pgsz pd asid vptr\nodE <catch> (K $ return ())\"", "property": "Unmap Page: Unmap a mapped page if the given mapping details are still current, ensuring that the page is correctly removed from the page table and the cache is cleaned. \n\nSubproperties:\n- Check Mapping: Verify that the given mapping details match the current mapping before unmapping the page.\n- Update Page Table: Update the page table by storing an invalid page table entry (PTE) or page directory entry (PDE) for the unmapped page.\n- Clean Cache: Clean the cache range associated with the unmapped page to ensure cache coherence.\n- Flush Page: Flush the page from the translation lookaside buffer (TLB) to ensure that the unmapping is propagated to the hardware.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition\n  arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\"\nwhere\n  \"arch_derive_cap c \\<equiv> case c of\n     PageTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageTableCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageDirectoryCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageDirectoryCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageCap dev r R pgs x \\<Rightarrow> returnOk (ArchObjectCap (PageCap dev r R pgs None))\n   | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n   | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\n   | VCPUCap _ \\<Rightarrow> returnOk (ArchObjectCap c)\"", "property": "Architectural Capability Derivation: Derive a new capability from an existing architectural capability, ensuring that PageDirectory and PageTable capabilities have a virtual ASID and location assigned before they can be copied. \n\nSubproperties:\n- PageTable and PageDirectory capabilities without a virtual ASID and location cannot be derived.\n- Page capabilities can be derived with their mapped and dirty flags reset.\n- ASIDControl, ASIDPool, and VCPU capabilities can be derived without modification.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "PageDirectory and PageTable capabilities cannot be copied until they\nhave a virtual ASID and location assigned. This is because page directories\ncannot have multiple current virtual ASIDs and page tables cannot be shared\nbetween address spaces or virtual locations."}
{"spec": "definition\n  arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "ARM-Specific Capability Integrity: Ensure that no user-modifiable data is stored in ARM-specific capabilities, maintaining the integrity and security of the system by preventing unauthorized modifications.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in ARM-specific capabilities."}
{"spec": "definition\n  arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n    (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n    delete_asid_pool b ptr;\n    return (NullCap, NullCap)\n    od\n  | (PageDirectoryCap ptr (Some a), True) \\<Rightarrow> do\n    delete_asid a ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageTableCap ptr (Some (a, v)), True) \\<Rightarrow> do\n    unmap_page_table a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageCap _ ptr _ s (Some (a, v)), _) \\<Rightarrow> do\n     unmap_page s a v ptr;\n     return (NullCap, NullCap)\n  od\n  | (VCPUCap vcpu_ref, True) \\<Rightarrow> do\n     vcpu_finalise vcpu_ref;\n     return (NullCap, NullCap)\n  od\n  | _ \\<Rightarrow> return (NullCap, NullCap)\"\n\ndefinition\n  prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"prepare_thread_delete p \\<equiv> do\n   t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu p;\n   case t_vcpu of\n   Some v \\<Rightarrow> dissociate_vcpu_tcb v p\n | None \\<Rightarrow> return ()\n od\"", "property": "AR_MHYP Capability Finalisation: Ensure that AR_MHYP-specific capabilities are properly finalised by deleting or unmapping associated resources, such as ASID pools, page directories, page tables, and pages, and finalising VCPUs.\n\nThread Deletion Preparation: Prepare a thread for deletion by dissociating its VCPU, if present, to ensure a clean removal of thread resources.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of AR\\_MHYP-specific\ncapabilities."}
{"spec": "definition\n  is_valid_vtable_root :: \"cap \\<Rightarrow> bool\" where\n  \"is_valid_vtable_root c \\<equiv> \\<exists>r a. c = ArchObjectCap (PageDirectoryCap r (Some a))\"\n\ndefinition\ncheck_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n\"check_valid_ipc_buffer vptr c \\<equiv> case c of\n  (ArchObjectCap (PageCap False _ _ _ _)) \\<Rightarrow> doE\n    whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError;\n    returnOk ()\n  odE\n| _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Valid IPC Buffer Capability: Ensure the thread's IPC buffer capability is valid by checking if it is a page directory capability for ARM architecture, and verify the alignment of the virtual address space pointer for page capabilities. \n\nSubproperties:\n- Valid VTable Root: The capability must be an ArchObjectCap to a PageDirectoryCap to be a valid virtual address space capability.\n- Alignment Check: The virtual address space pointer must be aligned to the message alignment bits for page capabilities.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A thread's virtual address space capability must be to a page directory\nto be valid on the ARM architecture."}
{"spec": "definition\nattribs_from_word :: \"word32 \\<Rightarrow> vm_attributes\" where\n\"attribs_from_word w \\<equiv>\n  let V = (if w !!0 then {PageCacheable} else {})\n  in if w!!2 then insert XNever V else V\"", "property": "VM Attribute Decoding: Decode a 32-bit word to determine the VM attributes for a mapping, specifically whether the page is cacheable and whether the XNever attribute is set.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Decode a user argument word describing the kind of VM attributes a\nmapping is to have."}
{"spec": "definition\n  update_map_data :: \"arch_cap \\<Rightarrow> (word32 \\<times> word32) option \\<Rightarrow> arch_cap\" where\n  \"update_map_data cap m \\<equiv> case cap of PageCap dev p R sz _ \\<Rightarrow> PageCap dev p R sz m\n                                     | PageTableCap p _ \\<Rightarrow> PageTableCap p m\"", "property": "Update Mapping Data: Update the mapping data saved in a page or page table capability with new data. \n\nMapping Data Update Rules: \n- For a Page Capability, update the mapping data while preserving the device, physical address, read-only status, and size.\n- For a Page Table Capability, update the mapping data while preserving the physical address.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Update the mapping data saved in a page or page table capability."}
{"spec": "definition\n  resolve_vaddr :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> ((vmpage_size \\<times> obj_ref) option, 'z::state_ext) s_monad\"\nwhere\n  \"resolve_vaddr pd vaddr \\<equiv> do\n     pd_slot \\<leftarrow> return $ lookup_pd_slot pd vaddr;\n     pde \\<leftarrow> get_master_pde pd_slot;\n     case pde of\n         SectionPDE f _ _ \\<Rightarrow> return $ Some (ARMSection, f)\n       | SuperSectionPDE f _ _ \\<Rightarrow> return $ Some (ARMSuperSection, f)\n       | PageTablePDE t \\<Rightarrow> (do\n           pt \\<leftarrow> return $ ptrFromPAddr t;\n           pte_slot \\<leftarrow> return $ lookup_pt_slot_no_fail pt vaddr;\n           pte \\<leftarrow> get_master_pte pte_slot;\n           case pte of\n               LargePagePTE f _ _ \\<Rightarrow> return $ Some (ARMLargePage, f)\n             | SmallPagePTE f _ _ \\<Rightarrow> return $ Some (ARMSmallPage, f)\n             | _ \\<Rightarrow> return None\n         od)\n       | _ \\<Rightarrow> return None\n   od\"", "property": "Resolve Virtual Address: Get information about the frame of a given virtual address, including the page size and object reference, by traversing the page directory and page tables.\n\nSubproperties:\n- Traverse Page Directory: Look up the page directory slot for the given virtual address and retrieve the corresponding page directory entry.\n- Handle Page Table Entries: If the page directory entry points to a page table, look up the page table slot for the virtual address and retrieve the corresponding page table entry.\n- Determine Frame Information: Based on the page directory or page table entry, determine the page size and object reference for the frame, or return None if the entry is invalid.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get information about the frame of a given virtual address"}
{"spec": "definition\n  in_user_frame :: \"word32 \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n  \"in_user_frame p s \\<equiv>\n   \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) =\n        Some (ArchObj (DataPage False sz))\"", "property": "User Frame Containment: A pointer is considered to be inside a user frame if its top bits point to a DataPage object in the kernel heap.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A pointer is inside a user frame if its top bits point to a @{text DataPage}.\n"}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\nend\n\nend", "property": "Message Alignment: The message alignment value is made visible through the msg_align_bits constant, ensuring proper alignment of messages in memory.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition\n  asid_high_bits_of :: \"asid \\<Rightarrow> 7 word\" where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"", "property": "Extract High Bits of ASID: Extract the high 7 bits of a virtual ASID by shifting the ASID to the right by the number of low bits and then casting the result to a 7-bit word.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "text \\<open>Manipulate ASID pools, page directories and page tables in the kernel\nheap.\\<close>", "property": "Kernel Heap Access: Provide access to and manipulation of kernel heap structures, including ASID pools, page directories, and page tables, to manage the ARM virtual space.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\"\n  where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"\n\ndefinition\n  get_asid_pool :: \"obj_ref \\<Rightarrow> (10 word \\<rightharpoonup> obj_ref,'z::state_ext) s_monad\" where\n  \"get_asid_pool ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (ASIDPool pool) \\<Rightarrow> return pool\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_asid_pool :: \"obj_ref \\<Rightarrow> (10 word \\<rightharpoonup> obj_ref) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"set_asid_pool ptr pool \\<equiv> set_object ptr (ArchObj (arch_kernel_obj.ASIDPool pool))\"\n\ndefinition\n  get_vcpu :: \"obj_ref \\<Rightarrow> (vcpu,'z::state_ext) s_monad\" where\n  \"get_vcpu ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (VCPU v) \\<Rightarrow> return v\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_vcpu :: \"obj_ref \\<Rightarrow> vcpu \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_vcpu ptr vcpu \\<equiv> set_object ptr (ArchObj (VCPU vcpu))\"\n\ndefinition\n  get_pd :: \"obj_ref \\<Rightarrow> (11 word \\<Rightarrow> pde,'z::state_ext) s_monad\" where\n  \"get_pd ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageDirectory pd) \\<Rightarrow> return pd\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pd :: \"obj_ref \\<Rightarrow> (11 word \\<Rightarrow> pde) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pd ptr pd \\<equiv> set_object ptr (ArchObj (PageDirectory pd))\"\n\ndefinition\n  set_current_pd :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_current_pd pd \\<equiv> setCurrentPDPL2 pd\"", "property": "Accessing the ARM VSpace: \nKernel Heap Accessors provide functions to access and modify ARM VSpace objects, including ASID pools, VCPUs, page directories, and page tables, ensuring controlled and efficient management of the kernel's virtual memory space.\n\nSubproperties:\n- Get and Set ASID Pool: Retrieve and update the ASID pool associated with a given object reference, facilitating the management of address space identifiers.\n- Get and Set VCPU: Access and modify the VCPU (Virtual CPU) object associated with a given object reference, enabling control over virtual CPU settings.\n- Get and Set Page Directory: Retrieve and update the page directory associated with a given object reference, allowing for efficient page table management.\n- Set Current Page Directory: Update the current page directory, ensuring the correct page table is used for memory access.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": " declared in Arch as workaround for VER-1099 "}
{"spec": "definition\n  get_pde :: \"obj_ref \\<Rightarrow> (pde,'z::state_ext) s_monad\" where\n  \"get_pde ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pd_bits);\n     offset \\<leftarrow> return ((ptr && mask pd_bits) >> pde_bits);\n     pd \\<leftarrow> get_pd base;\n     return $ pd (ucast offset)\n   od\"\n\ndefinition\n  store_pde :: \"obj_ref \\<Rightarrow> pde \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pde p pde \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pd_bits);\n    offset \\<leftarrow> return ((p && mask pd_bits) >> pde_bits);\n    pd \\<leftarrow> get_pd base;\n    pd' \\<leftarrow> return $ pd (ucast offset := pde);\n    set_pd base pd'\n  od\"\n\n\ndefinition\n  get_pt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pte,'z::state_ext) s_monad\" where\n  \"get_pt ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageTable pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pte) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pt ptr pt \\<equiv> set_object ptr (ArchObj (PageTable pt))\"", "property": "Kernel Heap Accessors: Provide functions to access and manipulate page directory entries (PDEs) and page tables (PTs) in kernel memory. \n\nGet PDE: Retrieve the actual PDE from kernel memory given a pointer to a PDE.\nStore PDE: Store a PDE at a given location in kernel memory.\nGet PT: Retrieve the page table associated with a given object reference.\nSet PT: Set the page table for a given object reference.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PDE in kernel memory\n  and returns the actual PDE."}
{"spec": "definition\n  get_pte :: \"obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\" where\n  \"get_pte ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pt_bits);\n     offset \\<leftarrow> return ((ptr && mask pt_bits) >> pte_bits);\n     pt \\<leftarrow> get_pt base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pte :: \"obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pte p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pt_bits);\n    offset \\<leftarrow> return ((p && mask pt_bits) >> pte_bits);\n    pt \\<leftarrow> get_pt base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pt base pt'\n  od\"", "property": "Kernel Heap Accessors: Access and modify page table entries (PTEs) in kernel memory. \n\nGet PTE: Retrieve the actual PTE from a given pointer to a PTE in kernel memory, using bitwise operations to extract the base address and offset.\n\nStore PTE: Update a PTE at a given pointer in kernel memory, using bitwise operations to extract the base address and offset, and then modifying the corresponding page table.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory\n  and returns the actual PTE."}
{"spec": "text \\<open>The kernel window is mapped into every virtual address space from the\n@{term kernel_base} pointer upwards. This function copies the mappings which\ncreate the kernel window into a new page directory object.\\<close>\ndefinition\ncopy_global_mappings :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"copy_global_mappings new_pd \\<equiv> return ()\"", "property": "Kernel Window Mapping: The kernel window is mapped into every virtual address space from the kernel base pointer upwards, ensuring consistent access to kernel memory.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition\nlookup_pd_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\" where\n\"lookup_pd_slot pd vptr \\<equiv>\n    let pd_index = vptr >> (pageBits + pt_bits - pte_bits) \\<comment> \\<open>ARMHYP\\<close>\n    in pd + (pd_index << pde_bits)\"", "property": "Compute PDE Pointer: Calculate the pointer to the Page Directory Entry (PDE) in kernel memory given a page-directory reference and a virtual address.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PDE in kernel memory"}
{"spec": "definition\nlookup_pt_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"lookup_pt_slot pd vptr \\<equiv> doE\n    pd_slot \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    (case pde of\n          PageTablePDE ptab \\<Rightarrow>   (doE\n            pt \\<leftarrow> returnOk (ptrFromPAddr ptab);\n            pt_index \\<leftarrow> returnOk ((vptr >> pageBits) && mask (pt_bits - pte_bits));\n            pt_slot \\<leftarrow> returnOk (pt + (pt_index << pte_bits));\n            returnOk pt_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability 21)\nodE\"", "property": "Lookup Page Table Slot: Compute the pointer to the Page Table Entry (PTE) in kernel memory for a given page directory reference and virtual address. The function fails if the virtual address is mapped on a section or super section. \n\nSubproperties:\n- Retrieve the page directory slot for the given virtual address.\n- Get the Page Directory Entry (PDE) from the page directory slot.\n- If the PDE is a Page Table PDE, extract the page table address and calculate the page table index.\n- Compute the page table slot address using the page table index and return it.\n- If the PDE is not a Page Table PDE, throw a MissingCapability error.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PTE in kernel memory.\n  Note that the function fails if the virtual address is mapped on a section or\n  super section."}
{"spec": "definition\n  lookup_pt_slot_no_fail :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\"\nwhere\n  \"lookup_pt_slot_no_fail pt vptr \\<equiv>\n     let pt_index = ((vptr >> pageBits) && mask (pt_bits - pte_bits))\n     in pt + (pt_index << pte_bits)\"\n\nend\n\nend", "property": "Lookup PT Slot: Calculate the address of a page table slot for a given virtual address and page table.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pt_slot} when the pd is already known"}
{"spec": "text \\<open>This definition ensures that the given pointer is aligned\nto the given page size.\\<close>\n\ndefinition\n  check_vp_alignment :: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $\n       throwError AlignmentError\"", "property": "Check Virtual Page Alignment: Ensures that a given virtual page pointer is aligned to the specified page size, throwing an AlignmentError if it is not.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "definition\n  label_to_flush_type :: \"invocation_label \\<Rightarrow> flush_type\"\nwhere\n  \"label_to_flush_type label \\<equiv> case label of\n       ArchInvocationLabel ARMPDClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPageClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPDInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPageInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPDCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPageCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPDUnify_Instruction \\<Rightarrow> Unify\n     | ArchInvocationLabel ARMPageUnify_Instruction \\<Rightarrow> Unify\"", "property": "Architecture-specific System Call Decoding: Maps user-supplied invocation labels to specific flush types for architecture-specific system calls, ensuring correct handling of cache and memory operations. \n\nFlush Type Mapping: Invocation labels are categorized into flush types (Clean, Invalidate, CleanInvalidate, Unify) based on their intended architecture-specific operation.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": "This definition converts a user-supplied argument into an\ninvocation label, used to determine the method to invoke.\n"}
{"spec": "text \\<open>This definition decodes architecture-specific invocations.\n\\<close>\n\ndefinition\n  page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\nwhere\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"", "property": "Architecture-specific Invocation Decoding: Provides a function to calculate the base address of a page in a virtual address space, given a virtual address and a page size. \n\nPage Base Calculation: Calculates the base address of a page by performing a bitwise AND operation between the virtual address and the negation of the mask for the given page size.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "definition\n  isIOSpaceFrame :: \"arch_cap \\<Rightarrow> bool\"\n  where \"isIOSpaceFrame c \\<equiv> False\"\n\ndefinition\n  decode_mmu_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_mmu_invocation label args x_slot cte cap extra_caps \\<equiv>\ncase cap of\n\n  PageDirectoryCap _ _ \\<Rightarrow>\n    if isPDFlushLabel (invocation_type label) then\n    if length args > 1\n    then let start = args ! 0;\n             end = args ! 1\n    in doE\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            whenE (start \\<ge> kernel_base \\<or> end > kernel_base) $ throwError IllegalOperation;\n            (pd,asid) \\<leftarrow> (case cap of\n                    PageDirectoryCap pd (Some asid) \\<Rightarrow> returnOk (pd,asid)\n                  | _ \\<Rightarrow> throwError $ InvalidCapability 0);\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 0;\n            frame_info \\<leftarrow> liftE $ resolve_vaddr pd start;\n            case frame_info of\n                None \\<Rightarrow> returnOk $ InvokePageDirectory PageDirectoryNothing\n              | Some (frame_size, frame_base) \\<Rightarrow>\n                    let base_start = page_base start frame_size;\n                        base_end = page_base (end - 1) frame_size;\n                        offset = start && mask (pageBitsForSize frame_size);\n                        pstart = frame_base + offset\n                    in doE\n                        whenE (base_start \\<noteq> base_end) $ throwError $\n                            RangeError start (base_start + mask (pageBitsForSize frame_size));\n                        returnOk $ InvokePageDirectory $\n                            PageDirectoryFlush (label_to_flush_type (invocation_type label))\n                            start (end - 1) pstart pd asid\n                    odE\n    odE\n    else throwError TruncatedMessage\n    else throwError IllegalOperation\n\n| PageTableCap p mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageTableMap then\n    if length args > 1 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             pd_cap = fst (extra_caps ! 0)\n    in doE\n            whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            whenE (vaddr \\<ge> kernel_base) $ throwError $ InvalidArgument 0;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            pd_index \\<leftarrow> returnOk (shiftr vaddr (pageBits + pt_bits - pte_bits));\n            vaddr' \\<leftarrow> returnOk (vaddr && ~~ mask (pageBits + pt_bits - pte_bits));\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << pde_bits));\n            oldpde \\<leftarrow> liftE $ get_master_pde pd_slot;\n            unlessE (oldpde = InvalidPDE) $ throwError DeleteFirst;\n            pde \\<leftarrow> returnOk (PageTablePDE (addrFromPPtr p));\n            returnOk $ InvokePageTable $\n                PageTableMap\n                (ArchObjectCap $ PageTableCap p (Some (asid, vaddr')))\n                cte pde pd_slot\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageTableUnmap\n    then doE\n            final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n            unlessE final $ throwError RevokeFirst;\n            returnOk $ InvokePageTable $ PageTableUnmap (ArchObjectCap cap) cte\n    odE\n    else throwError IllegalOperation\n\n| PageCap dev p R pgsz mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageMap then\n    if length args > 2 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             rights_mask = args ! 1;\n             attr = args ! 2;\n             pd_cap = fst (extra_caps ! 0)\n        in doE\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            case mapped_address of\n              Some (asid', vaddr') \\<Rightarrow> doE\n                whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n                whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0)\n              odE\n            | None \\<Rightarrow> doE\n                vtop \\<leftarrow> returnOk (vaddr + (1 << (pageBitsForSize pgsz)) - 1);\n                whenE (vtop \\<ge> kernel_base) $ throwError $ InvalidArgument 0\n              odE;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            vm_rights \\<leftarrow> returnOk (mask_vm_rights R (data_to_rights rights_mask));\n            check_vp_alignment pgsz vaddr;\n            entries \\<leftarrow> create_mapping_entries (addrFromPPtr p)\n                                              vaddr pgsz vm_rights\n                                              (attribs_from_word attr) pd;\n            ensure_safe_mapping entries;\n            returnOk $ InvokePage $ PageMap asid\n                (ArchObjectCap $ PageCap dev p R pgsz (Some (asid, vaddr)))\n                cte entries\n        odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageUnmap\n    then  returnOk $ InvokePage $ PageUnmap cap cte\n    else if isPageFlushLabel (invocation_type label) then\n        if length args > 1\n        then let start = args ! 0;\n                 end = args ! 1;\n                 pstart = start + addrFromPPtr p\n        in doE\n            (asid, _) \\<leftarrow> (case mapped_address of\n                Some a \\<Rightarrow> returnOk a\n              | _ \\<Rightarrow> throwError IllegalOperation);\n            pd \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            page_size \\<leftarrow> returnOk $ 1 << pageBitsForSize pgsz;\n            whenE (start \\<ge> page_size \\<or> end > page_size) $ throwError $ InvalidArgument 0;\n            whenE (pstart < physBase \\<or> ((end - start) + pstart) > paddrTop) $ throwError IllegalOperation;\n            returnOk $ InvokePage $ PageFlush\n                (label_to_flush_type (invocation_type label)) (start + p) \\<comment> \\<open>check\\<close>\n                (end + p - 1) pstart pd asid\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageGetAddress\n    then returnOk $ InvokePage $ PageGetAddr p\n  else  throwError IllegalOperation\n\n| ASIDControlCap \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMASIDControlMakePool then\n    if length args > 1 \\<and> length extra_caps > 1\n    then let index = args ! 0;\n             depth = args ! 1;\n             (untyped, parent_slot) = extra_caps ! 0;\n             root = fst (extra_caps ! 1)\n         in doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            free_set \\<leftarrow> returnOk (- dom asid_table \\<inter> {x. x \\<le> (1 << asid_high_bits) - 1});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n            base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n            (p,n) \\<leftarrow> (case untyped of UntypedCap False p n f \\<Rightarrow> returnOk (p,n)\n                                    | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            frame \\<leftarrow> (if n = pageBits\n                      then doE\n                        ensure_no_children parent_slot;\n                        returnOk p\n                      odE\n                      else  throwError $ InvalidCapability 1);\n            dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n            ensure_empty dest_slot;\n            returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n        odE\n    else  throwError TruncatedMessage\n    else  throwError IllegalOperation\n\n| ASIDPoolCap p base \\<Rightarrow>\n  if invocation_type label = ArchInvocationLabel ARMASIDPoolAssign then\n  if length extra_caps > 0\n  then\n    let (pd_cap, pd_cap_slot) = extra_caps ! 0\n     in case pd_cap of\n          ArchObjectCap (PageDirectoryCap _ None) \\<Rightarrow> doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n            whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n            whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n            pool \\<leftarrow> liftE $ get_asid_pool p;\n            free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n            returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pd_cap_slot\n          odE\n        | _ \\<Rightarrow>  throwError $ InvalidCapability 1\n  else  throwError TruncatedMessage\n  else  throwError IllegalOperation\n| VCPUCap p \\<Rightarrow> fail \\<comment> \\<open>not an MMU invocation\\<close>\"", "property": "Decode MMU Invocations: Decodes architecture-specific system calls related to Memory Management Unit (MMU) invocations, handling various operations such as page directory flushes, page table maps and unmaps, page maps and unmaps, ASID control, and ASID pool assignments.\n\nSubproperties:\n- Page Directory Flush: Flushes a range of addresses in a page directory, ensuring that the start address is less than the end address and that the range does not exceed the kernel base.\n- Page Table Map: Maps a page table to a virtual address, checking that the mapped address is not already in use and that the page directory and ASID match.\n- Page Table Unmap: Unmaps a page table from a virtual address, checking that the final capability is being used.\n- Page Map: Maps a page to a virtual address, checking that the page is not already mapped and that the ASID and page directory match.\n- Page Unmap: Unmaps a page from a virtual address.\n- Page Flush: Flushes a range of addresses in a page, ensuring that the start address is less than the end address and that the range does not exceed the page size.\n- ASID Control: Creates a new ASID pool or assigns an ASID to a page directory, checking that the ASID is not already in use and that the page directory and ASID match.\n- ASID Pool Assignment: Assigns an ASID to a page directory, checking that the ASID is not already in use and that the page directory and ASID match.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": " decode mmu invocations "}
{"spec": "definition\n  arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n VCPUCap _ \\<Rightarrow> decode_vcpu_invocation label args cap extra_caps\n\\<comment> \\<open>arm-hyp: add cases for iommu\\<close>\n| _ \\<Rightarrow> decode_mmu_invocation label args x_slot cte cap extra_caps\"\n\ndefinition\n  arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\" where\n \"arch_data_to_obj_type n \\<equiv>\n  if n = 0 then Some PageDirectoryObj\n  else if n = 1 then Some SmallPageObj\n  else if n = 2 then Some LargePageObj\n  else if n = 3 then Some SectionObj\n  else if n = 4 then Some SuperSectionObj\n  else if n = 5 then Some PageTableObj\n  else if n = 6 then Some VCPUObj\n  else None\"\n\ndefinition arch_decode_irq_control_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list \\<Rightarrow> (arch_irq_control_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_irq_control_invocation label args src_slot cps \\<equiv>\n    (if invocation_type label = ArchInvocationLabel ARMIRQIssueIRQHandler\n      then if length args \\<ge> 4 \\<and> length cps \\<ge> 1\n        then let irq_word = args ! 0;\n                 trigger = args ! 1;\n                 index = args ! 2;\n                 depth = args ! 3;\n                 cnode = cps ! 0;\n                 irq = ucast irq_word\n        in doE\n          arch_check_irq irq_word;\n          irq_active \\<leftarrow> liftE $ is_irq_active irq;\n          whenE irq_active $ throwError RevokeFirst;\n\n          dest_slot \\<leftarrow> lookup_target_slot cnode (data_to_cptr index) (unat depth);\n          ensure_empty dest_slot;\n\n          returnOk $ ArchIRQControlIssue irq dest_slot src_slot (trigger \\<noteq> 0)\n        odE\n      else throwError TruncatedMessage\n    else throwError IllegalOperation)\"\n\nend\n\nend", "property": "Architecture-specific System Call Decoding: Decodes architecture-specific invocations, handling VCPU and MMU-related operations, and IRQ control invocations for issuing IRQ handlers.\n\nSubproperties:\n- VCPU and MMU Decoding: Decodes VCPU and MMU-related invocations based on the provided capability and arguments.\n- IRQ Control Decoding: Decodes IRQ control invocations, specifically for issuing IRQ handlers, and performs necessary checks and operations to ensure correct IRQ handling.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": " arch decode invocations "}
{"spec": "datatype flush_type = Clean | Invalidate | CleanInvalidate | Unify\n\ndatatype page_directory_invocation =\n    PageDirectoryFlush (pd_flush_type: flush_type) (pd_flush_start: vspace_ref)\n                       (pd_flush_end: vspace_ref) (pd_flush_pstart: word32)\n                       (pd_flush_pd: obj_ref) (pd_flush_asid: asid)\n  | PageDirectoryNothing\n\ndatatype page_table_invocation =\n    PageTableMap cap cslot_ptr pde obj_ref\n  | PageTableUnmap cap cslot_ptr\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation\n     = PageMap\n         (page_map_asid: asid)\n         (page_map_cap: cap)\n         (page_map_ct_slot: cslot_ptr)\n         (page_map_entries: \"pte \\<times> (obj_ref list) + pde \\<times> (obj_ref list)\")\n     | PageUnmap\n         (page_unmap_cap: arch_cap)\n         (page_unmap_cap_slot: cslot_ptr)\n     | PageFlush\n         (page_flush_type: flush_type)\n         (page_flush_start: vspace_ref)\n         (page_flush_end: vspace_ref)\n         (page_flush_pstart: word32)\n         (page_flush_pd: obj_ref)\n         (page_flush_asid: asid)\n     | PageGetAddr\n         (page_get_paddr: obj_ref)\n\ndatatype vcpu_invocation =\n       VCPUSetTCB obj_ref (*vcpu*) obj_ref (*tcb*)\n     | VCPUInjectIRQ obj_ref nat virq\n     | VCPUReadRegister obj_ref vcpureg\n     | VCPUWriteRegister obj_ref vcpureg machine_word\n     | VCPUAckVPPI obj_ref (* vcpu *) vppievent_irq\n\ndatatype arch_invocation\n     = InvokePageTable page_table_invocation\n     | InvokePageDirectory page_directory_invocation\n     | InvokePage page_invocation\n     | InvokeASIDControl asid_control_invocation\n     | InvokeASIDPool asid_pool_invocation\n     | InvokeVCPU vcpu_invocation", "property": "ARM-Specific System Call Arguments: Define the various data types for encoding arguments to ARM-specific system calls, including flush types, page directory, page table, ASID control, ASID pool, page, and VCPU invocations. These data types provide a structured way to represent the different parameters and options for each system call, ensuring that the correct information is passed to the kernel for processing.\n\nSubproperties:\n- Flush Type: Specifies the type of flush operation to perform (Clean, Invalidate, CleanInvalidate, or Unify).\n- Page Directory and Page Table Invocations: Define the structure for page directory and page table operations, including mapping, unmapping, and flushing.\n- ASID Control and Pool Invocations: Represent the creation and assignment of ASID pools.\n- Page Invocations: Encode page-related operations, such as mapping, unmapping, flushing, and getting addresses.\n- VCPU Invocations: Define the structure for VCPU-related operations, including setting TCBs, injecting IRQs, reading and writing registers, and acknowledging VPP events.", "title": "./spec/abstract/ARM_HYP/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the various possible\nARM-specific system calls. Selectors are defined for various fields\nfor convenience elsewhere."}
{"spec": "datatype arch_copy_register_sets = ARMNoExtraRegisters\n\ndefinition \"ArchDefaultExtraRegisters \\<equiv> ARMNoExtraRegisters\"\n\ndatatype arch_irq_control_invocation =\n    ArchIRQControlIssue irq cslot_ptr cslot_ptr bool\n\nend\n\nend", "property": "ARM Platform Register Sets: The ARM platform currently does not define any additional register sets for the \"CopyRegisters\" operation, with a default value of ARMNoExtraRegisters.", "title": "./spec/abstract/ARM_HYP/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": " The ARM platform currently does not define any additional register sets for\nthe \"CopyRegisters\" operation. This may be changed in future to support a floating point unit. "}
{"spec": "text \\<open>An ASID is simply a word.\\<close>\ntype_synonym asid = \"word32\"\n\ndatatype vm_attribute = PageCacheable | XNever\ntype_synonym vm_attributes = \"vm_attribute set\"", "property": "ARM-Specific Data Types: Define architecture-specific data types for the ARM architecture, including the ASID (Application-Specific ID) type and virtual memory attributes (PageCacheable and XNever). \n\nSubproperties:\nASID Definition: An ASID is represented as a 32-bit word.\nVM Attribute Definition: Virtual memory attributes are defined as a set of PageCacheable and XNever attributes.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific capabilities", "comment": ""}
{"spec": "text \\<open>The ARM kernel supports capabilities for ASID pools and an ASID controller capability,\nalong with capabilities for page directories, page tables, and page mappings.\\<close>\n\ndatatype arch_cap =\n   ASIDPoolCap obj_ref asid\n | ASIDControlCap\n | PageCap bool obj_ref cap_rights vmpage_size \"(asid * vspace_ref) option\"\n | PageTableCap obj_ref \"(asid * vspace_ref) option\"\n | PageDirectoryCap obj_ref \"asid option\"\n | VCPUCap obj_ref\n\nlemmas arch_cap_cases =\n  arch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P, simplified, rule_format]\n\nlemmas arch_cap_cases_asm =\narch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n  simplified, rule_format, rotated -1]\n\ndefinition\n  is_page_cap :: \"arch_cap \\<Rightarrow> bool\" where\n  \"is_page_cap c \\<equiv> \\<exists>x0 x1 x2 x3 x4. c = PageCap x0 x1 x2 x3 x4\"", "property": "ARM-Specific Capability Types: The ARM kernel supports various capability types, including ASID pools, ASID controllers, page directories, page tables, page mappings, and VCPU capabilities, each with its own specific structure and properties. \n\nCapability Type Identification: Identify whether a given capability is a page capability or not.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "text \\<open>This section gives the types and auxiliary definitions for the\narchitecture-specific objects: a page directory entry (@{text \"pde\"})\ncontains either an invalid entry, a page table reference, a section\nreference, or a super-section reference; a page table entry contains\neither an invalid entry, a large page, or a small page mapping;\nfinally, an architecture-specific object is either an ASID pool, a\npage table, a page directory, or a data page used to model user\nmemory.\n\\<close>", "property": "ARM-Specific Object Types: Defines the types and structures for architecture-specific objects, including page directory entries (PDEs), page table entries (PTEs), ASID pools, page tables, page directories, and data pages, which are used to model user memory and facilitate memory management.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "datatype pde =\n   InvalidPDE\n | PageTablePDE obj_ref\n | SectionPDE obj_ref vm_attributes cap_rights\n | SuperSectionPDE obj_ref vm_attributes cap_rights\n\ndatatype pte =\n   InvalidPTE\n | LargePagePTE obj_ref vm_attributes cap_rights\n | SmallPagePTE obj_ref vm_attributes cap_rights\n\ntype_synonym hyper_reg_context = machine_word", "property": "ARM Hypervisor Page Table Structure: Supports a three-level page table system for stage 2 translation, but is configured to use only two levels to maintain the usual page table/directory nomenclature. \nPage Table Entry Types: Defines the types of page directory entries (Invalid, Page Table, Section, and Super Section) and page table entries (Invalid, Large Page, and Small Page) used in the ARM hypervisor.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": "\nHypervisor extensions use long page table descriptors (64-bit) for the stage 2\ntranslation (host-to-hypervisor). This is a three-level table system, but the\nhardware can be configured to omit the first level entirely if all second\nlevels are stored contiguously. We use this configuration to preserve the usual\npage table/directory nomenclature.\nseL4 does not use hardware domains or parity on ARM hypervisor systems.\n"}
{"spec": "definition\n  pde_bits :: \"nat\" where\n  \"pde_bits \\<equiv> 3\"\n\ndefinition\n  pte_bits :: \"nat\" where\n  \"pte_bits \\<equiv> 3\"\n\ndefinition\n  pd_bits :: \"nat\" where\n  \"pd_bits \\<equiv> 11 + pde_bits\"\n\ndefinition\n  pt_bits :: \"nat\" where\n  \"pt_bits \\<equiv> 9 + pte_bits\"\n\ndefinition\n  vcpu_bits :: \"nat\" where\n  \"vcpu_bits \\<equiv> pageBits\"", "property": "ARM-Specific Data Type Sizes: Define the sizes of various ARM-specific data types, including page directory entries (PDEs), page table entries (PTEs), page directories (PDs), page tables (PTs), and virtual CPU (VCPU) bits. \n\nSubproperties:\n- PDE Size: 3 bits\n- PTE Size: 3 bits\n- PD Size: 11 + PDE size (14 bits)\n- PT Size: 9 + PTE size (12 bits)\n- VCPU Size: equal to pageBits", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": "With hypervisor extensions enabled, page table and page directory entries occupy\n8 bytes. Page directories occupy four frames, and page tables occupy a frame."}
{"spec": "type_synonym virq = machine_word\n\nend\n\nqualify ARM_HYP_A (in Arch)\n\nrecord  gic_vcpu_interface =\n  vgic_hcr  :: machine_word\n  vgic_vmcr :: machine_word\n  vgic_apr  :: machine_word\n  vgic_lr   :: \"nat \\<Rightarrow> ARM_HYP_A.virq\"\n\nrecord vcpu =\n  vcpu_tcb   :: \"obj_ref option\"\n  vcpu_vgic  :: gic_vcpu_interface\n  vcpu_regs :: \"vcpureg \\<Rightarrow> machine_word\"\n  vcpu_vppi_masked :: \"vppievent_irq \\<Rightarrow> bool\"\n  vcpu_vtimer :: virt_timer\n\nend_qualify\n\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition \"vcpu_sctlr vcpu \\<equiv> vcpu_regs vcpu VCPURegSCTLR\"\n\ndefinition\n  default_gic_vcpu_interface :: gic_vcpu_interface\nwhere\n  \"default_gic_vcpu_interface \\<equiv> \\<lparr>\n      vgic_hcr  = vgicHCREN,\n      vgic_vmcr = 0,\n      vgic_apr  = 0,\n      vgic_lr   = \\<lambda>_. 0 \\<rparr>\"\n\ndefinition\n  default_vcpu :: vcpu where\n  \"default_vcpu \\<equiv> \\<lparr>\n      vcpu_tcb    = None,\n      vcpu_vgic   = default_gic_vcpu_interface,\n      vcpu_regs   = (\\<lambda>_. 0) (VCPURegSCTLR := sctlrDefault\n                             , VCPURegACTLR := actlrDefault),\n      vcpu_vppi_masked = (\\<lambda>_. False),\n      vcpu_vtimer = VirtTimer 0\n      \\<rparr>\"", "property": "ARM-Specific Data Types: Define the architecture-specific data types for ARM, including virtual CPU (vcpu) and Generic Interrupt Controller (GIC) vcpu interface, which comprise various registers and settings for managing interrupts, timers, and CPU configurations.\n\nDefault vcpu Settings: Specify the default settings for the vcpu, including the GIC interface, registers, and timer configurations, ensuring a consistent and predictable initial state for virtual CPUs.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": "vcpu"}
{"spec": "datatype arch_kernel_obj =\n   ASIDPool \"10 word \\<rightharpoonup> obj_ref\"\n | PageTable \"9 word \\<Rightarrow> pte\"  (* ARMHYP *)\n | PageDirectory \"11 word \\<Rightarrow> pde\"  (* ARMHYP *)\n | DataPage bool vmpage_size\n | VCPU vcpu\n\nlemmas arch_kernel_obj_cases =\n  arch_kernel_obj.induct[where arch_kernel_obj=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P,\n                         simplified, rule_format]\n\nlemmas arch_kernel_obj_cases_asm =\n  arch_kernel_obj.induct[where arch_kernel_obj=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n                         simplified, rule_format, rotated -1]\n\ndefinition cte_level_bits :: nat where\n  \"cte_level_bits \\<equiv> 4\"\n\nprimrec\n  arch_obj_size :: \"arch_cap \\<Rightarrow> nat\"\nwhere\n  \"arch_obj_size (ASIDPoolCap p as) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (PageCap dev x rs sz as4) = pageBitsForSize sz\"\n| \"arch_obj_size (PageDirectoryCap x as2) = pd_bits\"\n| \"arch_obj_size (PageTableCap x as3) = pt_bits\"\n| \"arch_obj_size (VCPUCap _) = vcpu_bits\"\n\nprimrec\n  arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_cap_is_device (PageCap dev x rs sz as4) = dev\"\n| \"arch_cap_is_device ASIDControlCap = False\"\n| \"arch_cap_is_device (ASIDPoolCap p as) = False\"\n| \"arch_cap_is_device (PageTableCap x as3) = False\"\n| \"arch_cap_is_device (PageDirectoryCap x as2) = False\"\n| \"arch_cap_is_device (VCPUCap _) = False\"\n\ndefinition tcb_bits :: nat where\n  \"tcb_bits \\<equiv> 9\"\n\ndefinition endpoint_bits :: nat where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat where\n  \"ntfn_bits \\<equiv> 4\"\n\ndefinition untyped_min_bits :: nat where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat where\n  \"untyped_max_bits \\<equiv> 29\"\n\nprimrec\n  arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\"\nwhere\n  \"arch_kobj_size (ASIDPool p) = pageBits\"\n| \"arch_kobj_size (PageTable pte) = pt_bits\"\n| \"arch_kobj_size (PageDirectory pde) = pd_bits\"\n| \"arch_kobj_size (DataPage dev sz) = pageBitsForSize sz\"\n| \"arch_kobj_size (VCPU _) = vcpu_bits\"\n\nprimrec\n  aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\"\nwhere\n  \"aobj_ref (ASIDPoolCap p as) = Some p\"\n| \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref (PageCap dev x rs sz as4) = Some x\"\n| \"aobj_ref (PageDirectoryCap x as2) = Some x\"\n| \"aobj_ref (PageTableCap x as3) = Some x\"\n| \"aobj_ref (VCPUCap x) = Some x\"\n\nprimrec (nonexhaustive)\n  acap_rights :: \"arch_cap \\<Rightarrow> cap_rights\"\nwhere\n \"acap_rights (PageCap dev x rs sz as) = rs\"\n\ndefinition\n  acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\" where\n \"acap_rights_update rs ac \\<equiv> case ac of\n    PageCap dev x rs' sz as \\<Rightarrow> PageCap dev x (validate_vm_rights rs) sz as\n  | _                   \\<Rightarrow> ac\"", "property": "ARM-Specific Data Types: Define architecture-specific objects, including ASID pools, page tables, page directories, data pages, and VCPUs, each with their respective properties and attributes.\n\nSubproperties:\n- ASID Pool: Translate 10 bits to an object reference.\n- Page Table: Contain 512 entries, each representing a page table entry.\n- Page Directory: Contain 512 entries, each representing a page directory entry.\n- Data Page: Record the page size and whether it is a device page.\n- VCPU: Store a potential association to a TCB and an extended register context.\n- Object Sizes: Define the sizes of various architecture-specific objects, including ASID pools, page tables, page directories, data pages, and VCPUs.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": "\n  ASID pools translate 10 bits, VCPUs store a potential association to a TCB as well as\n  an extended register context. Page tables have 512 entries (cf B3.6.5, pg 1348). For data pages,\n  we record their size.\n"}
{"spec": "datatype\n  aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | SectionObj\n  | SuperSectionObj\n  | PageTableObj\n  | PageDirectoryObj\n  | ASIDPoolObj\n  | VCPUObj\n\ndefinition\n  arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\"\n  where\n    \"arch_is_frame_type aobj \\<equiv> case aobj of\n         SmallPageObj \\<Rightarrow> True\n       | LargePageObj \\<Rightarrow> True\n       | SectionObj \\<Rightarrow> True\n       | SuperSectionObj \\<Rightarrow> True\n       | _ \\<Rightarrow> False\"\n\ndefinition  arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\" where\n \"arch_default_cap tp r n dev \\<equiv> case tp of\n  SmallPageObj \\<Rightarrow> PageCap dev r vm_read_write ARMSmallPage None\n  | LargePageObj \\<Rightarrow> PageCap dev r vm_read_write ARMLargePage None\n  | SectionObj \\<Rightarrow> PageCap dev r vm_read_write ARMSection None\n  | SuperSectionObj \\<Rightarrow> PageCap dev r vm_read_write ARMSuperSection None\n  | PageTableObj \\<Rightarrow> PageTableCap r None\n  | PageDirectoryObj \\<Rightarrow> PageDirectoryCap r None\n  | VCPUObj \\<Rightarrow> VCPUCap r\n  | ASIDPoolObj \\<Rightarrow> ASIDPoolCap r 0\" (* unused *)\n\ndefinition\n  default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\" where\n \"default_arch_object tp dev n \\<equiv> case tp of\n    SmallPageObj \\<Rightarrow> DataPage dev ARMSmallPage\n  | LargePageObj \\<Rightarrow> DataPage dev ARMLargePage\n  | SectionObj \\<Rightarrow> DataPage dev ARMSection\n  | SuperSectionObj \\<Rightarrow> DataPage dev ARMSuperSection\n  | PageTableObj \\<Rightarrow> PageTable (\\<lambda>x. InvalidPTE)\n  | PageDirectoryObj \\<Rightarrow> PageDirectory (\\<lambda>x. InvalidPDE)\n  | VCPUObj \\<Rightarrow> VCPU default_vcpu\n  | ASIDPoolObj \\<Rightarrow> ASIDPool (\\<lambda>_. None)\"\n\ntype_synonym hw_asid = word8\n\ntype_synonym arm_vspace_region_uses = \"vspace_ref \\<Rightarrow> arm_vspace_region_use\"", "property": "ARM-Specific Object Types and Default Objects: Define architecture-specific object types, including various page objects, table and directory objects, ASID pool objects, and VCPU objects. Provide functions to determine if an object type is a frame type, create default capabilities for objects, and generate default objects based on their type, device, and size. These definitions ensure that ARM-specific objects are correctly represented and managed within the kernel. \n\nSubproperties:\n- Frame Type Identification: Identify if an ARM-specific object type is a frame type, which includes small, large, section, and super section page objects.\n- Default Capability Generation: Create default capabilities for ARM-specific objects based on their type, including page, table, directory, VCPU, and ASID pool capabilities.\n- Default Object Creation: Generate default objects for ARM-specific types, including data pages, page tables, page directories, VCPUs, and ASID pools, ensuring correct initialization and management of these objects within the kernel.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "text \\<open>The architecture-specific state for the ARM model\nconsists of the first level of the ASID table (@{text \"arm_asid_table\"}), a\nmap from hardware ASIDs to seL4 ASIDs (@{text \"arm_hwasid_table\"}),\nthe next hardware ASID to preempt (@{text \"arm_next_asid\"}), the\ninverse map from seL4 ASIDs to hardware ASIDs (first component of\n@{text \"arm_asid_map\"}), and the address of the page directory and\npage tables mapping the shared address space, along with a description\nof this space (@{text \"arm_global_pd\"}, @{text \"arm_global_pts\"}, and\n@{text \"arm_kernel_vspace\"} respectively).\n\nHardware ASIDs are only ever associated with seL4 ASIDs that have a\ncurrently active page directory. The second component of\n@{text \"arm_asid_map\"} values is the address of that page directory.\n\\<close>\n\nend\n\nqualify ARM_HYP_A (in Arch)", "property": "ARM Architecture State: Maintains architecture-specific state, including the ASID table, hardware ASID to seL4 ASID mapping, next hardware ASID, inverse mapping from seL4 ASIDs to hardware ASIDs, and shared address space mappings.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "record arch_state =\n  arm_asid_table    :: \"7 word \\<rightharpoonup> obj_ref\"\n  arm_hwasid_table  :: \"ARM_HYP_A.hw_asid \\<rightharpoonup> ARM_HYP_A.asid\"\n  arm_next_asid     :: ARM_HYP_A.hw_asid\n  arm_asid_map      :: \"ARM_HYP_A.asid \\<rightharpoonup> (ARM_HYP_A.hw_asid \\<times> obj_ref)\"\n  arm_current_vcpu    :: \"(obj_ref \\<times> bool) option\"\n  arm_gicvcpu_numlistregs :: nat\n  arm_kernel_vspace :: ARM_HYP_A.arm_vspace_region_uses\n  arm_us_global_pd  :: obj_ref\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)", "property": "ARM Architecture State: Maintains architecture-specific state information, including ASID tables, hardware ASID mappings, current VCPU state, GIC VCPU number list registers, kernel vspace region uses, and user-space global page directory references.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific state", "comment": "arch\\_state"}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable\n  | APageDirectory\n  | AVCPU\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\"\nwhere\n \"aa_type ao \\<equiv> (case ao of\n           PageTable pt             \\<Rightarrow> APageTable\n         | PageDirectory pd         \\<Rightarrow> APageDirectory\n         | DataPage dev sz          \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n         | ASIDPool f               \\<Rightarrow> AASIDPool\n         | VCPU v                   \\<Rightarrow> AVCPU)\"", "property": "ARM-Specific Data Type Classification: Classify ARM-specific kernel objects into distinct types, including ASID pool, page table, page directory, VCPU, user data, and device data, to ensure accurate and efficient management of these objects.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "definition\n  badge_bits :: nat where\n  badge_bits_def [simp]: \"badge_bits \\<equiv> 28\"\nend", "property": "Badge Bits Definition: The badge word has a fixed number of bits, specifically 28.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": "For implementation reasons the badge word has differing amounts of bits"}
{"spec": "qualify ARM_HYP_A (in Arch)", "property": "Arch-Specific TCB Structure: Defines the architecture-specific components of a Thread Control Block (TCB) for ARM Hypervisor mode.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Arch-specific tcb", "comment": ""}
{"spec": "definition\n  arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\nwhere\n  \"arch_tcb_set_registers regs a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := UserContext regs \\<rparr>\"\n\ndefinition\n  arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\"\nwhere\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\n\n\nend", "property": "Arch-Specific TCB Accessors: Provide access to the user register part of the arch_tcb, allowing for the retrieval and modification of user registers within the tcb_context. \n\nRegister Access: Get and set user registers within the tcb_context of an arch_tcb.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Arch-specific tcb", "comment": "\n  Accessors for the user register part of the @{text \"arch_tcb\"}.\n  (Because @{typ \"register \\<Rightarrow> machine_word\"} might not be equal to @{typ user_context})."}
{"spec": "(*\nFunctions for fault handling.\n*)\n\nchapter \\<open>arch fault related functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\nwhere\n  \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData) od\"\n| \"make_arch_fault_msg (VCPUFault hsr) thread = return (7, [hsr])\"\n| \"make_arch_fault_msg (VPPIEvent irq) thread = return (8, [ucast irq])\"\n| \"make_arch_fault_msg (VGICMaintenance archData) thread = do\n      msg \\<leftarrow> return $ (case archData of None \\<Rightarrow> [-1] | Some idx \\<Rightarrow> [idx]);\n      return (6, msg)\n   od\"\n\ndefinition\n  handle_arch_fault_reply :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"handle_arch_fault_reply af thread x y = return True\"\n\n\nend\n\nend", "property": "Arch Fault Handling: Provides functions for creating architecture-specific fault messages and handling replies to these faults, ensuring proper communication and error handling in the system.\n\nSubproperties:\n- Make Arch Fault Message: Creates a fault message based on the type of architecture-specific fault (e.g., VM fault, VCPU fault, VPPI event, VGIC maintenance) and the thread experiencing the fault.\n- Handle Arch Fault Reply: Handles the reply to an architecture-specific fault, currently always returning True.", "title": "./spec/abstract/ARM_HYP/ArchFault_A.thy", "chapter": "arch fault related functions", "section": "", "comment": ""}
{"spec": "(*\nArch-specific functions for the abstract model of CSpace.\n*)\n\nchapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"sanitise_register t r v \\<equiv> case r of\n      CPSR \\<Rightarrow>\n       if t \\<and>\n          v && 0x1f \\<in> {0x10, 0x11, 0x12, 0x13, 0x17, 0x1b, 0x1f}\n            \\<comment> \\<open>@{text \\<open>PMODE_(USER/FIQ/IRQ/SUPERVISOR/ABORT/UNDEFINED/SYSTEM)\\<close>}\\<close>\n       then v\n       else (v && 0xf8000000) || 0x150\n    | _    \\<Rightarrow> v\"\n\ndefinition\n  arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\nwhere\n  \"arch_get_sanitise_register_info t \\<equiv> do\n          vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n          return (vcpu \\<noteq> None)\n   od\"\n\ndefinition\n  arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\nwhere\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "TCB Register Management: Sanitizes and manages registers, ensuring that certain registers are modified according to specific rules, while others remain unchanged.\n\nSubproperties:\n- Sanitize Register: Modifies the CPSR register to ensure it only contains specific values, otherwise, it sets the register to a default value.\n- Get Sanitise Register Info: Retrieves information about whether the thread's VCPU is set, indicating whether sanitization is required.\n- Post Modify Registers: Currently a no-op, intended to perform additional actions after modifying registers.", "title": "./spec/abstract/ARM_HYP/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "definition\n  update_cnode_cap_data :: \"data \\<Rightarrow> nat \\<times> data\" where\n \"update_cnode_cap_data w \\<equiv>\n    let\n      guard_bits = 18;\n      guard_size' = unat ((w >> cnode_padding_bits) && mask cnode_guard_size_bits);\n      guard'' = (w >> (cnode_padding_bits + cnode_guard_size_bits)) && mask guard_bits\n    in (guard_size', guard'')\"", "property": "Cnode Capability Modification: Extract new guard bits and guard from user-provided data for modifying a cnode capability. \n\nExtract Guard Information: Calculate the guard size and guard value from the given data word, considering the padding bits, guard size bits, and guard bits.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "On a user request to modify a cnode capability, extract new guard bits and guard."}
{"spec": "definition\n  arch_is_physical :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_is_physical cap \\<equiv> case cap of ASIDControlCap \\<Rightarrow> False | _ \\<Rightarrow> True\"", "property": "Distinguish Physical Capabilities: Identify whether an architecture-specific capability is physical or not, with ASIDControlCap being treated as non-physical and all others as physical.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "For some purposes capabilities to physical objects are treated\ndifferently to others."}
{"spec": "fun\n  arch_same_region_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_same_region_as (PageCap dev r R s x) (PageCap dev' r' R' s' x') =\n   (let\n     topA = r + (1 << pageBitsForSize s) - 1;\n     topB = r' + (1 << pageBitsForSize s') - 1\n   in r \\<le> r' \\<and> topA \\<ge> topB \\<and> r' \\<le> topB)\"\n| \"arch_same_region_as (PageTableCap r x) (PageTableCap r' x') = (r' = r)\"\n| \"arch_same_region_as (PageDirectoryCap r x) (PageDirectoryCap r' x') = (r' = r)\"\n| \"arch_same_region_as ASIDControlCap ASIDControlCap = True\"\n| \"arch_same_region_as (ASIDPoolCap r a) (ASIDPoolCap r' a') = (r' = r)\"\n| \"arch_same_region_as (VCPUCap r) (VCPUCap r') = (r' = r)\"\n| \"arch_same_region_as _ _ = False\"", "property": "Architectural Capability Region Check: Determine if two architectural capabilities refer to the same object or if one is contained within the region of the other, ensuring proper relationships between capabilities.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether the second capability is to the same object or an object\ncontained in the region of the first one."}
{"spec": "definition\n  same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n \"same_aobject_as cp cp' \\<equiv>\n   (case (cp, cp') of\n      (PageCap dev ref _ pgsz _,PageCap dev' ref' _ pgsz' _)\n          \\<Rightarrow> (dev, ref, pgsz) = (dev', ref', pgsz')\n              \\<and> ref \\<le> ref + 2 ^ pageBitsForSize pgsz - 1\n    | _ \\<Rightarrow> arch_same_region_as cp cp')\"", "property": "Arch Capability Equivalence: Two architecture-specific capabilities are considered equivalent if they refer to the same object, which is determined by matching device, reference, and page size attributes for page capabilities, or by using architecture-specific region comparison for other capability types.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "declare same_aobject_as_def[simp]\n\ndefinition\n  arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"arch_is_cap_revocable c c' \\<equiv> False\"\n\nend\nend", "property": "Architectural Capability Revocability: No architectural capabilities are revocable.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": " Proofs don't want to see this definition "}
{"spec": "type_synonym obj_ref            = machine_word\ntype_synonym vspace_ref         = machine_word\n\ntype_synonym data               = machine_word\ntype_synonym cap_ref            = \"bool list\"\ntype_synonym length_type        = machine_word\n\ntype_synonym asid_low_len       = 10\ntype_synonym asid_low_index     = \"asid_low_len word\"\n\ntype_synonym asid_high_len      = 7\ntype_synonym asid_high_index    = \"asid_high_len word\"", "property": "Type Instantiation: Define concrete types for abstract type names in the specification for the ARM architecture, including object references, virtual space references, data, capability references, and length types. \n\nSubproperties:\n- Object Reference Type: obj_ref is instantiated as machine_word.\n- Virtual Space Reference Type: vspace_ref is instantiated as machine_word.\n- Data Type: data is instantiated as machine_word.\n- Capability Reference Type: cap_ref is instantiated as a list of boolean values.\n- Length Type: length_type is instantiated as machine_word.\n- ASID Low Length: asid_low_len is set to 10.\n- ASID Low Index Type: asid_low_index is instantiated as a 10-bit word.\n- ASID High Length: asid_high_len is set to 7.\n- ASID High Index Type: asid_high_index is instantiated as a 7-bit word.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object\n  references, user pointers, word-based data, cap references, and so\n  on. This theory provides an instantiation of these names to concrete\n  types for the ARM architecture. Other architectures may have slightly\n  different instantiations.\n"}
{"spec": "type_synonym asid_len           = 17\ntype_synonym asid_rep_len       = machine_word_len\ntype_synonym asid               = \"asid_rep_len word\"", "property": "ASID Representation: ASIDs are represented as machine words with a fixed length, where only the first 17 bits are significant and the remaining bits are zero.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": " Making asid a machine_word means that we need invariants that the extra bits are zero. "}
{"spec": "definition\n  oref_to_data   :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_oref   :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition\n  vref_to_data   :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_vref   :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition\n  nat_to_len     :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition\n  data_to_nat    :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition\n  data_to_16     :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition\n  data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition\n  combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition\n  combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Provide functions for converting between different data types, including object references, virtual space references, natural numbers, length types, and capability pointers, to facilitate data manipulation and exchange in the system.\n\nSubproperties:\n- Identity Conversions: Define identity functions for converting between abstract type names, such as object references and data, and virtual space references and data.\n- Numeric Conversions: Specify functions for converting between natural numbers and length types, as well as between data and natural numbers.\n- Bitwise Conversions: Define functions for converting between data and 16-bit words using unsigned casting.\n- Capability Pointer Conversions: Provide a function for converting data to capability pointers using bit list representation.\n- Notification Combinations: Define functions for combining notification badges and messages using bitwise OR operations.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "With the definitions above, most conversions between abstract\ntype names boil down to just the identity function, some convert from\n@{text word} to @{typ nat} and others between different word sizes\nusing @{const ucast}."}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversions: Define conversions between different data types, including object references, virtual references, lengths, and capability pointers, to facilitate automatic unfolding in proofs.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition\n  slot_bits :: nat where\n  \"slot_bits \\<equiv> 4\"\n\ndefinition\n  msg_label_bits :: nat where\n  [simp]: \"msg_label_bits \\<equiv> 20\"\n\ndefinition\n  new_context :: \"user_context\" where\n  \"new_context \\<equiv> UserContext ((\\<lambda>r. 0) (CPSR := 0x150))\"", "property": "Architecture-Dependent Sizes: Define the sizes of various architecture-dependent components, including the slot size and message label size, to ensure compatibility with the underlying machine architecture.\nStandard Configuration: Establish a standard user context with default register values, including the CPSR register set to a specific value, to facilitate the initialization of new user contexts.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "The following definitions provide architecture-dependent sizes\n  such as the standard page size and capability size of the underlying\n  machine.\n"}
{"spec": "definition\n  kernel_base :: \"vspace_ref\" where\n  \"kernel_base \\<equiv> 0xe0000000\"\n\ndefinition\n  idle_thread_ptr :: vspace_ref where\n  \"idle_thread_ptr = kernel_base + 0x1000\"\n\nend\n\narch_requalify_consts (A) kernel_base idle_thread_ptr\n\ncontext Arch begin arch_global_naming (A)", "property": "Kernel Window Base Address: The kernel reserves virtual addresses from a fixed base address (0xe0000000) upwards in every virtual address space, ensuring a consistent and protected kernel region. \n\nSubproperty: \nIdle Thread Pointer: The idle thread pointer is offset from the kernel base address by 0x1000, providing a fixed location for the idle thread in the kernel's virtual address space.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "The lowest virtual address in the kernel window. The kernel reserves the\nvirtual addresses from here up in every virtual address space."}
{"spec": "definition\n  nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\" where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len)\n                           (to_bl (of_nat n :: machine_word))\"\n\ndefinition\n \"msg_info_register \\<equiv> msgInfoRegister\"\ndefinition\n \"msg_registers \\<equiv> msgRegisters\"\ndefinition\n \"cap_register \\<equiv> capRegister\"\ndefinition\n \"badge_register \\<equiv> badgeRegister\"\ndefinition\n \"frame_registers \\<equiv> frameRegisters\"\ndefinition\n \"gp_registers \\<equiv> gpRegisters\"\ndefinition\n \"exception_message \\<equiv> exceptionMessage\"\ndefinition\n \"syscall_message \\<equiv> syscallMessage\"\n\n\ndatatype arch_fault =\n    VMFault vspace_ref \"machine_word list\"\n  | VGICMaintenance \"data option\" (* idx *)\n  | VCPUFault data (* hsr *)\n  | VPPIEvent irq (* vppi IRQ *)\n\n\nend\n\nend", "property": "Constant Definitions: Define various constants used in modelling machine operations, including register names, message types, and fault types for architecture-specific errors. \n\nSubproperties:\n- Register Names: Specify the names of registers used in message handling, capability management, and other operations.\n- Message Types: Define the types of messages used in the system, including exception and syscall messages.\n- Fault Types: Enumerate the types of faults that can occur in the architecture, including virtual memory faults, VGIC maintenance, VCPU faults, and VPPI events.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "Miscellaneous definitions of constants used in modelling machine\noperations."}
{"spec": "theory TypHeapLimits\n  imports CParser.TypHeapLib\nbegin\n\ndefinition\n  states_all_but_typs_eq :: \"char list set \\<Rightarrow> heap_raw_state \\<Rightarrow> heap_raw_state \\<Rightarrow> bool\"\nwhere\n \"states_all_but_typs_eq names hrs hrs'\n    = (hrs_htd hrs = hrs_htd hrs'\n        \\<and> (\\<forall>x. hrs_mem hrs x = hrs_mem hrs' x\n             \\<or> (\\<exists>p td. x \\<in> {p ..+ size_td td} \\<and> td_names td \\<subseteq> names\n                    \\<and> typ_name td \\<noteq> pad_typ_name\n                    \\<and> valid_footprint (hrs_htd hrs) p td)))\"\n\nlemma heap_list_eq_from_region_eq:\n  \"\\<forall>x \\<in> {p ..+ n}. hp x = hp' x\n    \\<Longrightarrow> heap_list hp n p = heap_list hp' n p\"\n  apply (induct n arbitrary: p)\n   apply simp\n  apply (simp add: intvl_def)\n  apply (frule_tac x=p in spec, drule mp, rule_tac x=0 in exI,\n         simp+)\n  apply (erule meta_allE, erule meta_mp)\n  apply clarsimp\n  apply (drule spec, erule mp)\n  apply (rule_tac x=\"Suc k\" in exI)\n  apply simp\n  done\n\nlemma states_all_but_typs_eq_clift:\n  \"\\<lbrakk> states_all_but_typs_eq names hrs hrs';\n      \\<forall>x \\<in> td_names (typ_info_t TYPE('a)). x \\<notin> names;\n      typ_name (typ_info_t TYPE('a)) \\<noteq> pad_typ_name \\<rbrakk>\n     \\<Longrightarrow> (clift hrs :: (_ \\<rightharpoonup> ('a :: c_type))) = clift hrs'\"\n  apply (rule ext, simp add: lift_t_def)\n  apply (cases hrs, cases hrs', clarsimp)\n  apply (simp add: lift_typ_heap_def restrict_map_def)\n  apply (simp add: s_valid_def proj_d_lift_state\n                   states_all_but_typs_eq_def hrs_htd_def\n                   hrs_mem_def)\n  apply clarsimp\n  apply (simp add: heap_list_s_heap_list h_t_valid_def)\n  apply (subst heap_list_eq_from_region_eq, simp_all)\n  apply clarsimp\n  apply (drule spec, erule disjE, assumption)\n  apply clarsimp\n  apply (drule(1) valid_footprint_neq_disjoint)\n    apply (clarsimp simp: typ_uinfo_t_def typ_tag_lt_def\n                          typ_tag_le_def)\n    apply (force dest: td_set_td_names\n                intro: td_set_td_names[OF td_set_self])\n   apply (clarsimp simp: field_of_def typ_uinfo_t_def)\n   apply (force dest: td_set_td_names\n               intro: td_set_td_names[OF td_set_self])\n  apply (simp add: size_of_def)\n  apply blast\n  done\n\nlemma states_all_but_typs_eq_refl:\n  \"states_all_but_typs_eq names hrs hrs\"\n  by (simp add: states_all_but_typs_eq_def)\n\nlemma states_all_but_typs_eq_trans:\n  \"states_all_but_typs_eq names hrs hrs'\n     \\<Longrightarrow> states_all_but_typs_eq names hrs' hrs''\n     \\<Longrightarrow> states_all_but_typs_eq names hrs hrs''\"\n  apply (clarsimp simp add: states_all_but_typs_eq_def\n                  del: disjCI)\n  apply (drule_tac x=x in spec)+\n  apply clarsimp\n  done\n\nlemma states_all_but_typs_eq_update:\n  \"\\<lbrakk> hrs_htd hrs \\<Turnstile>\\<^sub>t (ptr :: ('a :: c_type) ptr);\n      td_names (typ_info_t TYPE('a)) \\<subseteq> names;\n      typ_name (typ_info_t TYPE('a)) \\<noteq> pad_typ_name;\n      wf_fd (typ_info_t TYPE('a)) \\<rbrakk>\n        \\<Longrightarrow>\n   states_all_but_typs_eq names hrs\n    (hrs_mem_update (heap_update ptr v) hrs)\"\n  apply (clarsimp simp: states_all_but_typs_eq_def hrs_mem_update\n                   del: disjCI)\n  apply (subst disj_commute, rule disjCI)\n  apply (rule_tac x=\"ptr_val ptr\" in exI)\n  apply (rule_tac x=\"typ_uinfo_t TYPE('a)\" in exI)\n  apply (simp add: typ_uinfo_t_def h_t_valid_def heap_update_def)\n  apply (rule ccontr)\n  apply (subst(asm) heap_update_nmem_same)\n   apply (simp add: to_bytes_def length_fa_ti)\n   apply (subst length_fa_ti, simp_all add: size_of_def)\n  done\n\nend", "property": "Heap Equivalence Properties: Define the conditions under which two heaps are considered equivalent, ignoring differences in type information. Specifically, two heaps are equivalent if their heap type descriptions (htd) are equal and their memory contents are equal, except for regions occupied by types with names in a specified set.\n\nSubproperties:\n\n* Heap List Equivalence: If two heaps have equal memory contents in a specific region, then their heap lists are also equal in that region.\n* Lifted Heap Equivalence: If two heaps are equivalent, ignoring differences in type information, and a specific type is not in the set of ignored types, then the lifted heaps (clift) are also equal.\n* Reflexivity, Transitivity, and Update Properties: Heap equivalence is reflexive and transitive, and updating a heap with a new value preserves equivalence if the updated region is occupied by a type with a name in the specified set.", "title": "./spec/cspec/TypHeapLimits.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(* The base theory for generated bitfield proofs about the kernel *)\n\ntheory KernelState_C\nimports\n  \"Word_Lib.WordSetup\"\n  \"CLib.BitFieldProofsLib\"\n  \"Substitute\"\nbegin\n\ntype_synonym c_ptr_name = int\ntype_synonym 't c_com = \"('t, c_ptr_name, strictc_errortype) com\"\ntype_synonym 't c_body = \"('t, c_ptr_name, strictc_errortype) body\"\ntype_synonym 't c_xstate = \"('t, strictc_errortype) xstate\"\n\ntype_synonym cstate = \"globals myvars\"\ntype_synonym rf_com = \"cstate c_com\"\n\nabbreviation\n  \"cslift (s :: cstate) \\<equiv> clift (t_hrs_' (globals s))\"\n\nlemma cslift_def: \"is_an_abbreviation\" by (simp add: is_an_abbreviation_def)", "property": "Kernel State Abstraction: Define the kernel state and its related types, including pointer names, computations, and states, to provide a foundation for generated bitfield proofs about the kernel.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation\n  \"c_h_t_valid\" :: \"cstate \\<Rightarrow> 'a::c_type ptr \\<Rightarrow> bool\"  (\"_ \\<Turnstile>\\<^sub>c _\" [99,99] 100)\nwhere\n  \"s \\<Turnstile>\\<^sub>c p == hrs_htd (t_hrs_' (globals s)),c_guard \\<Turnstile>\\<^sub>t p\"", "property": "C State Validity: A cstate is valid with respect to a pointer if the heap satisfies the type and guard conditions for that pointer.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": " Add an abbreviation for the common case of hrs_htd (t_hrs_' (globals s)) \\<Turnstile>\\<^sub>t p "}
{"spec": "lemmas conseqPre = HoarePartialDef.conseqPre\nlemmas conseqPost = HoarePartialDef.conseqPost", "property": "Override HoarePartialDef Namespaces: Allow the use of shorter names for specific HoarePartialDef theorems (conseqPre and conseqPost) to simplify and reduce repetition in proofs, improving readability and maintainability.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": " The HoarePartialDef theorems are used extensively\n   (as opposed to their HoareTotalDef counterparts, which aren't used much).\n   We can give most their long names, but conseqPre is used over 400 times,\n   so for these cases we override the namespaces "}
{"spec": "lemmas conj_cong = HOL.conj_cong", "property": "Logical Conjunction Congruence: Establishes the congruence property for logical conjunction, ensuring that equal propositions can be substituted in a conjunction without affecting its validity.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": " Likewise, we'd prefer to get HOL.conj_cong over StateFun.conj_cong "}
{"spec": "declare bit_shiftr_eq[simp del]\ndeclare shiftl_of_Suc[simp del]\n\nend", "property": "No Simplification Rules: Excludes two specific rules (bit_shiftr_eq and shiftl_of_Suc) from the simplification process to facilitate bitfield proofs.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": " Removes two rules that are too eager for the bitfield proofs. "}
{"spec": "theory KernelInc_C\nimports\n  \"Substitute\"\n  \"structures_defs\"\n  \"structures_proofs\"\n  \"shared_types_defs\"\n  \"shared_types_proofs\"\nbegin\n\nend", "property": "No specific property can be summarized from the given code as it only contains import statements and does not describe any specific behavior or functionality.", "title": "./spec/cspec/KernelInc_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Substitute\n\nimports\n  \"CKernel.Kernel_C\"\n  \"AsmRefine.GlobalsSwap\"\nbegin\n\nML \\<open>\n\nstructure SubstituteSpecs = struct\n\nval list_abs = uncurry (fold_rev (fn (x, T) => fn t => Abs (x, T, t)));\n\nfun get_rhs thm =\n    snd (Logic.dest_equals (Thm.concl_of thm))\n    handle TYPE _ =>\n      snd (HOLogic.dest_eq (Thm.concl_of thm));\n\nfun get_lhs thm =\n    fst (Logic.dest_equals (Thm.concl_of thm))\n    handle TYPE _ =>\n      fst (HOLogic.dest_eq (Thm.concl_of thm));\n\nfun term_convert prefix convs (tm as Const (name, _)) =\n    if not (String.isPrefix prefix name) then tm\n    else the (Termtab.lookup convs tm)\n  | term_convert _ _ tm = tm;\n\nfun suspicious_term ctxt s t = if Term.add_var_names t [] = [] then ()\n  else (tracing (\"suspicious \" ^ s);\n    Syntax.pretty_term ctxt t |> Pretty.string_of |> tracing;\n    ())\n\nval debug_trace = ref (Bound 0);\n\nfun convert prefix src_ctxt proc (tm as Const (name, _)) (convs, ctxt) =\n  ((term_convert prefix convs tm; (convs, ctxt))\n  handle Option =>\n let\n    val cname = unprefix prefix name;\n    val def_thm = Proof_Context.get_thm src_ctxt (cname ^ \"_def\")\n    val rhs = get_rhs def_thm;\n    val _ = suspicious_term ctxt \"init rhs\" rhs;\n    val consts = Term.add_consts rhs [];\n    val (convs, ctxt) = fold (convert prefix src_ctxt proc o Const)\n        consts (convs, ctxt);\n    val rhs' = map_aterms (term_convert prefix convs) rhs;\n    val rhs'' = proc ctxt cname rhs';\n    val _ = suspicious_term ctxt \"adjusted rhs\" rhs'';\n\n  in if rhs'' aconv rhs\n    then (Termtab.insert (K true) (tm, tm) convs,\n        ctxt\n        |> Local_Theory.begin_nested |> snd\n        |> Local_Theory.abbrev Syntax.mode_default ((Binding.name cname, NoSyn), get_lhs def_thm)\n        |> snd |> Local_Theory.note ((Binding.name (cname ^ \"_def\"), []), [def_thm])\n        |> snd |> Local_Theory.end_nested\n    )\n\n  else let\n      val _ = tracing (\"Defining \" ^ cname);\n\n      val pre_def_ctxt = ctxt\n      val b = Binding.name cname\n      val ctxt = Local_Theory.begin_nested ctxt |> snd\n      val ((tm', _), ctxt) = Local_Theory.define\n          ((b, NoSyn), ((Thm.def_binding b, []), rhs'')) ctxt\n      val tm'' = Morphism.term (Proof_Context.export_morphism ctxt pre_def_ctxt) tm'\n      val ctxt = Local_Theory.end_nested ctxt\n\n      val lhs_argTs = get_lhs def_thm |> strip_comb |> snd |> map fastype_of;\n      val abs_tm = list_abs (map (pair \"_\") lhs_argTs, tm'')\n\n    in (Termtab.insert (K true) (tm, abs_tm) convs, ctxt) end\n  end)\n  | convert _ _ _ (tm) _ = raise TERM (\"convert: not Const\", [tm])\n\n\nfun prove_impl_tac ctxt ss =\n    SUBGOAL (fn (t, n) => let\n        val lhs = t |> HOLogic.dest_Trueprop |> HOLogic.dest_eq |> fst;\n        val cnames = Term.add_const_names lhs []\n          |> filter (String.isSuffix \"_'proc\");\n        val unfolds = map (Proof_Context.get_thm ctxt o suffix \"_def\"\n          o Long_Name.base_name) cnames;\n      in simp_tac (put_simpset ss ctxt addsimps unfolds) n\n      end);\n\nfun convert_impls ctxt = let\n\n    val thm = Proof_Context.get_thm ctxt \"\\<Gamma>_def\"\n\n    val proc_defs = (Term.add_const_names (Thm.concl_of thm) [])\n      |> filter (String.isSuffix Hoare.proc_deco)\n      |> map (suffix \"_def\" #> Proof_Context.get_thm ctxt)\n\n    val tree_lemmata = StaticFun.prove_partial_map_thms thm\n        (ctxt addsimps proc_defs)\n\n    fun impl_name_from_proc (Const (s, _)) = s\n            |> Long_Name.base_name\n            |> unsuffix Hoare.proc_deco\n            |> suffix HoarePackage.implementationN\n      | impl_name_from_proc t = raise TERM (\"impl_name_from_proc\", [t])\n\n    val saves = tree_lemmata |> map (apfst (fst #> impl_name_from_proc))\n\n  in Local_Theory.notes (map (fn (n, t) => ((Binding.name n, []), [([t], [])])) saves)\n    ctxt |> snd end\n\nfun take_all_actions prefix src_ctxt proc tm csenv\n      styargs ctxt = let\n    val (_, ctxt) = convert prefix src_ctxt proc tm (Termtab.empty, ctxt);\n  in ctxt\n    |> convert_impls\n    |> Modifies_Proofs.prove_all_modifies_goals_local csenv (fn _ => true) styargs\n  end\n\nend\n\n\\<close>\n\nML \\<open>\nfun com_rewrite f t = case fastype_of t of\n    (comT as Type (@{type_name com}, [s, _, ft]))\n      => let\n    val gd = Const (@{const_name Guard},\n                ft --> (HOLogic.mk_setT s) --> comT --> comT)\n    fun add_guard ((f, gd_s), c) = gd $ f $ gd_s $ c;\n\n    val seq = Const (@{const_name Seq}, comT --> comT --> comT);\n    val skip = Const (@{const_name Skip}, comT);\n    fun add_guards_to_seq gs (Const (@{const_name Seq}, _) $ a $ b)\n        = seq $ add_guards_to_seq gs a $ b\n      | add_guards_to_seq gs c\n        = seq $ foldr add_guard skip gs $ c;\n\n    fun add_guards c [] = c\n      | add_guards ((w as Const (@{const_name While}, _)) $ S $ c) gs\n        = seq $ (w $ S $ add_guards_to_seq gs c) $ foldr add_guard skip gs\n      | add_guards (call as (Const (@{const_name call}, _) $ _ $ _ $ _ $ _)) gs\n        = foldr add_guard (seq $ call $ foldr add_guard skip gs) gs\n      | add_guards c gs = foldr add_guard c gs;\n\n    fun inner t = case t of\n      (Const (@{const_name \"switch\"}, T) $ v $ set_com_list) => let\n        val (ss, cs) = map_split HOLogic.dest_prod\n          (HOLogic.dest_list set_com_list);\n        val cs' = map inner cs;\n        val (v', gs) = f v;\n        val (ss', gss) = map_split f ss;\n        val listT = HOLogic.mk_prodT\n          (HOLogic.mk_setT (range_type (domain_type T)), comT);\n      in foldr add_guard (head_of t $ v' $ HOLogic.mk_list listT\n            (map HOLogic.mk_prod (ss' ~~ cs')))\n          (gs @ flat gss)\n      end\n      | _ => let\n        val (h, xs) = strip_comb t;", "property": "Code Transformation and Refinement: Enables the transformation and refinement of code in a formal and structured manner, ensuring that the resulting code is correct and maintainable. This is achieved through the use of various functions and data structures that facilitate the conversion and manipulation of code, including the use of abstract syntax trees and the application of transformation rules.\n\nSubproperties:\n- Code Conversion: Facilitates the conversion of code from one form to another, ensuring that the resulting code is semantically equivalent to the original code.\n- Code Refinement: Enables the refinement of code, allowing for the introduction of additional details and the transformation of abstract code into more concrete implementations.\n- Code Manipulation: Provides facilities for manipulating code, including the use of abstract syntax trees and the application of transformation rules.", "title": "./spec/cspec/Substitute.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "val xTs = xs ~~ (fastype_of h |> strip_type |> fst);\n        fun upd_arg (x, T) = if T = comT then (inner x, []) else f x;\n        val (ys, gss) = map_split upd_arg xTs;\n      in add_guards (list_comb (h, ys)) (flat gss) end\n  in inner (Envir.beta_eta_contract t) end\n  | _ => t;\n\n\\<close>\n\nsetup \\<open>DefineGlobalsList.define_globals_list_i\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\" @{typ globals}\\<close>\n\n\nlocale substitute_pre\n  = fixes symbol_table :: \"string \\<Rightarrow> addr\"\n      and domain :: \"addr set\"\n\nbegin\n\nabbreviation\n \"globals_list \\<equiv> kernel_all_global_addresses.global_data_list\"\n\nend\n\nlocale kernel_all_substitute = substitute_pre\nbegin\n\nML \\<open>\nfun mk_rew (t as Abs (s, T, _)) = mk_rew (betapply (t, Var ((s, 0), T)))\n  | mk_rew t = HOLogic.dest_eq t\n\nval mk_varifyT = Term.map_types Logic.varifyT_global\n\nlocal\nval c_guard_rew =\n  @{term \"\\<lambda>p b. Guard C_Guard {s. c_guard (p s)} b\n     = Guard C_Guard {s. h_t_valid (hrs_htd (t_hrs_' (globals s))) c_guard (p s)} b\"}\n  |> mk_varifyT |> mk_rew\n\nval c_guard_rew_weak =\n  @{term \"\\<lambda>p b. Guard C_Guard {s. c_guard (p s)} b\n         = Guard C_Guard {s. ptr_safe (p s) (hrs_htd (t_hrs_' (globals s)))\n            \\<and> c_guard (p s)} b\"}\n      |> mk_varifyT |> mk_rew\n\nin\nfun strengthen_c_guards ss thy s =\n  if (exists (curry (=) s) ss)\n  then Pattern.rewrite_term thy [c_guard_rew_weak] []\n  else Pattern.rewrite_term thy [c_guard_rew] []\nend;\n\\<close>\n\nlemmas global_data_defs\n    = kernel_all_global_addresses.global_data_defs\n\nlemmas globals_list_def\n    = kernel_all_global_addresses.global_data_list_def\n\nML \\<open>", "property": "Strengthen C Guards: Rewrite and strengthen the C guard definitions to ensure proper memory safety and pointer validity, using either strong or weak definitions depending on the context.", "title": "./spec/cspec/Substitute.thy", "chapter": "", "section": "", "comment": " assumption: we can only get into the com type with one of the\n           constructors or pseudo-constructors, which don't need rewriting,\n           so we can ignore h "}
{"spec": "val global_datas = @{thms global_data_defs}\n  |> map (Thm.concl_of #> Logic.unvarify_global\n        #> Logic.dest_equals #> snd #> Envir.beta_eta_contract)\n\nval const_globals = map_filter\n    (fn (Const (@{const_name const_global_data}, _) $ nm $ t)\n        => SOME (HOLogic.dest_string nm, t)\n        | _ => NONE) global_datas\n\nlocal\n\nval hrs_htd_update_guard_rew1 =\n    @{term \"\\<lambda>u. Basic (\\<lambda>s. globals_update (t_hrs_'_update (hrs_htd_update (u s))) s)\n         = Guard C_Guard {s. globals_list_distinct (fst ` dom_s (u s (hrs_htd (t_hrs_' (globals s)))))\n                         symbol_table globals_list}\n           (Basic (\\<lambda>s. globals_update (t_hrs_'_update (id hrs_htd_update (u s))) s))\"}\n        |> mk_rew\n\nval hrs_htd_update_guard_rew2 =\n  @{term \"t_hrs_'_update (id hrs_htd_update f) = t_hrs_'_update (hrs_htd_update f)\"}\n  |> Logic.varify_global |> HOLogic.dest_eq;\n\nval consts = map snd const_globals\n\nval index_eq_set_helper\n  = Syntax.parse_term @{context} (String.concat\n    [\"\\<lambda>str t n c. {s :: globals myvars. c \\<longrightarrow>\",\n        \"h_val (hrs_mem (t_hrs_' (globals s)))\",\n        \" (CTypesDefs.ptr_add (Ptr (symbol_table str)) (of_nat (n s)))\",\n        \" = t s}\"])\n\nval eq_set_helper\n  = Syntax.parse_term @{context} (String.concat\n    [\"\\<lambda>str t c. {s :: globals myvars. c \\<longrightarrow>\",\n        \"h_val (hrs_mem (t_hrs_' (globals s)))\",\n        \" (Ptr (symbol_table str)) = t}\"])\n\nval s = @{term \"s :: globals myvars\"}\n\nval grab_name_str = head_of #> dest_Const #> fst #> Long_Name.base_name\n    #> HOLogic.mk_string\n\nin\n\nfun const_global_asserts ctxt cond\n  (t as (Const (@{const_name index}, _) $ arr $ n)) = if member (=) consts arr\n    then [(index_eq_set_helper $ grab_name_str arr\n        $ lambda s t $ lambda s n $ cond) |> Syntax.check_term ctxt]\n    else []\n  | const_global_asserts ctxt cond (Const c) = if member (=) consts (Const c)\n    then [(eq_set_helper $ grab_name_str (Const c) $ Const c $ cond)\n        |> Syntax.check_term ctxt]\n    else []\n  | const_global_asserts ctxt cond (f $ x) = if member (=) consts (f $ x)\n    then [(eq_set_helper $ grab_name_str (f $ x) $ (f $ x) $ cond)\n        |> Syntax.check_term ctxt]\n    else const_global_asserts ctxt cond f @ const_global_asserts ctxt cond x\n  | const_global_asserts ctxt cond (a as Abs (_, @{typ \"globals myvars\"}, _))\n    = const_global_asserts ctxt cond (betapply (a, s))\n  | const_global_asserts ctxt cond (Abs (_, _, t))\n    = const_global_asserts ctxt cond t\n  | const_global_asserts _ _ _ = []\n\nfun guard_rewritable_globals const_cond ctxt =\n  Pattern.rewrite_term @{theory} [hrs_htd_update_guard_rew2] []\n  o Pattern.rewrite_term @{theory} [hrs_htd_update_guard_rew1] []\n  o com_rewrite (fn t =>\n     (t, map (pair @{term C_Guard})\n        (case const_cond of SOME cond => const_global_asserts ctxt cond t\n                | NONE => [])))\n\nval guard_htd_updates_with_domain = com_rewrite\n  (fn t => if fastype_of t = @{typ \"globals myvars \\<Rightarrow> globals myvars\"}\n        andalso Term.exists_Const (fn (s, _) => s = @{const_name \"hrs_htd_update\"}) t\n        then (t, [(@{term MemorySafety}, betapply (@{term \"\\<lambda>f :: globals myvars \\<Rightarrow> globals myvars.\n                {s. htd_safe domain (hrs_htd (t_hrs_' (globals s)))\n              \\<and> htd_safe domain (hrs_htd (t_hrs_' (globals (f s))))}\"}, t))])\n        else (t, []))\n\nval guard_halt = com_rewrite\n  (fn t => if t = @{term \"halt_'proc\"}\n    then (t, [(@{term DontReach}, @{term \"{} :: globals myvars set\"})])\n    else (t, []))\n\nfun acc_ptr_adds (Const (@{const_name h_val}, _) $ m $ (Const (@{const_name ptr_add}, _) $ p $ n))\n    = [(p, n, true)] @ maps acc_ptr_adds [m, p, n]\n  | acc_ptr_adds (Const (@{const_name heap_update}, _) $ (Const (@{const_name ptr_add}, _) $ p $ n))\n    = [(p, n, true)] @ maps acc_ptr_adds [p, n]\n  | acc_ptr_adds (Const (@{const_name ptr_add}, _) $ p $ n)\n    = [(p, n, false)] @ maps acc_ptr_adds [p, n]\n  | acc_ptr_adds (f $ x) = maps acc_ptr_adds [f, x]\n  | acc_ptr_adds (abs as Abs (_, T, t)) = if T = @{typ \"globals myvars\"}\n    then acc_ptr_adds (betapply (abs, @{term \"s :: globals myvars\"}))\n    else acc_ptr_adds t\n  | acc_ptr_adds _ = []\n\nfun mk_bool true = @{term True} | mk_bool false = @{term False}\n\nval guard_acc_ptr_adds = com_rewrite\n  (fn t => (t, acc_ptr_adds t |> map (fn (p, n, strong) => let\n    val assn = Const (@{const_name ptr_add_assertion'},\n            fastype_of p --> @{typ \"int \\<Rightarrow> bool \\<Rightarrow> heap_typ_desc \\<Rightarrow> bool\"})\n        $ p $ n $ mk_bool strong\n        $ @{term \"hrs_htd (t_hrs_' (globals (s :: globals myvars)))\"}\n    val gd = HOLogic.mk_Collect (\"s\", @{typ \"globals myvars\"}, assn)\n  in (@{term MemorySafety}, gd) end)))\n\nend\n\n\\<close>\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\nML \\<open>\n  Feedback.verbosity_level := ~1;\n\\<close>\n\nlocal_setup \\<open>\nSubstituteSpecs.take_all_actions\n  \"Kernel_C.kernel_all_global_addresses.\"\n  (Locale.init \"Kernel_C.kernel_all_global_addresses\" @{theory})\n  (fn ctxt => fn s => guard_rewritable_globals NONE ctxt\n    o (strengthen_c_guards [\"memset_body\", \"memcpy_body\", \"memzero_body\"]\n          (Proof_Context.theory_of ctxt) s)\n    o guard_halt\n    o guard_htd_updates_with_domain\n    o guard_acc_ptr_adds)\n  @{term kernel_all_global_addresses.\\<Gamma>}\n  (CalculateState.get_csenv @{theory} \"../c/build/$L4V_ARCH/kernel_all.c_pp\" |> the)\n  [@{typ \"globals myvars\"}, @{typ int}, @{typ strictc_errortype}]\n\\<close>\n\nend\n\nend", "property": "Memory Safety: Ensure that memory operations (e.g., pointer additions, heap updates) are safe and do not compromise the integrity of the system.\nGlobal Variable Management: Manage global variables correctly, including updating and accessing their values, to prevent unexpected behavior or errors.\nPointer Arithmetic: Perform pointer arithmetic operations (e.g., pointer additions) correctly and safely to prevent memory-related issues.\nHeap Management: Manage the heap correctly, including updating and accessing heap memory, to prevent memory-related issues.\nMemory Access Control: Control access to memory locations to prevent unauthorized or incorrect access.\nMemory Safety Invariants: Maintain memory safety invariants, such as the validity of pointer addresses and the consistency of memory contents.", "title": "./spec/cspec/Substitute.thy", "chapter": "", "section": "", "comment": " the unvarify sets ?symbol_table back to symbol_table. be careful "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> word32\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> word32 \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: \nManage the ghost state, which tracks the allocation and deallocation of memory regions, including the creation of new frames and CNodes, and the clearing of regions. It ensures that the ghost state accurately reflects the current state of the system's memory. \n\nSubproperties:\n- Clear Region: Clear a region of memory in the ghost state, ensuring that the region is marked as unallocated.\n- New Frames: Create new frames in the ghost state, tracking the allocation of memory for a given page size and address range.\n- New CNodes: Create new CNodes in the ghost state, tracking the allocation of memory for a given CNode size and address range.\n- Get and Set Assertions: Retrieve and update the values of ghost assertions, which are used to track additional information about the system's state.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\n\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\n\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 8\"\n\ndefinition\n  ctcb_offset :: \"32 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Appropriately Qualified Aliases: Define and requalify constants for architecture-specific page sizes and create definitions for the size and offset of the CTCB (C Thread Control Block).", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "hide_const (open)\n  numDomains", "property": "Name Hiding: Hide unqualified names that conflict with Kernel_Config names, forcing the use of the Kernel_C prefix to avoid naming conflicts and ensure clarity in the kernel configuration.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "Thread State Definitions: Provide a comprehensive set of definitions for thread states, encapsulating various states a thread can be in.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n vmpage_size.ARMSmallPage\n vmpage_size.ARMLargePage\n vmpage_size.ARMSection\n vmpage_size.ARMSuperSection", "property": "Hide Virtual Memory Page Sizes: Conceal the sizes of virtual memory pages for different architectures to prevent direct access and modification.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\n\nglobal_naming \"ARM.vmpage_size\"\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\n\nglobal_naming ARM\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\nend\n\n\nend", "property": "Requalification of Constants: Re-allow fully qualified accesses to ARM page size constants for consistency, ensuring that ARM page size constants (ARMSmallPage, ARMLargePage, ARMSection, ARMSuperSection) can be accessed in a fully qualified manner.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> machine_word\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> machine_word \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: \nManage the ghost state, which tracks the allocation and deallocation of memory regions, including the creation of new frames and CNodes, and the clearing of regions. It ensures that the ghost state accurately reflects the current state of the system's memory. \n\nSubproperties:\n- Clear Region: Clear a region of memory in the ghost state, ensuring that the region is marked as unallocated.\n- New Frames: Create new frames in the ghost state, tracking the allocation of memory for a given page size and address range.\n- New CNodes: Create new CNodes in the ghost state, tracking the allocation of memory for a given size and address range.\n- Get Assertion: Retrieve the value of a specific assertion from the ghost state.\n- Set Assertion: Set the value of a specific assertion in the ghost state.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "setup \\<open>Context.theory_map (ASM_Ignore_Hooks.add_hook (fn _ => true))\\<close>", "property": "Ignore x86-64 ASM Statements: The c-parser does not support x86-64 assembly statements, so they are ignored.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " x86-64 asm statements are not yet supported by the c-parser "}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\nrequalify_consts X64SmallPage X64LargePage X64HugePage\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 10\"\n\ndefinition\n  ctcb_offset :: \"64 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Appropriately Qualified Aliases: Define and requalify constants for architecture-specific page sizes and create definitions for the size and offset of the CTCB (C Thread Control Block) data structure.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "hide_const (open)\n  numDomains", "property": "Name Hiding: Hide unqualified names that conflict with Kernel_Config names, forcing the use of the Kernel_C prefix to avoid naming conflicts and ensure clarity in the kernel configuration.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "Thread State Definitions Collection: Provide an alias for a collection of thread state definitions for easier reference and usage.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n  vmpage_size.X64SmallPage\n  vmpage_size.X64LargePage\n  vmpage_size.X64HugePage", "property": "Hide Virtual Memory Page Sizes: Conceal the definitions of virtual memory page sizes (X64SmallPage, X64LargePage, X64HugePage) to prevent direct access.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\nglobal_naming \"X64.vmpage_size\" requalify_consts X64SmallPage X64LargePage X64HugePage\nglobal_naming \"X64\" requalify_consts X64SmallPage X64LargePage X64HugePage\nend\n\nend", "property": "Requalification of Constants: Re-allow fully qualified accesses to constants for consistency, specifically requalifying X64 page size constants (X64SmallPage, X64LargePage, X64HugePage) in the X64 context.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> machine_word\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> machine_word \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: \nManage the ghost state, which tracks the allocation and deallocation of memory regions, including the creation of new frames and CNodes, and the clearing of regions. It ensures that the ghost state accurately reflects the current state of the system's memory. \n\nSubproperties:\n- Clear Region: Clear a region of memory in the ghost state, ensuring that the region is marked as unallocated.\n- New Frames: Create new frames in the ghost state, tracking the allocation of memory for the frames.\n- New CNodes: Create new CNodes in the ghost state, tracking the allocation of memory for the CNodes.\n- Get Assertion: Retrieve the value of a specific assertion from the ghost state.\n- Set Assertion: Set the value of a specific assertion in the ghost state.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\nrequalify_consts RISCVSmallPage RISCVLargePage RISCVHugePage\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 9\"\n\ndefinition\n  ctcb_offset :: \"64 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Appropriately Qualified Aliases: Define and requalify constants for architecture-specific page sizes and create aliases for TCB size and offset.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "hide_const (open)\n  numDomains", "property": "Name Hiding: Hide unqualified names that conflict with Kernel_Config names, forcing the use of the Kernel_C prefix to avoid naming conflicts and ensure clarity in the kernel configuration.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "Thread State Definitions Collection: Provide an alias for a collection of thread state definitions for easier reference and usage.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n  vmpage_size.RISCVSmallPage\n  vmpage_size.RISCVLargePage\n  vmpage_size.RISCVHugePage", "property": "Hide Virtual Memory Page Sizes: Conceal the definitions of virtual memory page sizes for RISC-V architecture, including small, large, and huge page sizes.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\nglobal_naming \"RISCV.vmpage_size\" requalify_consts RISCVSmallPage RISCVLargePage RISCVHugePage\nglobal_naming \"RISCV\" requalify_consts RISCVSmallPage RISCVLargePage RISCVHugePage\nend\n\nend", "property": "Requalification of Constants: Re-allow fully qualified accesses to RISCV page size constants for consistency.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n  pt_array_len\n  vs_array_len\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\n\nlemma ptTranslationBits_vs_array_len':\n  \"2 ^ ptTranslationBits VSRootPT_T = vs_array_len\"\n  by (simp add: vs_array_len_val ptTranslationBits_vs_index_bits vs_index_bits_def\n                Kernel_Config.config_ARM_PA_SIZE_BITS_40_def)\n\nlemmas ptTranslationBits_vs_array_len = ptTranslationBits_vs_array_len'[unfolded vs_array_len_val]\n\ntype_synonym cghost_state =\n  \"(machine_word \\<rightharpoonup> vmpage_size) \\<times>   \\<comment> \\<open>Frame sizes\\<close>\n   (machine_word \\<rightharpoonup> nat) \\<times>           \\<comment> \\<open>CNode sizes\\<close>\n   (machine_word \\<rightharpoonup> pt_type) \\<times>       \\<comment> \\<open>PT types\\<close>\n   ghost_assertions\"                 \\<comment> \\<open>ASMRefine assertions\\<close>\n\ndefinition gs_clear_region :: \"addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n     (\\<lambda>x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n      \\<lambda>x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x,\n      \\<lambda>x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd (snd gs)) x,\n      snd (snd (snd gs)))\"\n\ndefinition gs_new_frames:: \"vmpage_size \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n     if bits < pageBitsForSize sz then gs\n     else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                    x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n               else fst gs x, snd gs)\"\n\ndefinition gs_new_cnodes:: \"nat \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n     if bits < sz + 4 then gs\n     else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                       then Some sz\n                       else fst (snd gs) x, snd (snd gs))\"\n\ndefinition gs_new_pt_t:: \"pt_type \\<Rightarrow> addr \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_new_pt_t pt_t ptr \\<equiv>\n     \\<lambda>gs. (fst gs, fst (snd gs), (fst (snd (snd gs))) (ptr \\<mapsto> pt_t), snd (snd (snd gs)))\"\n\nabbreviation gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> machine_word\" where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd \\<circ> snd \\<circ> snd)\"\n\nabbreviation gs_set_assn :: \"int \\<Rightarrow> machine_word \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd \\<circ> apsnd \\<circ> apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: \nManage the ghost state, which includes information about frame sizes, CNode sizes, page table types, and ASMRefine assertions. \nClear Region: Clear a region of the ghost state by setting all entries within a specified range to None. \nNew Frames: Add new frames to the ghost state by setting the size of frames within a specified range. \nNew CNodes: Add new CNodes to the ghost state by setting the size of CNodes within a specified range. \nNew Page Table: Add a new page table to the ghost state by setting its type. \nAssertion Management: Get and set the values of ghost assertions.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\nrequalify_consts ARMSmallPage ARMLargePage ARMHugePage\nend", "property": "Create Appropriately Qualified Aliases: Define aliases for page sizes (small, large, huge) with the correct qualifications to ensure accurate and consistent references to these page sizes within the system.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "context begin interpretation Arch .\nrequalify_consts NormalPT_T VSRootPT_T\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 10\"\n\ndefinition\n  ctcb_offset :: \"64 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Kernel Configuration: Define kernel constants and settings, including page table type constructors for retype annotations, and specify the size and offset of the CTCB (C Thread Control Block).", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": " Also need pt_type constructors for retype annotations. We leave them available globally for C. "}
{"spec": "hide_const (open)\n  numDomains", "property": "Name Hiding: Hide unqualified names that conflict with Kernel_Config names, forcing the use of the Kernel_C prefix to avoid naming conflicts and ensure clarity in the kernel configuration.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "Thread State Definitions Collection: Provide an alias for the collection of thread state definitions for easier reference and usability.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n  vmpage_size.ARMSmallPage\n  vmpage_size.ARMLargePage\n  vmpage_size.ARMHugePage", "property": "Hide Virtual Memory Page Sizes: Conceal the sizes of virtual memory pages (ARMSmallPage, ARMLargePage, and ARMHugePage) to prevent external access or modification.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\nglobal_naming \"AARCH64.vmpage_size\" requalify_consts ARMSmallPage ARMLargePage ARMHugePage\nglobal_naming \"AARCH64\" requalify_consts ARMSmallPage ARMLargePage ARMHugePage\nend\n\nend", "property": "Requalification of Constants: Re-allow fully qualified accesses to AARCH64 page size constants (ARMSmallPage, ARMLargePage, ARMHugePage) for consistency.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> word32\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> word32 \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: \nManage the ghost state, which tracks the allocation and deallocation of memory regions, including the creation of new frames and CNodes, and the clearing of regions. It ensures that the ghost state accurately reflects the current state of the system's memory. \n\nSubproperties:\n- Clear Region: Clear a region of memory in the ghost state, ensuring that the region is marked as unallocated.\n- New Frames: Create new frames in the ghost state, tracking the allocation of memory for a given page size and address range.\n- New CNodes: Create new CNodes in the ghost state, tracking the allocation of memory for a given CNode size and address range.\n- Get/Set Assertion: Get and set the values of ghost assertions, which are used to track additional information about the system's state.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\n\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\n\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 8\"\n\ndefinition\n  ctcb_offset :: \"32 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Appropriately Qualified Aliases: Define and requalify constants for architecture-specific page sizes and create definitions for the size and offset of the CTCB (C Thread Control Block) data structure.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "hide_const (open)\n  numDomains", "property": "Name Hiding: Hide unqualified names that conflict with Kernel_Config names, forcing the use of the Kernel_C prefix to avoid naming conflicts and ensure clarity in the kernel configuration.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "Thread State Definitions Collection: Provide an alias for the collection of thread state definitions for easier reference and usability.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n vmpage_size.ARMSmallPage\n vmpage_size.ARMLargePage\n vmpage_size.ARMSection\n vmpage_size.ARMSuperSection", "property": "Hide Virtual Memory Page Sizes: Conceal the definitions of virtual memory page sizes for different architectures to prevent direct access and modification.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\n\nglobal_naming \"ARM.vmpage_size\"\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\n\nglobal_naming ARM\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\nend\n\n\nend", "property": "Requalification of Constants: Re-allow fully qualified accesses to ARM page size constants for consistency, ensuring that ARM page size constants can be accessed in a fully qualified manner.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "text \\<open>\n  The basic type of the nondeterministic state monad with failure is\n  very similar to the normal state monad. Instead of a pair consisting\n  of result and new state, we return a set of these pairs coupled with\n  a failure flag. Each element in the set is a potential result of the\n  computation. The flag is @{const True} if there is an execution path\n  in the computation that may have failed. Conversely, if the flag is\n  @{const False}, none of the computations resulting in the returned\n  set can have failed.\\<close>\ntype_synonym ('s, 'a) nondet_monad = \"'s \\<Rightarrow> ('a \\<times> 's) set \\<times> bool\"", "property": "Nondeterministic State Monad with Failure: Represents computations that return a set of potential results along with a failure flag, indicating whether any execution path may have failed.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "print_ast_translation \\<open>\n  let\n    fun monad_tr _ [t1, Ast.Appl [Ast.Constant @{type_syntax prod},\n                          Ast.Appl [Ast.Constant @{type_syntax set},\n                            Ast.Appl [Ast.Constant @{type_syntax prod}, t2, t3]],\n                          Ast.Constant @{type_syntax bool}]] =\n      if t3 = t1\n      then Ast.Appl [Ast.Constant @{type_syntax \"nondet_monad\"}, t1, t2]\n      else raise Match\n  in [(@{type_syntax \"fun\"}, monad_tr)] end\n\\<close>", "property": "Nondeterministic State Monad with Failure: Represents a computation that may fail, returning an error or successfully producing a value, while also encapsulating nondeterministic behavior and state modifications.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Print the type @{typ \"('s,'a) nondet_monad\"} instead of its unwieldy expansion.\n  Needs an AST translation in code, because it needs to check that the state variable\n  @{typ 's} occurs twice. This comparison is not guaranteed to always work as expected\n  (AST instances might have different decoration), but it does seem to work here."}
{"spec": "definition return :: \"'a \\<Rightarrow> ('s,'a) nondet_monad\" where\n  \"return a \\<equiv> \\<lambda>s. ({(a,s)},False)\"", "property": "Return Function: The return function in the nondeterministic state monad does not modify the state, never fails, and yields the given value.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  The definition of fundamental monad functions @{text return} and\n  @{text bind}. The monad function @{text \"return x\"} does not change\n  the  state, does not fail, and returns @{text \"x\"}."}
{"spec": "definition bind ::\n  \"('s, 'a) nondet_monad \\<Rightarrow> ('a \\<Rightarrow> ('s, 'b) nondet_monad) \\<Rightarrow> ('s, 'b) nondet_monad\" (infixl \">>=\" 60)\n  where\n  \"bind f g \\<equiv> \\<lambda>s. (\\<Union>(fst ` case_prod g ` fst (f s)),\n                   True \\<in> snd ` case_prod g ` fst (f s) \\<or> snd (f s))\"", "property": "Bind Operation with Failure Propagation: Combines two nondeterministic state monad operations, where the second operation is executed with the result value and state of the first operation, and propagates failure if either operation may fail.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  The monad function @{text \"bind f g\"}, also written @{text \"f >>= g\"},\n  is the execution of @{term f} followed by the execution of @{text g}.\n  The function @{text g} takes the result value \\emph{and} the result\n  state of @{text f} as parameter. The definition says that the result of\n  the combined operation is the union of the set of sets that is created\n  by @{text g} applied to the result sets of @{text f}. The combined\n  operation may have failed, if @{text f} may have failed or @{text g} may\n  have failed on any of the results of @{text f}."}
{"spec": "abbreviation (input) bind_rev ::\n  \"('c \\<Rightarrow> ('a, 'b) nondet_monad) \\<Rightarrow> ('a, 'c) nondet_monad \\<Rightarrow> ('a, 'b) nondet_monad\" (infixl \"=<<\" 60)\n  where\n  \"g =<< f \\<equiv> f >>= g\"", "property": "Reversed Bind Operation: Allows writing the bind operation in reverse order, providing an alternative way to compose monadic functions.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Sometimes it is convenient to write @{text bind} in reverse order."}
{"spec": "definition get :: \"('s,'s) nondet_monad\" where\n  \"get \\<equiv> \\<lambda>s. ({(s,s)}, False)\"\n\ndefinition put :: \"'s \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"put s \\<equiv> \\<lambda>_. ({((),s)}, False)\"", "property": "State Accessor Functions: Provide basic access to the state in a nondeterministic state monad with failure, allowing retrieval of the current state and updating it with a new state, without causing failures. \n\nGet Function: Returns the current state without modifying it or causing failure.\nPut Function: Updates the current state to a specified new state without returning a value or causing failure.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  The basic accessor functions of the state monad. @{text get} returns\n  the current state as result, does not fail, and does not change the state.\n  @{text \"put s\"} returns nothing (@{typ unit}), changes the current state\n  to @{text s} and does not fail."}
{"spec": "text \\<open>\n  Basic nondeterministic functions. @{text \"select A\"} chooses an element\n  of the set @{text A}, does not change the state, and does not fail\n  (even if the set is empty). @{text \"f \\<sqinter> g\"} executes @{text f} or\n  executes @{text g}. It retuns the union of results of @{text f} and\n  @{text g}, and may have failed if either may have failed.\\<close>\ndefinition select :: \"'a set \\<Rightarrow> ('s,'a) nondet_monad\" where\n  \"select A \\<equiv> \\<lambda>s. (A \\<times> {s}, False)\"\n\ndefinition alternative ::\n  \"('s, 'a) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad\" (infixl \"\\<sqinter>\" 20)\n  where\n  \"f \\<sqinter> g \\<equiv> \\<lambda>s. (fst (f s) \\<union> fst (g s), snd (f s) \\<or> snd (g s))\"", "property": "Nondeterministic State Monad with Failure: Provides basic nondeterministic functions for handling failure in a state monad. \n\nNondeterministic Choice: Allows choosing an element from a set without changing the state or failing, even if the set is empty. \nFailure Handling: Combines two monadic actions, executing either one and returning the union of their results, with the potential for failure if either action may fail.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "definition select_f :: \"'a set \\<times> bool  \\<Rightarrow> ('s,'a) nondet_monad\" where\n  \"select_f S \\<equiv> \\<lambda>s. (fst S \\<times> {s}, snd S)\"", "property": "Nondeterministic State Monad with Failure: Allows for the selection of a value from a set, while also indicating whether the execution has failed.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  A variant of @{text select} that takes a pair. The first component is a set\n  as in normal @{text select}, the second component indicates whether the\n  execution failed. This is useful to lift monads between different state\n  spaces."}
{"spec": "definition state_select :: \"('s \\<times> 's) set \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"state_select r \\<equiv> \\<lambda>s. ((\\<lambda>x. ((), x)) ` {s'. (s, s') \\<in> r}, \\<not> (\\<exists>s'. (s, s') \\<in> r))\"", "property": "Nondeterministic State Selection: Selects a new state nondeterministically based on a given relationship between states, failing if no such state exists. \n\nSubproperty: State Selection Relation: The selection is based on a specified relation between the input state and the output state.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  @{text state_select} takes a relationship between states, and outputs\n  nondeterministically a state related to the input state. Fails if no such\n  state exists."}
{"spec": "text \\<open>\n  The monad function that always fails. Returns an empty set of results and sets the failure flag.\\<close>\ndefinition fail :: \"('s, 'a) nondet_monad\" where\n  \"fail \\<equiv> \\<lambda>s. ({}, True)\"", "property": "Always Fails: The monad function always returns an empty set of results and sets the failure flag.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "definition assert :: \"bool \\<Rightarrow> ('a, unit) nondet_monad\" where\n  \"assert P \\<equiv> if P then return () else fail\"", "property": "Assertion: Fails if a given property is not true, ensuring that the system's behavior adheres to expected conditions.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Assertions: fail if the property @{text P} is not true"}
{"spec": "definition assert_opt :: \"'a option \\<Rightarrow> ('b, 'a) nondet_monad\" where\n  \"assert_opt v \\<equiv> case v of None \\<Rightarrow> fail | Some v \\<Rightarrow> return v\"", "property": "Assert Option: Fails if the input option is None, otherwise returns the value inside the option. \n\nFail on None: If the input option is None, the operation fails.\nReturn on Some: If the input option is Some, the operation returns the value inside the option.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Fail if the value is @{const None}, return result @{text v} for @{term \"Some v\"}"}
{"spec": "definition state_assert :: \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"state_assert P \\<equiv> get >>= (\\<lambda>s. assert (P s))\"", "property": "State Assertion: Ensure that the current state satisfies a given condition, failing if the condition is not met.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "An assertion that also can introspect the current state."}
{"spec": "text \\<open>Apply a function to the current state and return the result without changing the state.\\<close>\ndefinition gets :: \"('s \\<Rightarrow> 'a) \\<Rightarrow> ('s, 'a) nondet_monad\" where\n  \"gets f \\<equiv> get >>= (\\<lambda>s. return (f s))\"", "property": "State Retrieval: Retrieve information from the current state without modifying it, applying a given function to the state and returning the result.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "definition modify :: \"('s \\<Rightarrow> 's) \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"modify f \\<equiv> get >>= (\\<lambda>s. put (f s))\"\n\nlemma simpler_gets_def:\n  \"gets f = (\\<lambda>s. ({(f s, s)}, False))\"\n  by (simp add: gets_def return_def bind_def get_def)\n\nlemma simpler_modify_def:\n  \"modify f = (\\<lambda>s. ({((), f s)}, False))\"\n  by (simp add: modify_def bind_def get_def put_def)", "property": "State Modification: Modify the current state using a given function, ensuring that the state is updated correctly without raising any exceptions.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Modify the current state using the function passed in."}
{"spec": "definition \"when\" :: \"bool \\<Rightarrow> ('s, unit) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"when P m \\<equiv> if P then m else return ()\"", "property": "Conditional Execution: Execute a given monad only when a specified condition is true, otherwise return a unit value.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Execute the given monad when the condition is true, return @{text \"()\"} otherwise."}
{"spec": "definition unless :: \"bool \\<Rightarrow> ('s, unit) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"unless P m \\<equiv> when (\\<not>P) m\"", "property": "Conditional Execution: Execute a monad only if a given condition is false.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Execute the given monad unless the condition is true, return @{text \"()\"} otherwise."}
{"spec": "definition condition ::\n  \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s, 'r) nondet_monad \\<Rightarrow> ('s, 'r) nondet_monad \\<Rightarrow> ('s, 'r) nondet_monad\"\n  where\n  \"condition P L R \\<equiv> \\<lambda>s. if (P s) then (L s) else (R s)\"\n\nnotation (output)\n  condition  (\"(condition (_)//  (_)//  (_))\" [1000,1000,1000] 1000)", "property": "Conditional Execution: Execute one of two monads based on a condition applied to the current state. If the condition is true, execute the first monad; otherwise, execute the second monad.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Perform a test on the current state, performing the left monad if\n  the result is true or the right monad if the result is false. "}
{"spec": "definition gets_the :: \"('s \\<Rightarrow> 'a option) \\<Rightarrow> ('s, 'a) nondet_monad\" where\n  \"gets_the f \\<equiv> gets f >>= assert_opt\"", "property": "Apply Option Valued Function to State: Applies an option-valued function to the current state, failing if it returns None and returning the value if it returns Some.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Apply an option valued function to the current state, fail if it returns @{const None},\n  return @{text v} if it returns @{term \"Some v\"}."}
{"spec": "definition gets_map :: \"('s \\<Rightarrow> 'a \\<Rightarrow> 'b option) \\<Rightarrow> 'a \\<Rightarrow> ('s, 'b) nondet_monad\" where\n  \"gets_map f p \\<equiv> gets f >>= (\\<lambda>m. assert_opt (m p))\"", "property": "Get Value from State Map: Retrieves a value from a map in the current state by applying a given argument to the map, failing if the map returns None. \n\nGet Map Value Existence: The map must contain the requested key to retrieve a value successfully. \n\nGet Map Value Failure: If the map does not contain the requested key, the operation will fail.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Get a map (such as a heap) from the current state and apply an argument to the map.\n  Fail if the map returns @{const None}, otherwise return the value."}
{"spec": "text \\<open>An alternative definition of @{term bind}, sometimes more convenient.\\<close>\nlemma bind_def':\n  \"(f >>= g) \\<equiv>\n       \\<lambda>s. ({(r'', s''). \\<exists>(r', s') \\<in> fst (f s). (r'', s'') \\<in> fst (g r' s') },\n                     snd (f s) \\<or> (\\<exists>(r', s') \\<in> fst (f s). snd (g r' s')))\"\n  by (rule eq_reflection)\n     (auto simp add: bind_def split_def Let_def)", "property": "Alternative Bind Definition: The bind operation can be redefined to provide an alternative, yet equivalent, way of composing monadic functions, highlighting the relationship between the results and errors of the two functions being bound together.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "lemma return_bind[simp]:\n  \"(return x >>= f) = f x\"\n  by (simp add: return_def bind_def)", "property": "Left Absorption of Return: The return operation is absorbed when bound to the left of another operation, directly applying the return value to the subsequent operation.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "@{term return} is absorbed at the left of a @{term bind}, applying the return value directly:"}
{"spec": "lemma bind_return[simp]:\n  \"(m >>= return) = m\"\n  by (simp add: bind_def return_def split_def)", "property": "Bind Return Equivalence: The bind operation followed by a return is equivalent to the original monadic value, ensuring that unnecessary returns are eliminated and the monadic computation is simplified.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "@{term return} is absorbed on the right of a @{term bind}"}
{"spec": "lemma bind_assoc:\n  fixes m :: \"('a,'b) nondet_monad\"\n  fixes f :: \"'b \\<Rightarrow> ('a,'c) nondet_monad\"\n  fixes g :: \"'c \\<Rightarrow> ('a,'d) nondet_monad\"\n  shows \"(m >>= f) >>= g  =  m >>= (\\<lambda>x. f x >>= g)\"\n  unfolding bind_def Let_def split_def\n  by (auto intro: rev_image_eqI)", "property": "Associativity of Bind Operation: The bind operation in the nondeterministic state monad with failure is associative, ensuring that the order in which computations are composed does not affect the outcome.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "@{term bind} is associative"}
{"spec": "text \\<open>\n  The type @{typ \"('s,'a) nondet_monad\"} gives us nondeterminism and\n  failure. We now extend this monad with exceptional return values\n  that abort normal execution, but can be handled explicitly.\n  We use the sum type to indicate exceptions.\n\n  In @{typ \"('s, 'e + 'a) nondet_monad\"}, @{typ \"'s\"} is the state,\n  @{typ 'e} is an exception, and @{typ 'a} is a normal return value.\n\n  This new type itself forms a monad again. Since type classes in\n  Isabelle are not powerful enough to express the class of monads,\n  we provide new names for the @{term return} and @{term bind} functions\n  in this monad. We call them @{text returnOk} (for normal return values)\n  and @{text bindE} (for composition). We also define @{text throwError}\n  to return an exceptional value.\\<close>\ndefinition returnOk :: \"'a \\<Rightarrow> ('s, 'e + 'a) nondet_monad\" where\n  \"returnOk \\<equiv> return o Inr\"\n\ndefinition throwError :: \"'e \\<Rightarrow> ('s, 'e + 'a) nondet_monad\" where\n  \"throwError \\<equiv> return o Inl\"", "property": "Nondeterministic State Monad with Failure and Exceptions: Provides a monadic framework for handling nondeterminism, failure, and exceptions in a computation. It allows for normal return values and exceptional return values that can be explicitly handled.\n\nMonad Laws: The monad satisfies the standard monad laws, ensuring that the return and bind operations behave correctly and consistently.\n\nReturn Operations: Two return operations are defined: returnOk for normal return values and throwError for exceptional return values.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "definition lift :: \"('a \\<Rightarrow> ('s, 'e + 'b) nondet_monad) \\<Rightarrow> 'e +'a \\<Rightarrow> ('s, 'e + 'b) nondet_monad\" where\n  \"lift f v \\<equiv> case v of Inl e \\<Rightarrow> throwError e | Inr v' \\<Rightarrow> f v'\"", "property": "Lifting Over Exceptions: Propagates exceptions from the input, allowing normal execution to proceed only if no exception is present. \n\nException Propagation: If the input is an exception, it is re-thrown. \nNormal Execution: If the input is not an exception, execution continues with the provided function.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Lifting a function over the exception type: if the input is an\n  exception, return that exception; otherwise continue execution."}
{"spec": "definition bindE ::\n  \"('s, 'e + 'a) nondet_monad \\<Rightarrow> ('a \\<Rightarrow> ('s, 'e + 'b) nondet_monad) \\<Rightarrow> ('s, 'e + 'b) nondet_monad\"\n  (infixl \">>=E\" 60) where\n  \"f >>=E g \\<equiv> f >>= lift g\"", "property": "Bind with Exception: The bind operation in the exception monad skips the execution of the right-hand side if the left-hand side produces an exception, ensuring that exceptions are propagated correctly.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  The definition of @{term bind} in the exception monad (new\n  name @{text bindE}): the same as normal @{term bind}, but\n  the right-hand side is skipped if the left-hand side\n  produced an exception."}
{"spec": "definition liftE :: \"('s,'a) nondet_monad \\<Rightarrow> ('s, 'e+'a) nondet_monad\" where\n  \"liftE f \\<equiv> f >>= (\\<lambda>r. return (Inr r))\"", "property": "Lifting Normal Results: Ensures that a normal nondeterministic monad is lifted into the exception monad, always returning its result as a normal result and never throwing an exception.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Lifting a normal nondeterministic monad into the\n  exception monad is achieved by always returning its\n  result as normal result and never throwing an exception."}
{"spec": "definition whenE :: \"bool \\<Rightarrow> ('s, 'e + unit) nondet_monad \\<Rightarrow> ('s, 'e + unit) nondet_monad\" where\n  \"whenE P f \\<equiv> if P then f else returnOk ()\"\n\ndefinition unlessE :: \"bool \\<Rightarrow> ('s, 'e + unit) nondet_monad \\<Rightarrow> ('s, 'e + unit) nondet_monad\" where\n  \"unlessE P f \\<equiv> if P then returnOk () else f\"", "property": "Conditional Execution with Error Handling: Execute a monadic action conditionally, handling errors and returning a success value when the condition is not met. \n\nSubproperties:\n- When True, execute the action and propagate any errors.\n- When False, return a successful unit value without executing the action.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Since the underlying type and @{text return} function changed,\n  we need new definitions for when and unless:"}
{"spec": "definition throw_opt :: \"'e \\<Rightarrow> 'a option \\<Rightarrow> ('s, 'e + 'a) nondet_monad\" where\n  \"throw_opt ex x \\<equiv> case x of None \\<Rightarrow> throwError ex | Some v \\<Rightarrow> returnOk v\"", "property": "Throwing Exceptions: If the parameter is None, an exception is thrown, otherwise, the value v is returned for Some v.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Throwing an exception when the parameter is @{term None}, otherwise\n  returning @{term \"v\"} for @{term \"Some v\"}."}
{"spec": "definition assertE :: \"bool \\<Rightarrow> ('a, 'e + unit) nondet_monad\" where\n  \"assertE P \\<equiv> if P then returnOk () else fail\"", "property": "Assert Property: Ensure that a condition is met, returning success if true and failure if false.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Failure in the exception monad is redefined in the same way\n  as @{const whenE} and @{const unlessE}, with @{term returnOk}\n  instead of @{term return}."}
{"spec": "text \\<open>More direct definition of @{const liftE}:\\<close>\nlemma liftE_def2:\n  \"liftE f = (\\<lambda>s. ((\\<lambda>(v,s'). (Inr v, s')) ` fst (f s), snd (f s)))\"\n  by (auto simp: liftE_def return_def split_def bind_def)", "property": "LiftE Definition: The liftE function maps a value and state pair to a pair with the value wrapped in Inr and the original state, preserving the state's nondeterminism and failure properties.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "lemma returnOk_bindE[simp]: \"(returnOk x >>=E f) = f x\"\n  unfolding bindE_def returnOk_def\n  by (clarsimp simp: lift_def)\n\nlemma lift_return[simp]:\n  \"lift (return \\<circ> Inr) = return\"\n  by (auto simp: lift_def throwError_def split: sum.splits)", "property": "Monad Laws: The monad laws for the nondeterministic state monad with failure ensure that the monad operations behave correctly and consistently. Specifically, the left returnOk absorption law over bindE states that binding a returnOk value to a function is equivalent to applying the function directly to the value. Additionally, lifting a return value is equivalent to returning the value itself. \n\nReturnOk Absorption: (returnOk x >>=E f) = f x \nLift Return: lift (return ∘ Inr) = return", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Left @{const returnOk} absorbtion over @{term bindE}:"}
{"spec": "lemma bindE_returnOk[simp]:\n  \"(m >>=E returnOk) = m\"\n  by (simp add: bindE_def returnOk_def)", "property": "Right Unit Absorption: The bind operation over a monad followed by a return operation is equivalent to the original monad, ensuring that unnecessary return operations can be eliminated without affecting the outcome.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Right @{const returnOk} absorbtion over @{term bindE}:"}
{"spec": "lemma bindE_assoc:\n  \"(m >>=E f) >>=E g = m >>=E (\\<lambda>x. f x >>=E g)\"\n  unfolding bindE_def\n  by (fastforce simp: bind_assoc lift_def throwError_def\n                split: sum.splits\n                intro: arg_cong[where f=\"\\<lambda>x. m >>= x\"])", "property": "Associativity of Bind with Exceptions: The bind operation with exceptions is associative, ensuring that the order in which exceptions are handled does not affect the outcome.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Associativity of @{const bindE}:"}
{"spec": "lemma returnOk_liftE:\n  \"returnOk x = liftE (return x)\"\n  by (simp add: liftE_def returnOk_def)", "property": "Equivalence of ReturnOk and LiftE: The returnOk function is equivalent to using liftE with the return function, ensuring that the monad laws hold for the nondeterministic state monad with failure.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "@{const returnOk} could also be defined via @{const liftE}:"}
{"spec": "lemma throwError_bindE[simp]:\n  \"(throwError E >>=E f) = throwError E\"\n  by (simp add: bindE_def bind_def throwError_def lift_def return_def)", "property": "Exception Propagation: Throwing an exception skips subsequent execution, propagating the exception through the monad. \n\nException Handling: Bind operation with an error is equivalent to throwing that error.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Execution after throwing an exception is skipped:"}
{"spec": "text \\<open>This section defines traditional Haskell-like do-syntax\n  for the state monad in Isabelle.\\<close>", "property": "Monad Laws: Ensure that the state monad satisfies the traditional monad laws, specifically the left identity, right identity, and associativity laws, providing a sound foundation for monadic computations.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": ""}
{"spec": "text \\<open>\n  We use @{text K_bind} to syntactically indicate the case where the return argument\n  of the left side of a @{term bind} is ignored\\<close>\ndefinition K_bind :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'a\" where\n  K_bind_def[iff]: \"K_bind \\<equiv> \\<lambda>x y. x\"\n\nnonterminal\n  dobinds and dobind and nobind\n\nsyntax\n  \"_dobind\"    :: \"[pttrn, 'a] => dobind\"             (\"(_ <-/ _)\" 10)\n  \"\"           :: \"dobind => dobinds\"                 (\"_\")\n  \"_nobind\"    :: \"'a => dobind\"                      (\"_\")\n  \"_dobinds\"   :: \"[dobind, dobinds] => dobinds\"      (\"(_);//(_)\")\n\n  \"_do\"        :: \"[dobinds, 'a] => 'a\"               (\"(do ((_);//(_))//od)\" 100)\nsyntax (xsymbols)\n  \"_dobind\"    :: \"[pttrn, 'a] => dobind\"             (\"(_ \\<leftarrow>/ _)\" 10)\n\ntranslations\n  \"_do (_dobinds b bs) e\"  == \"_do b (_do bs e)\"\n  \"_do (_nobind b) e\"      == \"b >>= (CONST K_bind e)\"\n  \"do x <- a; e od\"        == \"a >>= (\\<lambda>x. e)\"", "property": "Nondeterministic State Monad Bind: Allows binding of values to names in a monadic expression, ignoring the return argument of the left side of the bind when necessary, and syntactically indicating this case using K_bind.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": ""}
{"spec": "lemma \"do x \\<leftarrow> return 1;\n          return (2::nat);\n          return x\n       od =\n       return 1 >>=\n       (\\<lambda>x. return (2::nat) >>=\n            K_bind (return x))\"\n  by (rule refl)\n\nlemma \"do x \\<leftarrow> return 1;\n          return 2;\n          return x\n       od = return 1\"\n  by simp", "property": "Nondeterministic State Monad Bind: The bind operation (>>=) in the nondeterministic state monad with failure sequences computations, allowing the result of one computation to be passed as an argument to another, while propagating exceptions.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": "Syntax examples:"}
{"spec": "text \\<open>\n  Since the exception monad is a different type, we need to distinguish it in the syntax\n  if we want to avoid ambiguous terms. We use @{text doE}/@{text odE} for this, but can\n  re-use most of the productions from @{text do}/@{text od} above. \\<close>\nsyntax\n  \"_doE\" :: \"[dobinds, 'a] => 'a\"  (\"(doE ((_);//(_))//odE)\" 100)\n\ntranslations\n  \"_doE (_dobinds b bs) e\"  == \"_doE b (_doE bs e)\"\n  \"_doE (_nobind b) e\"      == \"b >>=E (CONST K_bind e)\"\n  \"doE x <- a; e odE\"       == \"a >>=E (\\<lambda>x. e)\"", "property": "Exception Handling: Provides a syntax for handling exceptions in a monadic context, allowing for the distinction between regular and exceptional computations.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": ""}
{"spec": "lemma \"doE x \\<leftarrow> returnOk 1;\n           returnOk (2::nat);\n           returnOk x\n       odE =\n       returnOk 1 >>=E\n       (\\<lambda>x. returnOk (2::nat) >>=E\n            K_bind (returnOk x))\"\n  by (rule refl)\n\nlemma \"doE x \\<leftarrow> returnOk 1;\n           returnOk 2;\n           returnOk x\n       odE = returnOk 1\"\n  by simp", "property": "Nondeterministic State Monad Bind: The bind operation (>>=E) in the exception monad composes two monadic actions, passing the result of the first action to the second action while propagating exceptions.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": "Syntax examples:"}
{"spec": "text \\<open>Lifting a normal function into the monad type:\\<close>\ndefinition liftM :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('s,'a) nondet_monad \\<Rightarrow> ('s, 'b) nondet_monad\" where\n  \"liftM f m \\<equiv> do x \\<leftarrow> m; return (f x) od\"", "property": "Lifting Function into Monad: Lifts a normal function into the nondeterministic state monad, allowing it to operate on monadic values while preserving the monadic context.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": ""}
{"spec": "definition liftME :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('s,'e+'a) nondet_monad \\<Rightarrow> ('s,'e+'b) nondet_monad\" where\n  \"liftME f m \\<equiv> doE x \\<leftarrow> m; returnOk (f x) odE\"", "property": "Lift Function for Exception Monad: Lifts a function into the exception monad, applying it to the result of a monadic computation and returning the result as a success.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "The same for the exception monad:"}
{"spec": "definition maybeM :: \"('a \\<Rightarrow> ('s, unit) nondet_monad) \\<Rightarrow> 'a option \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"maybeM f y \\<equiv> case y of Some x \\<Rightarrow> f x | None \\<Rightarrow> return ()\"", "property": "Conditional Execution: Execute a given function if a value is present, otherwise do nothing.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "Execute @{term f} for @{term \"Some x\"}, otherwise do nothing."}
{"spec": "definition sequence_x :: \"('s, 'a) nondet_monad list \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"sequence_x xs \\<equiv> foldr (\\<lambda>x y. x >>= (\\<lambda>_. y)) xs (return ())\"", "property": "Sequence Monadic Actions: Run a list of monadic actions in sequence from left to right, ignoring their return values.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "Run a sequence of monads from left to right, ignoring return values."}
{"spec": "definition mapM_x :: \"('a \\<Rightarrow> ('s,'b) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"mapM_x f xs \\<equiv> sequence_x (map f xs)\"", "property": "Map Function Over List: Apply a monadic function to each element of a list from left to right, ignoring return values.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  Map a monadic function over a list by applying it to each element\n  of the list from left to right, ignoring return values."}
{"spec": "definition zipWithM_x ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> ('s,'c) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> ('s, unit) nondet_monad\"\n  where\n  \"zipWithM_x f xs ys \\<equiv> sequence_x (zipWith f xs ys)\"", "property": "Map Function over Two Lists: Apply a monadic function to two lists in parallel, discarding return values, and return a unit value in the nondeterministic state monad.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  Map a monadic function with two parameters over two lists,\n  going through both lists simultaneously, left to right, ignoring\n  return values."}
{"spec": "definition sequence :: \"('s, 'a) nondet_monad list \\<Rightarrow> ('s, 'a list) nondet_monad\" where\n  \"sequence xs \\<equiv> let mcons = (\\<lambda>p q. p >>= (\\<lambda>x. q >>= (\\<lambda>y. return (x#y))))\n                 in foldr mcons xs (return [])\"\n\ndefinition mapM :: \"('a \\<Rightarrow> ('s,'b) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, 'b list) nondet_monad\" where\n  \"mapM f xs \\<equiv> sequence (map f xs)\"\n\ndefinition zipWithM ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> ('s,'c) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> ('s, 'c list) nondet_monad\"\n  where\n  \"zipWithM f xs ys \\<equiv> sequence (zipWith f xs ys)\"\n\ndefinition foldM ::\n  \"('b \\<Rightarrow> 'a \\<Rightarrow> ('s, 'a) nondet_monad) \\<Rightarrow> 'b list \\<Rightarrow> 'a \\<Rightarrow> ('s, 'a) nondet_monad\"\n  where\n  \"foldM m xs a \\<equiv> foldr (\\<lambda>p q. q >>= m p) xs (return a) \"\n\ndefinition foldME ::\n  \"('b \\<Rightarrow> 'a \\<Rightarrow> ('s,('e + 'b)) nondet_monad) \\<Rightarrow> 'b \\<Rightarrow> 'a list \\<Rightarrow> ('s, ('e + 'b)) nondet_monad\"\n  where\n  \"foldME m a xs \\<equiv> foldr (\\<lambda>p q. q >>=E swp m p) xs (returnOk a)\"", "property": "Monadic Function Combinators: Provide a set of higher-order functions to manipulate and combine monadic computations, including sequencing, mapping, zipping, and folding, allowing for more expressive and concise monadic code.\n\nSubproperties:\n- Sequencing: Combine a list of monadic computations into a single computation that returns a list of results.\n- Mapping: Apply a monadic function to each element of a list, returning a list of results.\n- Zipping: Combine two lists by applying a monadic function to corresponding elements, returning a list of results.\n- Folding: Apply a monadic function to each element of a list, accumulating a result.\n- Error-aware Folding: Apply a monadic function to each element of a list, accumulating a result while propagating errors.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  The same three functions as above, but returning a list of\n  return values instead of @{text unit}"}
{"spec": "definition sequenceE_x :: \"('s, 'e+'a) nondet_monad list \\<Rightarrow> ('s, 'e+unit) nondet_monad\" where\n  \"sequenceE_x xs \\<equiv> foldr (\\<lambda>x y. doE _ <- x; y odE) xs (returnOk ())\"\n\ndefinition mapME_x :: \"('a \\<Rightarrow> ('s,'e+'b) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s,'e+unit) nondet_monad\" where\n  \"mapME_x f xs \\<equiv> sequenceE_x (map f xs)\"\n\ndefinition sequenceE :: \"('s, 'e+'a) nondet_monad list \\<Rightarrow> ('s, 'e+'a list) nondet_monad\" where\n  \"sequenceE xs \\<equiv> let mcons = (\\<lambda>p q. p >>=E (\\<lambda>x. q >>=E (\\<lambda>y. returnOk (x#y))))\n                   in foldr mcons xs (returnOk [])\"\n\ndefinition mapME ::\n  \"('a \\<Rightarrow> ('s,'e+'b) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s,'e+'b list) nondet_monad\"\n  where\n  \"mapME f xs \\<equiv> sequenceE (map f xs)\"", "property": "Exception Monad Combinators: Provide functions for sequencing and mapping monadic operations with exceptions, allowing for the combination of multiple operations that may fail, while propagating and handling errors.\n\nSequencing with Exceptions: Sequence a list of monadic operations, propagating exceptions and returning a list of results if all operations succeed.\n\nMapping with Exceptions: Map a monadic function over a list of values, propagating exceptions and returning a list of results if all operations succeed.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  The sequence and map functions above for the exception monad, with and without\n  lists of return value"}
{"spec": "primrec filterM :: \"('a \\<Rightarrow> ('s, bool) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, 'a list) nondet_monad\" where\n  \"filterM P []       = return []\"\n| \"filterM P (x # xs) = do\n     b  <- P x;\n     ys <- filterM P xs;\n     return (if b then (x # ys) else ys)\n   od\"", "property": "Filtering with Monadic Predicate: Filter a list using a monadic function as a predicate, returning a list of elements for which the predicate holds true. \n\nMonadic Filtering: Apply a monadic predicate to each element of a list, returning a list of elements that satisfy the predicate while maintaining the monadic context.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "Filtering a list using a monadic function as predicate:"}
{"spec": "lemma state_select_def2:\n  \"state_select r \\<equiv> (do\n    s \\<leftarrow> get;\n    S \\<leftarrow> return {s'. (s, s') \\<in> r};\n    assert (S \\<noteq> {});\n    s' \\<leftarrow> select S;\n    put s'\n  od)\"\n  apply (clarsimp simp add: state_select_def get_def return_def assert_def fail_def select_def\n                            put_def bind_def fun_eq_iff\n                    intro!: eq_reflection)\n  apply fastforce\n  done", "property": "State Selection: Nondeterministically select a new state from a relation, ensuring the new state is related to the current state and the relation is not empty. \n\nRelation Non-emptiness: The relation must not be empty to ensure a valid state selection. \n\nState Transition: The new state is selected and updated, replacing the current state.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "An alternative definition of @{term state_select}"}
{"spec": "text \\<open>\n  Turning an exception monad into a normal state monad\n  by catching and handling any potential exceptions:\\<close>\ndefinition catch ::\n  \"('s, 'e + 'a) nondet_monad \\<Rightarrow> ('e \\<Rightarrow> ('s, 'a) nondet_monad) \\<Rightarrow> ('s, 'a) nondet_monad\"\n  (infix \"<catch>\" 10) where\n  \"f <catch> handler \\<equiv>\n     do x \\<leftarrow> f;\n        case x of\n          Inr b \\<Rightarrow> return b\n        | Inl e \\<Rightarrow> handler e\n     od\"", "property": "Exception Handling: Catch and handle exceptions in a nondeterministic state monad, converting it into a normal state monad by executing a handler function for any potential exceptions.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": ""}
{"spec": "definition handleE' ::\n  \"('s, 'e1 + 'a) nondet_monad \\<Rightarrow> ('e1 \\<Rightarrow> ('s, 'e2 + 'a) nondet_monad) \\<Rightarrow> ('s, 'e2 + 'a) nondet_monad\"\n  (infix \"<handle2>\" 10) where\n  \"f <handle2> handler \\<equiv>\n   do\n      v \\<leftarrow> f;\n      case v of\n        Inl e \\<Rightarrow> handler e\n      | Inr v' \\<Rightarrow> return (Inr v')\n   od\"", "property": "Exception Handling: Catch and handle exceptions in a nondeterministic state monad, allowing the handler to throw a different type of exception than the original computation.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": "\n  Handling exceptions, but staying in the exception monad.\n  The handler may throw a type of exceptions different from\n  the left side."}
{"spec": "definition handleE ::\n  \"('s, 'x + 'a) nondet_monad \\<Rightarrow> ('x \\<Rightarrow> ('s, 'x + 'a) nondet_monad) \\<Rightarrow> ('s, 'x + 'a) nondet_monad\"\n  (infix \"<handle>\" 10) where\n  \"handleE \\<equiv> handleE'\"", "property": "Exception Handling: Provides a mechanism to catch and handle exceptions in a nondeterministic state monad, allowing for the handling of exceptions of the same type as the original monad.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": "\n  A type restriction of the above that is used more commonly in\n  practice: the exception handle (potentially) throws exception\n  of the same type as the left-hand side."}
{"spec": "definition handle_elseE ::\n  \"('s, 'e + 'a) nondet_monad \\<Rightarrow> ('e \\<Rightarrow> ('s, 'ee + 'b) nondet_monad) \\<Rightarrow>\n   ('a \\<Rightarrow> ('s, 'ee + 'b) nondet_monad) \\<Rightarrow> ('s, 'ee + 'b) nondet_monad\" (\"_ <handle> _ <else> _\" 10)\n  where\n  \"f <handle> handler <else> continue \\<equiv>\n   do v \\<leftarrow> f;\n      case v of Inl e  \\<Rightarrow> handler e\n              | Inr v' \\<Rightarrow> continue v'\n   od\"", "property": "Exception Handling with Continuation: Handle exceptions thrown by a nondeterministic state monad, providing a continuation if no exception is thrown.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": "\n  Handling exceptions, and additionally providing a continuation\n  if the left-hand side throws no exception:"}
{"spec": "text \\<open>\n  Loops are handled using the following inductive predicate;\n  non-termination is represented using the failure flag of the\n  monad.\\<close>\n\ninductive_set whileLoop_results ::\n  \"('r \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> ('r \\<Rightarrow> ('s, 'r) nondet_monad) \\<Rightarrow> ((('r \\<times> 's) option) \\<times> (('r \\<times> 's) option)) set\"\n  for C B where\n    \"\\<lbrakk> \\<not> C r s \\<rbrakk> \\<Longrightarrow> (Some (r, s), Some (r, s)) \\<in> whileLoop_results C B\"\n  | \"\\<lbrakk> C r s; snd (B r s) \\<rbrakk> \\<Longrightarrow> (Some (r, s), None) \\<in> whileLoop_results C B\"\n  | \"\\<lbrakk> C r s; (r', s') \\<in> fst (B r s); (Some (r', s'), z) \\<in> whileLoop_results C B  \\<rbrakk>\n       \\<Longrightarrow> (Some (r, s), z) \\<in> whileLoop_results C B\"\n\ninductive_cases whileLoop_results_cases_valid: \"(Some x, Some y) \\<in> whileLoop_results C B\"\ninductive_cases whileLoop_results_cases_fail: \"(Some x, None) \\<in> whileLoop_results C B\"\ninductive_simps whileLoop_results_simps: \"(Some x, y) \\<in> whileLoop_results C B\"\ninductive_simps whileLoop_results_simps_valid: \"(Some x, Some y) \\<in> whileLoop_results C B\"\ninductive_simps whileLoop_results_simps_start_fail[simp]: \"(None, x) \\<in> whileLoop_results C B\"\n\ninductive whileLoop_terminates ::\n  \"('r \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> ('r \\<Rightarrow> ('s, 'r) nondet_monad) \\<Rightarrow> 'r \\<Rightarrow> 's \\<Rightarrow> bool\"\n  for C B where\n    \"\\<not> C r s \\<Longrightarrow> whileLoop_terminates C B r s\"\n  | \"\\<lbrakk> C r s; \\<forall>(r', s') \\<in> fst (B r s). whileLoop_terminates C B r' s' \\<rbrakk>\n        \\<Longrightarrow> whileLoop_terminates C B r s\"\n\ninductive_cases whileLoop_terminates_cases: \"whileLoop_terminates C B r s\"\ninductive_simps whileLoop_terminates_simps: \"whileLoop_terminates C B r s\"\n\ndefinition whileLoop ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> ('b, 'a) nondet_monad) \\<Rightarrow> 'a \\<Rightarrow> ('b, 'a) nondet_monad\"\n  where\n  \"whileLoop C B \\<equiv> \\<lambda>r s.\n     ({(r',s'). (Some (r, s), Some (r', s')) \\<in> whileLoop_results C B},\n      (Some (r, s), None) \\<in> whileLoop_results C B \\<or> \\<not>whileLoop_terminates C B r s)\"\n\nnotation (output)\n  whileLoop  (\"(whileLoop (_)//  (_))\" [1000, 1000] 1000)\n\ndefinition whileLoopE ::\n  \"('r \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> ('r \\<Rightarrow> ('s, 'e + 'r) nondet_monad) \\<Rightarrow> 'r \\<Rightarrow> 's \\<Rightarrow> (('e + 'r) \\<times> 's) set \\<times> bool\"\n  where\n  \"whileLoopE C body \\<equiv>\n     \\<lambda>r. whileLoop (\\<lambda>r s. (case r of Inr v \\<Rightarrow> C v s | _ \\<Rightarrow> False)) (lift body) (Inr r)\"\n\nnotation (output)\n  whileLoopE  (\"(whileLoopE (_)//  (_))\" [1000, 1000] 1000)", "property": "While Loop Execution: The while loop construct allows for repeated execution of a body function until a condition is met, handling both terminating and non-terminating cases, with the possibility of failure or successful termination.\n\nSubproperties:\n- Loop Termination: The loop terminates when the condition is no longer met or when the body function indicates failure.\n- Non-Termination Representation: Non-termination is represented using the failure flag of the monad.\n- Loop Results: The results of the loop execution are captured using an inductive predicate, accounting for both successful termination and failure cases.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": ""}
{"spec": "definition notM :: \"('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad\" where\n  \"notM m = do c \\<leftarrow> m; return (\\<not> c) od\"\n\ndefinition whileM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad\"\n  where\n  \"whileM C B \\<equiv> do\n    c \\<leftarrow> C;\n    whileLoop (\\<lambda>c s. c) (\\<lambda>_. do B; C od) c;\n    return ()\n  od\"\n\ndefinition ifM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad\"\n  where\n  \"ifM test t f = do\n    c \\<leftarrow> test;\n    if c then t else f\n   od\"\n\ndefinition ifME ::\n  \"('a, 'b + bool) nondet_monad \\<Rightarrow> ('a, 'b + 'c) nondet_monad \\<Rightarrow> ('a, 'b + 'c) nondet_monad\n   \\<Rightarrow> ('a, 'b + 'c) nondet_monad\"\n  where\n  \"ifME test t f = doE\n    c \\<leftarrow> test;\n    if c then t else f\n   odE\"\n\ndefinition whenM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad\"\n  where\n  \"whenM t m = ifM t m (return ())\"\n\ndefinition orM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad\"\n  where\n  \"orM a b = ifM a (return True) b\"\n\ndefinition andM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad\"\n  where\n  \"andM a b = ifM a b (return False)\"\n\nend", "property": "Exception Handling Combinators: Provide a set of combinators for handling exceptions and errors in monadic computations, including conditional execution, looping, and error propagation.\n\n Subproperties:\n- Conditional Execution: Execute different monadic actions based on a boolean condition.\n- Looping: Repeat a monadic action while a condition holds.\n- Error Propagation: Handle errors and exceptions in monadic computations, propagating them to the caller.\n- Logical Operations: Perform logical operations (and, or, not) on monadic boolean values.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Combinators that have conditions with side effects", "comment": ""}
{"spec": "text \\<open>\n\n  The Separation Kernel maintains separation between processes by limiting the capabilities that are\n  present in the system. We call these the \"restricted capabilities\" in the documentation that\n  follows.\n\n  The specification described here, the Separation Kernel Abstract Specification (abbreviated\n  \\texttt{sep-abstract} from here on in), is identical to the Abstract Specification\n  (aka. \\texttt{abstract}), except that the following system calls have been overridden to\n  provide reduced (fully static) functionality only.\n\n  \\begin{itemize}\n  \\item{handle_fault}\n  \\item{invoke_irq_handler}\n  \\item{decode_invocation}\n  \\item{perform_invocation}\n  \\item{handle_invocation}\n  \\item{handle_reply}\n  \\item{handle_event}\n  \\item{call_kernel}\n  \\end{itemize}\n\n  The resulting kernel API is simplified significantly compared to full seL4.\n  The changes to the original abstract specification are minimal, except that it contains\n  much fewer system calls.\n\n  We achieve this by modifying the cases distinctions that determine which API call is\n  to by executed. The new case distinctions\n  on capabilities only provide code for the restricted capabilities in our reduced setup,\n  otherwise they fail (i.e. throw an exception).\n\n  We then prove that \\texttt{sep-abstract} and \\texttt{abstract} have the same behaviour under the\n  restricted capabilities of the separation kernel via bi-simulation. This simply requires that we\n  prove refinement in both directions. This proof implies that the missing (failing) code branches\n  in the reduced specification can never be executed.\n\n  It is clear that the behaviour will be the same for the \"mostly identical\" overridden\n  definitions. In a few cases, which are documented below, the definitions have bigger differencess.\n  We provide ab informal explanation at the site of the overriden definition in each of these\n  cases. (The bi-simulation proof provides the formal demonstration.)\n\n\\<close>", "property": "Separation Kernel Abstract Specification: The specification restricts the system calls to a reduced, fully static set of functionalities, ensuring that only specific, restricted capabilities are allowed. This simplification maintains the same behavior as the full abstract specification under the restricted capabilities, as proven by bi-simulation.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Generic system call structure\\label{s:spec_syscall}", "comment": ""}
{"spec": "fun\n  perform_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"perform_invocation block call (InvokeNotification ep badge) =\n    doE\n      without_preemption $ send_signal ep badge;\n      returnOk []\n    odE\"\n| \"perform_invocation _ _ _ = fail\"\n\ndefinition\n  handle_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_invocation calling blocking \\<equiv> doE\n    thread \\<leftarrow> liftE $ gets cur_thread;\n    info \\<leftarrow> without_preemption $ get_message_info thread;\n    ptr \\<leftarrow> without_preemption $ liftM data_to_cptr $\n          as_user thread $ getRegister cap_register;\n    syscall\n      (doE\n         (cap, slot) \\<leftarrow> cap_fault_on_failure (of_bl ptr) False $ lookup_cap_and_slot thread ptr;\n         buffer \\<leftarrow> liftE $ lookup_ipc_buffer False thread;\n         extracaps \\<leftarrow> lookup_extra_caps thread buffer info;\n         returnOk (slot, cap, extracaps, buffer)\n       odE)\n      (\\<lambda>fault. when blocking $ handle_fault thread fault)\n      (\\<lambda>(slot,cap,extracaps,buffer). doE\n            args \\<leftarrow> liftE $ get_mrs thread buffer info;\n            decode_invocation (mi_label info) args ptr slot cap extracaps\n       odE)\n      (\\<lambda>err. when calling $\n            reply_from_kernel thread $ msg_from_syscall_error err)\n      (\\<lambda>oper. doE\n            without_preemption $ set_thread_state thread Restart;\n            reply \\<leftarrow> perform_invocation blocking calling oper;\n            without_preemption $ do\n                state \\<leftarrow> get_thread_state thread;\n                case state of\n                      Restart \\<Rightarrow> do\n                          when calling $\n                              reply_from_kernel thread (0, reply);\n                          set_thread_state thread Running\n                      od\n                    | _ \\<Rightarrow>  return ()\n            od\n       odE)\n  odE\"\n\ndefinition\n  handle_yield :: \"(unit,'z::state_ext) s_monad\" where\n  \"handle_yield \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) thread);\n     do_extended_op (tcb_sched_action (tcb_sched_append) thread);\n     do_extended_op reschedule_required\n   od\"\n\ndefinition\n  handle_send :: \"bool \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"handle_send bl \\<equiv> handle_invocation False bl\"\n\ndefinition\n  handle_call :: \"(unit,'z::state_ext) p_monad\" where\n \"handle_call \\<equiv> handle_invocation True True\"", "property": "System Call Handling: Manages the execution of system calls by handling invocations, including sending signals to notifications, and managing thread states and scheduling. It ensures that system calls are processed correctly, with appropriate fault handling, state transitions, and rescheduling as needed.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": ""}
{"spec": "definition\n  handle_recv :: \"bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"handle_recv is_blocking \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n\n     ep_cptr \\<leftarrow> liftM data_to_cptr $ as_user thread $\n                 getRegister cap_register;\n\n     (cap_fault_on_failure (of_bl ep_cptr) True $ doE\n        ep_cap \\<leftarrow> lookup_cap thread ep_cptr;\n\n        let flt = (throwError $ MissingCapability 0)\n        in\n        case ep_cap\n          of\n            NotificationCap ref badge rights \\<Rightarrow>\n             (if AllowRecv \\<in> rights\n              then doE\n                ntfn \\<leftarrow> liftE $ get_notification ref;\n                boundTCB \\<leftarrow> returnOk $ ntfn_bound_tcb ntfn;\n                if boundTCB = Some thread \\<or> boundTCB = None\n                then liftE $ receive_signal thread ep_cap is_blocking\n                else flt\n               odE\n              else flt)\n           | _ \\<Rightarrow> flt\n      odE)\n      <catch> handle_fault thread\n   od\"", "property": "Handle Receive System Call: Processes a receive system call by checking the current thread's capability and performing the receive operation if the capability is a notification with the appropriate rights. If the capability is valid and allows receiving, it checks the notification's bound TCB and either receives the signal or throws a fault.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": "\n\n  This definition of \\texttt{handle_recv} is almost identical to the abstract specification's definition\n  for the restricted capabilities. Also, a call to \\texttt{delete_caller_cap} has been removed. They have\n  the same behaviour under the restricted capabilities since there are no caller capabilities in\n  \\texttt{sep-abstract}.\n\n"}
{"spec": "definition\n  handle_reply :: \"(unit,'z::state_ext) s_monad\" where\n \"handle_reply \\<equiv> return ()\"", "property": "Handle Reply: The system call entry point for handling replies is defined to perform no action, effectively returning immediately.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "System call entry point", "comment": "\n\n  The definition here has been specialised to \\texttt{return ()}. The behaviour\n  is identical with the abstract specification under restricted capabilities because there\n  are no \\texttt{Reply} capabilities in \\texttt{sep-abstract}.\n\n"}
{"spec": "text \\<open>\n\n  The definition here is almost identical to that of the abstract specification (for the restricted\n  capablities), except that a call to \\texttt{handle_reply} has been removed. Since there\n  are no \\texttt{Reply}s in the restricted capabilities the behaviour is the same.\n\n\\<close>\n\n\nfun\n  handle_event :: \"event \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_event (SyscallEvent call) =\n   (case call of\n          SysSend \\<Rightarrow> handle_send True\n        | SysNBSend \\<Rightarrow> handle_send False\n        | SysCall \\<Rightarrow> handle_call\n        | SysRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysYield \\<Rightarrow> without_preemption handle_yield\n        | SysReply \\<Rightarrow> without_preemption handle_reply\n        | SysReplyRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysNBRecv \\<Rightarrow> without_preemption $ handle_recv False)\"\n\n| \"handle_event (UnknownSyscall n) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UnknownSyscallException $ of_nat n;\n    return ()\n  od)\"\n\n| \"handle_event (UserLevelFault w1 w2) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UserException w1 (w2 && mask 28);\n    return ()\n  od)\"\n\n| \"handle_event Interrupt = (without_preemption $ do\n    active \\<leftarrow> do_machine_op (getActiveIRQ False);\n    case active of\n       Some irq \\<Rightarrow> handle_interrupt irq\n     | None \\<Rightarrow> return ()\n  od)\"\n\n| \"handle_event (VMFaultEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_vm_fault thread fault_type <catch> handle_fault thread;\n    return ()\n  od)\"\n\n| \"handle_event (HypervisorEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_hypervisor_fault thread fault_type;\n    return ()\n  od)\"", "property": "Event Handling: Processes various types of events, including system calls, unknown syscalls, user-level faults, interrupts, VM faults, and hypervisor events. Each event is handled in a non-preemptive context to ensure atomicity and consistency.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Top-level event handling", "comment": ""}
{"spec": "text \\<open>\n  This function is the main kernel entry point. The main event loop of the\n  kernel handles events, handles a potential preemption interrupt, schedules\n  and switches back to the active thread.\n\\<close>\n\ndefinition\n  call_kernel :: \"event \\<Rightarrow> (unit,'z::state_ext_sched) s_monad\" where\n  \"call_kernel ev \\<equiv> do\n       handle_event ev <handle>\n           (\\<lambda>_. without_preemption $ do\n                  irq \\<leftarrow> do_machine_op (getActiveIRQ True);\n                  when (irq \\<noteq> None) $ handle_interrupt (the irq)\n                od);\n       schedule;\n       activate_thread\n   od\"\n\nend", "property": "Kernel Entry Point: Processes events, handles potential preemption interrupts, schedules threads, and activates the next thread. This ensures that the kernel efficiently manages events and thread execution while maintaining system responsiveness and integrity.", "title": "./spec/sep-abstract/Syscall_SA.thy", "chapter": "Separation Kernel Abstract Specification", "section": "Kernel entry point", "comment": ""}
{"spec": "text \\<open>This definition is the toplevel decoding definition; it dispatches\nto the above definitions, after checking, in some cases, whether the\ninvocation is allowed.\n\\<close>\n\ndefinition\n  decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_invocation label args cap_index slot cap excaps \\<equiv>\n  case cap of\n    NotificationCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeNotification ptr badge\n      else throwError $ InvalidCapability 0\n  | _ \\<Rightarrow>\n      throwError $ InvalidCapability 0\"\n\nend", "property": "Decode Invocation: Decodes the system call based on the provided capability. If the capability is a NotificationCap and includes the AllowSend right, it returns an InvokeNotification invocation; otherwise, it throws an InvalidCapability error.", "title": "./spec/sep-abstract/Decode_SA.thy", "chapter": "Decoding System Calls", "section": "Toplevel invocation decode.", "comment": ""}
{"spec": "text \\<open>\n\n  \\texttt{handle_fault} in \\texttt{sep-abstract} always sets the thread state to\n  \\texttt{Inactive}. This is the same behaviour as \\texttt{handle_double_fault} in the abstract\n  specification.\n\n  The two \\texttt{handle_fault}s have the same behaviour under restricted capabilities because in\n  the abstract specification \\texttt{handle_fault} will call \\texttt{handle_double_fault} in all\n  cases except when the thread has an \\texttt{EndpointCap}. Since \\texttt{EndpointCap} is not part\n  of the restricted capabilities their behaviour is the same. This means, the system assumes\n  fully static virtual memory and no dynamic paging of any kind.\n  Faulting threads will be disabled by the kernel.\n\\<close>\n\ndefinition\n  handle_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault tptr ex \\<equiv> set_thread_state tptr Inactive\"\n\nend", "property": "Fault Handling: Sets the thread state to Inactive upon handling a fault, effectively disabling the faulting thread. This behavior is consistent under restricted capabilities, assuming fully static virtual memory and no dynamic paging.", "title": "./spec/sep-abstract/Ipc_SA.thy", "chapter": "IPC", "section": "", "comment": ""}
{"spec": "theory MachineMonad\nimports MachineTypes\nbegin\n\narch_requalify_types\n  machine_state\n  machine_state_rest\n\narch_requalify_consts\n  underlying_memory\n  underlying_memory_update\n  device_state\n  device_state_update\n  irq_masks\n  machine_state_rest\n  machine_state_rest_update", "property": "Machine State Management: Provides mechanisms to access and update the underlying memory, device state, and interrupt masks, ensuring that the machine state is correctly maintained and modified.", "title": "./spec/machine/MachineMonad.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\ntranslations\n  (type) \"'c machine_monad\" <= (type) \"machine_state \\<Rightarrow> ('c \\<times> machine_state) set \\<times> bool\"\n\ntype_synonym 'a machine_rest_monad = \"(machine_state_rest, 'a) nondet_monad\"\n\ndefinition\n  machine_rest_lift :: \"'a machine_rest_monad \\<Rightarrow> 'a machine_monad\"\nwhere\n  \"machine_rest_lift f \\<equiv> do\n    mr \\<leftarrow> gets machine_state_rest;\n    (r, mr') \\<leftarrow> select_f (f mr);\n    modify (\\<lambda>s. s \\<lparr> machine_state_rest := mr' \\<rparr>);\n    return r\n  od\"\n\n\ndefinition\n  ignore_failure :: \"('s,unit) nondet_monad \\<Rightarrow> ('s,unit) nondet_monad\"\n  where\n  \"ignore_failure f \\<equiv>\n  \\<lambda>s. if fst (f s) = {} then ({((),s)},False) else (fst (f s), False)\"", "property": "Machine Monad Operations: Facilitate operations on the machine state, allowing for the manipulation and transformation of the state in a nondeterministic manner. The `machine_rest_lift` function lifts operations from a restricted machine state to the full machine state, ensuring that changes are applied correctly. The `ignore_failure` function handles failures by ignoring them and continuing execution, providing a way to manage errors gracefully.", "title": "./spec/machine/MachineMonad.thy", "chapter": "", "section": "", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "lemma failure_consistent:\n  \"\\<lbrakk> empty_fail f; no_fail \\<top> f \\<rbrakk> \\<Longrightarrow> ignore_failure f = f\"\n  apply (simp add: ignore_failure_def empty_fail_def no_fail_def)\n  apply (rule ext)\n  apply (auto intro: prod_eqI)\n  done", "property": "Wrapper Consistency: The wrapper function `ignore_failure` behaves identically to the original function `f` when `f` is guaranteed not to fail and not to return a failure.", "title": "./spec/machine/MachineMonad.thy", "chapter": "", "section": "", "comment": "The wrapper doesn't do anything for usual operations:"}
{"spec": "lemma ef_ignore_failure [simp]:\n  \"empty_fail (ignore_failure f)\"\n  by (simp add: empty_fail_def ignore_failure_def)\n\nlemma no_fail_ignore_failure [simp, intro!]:\n  \"no_fail \\<top> (ignore_failure f)\"\n  by (simp add: no_fail_def ignore_failure_def)\n\n\nlemma ef_machine_rest_lift [simp, intro!]:\n  \"empty_fail f \\<Longrightarrow> empty_fail (machine_rest_lift f)\"\n  apply (clarsimp simp: empty_fail_def machine_rest_lift_def simpler_gets_def\n                        select_f_def bind_def simpler_modify_def return_def)\n  apply force\n  done\n\nlemma no_fail_machine_state_rest [intro!]:\n  \"no_fail P f \\<Longrightarrow> no_fail (P o machine_state_rest) (machine_rest_lift f)\"\n  apply (simp add: no_fail_def machine_rest_lift_def simpler_gets_def\n                        select_f_def bind_def simpler_modify_def return_def)\n  apply force\n  done\n\nlemma no_fail_machine_state_rest_T [simp, intro!]:\n  \"no_fail \\<top> f \\<Longrightarrow> no_fail \\<top> (machine_rest_lift f)\"\n  apply (drule no_fail_machine_state_rest)\n  apply (simp add: o_def)\n  done\n\ndefinition\n  \"machine_op_lift \\<equiv> machine_rest_lift o ignore_failure\"\n\n\nend", "property": "Failure Handling and Machine Operations: Ensures that operations wrapped with `ignore_failure` and `machine_rest_lift` do not fail, maintaining the integrity and reliability of the system.", "title": "./spec/machine/MachineMonad.thy", "chapter": "", "section": "", "comment": "And it has the desired properties"}
{"spec": "(* Architecture-independent lemmas constraining Kernel_Config definitions *)\n\ntheory Kernel_Config_Lemmas\nimports \"$L4V_ARCH/Kernel_Config\"\nbegin", "property": "Architectural Constraints: Ensures that the definitions in Kernel_Config adhere to specific architectural constraints, providing a consistent and reliable foundation for the kernel's behavior across different architectures.", "title": "./spec/machine/Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma numDomains_not_zero:\n  \"numDomains > 0\"\n  unfolding Kernel_Config.numDomains_def\n  by simp\n\nlemma numDomains_machine_word_safe:\n  \"unat (of_nat numDomains :: machine_word) = numDomains\"\n  unfolding Kernel_Config.numDomains_def by simp\n\nend", "property": "Configuration Constants Properties: The number of domains is greater than zero and its conversion to a machine word is safe, preserving the original value.", "title": "./spec/machine/Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": "\n  seL4's build system allows configuration of some architecture-independent constants, such as the\n  number of domains.\n\n  The long-term goal is to make the proofs resilient in the face of changes of these configuration\n  options. To this end this theory contains properties of these constants, to avoid unfolding\n  their values later in the proofs."}
{"spec": "term \"id :: machine_word \\<Rightarrow> machine_word_len word\"\n\narch_requalify_types\n  vmfault_type\n  hyp_fault_type\n  irq\n  user_monad\n  user_context\n\narch_requalify_consts\n  getActiveIRQ\n  maskInterrupt\n  freeMemory\n  loadWord\n  storeWord\n  storeWordVM\n  setNextPC\n  getRestartPC\n  setRegister\n  getRegister\n  initContext\n  exceptionMessage\n  syscallMessage\n  gpRegisters\n  frameRegisters\n  ackInterrupt\n  resetTimer\n  minIRQ\n  clearMemory\n  non_kernel_IRQs\n  tlsBaseRegister\n  debugPrint\n  configureTimer\n  initL2Cache\n  ptrFromPAddr\n  pageBits", "property": "Check Machine Word Consistency: Ensure that the `machine_word` and `machine_word_len word` types are consistent, allowing for seamless type conversion and usage in various architectural operations.", "title": "./spec/machine/MachineExports.thy", "chapter": "", "section": "", "comment": " Check consistency of machine_word and machine_word_len. "}
{"spec": "lemma Suc_unat_mask_div_obfuscated:\n  \"Suc (unat (mask sz div (word_size::machine_word))) = 2 ^ (min sz word_bits - word_size_bits)\"\n  by (rule Suc_unat_mask_div)\n\nlemma word_size_size_bits_nat:\n  \"2^word_size_bits = (word_size :: nat)\"\n  by (simp add: word_size_bits_def word_size_def)\n\nlemma word_size_size_bits_word:\n  \"2^word_size_bits = (word_size :: 'a :: len word)\"\n  by (simp add: word_size_bits_def word_size_def)\n\nend", "property": "Bitwise and Size Properties: Define relationships between bitwise operations, size constants, and their numerical representations. Specifically, the properties relate the size of a word, the number of bits in a word, and the result of dividing a masked value by the word size.", "title": "./spec/machine/MachineExports.thy", "chapter": "", "section": "", "comment": " HERE IS THE PLACE FOR GENERIC WORD LEMMAS FOR ALL ARCHITECTURES "}
{"spec": "locale Arch\n\nend", "property": "Namespace Management: Defines a locale for architecture-specific definitions, allowing for organized and namespaced management of architectural components. This ensures that architecture-specific entities are clearly delineated and can be selectively qualified or unqualified for use in generic proofs.", "title": "./spec/machine/Setup_Locale.thy", "chapter": "", "section": "", "comment": "\n   We use a locale for namespacing architecture-specific definitions.\n\n   The global_naming command changes the underlying naming of the locale. The intention is that\n   we liberally put everything into the \"ARM\" namespace, and then carefully unqualify (put into global namespace)\n   or requalify (change qualifier to \"Arch\" instead of \"ARM\") in order to refer to entities in\n   generic proofs.\n\n"}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified\n  part of the machine state @{typ machine_state_rest} and cannot fail.\n  We could express the latter by type (leaving out the failure flag),\n  but if we later wanted to implement them,\n  we'd have to set up a new hoare-logic\n  framework for that type. So instead, we provide a wrapper for these\n  operations that explicitly ignores the fail flag and sets it to\n  False. Similarly, these operations never return an empty set of\n  follow-on states, which would require the operation to fail.\n  So we explicitly make this (non-existing) case a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming ARM", "property": "Machine Operations: Perform operations on the underspecified part of the machine state, ensuring that they do not fail and always return a non-empty set of follow-on states. These operations explicitly ignore the failure flag, setting it to False, and treat any case that would result in an empty set of follow-on states as a null operation.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  memory_regions :: \"(paddr \\<times> paddr) list\" \n  initTimer_impl :: \"unit machine_rest_monad\"\ndefinition\n  initTimer :: \"unit machine_monad\"\nwhere \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts'\n  resetTimer_impl :: \"unit machine_rest_monad\"\n\ndefinition\n  resetTimer :: \"unit machine_monad\"\nwhere \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"\n\nconsts'\n  writeTTBR0_impl :: \"paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  writeTTBR0 :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere \"writeTTBR0 pd \\<equiv> machine_op_lift (writeTTBR0_impl pd)\"\n\n\nconsts'\n  setHardwareASID_impl :: \"hardware_asid \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setHardwareASID:: \"hardware_asid \\<Rightarrow> unit machine_monad\"\nwhere \"setHardwareASID a \\<equiv> machine_op_lift (setHardwareASID_impl a)\"", "property": "Machine Operations: Define a set of machine-level operations, including initializing and resetting the timer, writing to the Translation Table Base Register 0 (TTBR0), and setting the hardware Address Space Identifier (ASID). These operations are lifted from lower-level implementations to the machine monad, ensuring they can be executed within the context of the machine state.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  isb_impl :: \"unit machine_rest_monad\"\ndefinition\n  isb :: \"unit machine_monad\"\nwhere \"isb \\<equiv> machine_op_lift isb_impl\"\n\nconsts'\n  dsb_impl :: \"unit machine_rest_monad\"\ndefinition\n  dsb :: \"unit machine_monad\"\nwhere \"dsb \\<equiv> machine_op_lift dsb_impl\"\n\nconsts'\n  dmb_impl :: \"unit machine_rest_monad\"\ndefinition\n  dmb :: \"unit machine_monad\"\nwhere \"dmb \\<equiv> machine_op_lift dmb_impl\"\n\nconsts'\n  invalidateLocalTLB_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB :: \"unit machine_monad\"\nwhere \"invalidateLocalTLB \\<equiv> machine_op_lift invalidateLocalTLB_impl\"\n\n\nconsts'\n  invalidateLocalTLB_ASID_impl :: \"hardware_asid \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB_ASID :: \"hardware_asid \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateLocalTLB_ASID a \\<equiv> machine_op_lift (invalidateLocalTLB_ASID_impl a)\"", "property": "Memory Barrier Operations: Provide mechanisms to enforce memory ordering and synchronization, including instruction synchronization barriers (ISB), data synchronization barriers (DSB), and data memory barriers (DMB). Additionally, operations are available to invalidate the local Translation Lookaside Buffer (TLB) either for all ASIDs or for a specific ASID, ensuring that memory accesses are coherent and consistent.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " Memory Barriers "}
{"spec": "consts'\n  invalidateLocalTLB_VAASID_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB_VAASID :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateLocalTLB_VAASID w \\<equiv> machine_op_lift (invalidateLocalTLB_VAASID_impl w)\"\n\nconsts'\n  cleanByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanByVA w p \\<equiv> machine_op_lift (cleanByVA_impl w p)\"\n\nconsts'\n  cleanByVA_PoU_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanByVA_PoU :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanByVA_PoU w p \\<equiv> machine_op_lift (cleanByVA_PoU_impl w p)\"\n\nconsts'\n  invalidateByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateByVA w p \\<equiv> machine_op_lift (invalidateByVA_impl w p)\"\n\nconsts'\n  invalidateByVA_I_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateByVA_I :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateByVA_I w p \\<equiv> machine_op_lift (invalidateByVA_I_impl w p)\"\n\nconsts'\n  invalidate_I_PoU_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidate_I_PoU :: \"unit machine_monad\"\nwhere \"invalidate_I_PoU \\<equiv> machine_op_lift invalidate_I_PoU_impl\"\n\nconsts'\n  cleanInvalByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanInvalByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanInvalByVA w p \\<equiv> machine_op_lift (cleanInvalByVA_impl w p)\"\n\nconsts'\n  branchFlush_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  branchFlush :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"branchFlush w p \\<equiv> machine_op_lift (branchFlush_impl w p)\"\n\nconsts'\n  clean_D_PoU_impl :: \"unit machine_rest_monad\"\ndefinition\n  clean_D_PoU :: \"unit machine_monad\"\nwhere \"clean_D_PoU \\<equiv> machine_op_lift clean_D_PoU_impl\"\n\nconsts'\n  cleanInvalidate_D_PoC_impl :: \"unit machine_rest_monad\"\ndefinition\n  cleanInvalidate_D_PoC :: \"unit machine_monad\"\nwhere \"cleanInvalidate_D_PoC \\<equiv> machine_op_lift cleanInvalidate_D_PoC_impl\"\n\nconsts'\n  cleanInvalidateL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanInvalidateL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanInvalidateL2Range w p \\<equiv> machine_op_lift (cleanInvalidateL2Range_impl w p)\"\n\nconsts'\n  invalidateL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateL2Range w p \\<equiv> machine_op_lift (invalidateL2Range_impl w p)\"\n\nconsts'\n  cleanL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanL2Range w p \\<equiv> machine_op_lift (cleanL2Range_impl w p)\"\n\nconsts'\n  initL2Cache_impl :: \"unit machine_rest_monad\"\ndefinition\n  initL2Cache :: \"unit machine_monad\"\nwhere \"initL2Cache \\<equiv> machine_op_lift initL2Cache_impl\"\n\ndefinition\n  clearExMonitor :: \"unit machine_monad\"\nwhere \"clearExMonitor \\<equiv> modify (\\<lambda>s. s \\<lparr> exclusive_state := default_exclusive_state \\<rparr>)\"\n\nconsts'\n  flushBTAC_impl :: \"unit machine_rest_monad\"\ndefinition\n  flushBTAC :: \"unit machine_monad\"\nwhere \"flushBTAC \\<equiv> machine_op_lift flushBTAC_impl\"\n\nconsts'\n  initIRQController_impl :: \"unit machine_rest_monad\"\ndefinition\n  initIRQController :: \"unit machine_monad\"\nwhere \"initIRQController \\<equiv> machine_op_lift initIRQController_impl\"\n\ndefinition\n  IRQ :: \"irq \\<Rightarrow> irq\"\nwhere \"IRQ \\<equiv> id\"\n\nconsts'\n  writeContextID_impl :: \"unit machine_rest_monad\"\ndefinition\n  writeContextID :: \"unit machine_monad\"\nwhere \"writeContextID \\<equiv> machine_op_lift writeContextID_impl\"\n\nlemmas cache_machine_op_defs = isb_def dsb_def dmb_def writeContextID_def flushBTAC_def\n                               clearExMonitor_def cleanL2Range_def invalidateL2Range_def\n                               cleanInvalidateL2Range_def cleanInvalidate_D_PoC_def\n                               clean_D_PoU_def branchFlush_def cleanInvalByVA_def\n                               invalidate_I_PoU_def invalidateByVA_I_def invalidateByVA_def\n                               cleanByVA_PoU_def cleanByVA_def invalidateLocalTLB_VAASID_def\n                               invalidateLocalTLB_ASID_def invalidateLocalTLB_def\nconsts'\n  IFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  DFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  FAR_val :: \"machine_state \\<Rightarrow> machine_word\"\n\ndefinition\n  getIFSR :: \"machine_word machine_monad\"\n  where \"getIFSR \\<equiv> gets IFSR_val\"\n\ndefinition\n  getDFSR :: \"machine_word machine_monad\"\n  where \"getDFSR \\<equiv> gets DFSR_val\"\n\ndefinition\n  getFAR :: \"machine_word machine_monad\"\n  where \"getFAR \\<equiv> gets FAR_val\"\n\ndefinition\n  debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\"\nwhere\n  debugPrint_def[simp]:\n \"debugPrint \\<equiv> \\<lambda>message. return ()\"\n\nconsts'\n  ackInterrupt_impl :: \"irq \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"ackInterrupt irq \\<equiv> machine_op_lift (ackInterrupt_impl irq)\"\n\n\n\\<comment> \\<open>Interrupt controller operations\\<close>", "property": "Machine Operations: Provide a set of functions to perform various machine-level operations, including cache management, TLB invalidation, branch flushing, interrupt acknowledgment, and debug register access. These operations are lifted from their C implementations to the machine monad, ensuring that they can be safely and effectively used within the kernel's context.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " C implementation takes one argument, which is w || a "}
{"spec": "definition\n  \"non_kernel_IRQs = {}\"", "property": "Non-Kernel Interrupts: Defines a set of interrupts that cannot occur while the kernel is running but can occur from user mode. In this case, the set is empty, indicating no such interrupts exist on the specified architecture.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Interrupts that cannot occur while the kernel is running (e.g. at preemption points),\n  but that can occur from user mode. Empty on plain ARMv7.\n"}
{"spec": "definition\n  getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\"\nwhere\n  \"getActiveIRQ in_kernel \\<equiv> do\n    is_masked \\<leftarrow> gets $ irq_masks;\n    modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n    active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n    if is_masked active_irq \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n    then return None\n    else return (Some active_irq)\n  od\"\n\ndefinition\n  maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"maskInterrupt m irq \\<equiv>\n  modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"\n\ndefinition\n  lineStart :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"lineStart addr = (addr >> cacheLineBits) << cacheLineBits\"", "property": "Active IRQ Retrieval: Retrieves the active interrupt request (IRQ) after updating the IRQ state, considering whether the IRQ is masked or if it is a non-kernel IRQ when in kernel mode. If the IRQ is masked or is a non-kernel IRQ in kernel mode, it returns `None`; otherwise, it returns the active IRQ.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  @{term getActiveIRQ} is now derministic.\n  It 'updates' the irq state to the reflect the passage of\n  time since last the irq was gotten, then it gets the active\n  IRQ (if there is one).\n"}
{"spec": "definition\n  cacheRangeOp :: \"(machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad)\n                 \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cacheRangeOp operation vstart vend pstart \\<equiv>\n    let pend = pstart + (vend - vstart);\n        vptrs = [lineStart vstart, lineStart vstart + of_nat cacheLine .e. lineStart vend];\n        pptrs = [lineStart pstart, lineStart pstart + of_nat cacheLine .e. lineStart pend]\n    in mapM_x (\\<lambda>(v, p). operation v p) (zip vptrs pptrs)\"\n\ndefinition\n  cleanCacheRange_PoC :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_PoC vstart vend pstart \\<equiv> cacheRangeOp cleanByVA vstart vend pstart\"\n\ndefinition\n  cleanInvalidateCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanInvalidateCacheRange_RAM vstart vend pstart \\<equiv> do\n    cleanCacheRange_PoC vstart vend pstart;\n    dsb;\n    cleanInvalidateL2Range pstart (pstart + (vend - vstart));\n    cacheRangeOp cleanInvalByVA vstart vend pstart;\n    dsb\n  od\"\n\ndefinition\n  cleanCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_RAM vstart vend pstart \\<equiv> do\n    cleanCacheRange_PoC vstart vend pstart;\n    dsb;\n    cleanL2Range pstart (pstart + (vend - vstart))\n  od\"\n\ndefinition\n  cleanCacheRange_PoU :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_PoU vstart vend pstart \\<equiv> cacheRangeOp cleanByVA_PoU vstart vend pstart\"\n\ndefinition\n  invalidateCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"invalidateCacheRange_RAM vstart vend pstart \\<equiv> do\n    when (vstart \\<noteq> lineStart vstart) $\n        cleanCacheRange_RAM vstart vstart pstart;\n    when (vend + 1 \\<noteq> lineStart (vend + 1)) $\n        cleanCacheRange_RAM (lineStart vend) (lineStart vend)\n           (pstart + ((lineStart vend) - vstart));\n    invalidateL2Range pstart (pstart + (vend - vstart));\n    cacheRangeOp invalidateByVA vstart vend pstart;\n    dsb\n  od\"\n\ndefinition\n  invalidateCacheRange_I :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"invalidateCacheRange_I vstart vend pstart \\<equiv> cacheRangeOp invalidateByVA_I vstart vend pstart\"\n\ndefinition\n  branchFlushRange :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"branchFlushRange vstart vend pstart \\<equiv> cacheRangeOp branchFlush vstart vend pstart\"\n\ndefinition\n  cleanCaches_PoU :: \"unit machine_monad\"\nwhere\n  \"cleanCaches_PoU \\<equiv> do\n    dsb;\n    clean_D_PoU;\n    dsb;\n    invalidate_I_PoU;\n    dsb\n  od\"\n\ndefinition\n  cleanInvalidateL1Caches :: \"unit machine_monad\"\nwhere\n  \"cleanInvalidateL1Caches \\<equiv> do\n    dsb;\n    cleanInvalidate_D_PoC;\n    dsb;\n    invalidate_I_PoU;\n    dsb\n  od\"", "property": "Cache Operations: Perform specific cache operations (such as clean, invalidate, and branch flush) on every cache line that intersects the supplied virtual and physical address range. These operations ensure data consistency and coherence across different levels of the cache hierarchy.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Performs the given operation on every cache line that intersects the\n  supplied range.\n"}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory. Do not yet flush the cache.\\<close>\ndefinition\n  clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"clearMemory ptr bytelength \\<equiv>\n    mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"\n\ndefinition\n  clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Memory Clearance: Clear the contents of a specified memory region by setting each word to zero, preparing it for reuse as user memory. The operation does not flush the cache.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": ""}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Initialize memory to be used as user memory, ensuring it is cleared and ready for use. This process includes a call to clean the cache range, which is essential for maintaining memory integrity and performance.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Initialize memory to be used as user memory.\n  Note that zeroing out the memory is redundant in the specifications.\n  In any case, we cannot abstract from the call to cleanCacheRange,\n  which appears in the implementation.\n"}
{"spec": "definition\n  freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"freeMemory ptr bits \\<equiv>\n  mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Memory Clearance: Zero out the memory region starting from the specified pointer and spanning the given number of bits to ensure that the freed memory contains no garbage, allowing for predictable and consistent memory state.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Free memory that had been initialized as user memory.\n  While freeing memory is a no-(in) the implementation,\n  we zero out the underlying memory in the specifications to avoid garbage.\n  If we know that there is no garbage,\n  we can compute from the implementation state\n  what the exact memory content in the specifications is.\n"}
{"spec": "type_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\" where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\" where\n  \"modify_registers f uc \\<equiv> UserContext (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\" where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext ((user_regs s) (r := v)))\"\n\ndefinition\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition\n  \"setNextPC \\<equiv> setRegister NextIP\"\n\nend\n\ntranslations\n  (type) \"'a ARM.user_monad\" <= (type) \"(ARM.register \\<Rightarrow> machine_word, 'a) nondet_monad\"\n\n\nend", "property": "User Monad Operations: Provides functions to get and set machine word values for specific registers within a user context, including getting the restart program counter and setting the next program counter. These operations enable manipulation of the user context's register state in a non-deterministic monad.", "title": "./spec/machine/ARM/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Integer Representation: Defines the representation of integer literals and words, specifying that integer literals are 32-bit signed integers and integer words are 32-bit signed words.", "title": "./spec/machine/ARM/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming ARM\n\nvalue_type irq_len = Kernel_Config.irqBits (* IRQ_CNODE_SLOT_BITS *)\ntype_synonym irq = \"irq_len word\"\ntype_synonym paddr = word32\n\nabbreviation (input) \"toPAddr \\<equiv> id\"\nabbreviation (input) \"fromPAddr \\<equiv> id\"\n\ndefinition pageColourBits :: nat where\n  \"pageColourBits \\<equiv> 2\"\n\ndefinition cacheLineBits :: nat where\n  \"cacheLineBits = CONFIG_L1_CACHE_LINE_SIZE_BITS\"\n\ndefinition cacheLine :: nat where\n  \"cacheLine = 2^cacheLineBits\"", "property": "Platform Constants: Define and specify the bit lengths and sizes for IRQs, physical addresses, page colors, and cache lines, ensuring consistent and correct representation of these values in the system.", "title": "./spec/machine/ARM/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "definition pptrBase :: word32 where\n  \"pptrBase \\<equiv> 0xe0000000\"\n\nabbreviation (input) \"paddrBase \\<equiv> physBase\"\n\ndefinition pptrBaseOffset :: word32 where\n  \"pptrBaseOffset \\<equiv> pptrBase - paddrBase\"\n\ndefinition kernelELFPAddrBase :: word32 where\n  \"kernelELFPAddrBase \\<equiv> physBase\"\n\ndefinition kernelELFBase :: word32 where\n  \"kernelELFBase \\<equiv> pptrBase + (kernelELFPAddrBase && mask 22)\"\n\ndefinition kernelELFBaseOffset :: word32 where\n  \"kernelELFBaseOffset \\<equiv> kernelELFBase - kernelELFPAddrBase\"\n\ndefinition ptrFromPAddr :: \"paddr \\<Rightarrow> word32\" where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBaseOffset\"\n\ndefinition addrFromPPtr :: \"word32 \\<Rightarrow> paddr\" where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBaseOffset\"\n\ndefinition addrFromKPPtr :: \"word32 \\<Rightarrow> paddr\" where\n  \"addrFromKPPtr kpptr \\<equiv> kpptr - kernelELFBaseOffset\"\n\ndefinition minIRQ :: \"irq\" where\n  \"minIRQ \\<equiv> 0\"\n\nend\n\nend", "property": "Platform Constants: Define the base addresses and offsets for the kernel's physical memory window, including the first virtual address, physical address base, and offsets for the kernel ELF. These constants facilitate the conversion between physical and virtual addresses, ensuring correct memory mapping and access within the system.", "title": "./spec/machine/ARM/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": " The first virtual address of the kernel's physical memory window "}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming ARM", "property": "Architectural Constraints: Ensure that the kernel configuration definitions adhere to architectural-specific constraints, maintaining consistency and compatibility with the ARM platform.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma physBase_aligned:\n  \"is_aligned physBase 24\"\n  by (simp add: is_aligned_def Kernel_Config.physBase_def)", "property": "Physical Base Alignment: The physical base address is aligned to a 24-bit boundary, ensuring proper memory alignment for the system.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " note: 24 = pageBitsForSize ARMSuperSection, we do not have access to ASpec at this point "}
{"spec": "lemma maxIRQ_less_2p_irqBits:\n  \"(maxIRQ::nat) < 2^irqBits\"\n  by (simp add: Kernel_Config.maxIRQ_def Kernel_Config.irqBits_def)", "property": "Max IRQ Value: The maximum interrupt request (IRQ) value is less than 2 raised to the power of the number of bits allocated for IRQs.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ conditions "}
{"spec": "lemma LENGTH_irq_len_irqBits[simp]: (* [simp] will fire only for simp del: len_of_numeral_defs *)\n  \"LENGTH(irq_len) = irqBits\"\n  using irq_len_def irq_len_val\n  by simp\n\nlemma maxIRQ_less_2p_irq_len:\n  \"(maxIRQ::nat) < 2^LENGTH(irq_len)\"\n  using maxIRQ_less_2p_irqBits\n  by (simp del: len_of_numeral_defs)", "property": "IRQ Length and Maximum IRQ Value: The length of the `irq_len` is defined to be equal to `irqBits`, and the maximum IRQ value is less than \\(2^{irqBits}\\).", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " follows from value_type definition of irq_len "}
{"spec": "lemma of_nat_maxIRQ[simp]:\n  \"of_nat maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma of_int_maxIRQ[simp]:\n  \"of_int maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "MaxIRQ Conversion: The maximum interrupt request number can be converted to a word of any length without loss of information, ensuring consistency in numeric representations.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ as a generic numeral allows us to write rules about casts/unat/uint etc without\n   mentioning numbers: "}
{"spec": "lemma unat_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> unat (maxIRQ::'a word) = maxIRQ\"\n  by (metis maxIRQ_less_2p_irq_len Word.of_nat_unat of_nat_inverse of_nat_maxIRQ unat_ucast_up_simp)", "property": "Unat Conversion for maxIRQ: Ensures that the unat conversion of maxIRQ is equal to maxIRQ itself, provided that the length of irq_len is less than or equal to the bit length of the word type. This property guarantees safe simplification and usage of maxIRQ in various contexts without loss of information.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma uint_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> uint (maxIRQ::'a word) = maxIRQ\"\n  by (metis Kernel_Config.maxIRQ_def of_nat_numeral uint_nat unat_maxIRQ)", "property": "Safe Conversion of maxIRQ: Ensures that the conversion of the maximum interrupt request (maxIRQ) to an unsigned integer is safe and retains its value, provided that the length of the interrupt request is less than or equal to the bit width of the target type.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma ucast_maxIRQ[simp]:\n  \"\\<lbrakk> LENGTH(irq_len) \\<le> LENGTH('a::len); LENGTH(irq_len) \\<le> LENGTH('b::len) \\<rbrakk> \\<Longrightarrow>\n   UCAST ('a \\<rightarrow> 'b) maxIRQ = maxIRQ\"\n  by (metis of_nat_maxIRQ ucast_nat_def unat_maxIRQ)", "property": "Type Conversion Safety: The conversion of `maxIRQ` between different bit lengths is safe and preserves the value, provided that the target bit length is at least as large as the source bit length.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma maxIRQ_less_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   (maxIRQ < (ucast irq :: 'a word)) = (maxIRQ < irq)\" for irq::irq\n  by (simp add: word_less_nat_alt unat_ucast_up_simp)", "property": "Max IRQ Comparison: Ensures that the comparison of a maximum IRQ value with an upcast IRQ value remains consistent, provided the length of the upcast type is at least as large as the original IRQ type. This guarantees safe and predictable behavior when comparing IRQ values across different word sizes.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma maxIRQ_le_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   ((ucast irq :: 'a word) \\<le> Kernel_Config.maxIRQ) = (irq \\<le> Kernel_Config.maxIRQ)\" for irq::irq\n  by (simp add: word_le_nat_alt unat_ucast_up_simp)", "property": "Max IRQ Upcast Safety: Ensures that upcasting an IRQ to a larger word size does not affect the comparison with the maximum IRQ value, maintaining the safety and correctness of IRQ handling.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma le_maxIRQ_machine_less_irqBits_val[simplified]:\n  \"w \\<le> maxIRQ \\<Longrightarrow> unat w < 2^LENGTH(irq_len)\" for w::machine_word\n  using maxIRQ_less_2p_irq_len\n  by (simp add: word_le_nat_alt)\n\nlemma irq_machine_le_maxIRQ_irq:\n  \"irq \\<le> Kernel_Config.maxIRQ \\<Longrightarrow> (ucast irq::irq) \\<le> maxIRQ\" for irq::machine_word\n  by (simp add: Kernel_Config.maxIRQ_def word_le_nat_alt unat_ucast)\n\nlemma maxIRQ_eq_ucast_irq_32_signed_uint:\n  \"(maxIRQ = (ucast b :: int_word)) = (uint b = maxIRQ)\" for b::irq\n  unfolding Kernel_Config.maxIRQ_def\n  apply uint_arith\n  apply (simp add: uint_up_ucast is_up)\n  done\n\nlemma sint_maxIRQ_32[simp]:\n  \"sint (maxIRQ :: int_word) = maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_machine[simp]:\n  \"scast (maxIRQ :: int_word) = (maxIRQ::machine_word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_irq[simp]:\n  \"scast (maxIRQ :: int_word) = (maxIRQ::irq)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_machine:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = x\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_irq:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = (ucast x :: irq)\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_1_plus_eq_Suc_machine[simp]:\n  \"unat (1 + maxIRQ :: machine_word) = Suc Kernel_Config.maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "MaxIRQ Properties: Define and constrain the maximum interrupt request (IRQ) value, ensuring that it is within the bounds of the system's IRQ length and that conversions between different word types (machine_word, irq, int_word) maintain the integrity of the maxIRQ value. This ensures consistent and predictable behavior in IRQ handling across the system.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " The following are instances -- for some we could derive general rules, but the number of\n   instances is limited and the concrete proofs are much simpler: "}
{"spec": "lemma cacheLineBits_sanity:\n  \"cacheLineBits \\<in> {2..10}\"\n  by (simp add: cacheLineBits_def Kernel_Config.CONFIG_L1_CACHE_LINE_SIZE_BITS_def)\n\nend\nend", "property": "Cache Line Bits Sanity: The value of `cacheLineBits` must be within the range of 2 to 10, ensuring it is suitable for use in cache operations and does not conflict with other values.", "title": "./spec/machine/ARM/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Folding cacheLineBits_val in C functions only works reliably if cacheLineBits is not 1 and\n   not too large to conflict with other values used inside cache ops.\n   10 is ptBits, which is only available after ExecSpec. Anything > 1 and smaller than ptBits\n   works. "}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified\n  part of the machine state @{typ machine_state_rest} and cannot fail.\n  We could express the latter by type (leaving out the failure flag),\n  but if we later wanted to implement them,\n  we'd have to set up a new hoare-logic\n  framework for that type. So instead, we provide a wrapper for these\n  operations that explicitly ignores the fail flag and sets it to\n  False. Similarly, these operations never return an empty set of\n  follow-on states, which would require the operation to fail.\n  So we explicitly make this (non-existing) case a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming X64", "property": "Machine Operations: Perform operations on the underspecified part of the machine state, ensuring that they do not fail and always return a non-empty set of follow-on states. These operations are wrapped to explicitly set the failure flag to False and handle the non-existing case as a null operation.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  memory_regions :: \"(paddr \\<times> paddr) list\" \n  initTimer_impl :: \"unit machine_rest_monad\"\ndefinition\n  initTimer :: \"unit machine_monad\"\nwhere \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts'\n  resetTimer_impl :: \"unit machine_rest_monad\"\n\ndefinition\n  resetTimer :: \"unit machine_monad\"\nwhere \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"\n\nconsts'\n  invalidateTLB_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidateTLB :: \"unit machine_monad\"\nwhere \"invalidateTLB \\<equiv> machine_op_lift invalidateTLB_impl\"\n\nlemmas cache_machine_op_defs = invalidateTLB_def\n\ndefinition\n  debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\"\nwhere\n  debugPrint_def[simp]:\n \"debugPrint \\<equiv> \\<lambda>message. return ()\"\n\n\n\\<comment> \\<open>Interrupt controller operations\\<close>", "property": "Machine Operations: Define and lift machine-level operations such as initializing and resetting the timer, invalidating the TLB, and printing debug messages. These operations ensure that low-level hardware interactions are abstracted and managed within the machine monad, providing a clear interface for system-level tasks.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition\n  \"non_kernel_IRQs = {}\"", "property": "Non-Kernel Interrupts: Defines a set of interrupts that cannot occur while the kernel is running but can occur from user mode. The set is empty for plain x86-64 architectures.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Interrupts that cannot occur while the kernel is running (e.g. at preemption points),\n  but that can occur from user mode. Empty on plain x86-64.\n"}
{"spec": "definition\n  getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\"\nwhere\n  \"getActiveIRQ in_kernel \\<equiv> do\n    is_masked \\<leftarrow> gets $ irq_masks;\n    modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n    active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n    if is_masked active_irq \\<or> active_irq = 0xFF \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n    then return None\n    else return ((Some active_irq) :: irq option)\n  od\"\n\ndefinition\n  maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"maskInterrupt m irq \\<equiv>\n  modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"", "property": "Active IRQ Determination: Retrieves the active interrupt request (IRQ) by updating the IRQ state to reflect the passage of time, and then checks if the IRQ is masked, invalid, or not allowed in the current kernel state. If any of these conditions are met, it returns `None`; otherwise, it returns the active IRQ. \n\nInterrupt Masking: Modifies the IRQ mask for a specific interrupt, allowing or disallowing its processing based on the provided boolean value.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  @{term getActiveIRQ} is now derministic.\n  It 'updates' the irq state to the reflect the passage of\n  time since last the irq was gotten, then it gets the active\n  IRQ (if there is one).\n"}
{"spec": "definition\n  ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"ackInterrupt \\<equiv> \\<lambda>irq. return ()\"", "property": "Acknowledge Interrupt: The operation acknowledges an interrupt but performs no actual action on the imx31 platform.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Does nothing on imx31"}
{"spec": "definition\n  setInterruptMode :: \"irq \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setInterruptMode \\<equiv> \\<lambda>irq levelTrigger polarityLow. return ()\"", "property": "Set Interrupt Mode: The operation does not perform any action on the imx31 platform, effectively ignoring the specified interrupt mode settings.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Does nothing on imx31"}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory\\<close>\ndefinition\n  clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"clearMemory ptr bytelength \\<equiv> mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"\n\ndefinition\n  clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Clear Memory: Clear the contents of a specified memory region by setting each word to zero, preparing it for reuse as user memory.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": ""}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Clear the memory to be used as user memory, ensuring it is properly initialized and ready for use. This process includes a call to cleanCacheRange, which is essential for maintaining memory integrity and performance.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Initialize memory to be used as user memory.\n  Note that zeroing out the memory is redundant in the specifications.\n  In any case, we cannot abstract from the call to cleanCacheRange,\n  which appears in the implementation.\n"}
{"spec": "definition\n  freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"freeMemory ptr bits \\<equiv>\n  mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Memory Clearance: Zero out the underlying memory region specified by the pointer and size to ensure that no garbage data remains, allowing for a clean state in the specifications.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Free memory that had been initialized as user memory.\n  While freeing memory is a no-(in) the implementation,\n  we zero out the underlying memory in the specifications to avoid garbage.\n  If we know that there is no garbage,\n  we can compute from the implementation state\n  what the exact memory content in the specifications is.\n"}
{"spec": "text \\<open> There are 576 bytes of FPU state. Since there are no operations on this state apart from bulk\nsave/restore, we abstract from names and just say how many bytes there are. \\<close>\ntype_synonym fpu_bytes = 576\ntype_synonym fpu_state = \"fpu_bytes \\<Rightarrow> 8 word\"\n\ntype_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (fpu_state : fpu_state) (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition\n  getRegister :: \"register \\<Rightarrow> machine_word user_monad\"\nwhere\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition\n  \"modify_registers f uc \\<equiv> UserContext (fpu_state uc) (f (user_regs uc))\"\n\ndefinition\n  setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\"\nwhere\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext (fpu_state s) ((user_regs s) (r := v)))\"\n\ndefinition\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition\n  \"setNextPC \\<equiv> setRegister NextIP\"\n\n\ndefinition\n  getFPUState :: \"fpu_state user_monad\"\nwhere\n  \"getFPUState \\<equiv> gets fpu_state\"\n\ndefinition\n  setFPUState :: \"fpu_state \\<Rightarrow> unit user_monad\"\nwhere\n  \"setFPUState fc \\<equiv> modify (\\<lambda>s. UserContext fc (user_regs s))\"\n\n\n\ndefinition\n  hwASIDInvalidate :: \"word64 \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"hwASIDInvalidate \\<equiv> invalidateASID\"\n\nconsts'\n  getFaultAddress_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\ngetFaultAddress :: \"word64 machine_monad\"\nwhere\n\"getFaultAddress \\<equiv> gets getFaultAddress_val\"\n\nconsts'\n  irqIntOffset_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\nirqIntOffset :: \"machine_word\"\nwhere\n\"irqIntOffset \\<equiv> 0x20\"\n\ndefinition\nmaxPCIBus :: \"machine_word\"\nwhere\n\"maxPCIBus \\<equiv> 0xFF\"\n\ndefinition\nmaxPCIDev :: \"machine_word\"\nwhere\n\"maxPCIDev \\<equiv> 31\"\n\ndefinition\nmaxPCIFunc :: \"machine_word\"\nwhere\n\"maxPCIFunc \\<equiv> 7\"\n\ndefinition\nioapicIRQLines :: \"machine_word\"\nwhere\n\"ioapicIRQLines \\<equiv> 24\"\n\nconsts'\n  ioapicMapPinToVector_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow>\n    machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  ioapicMapPinToVector :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow>\n    machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"ioapicMapPinToVector ioapic pin level polarity vector \\<equiv>\n    machine_op_lift (ioapicMapPinToVector_impl ioapic pin level polarity vector)\"\n\ndefinition IRQ :: \"word8 \\<Rightarrow> irq\"\nwhere\n  \"IRQ \\<equiv> id\"\n\nconsts'\n  in8_impl :: \"word16 \\<Rightarrow> unit machine_rest_monad\"\n  in8_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  in8 :: \"word16 \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"in8 port \\<equiv> do machine_op_lift $ in8_impl port; gets in8_val od\"\n\nconsts'\n  in16_impl :: \"word16 \\<Rightarrow> unit machine_rest_monad\"\n  in16_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  in16 :: \"word16 \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"in16 port \\<equiv> do machine_op_lift $ in16_impl port; gets in16_val od\"\n\nconsts'\n  in32_impl :: \"word16 \\<Rightarrow> unit machine_rest_monad\"\n  in32_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  in32 :: \"word16 \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"in32 port \\<equiv> do machine_op_lift $ in32_impl port; gets in32_val od\"\n\nconsts'\n  out8_impl :: \"word16 \\<Rightarrow> word8 \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  out8 :: \"word16 \\<Rightarrow> word8 \\<Rightarrow> unit machine_monad\"\nwhere\n  \"out8 port dat \\<equiv> machine_op_lift $ out8_impl port dat\"\n\nconsts'\n  out16_impl :: \"word16 \\<Rightarrow> word16 \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  out16 :: \"word16 \\<Rightarrow> word16 \\<Rightarrow> unit machine_monad\"\nwhere\n  \"out16 port dat \\<equiv> machine_op_lift $ out16_impl port dat\"\n\nconsts'\n  out32_impl :: \"word16 \\<Rightarrow> word32 \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  out32 :: \"word16 \\<Rightarrow> word32 \\<Rightarrow> unit machine_monad\"\nwhere\n  \"out32 port dat \\<equiv> machine_op_lift $ out32_impl port dat\"\n\nend\n\n\nend", "property": "User Monad Operations: Provide a set of operations for managing user context, including getting and setting register values, managing FPU state, and performing I/O operations. These operations enable the manipulation of user-level state and interaction with hardware, ensuring that the system can effectively handle user-level processes and their associated data.", "title": "./spec/machine/X64/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Integer Literal Representation: Defines the representation of C integer literals and integer words, using a 32-bit signed format.", "title": "./spec/machine/X64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming X64\n\ntype_synonym irq_len = 8\ntype_synonym irq = \"irq_len word\"\ntype_synonym paddr = word64\n\n\nabbreviation (input) \"toPAddr \\<equiv> id\"\nabbreviation (input) \"fromPAddr \\<equiv> id\"\n\ndefinition\n  pptrBase :: word64 where\n  \"pptrBase = 0xffffff8000000000\"\n\ndefinition\n  kernelELFBaseOffset :: word64 where\n  \"kernelELFBaseOffset = 0xffffffff80000000\"\n\ndefinition\n  pptrUserTop :: word64 where\n  \"pptrUserTop = 0x00007fffffffffff\"\n\ndefinition\n  ptrFromPAddr :: \"paddr \\<Rightarrow> word64\" where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBase\"\n\ndefinition\n  addrFromPPtr :: \"word64 \\<Rightarrow> paddr\" where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBase\"\n\ndefinition\n  addrFromKPPtr :: \"word64 \\<Rightarrow> paddr\" where\n  \"addrFromKPPtr pptr \\<equiv> pptr - kernelELFBaseOffset\"\n\ndefinition\n  pageColourBits :: \"nat\" where\n  \"pageColourBits \\<equiv> undefined\"\n\ndefinition\n  minIRQ :: \"irq\" where\n  \"minIRQ \\<equiv> 0\"\n\ndefinition\n  maxIRQ :: \"irq\" where\n  \"maxIRQ \\<equiv> 125\"\n\ndefinition\n  minUserIRQ :: \"irq\" where\n  \"minUserIRQ \\<equiv> 16\"\n\ndefinition\n  maxUserIRQ :: \"irq\" where\n  \"maxUserIRQ \\<equiv> 123\"\n\ndatatype cr3 = X64CR3 (CR3BaseAddress: word64) (cr3pcid: word64)\n\nprimrec cr3BaseAddress_update :: \"(word64 \\<Rightarrow> word64) \\<Rightarrow> cr3 \\<Rightarrow> cr3\"\nwhere\n  \"cr3BaseAddress_update f (X64CR3 v0 v1) = (X64CR3 (f v0) v1)\"\n\nprimrec cr3pcid_update :: \"(word64 \\<Rightarrow> word64) \\<Rightarrow> cr3 \\<Rightarrow> cr3\"\nwhere\n  \"cr3pcid_update f (X64CR3 v0 v1) = (X64CR3 v0 (f v1))\"\n\n\nend\nend", "property": "Platform Constants: Define and establish a set of constants and type synonyms for the platform, including physical address ranges, interrupt request (IRQ) limits, and control register (CR3) manipulation functions. These constants and functions ensure consistent and accurate handling of platform-specific details, facilitating proper memory and interrupt management.", "title": "./spec/machine/X64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming X64\n\nend\nend", "property": "Architectural Constraints: Define and enforce architectural-specific constraints on kernel configurations, ensuring that the system adheres to the requirements and limitations of the X64 platform.", "title": "./spec/machine/X64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified part of the machine state @{typ\n  machine_state_rest} and cannot fail. We could express the latter by type (leaving out the failure\n  flag), but if we later wanted to implement them, we'd have to set up a new Hoare logic framework\n  for that type. So instead, we provide a wrapper for these operations that explicitly ignores the\n  fail flag and sets it to False. Similarly, these operations never return an empty set of follow-on\n  states, which would require the operation to fail. So we explicitly make this (non-existing) case\n  a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming RISCV64", "property": "Machine Operations: Perform operations on the underspecified part of the machine state, ensuring that they do not fail and always return a non-empty set of follow-on states. These operations explicitly ignore the failure flag and set it to False, and handle the non-existing case as a null operation to avoid the need for additional axioms.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition loadWord :: \"machine_word \\<Rightarrow> machine_word machine_monad\"\n  where\n  \"loadWord p \\<equiv> do\n     m \\<leftarrow> gets underlying_memory;\n     assert (p && mask 3 = 0);\n     return (word_rcat (map (\\<lambda>i. m (p + (7 - of_int i))) [0 .. 7]))\n   od\"\n\ndefinition storeWord :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\n  where\n  \"storeWord p w \\<equiv> do\n     assert (p && mask 3 = 0);\n     modify (underlying_memory_update\n              (fold (\\<lambda>i m. m((p + (of_int i)) := word_rsplit w ! (7 - nat i))) [0 .. 7]))\n   od\"\n\nlemma upto0_7_def:\n  \"[0..7] = [0,1,2,3,4,5,6,7]\" by eval\n\nlemma loadWord_storeWord_is_return:\n  \"p && mask 3 = 0 \\<Longrightarrow> (do w \\<leftarrow> loadWord p; storeWord p w od) = return ()\"\n  by (auto simp: loadWord_def storeWord_def bind_def assert_def return_def word_rsplit_rcat_size\n                 modify_def gets_def get_def eval_nat_numeral put_def upto0_7_def word_size)\n\nconsts' memory_regions :: \"(paddr \\<times> paddr) list\"\ndefinition getMemoryRegions :: \"(paddr * paddr) list machine_monad\"\n  where\n  \"getMemoryRegions \\<equiv> return memory_regions\"", "property": "Memory Operations: Load and store 64-bit words in the machine's memory, ensuring that the memory addresses are properly aligned. Additionally, retrieve the list of memory regions defined in the system.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition storeWordVM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\n  where\n  \"storeWordVM w p \\<equiv> return ()\"", "property": "Store Word in Virtual Machine: This operation is a placeholder for storing a machine word at a specified address in the virtual machine, used exclusively in the simulator.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "This instruction is required in the simulator, only."}
{"spec": "consts' configureTimer_impl :: \"unit machine_rest_monad\"\nconsts' configureTimer_val :: \"machine_state \\<Rightarrow> irq\"\ndefinition configureTimer :: \"irq machine_monad\"\n  where\n  \"configureTimer \\<equiv> do\n     machine_op_lift configureTimer_impl;\n     gets configureTimer_val\n   od\"\n\nconsts' initTimer_impl :: \"unit machine_rest_monad\"\ndefinition initTimer :: \"unit machine_monad\"\n  where\n  \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts' resetTimer_impl :: \"unit machine_rest_monad\"\ndefinition resetTimer :: \"unit machine_monad\"\n  where\n  \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"", "property": "Timer Operations: Configure, initialize, and reset the timer. These operations allow for the management of the timer's state and behavior within the machine, ensuring proper timing and scheduling functionality.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\"\n  where\n  debugPrint_def[simp]:\n  \"debugPrint \\<equiv> \\<lambda>message. return ()\"", "property": "Debug Print: Outputs a debug message, which is currently a no-op that returns immediately without any side effects.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition\n  IRQ :: \"irq \\<Rightarrow> irq\"\nwhere \"IRQ \\<equiv> id\"\n\nconsts'\n  setIRQTrigger_impl :: \"irq \\<Rightarrow> bool \\<Rightarrow> unit machine_rest_monad\"\n\ndefinition\n  setIRQTrigger :: \"irq \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setIRQTrigger irq trigger \\<equiv> machine_op_lift (setIRQTrigger_impl irq trigger)\"\n\nconsts'\n  plic_complete_claim_impl :: \"irq \\<Rightarrow> unit machine_rest_monad\"\n\ndefinition\n  plic_complete_claim :: \"irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"plic_complete_claim irq \\<equiv> machine_op_lift (plic_complete_claim_impl irq)\"", "property": "Interrupt Controller Operations: Manage interrupt requests by setting the trigger mode for a specific interrupt and completing the claim for an interrupt. These operations ensure that interrupts are handled correctly and efficiently by the system.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition non_kernel_IRQs :: \"irq set\"\n  where\n  \"non_kernel_IRQs = {}\"", "property": "Non-Kernel Interrupts: Defines a set of interrupts that cannot occur while the kernel is running but can occur from user mode. In this case, the set is empty, indicating no such interrupts exist on the RISCV64 architecture.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Interrupts that cannot occur while the kernel is running (e.g. at preemption points), but\nthat can occur from user mode. Empty on RISCV64."}
{"spec": "definition getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\"\n  where\n  \"getActiveIRQ in_kernel \\<equiv> do\n     is_masked \\<leftarrow> gets $ irq_masks;\n     modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n     active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n     if is_masked active_irq \\<or> active_irq = 0xFF \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n     then return None\n     else return ((Some active_irq) :: irq option)\n   od\"\n\ndefinition maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\"\n  where\n  \"maskInterrupt m irq \\<equiv> modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"\n\ndefinition ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\"\n  where\n  \"ackInterrupt \\<equiv> \\<lambda>irq. return ()\"\n\ndefinition setInterruptMode :: \"irq \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\"\n  where\n  \"setInterruptMode \\<equiv> \\<lambda>irq levelTrigger polarityLow. return ()\"", "property": "Interrupt Handling:\n- Get Active IRQ: Retrieves the active interrupt request, updating the IRQ state and checking if the IRQ is masked, invalid, or not allowed in the current kernel state.\n- Mask Interrupt: Updates the mask status of a specific IRQ, allowing or disallowing its processing.\n- Acknowledge Interrupt: Acknowledges an interrupt, though it currently performs no action.\n- Set Interrupt Mode: Sets the trigger level and polarity for a specific IRQ, though it currently performs no action.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "@{term getActiveIRQ} is oracle-based and deterministic to allow information flow proofs. It\nupdates the IRQ state to the reflect the passage of time since last the IRQ, then it gets the active\nIRQ (if there is one)."}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory\\<close>\ndefinition clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemory ptr bytelength \\<equiv>\n     mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"", "property": "Clear Memory: Clear a specified range of memory by setting each word in the range to zero, preparing it for reuse as user memory.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Clear Memory: Clears a specified number of bits starting from a given memory address.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Haskell simulator interface stub."}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Clear and initialize memory to be used as user memory, ensuring it is properly prepared for use. This includes a call to cleanCacheRange to maintain consistency between the memory and the cache.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Initialize memory to be used as user memory. Note that zeroing out the memory is redundant\n  in the specifications. In any case, we cannot abstract from the call to cleanCacheRange, which\n  appears in the implementation.\n"}
{"spec": "definition freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"freeMemory ptr bits \\<equiv>\n   mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Clear Memory: Zero out the memory region specified by the pointer and size to ensure that it contains no garbage, allowing for a clean state in the specifications.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Free memory that had been initialized as user memory. While freeing memory is a no-op in the\n  implementation, we zero out the underlying memory in the specifications to avoid garbage. If we\n  know that there is no garbage, we can compute from the implementation state what the exact memory\n  content in the specifications is.\n"}
{"spec": "type_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\"\n  where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\"\n  where\n  \"modify_registers f uc \\<equiv> UserContext (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\"\n  where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext ((user_regs s) (r := v)))\"\n\ndefinition getRestartPC :: \"machine_word user_monad\"\n  where\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition setNextPC :: \"machine_word \\<Rightarrow> unit user_monad\"\n  where\n  \"setNextPC \\<equiv> setRegister NextIP\"", "property": "User-Level Register Operations: Allow manipulation of user-level registers, including getting and setting register values, modifying multiple registers, and managing the program counter for restart and next execution.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' initL2Cache_impl :: \"unit machine_rest_monad\"\ndefinition initL2Cache :: \"unit machine_monad\"\n  where\n  \"initL2Cache \\<equiv> machine_op_lift initL2Cache_impl\"\n\nconsts' hwASIDFlush_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition hwASIDFlush :: \"machine_word \\<Rightarrow> unit machine_monad\"\n  where\n  \"hwASIDFlush asid \\<equiv> machine_op_lift (hwASIDFlush_impl asid)\"\n\nconsts' sfence_impl :: \"unit machine_rest_monad\"\ndefinition sfence :: \"unit machine_monad\"\n  where\n  \"sfence \\<equiv> machine_op_lift sfence_impl\"\n\nlemmas cache_machine_op_defs = sfence_def hwASIDFlush_def", "property": "Cache and Barrier Operations: Initialize the L2 cache, flush the hardware ASID, and perform a store fence (sfence) to ensure memory ordering and coherence.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' stval_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition read_stval :: \"machine_word machine_monad\"\n  where\n  \"read_stval = gets stval_val\"", "property": "Read Fault Status Value: Retrieve the fault status value from the machine state.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' setVSpaceRoot_impl :: \"paddr \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition setVSpaceRoot :: \"paddr \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\n  where\n  \"setVSpaceRoot pt asid \\<equiv> machine_op_lift $ setVSpaceRoot_impl pt asid\"\n\nend\nend", "property": "Set Virtual Space Root: Configures the virtual memory space by setting the root page table and the associated address space identifier.", "title": "./spec/machine/RISCV64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Integer Representation: Defines the representation of integer literals and words in the system, using a 32-bit signed format.", "title": "./spec/machine/RISCV64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming RISCV64\n\nvalue_type irq_len = Kernel_Config.irqBits (* IRQ_CNODE_SLOT_BITS *)\ntype_synonym irq = \"irq_len word\"\ntype_synonym paddr = machine_word\n\nabbreviation (input) \"toPAddr \\<equiv> id\"\nabbreviation (input) \"fromPAddr \\<equiv> id\"", "property": "Platform Constants: Define the length of IRQ identifiers and establish type synonyms for IRQ and physical addresses, ensuring consistent and clear representation of these fundamental platform-specific values.", "title": "./spec/machine/RISCV64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "definition canonical_bit :: nat\n  where\n  \"canonical_bit = 38\"\n\ndefinition kdevBase :: machine_word\n  where\n  \"kdevBase = - (1 << 30)\" (* 2^64 - 1 GiB *)\n\nlemma \"kdevBase = 0xFFFFFFFFC0000000\" (* Sanity check with C *)\n  by (simp add: kdevBase_def)\n\ndefinition kernelELFPAddrBase :: machine_word\n  where\n  \"kernelELFPAddrBase = physBase + 0x4000000\"\n\ndefinition pptrTop :: machine_word\n  where\n  \"pptrTop \\<equiv> - (1 << 31)\"\n\ndefinition kernelELFBase :: machine_word\n  where\n  \"kernelELFBase = pptrTop + (kernelELFPAddrBase && mask 30)\" (* 2^64 - 2 GiB + ... *)\n\ndefinition kernelELFBaseOffset :: machine_word\n  where\n  \"kernelELFBaseOffset = kernelELFBase - kernelELFPAddrBase\"\n\ndefinition pptrBase :: machine_word\n  where\n  \"pptrBase = - (1 << canonical_bit)\"\n\nlemma \"pptrBase = 0xFFFFFFC000000000\" (* Sanity check with C *)\n  by (simp add: pptrBase_def canonical_bit_def)\n\ndefinition pptrUserTop :: machine_word\n  where\n  \"pptrUserTop \\<equiv> mask canonical_bit && ~~mask 12\" (* for page boundary alignment *)\n\nlemma \"pptrUserTop = 0x0000003ffffff000\" (* Sanity check with C *)\n  by (simp add: pptrUserTop_def canonical_bit_def mask_def)\n\nschematic_goal pptrUserTop_def': (* direct constant definition *)\n  \"RISCV64.pptrUserTop = numeral ?x\"\n  by (simp add: RISCV64.pptrUserTop_def canonical_bit_def mask_def del: word_eq_numeral_iff_iszero)\n\ndefinition paddrBase :: machine_word\n  where\n  \"paddrBase \\<equiv> 0\"\n\ndefinition pptrBaseOffset :: machine_word\n  where\n  \"pptrBaseOffset = pptrBase - paddrBase\"\n\ndefinition ptrFromPAddr :: \"paddr \\<Rightarrow> machine_word\"\n  where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBaseOffset\"\n\ndefinition addrFromPPtr :: \"machine_word \\<Rightarrow> paddr\"\n  where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBaseOffset\"\n\ndefinition addrFromKPPtr :: \"machine_word \\<Rightarrow> paddr\"\n  where\n  \"addrFromKPPtr pptr \\<equiv> pptr - kernelELFBaseOffset\"\n\ndefinition minIRQ :: \"irq\"\n  where\n  \"minIRQ \\<equiv> 0\"\n\ndefinition maxIRQ :: \"irq\"\n  where\n  \"maxIRQ \\<equiv> 54\"", "property": "Platform Constants Definition: Defines a set of constants for platform-specific memory addresses, offsets, and boundaries, ensuring consistent and accurate memory management and address translation. These constants include base addresses, top addresses, and offsets for kernel and user space, as well as interrupt request (IRQ) ranges, facilitating the alignment and mapping of physical and virtual addresses.", "title": "./spec/machine/RISCV64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": " NOTE: a number of these constants appear in the Haskell, but are shadowed\n   here due to more convenient formulation.\n   Examples: kernelELFBase, kernelELFBaseOffset, kernelELFAddressBase, pptrBase\n   Ideally and in future, we should converge on a single authoritative source\n   of these constants.\n"}
{"spec": "definition irqInvalid :: \"irq\"\n  where\n  \"irqInvalid \\<equiv> 0\"\n\ndefinition pageColourBits :: nat\n  where\n  \"pageColourBits \\<equiv> undefined\" \\<comment> \\<open>not implemented on this platform\\<close>\n\nend\nend", "property": "Reserved IRQ Value: Defines a constant `irqInvalid` with a value of 0 to represent an invalid or non-existent interrupt request. \n\nPage Coloring: Defines a constant `pageColourBits` which is currently undefined, indicating that page coloring is not implemented on this platform.", "title": "./spec/machine/RISCV64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": " Reserved by C to represent \"not an IRQ\" "}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming RISCV64\n\nlemma pptrBase_kernelELFBase:\n  \"pptrBase < kernelELFBase\"\n  by (simp add: pptrBase_def canonical_bit_def kernelELFBase_def kernelELFPAddrBase_def pptrTop_def\n                Kernel_Config.physBase_def mask_def)", "property": "Physical Pointer Base and Kernel ELF Base Relationship: The physical pointer base is less than the kernel ELF base, ensuring that the memory regions for physical pointers and the kernel ELF are properly separated.", "title": "./spec/machine/RISCV64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma is_page_aligned_physBase:\n  \"is_aligned physBase 12\"\n  by (simp add: Kernel_Config.physBase_def is_aligned_def)", "property": "Physical Base Alignment: The physical base address is aligned to a 12-bit boundary, ensuring proper memory alignment for the system.", "title": "./spec/machine/RISCV64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " 12 in this lemma and below is pageBits, which is not yet defined in this theory.\n   Definition will be folded and the lemmas shadowed in AInvs. "}
{"spec": "lemma kernel_window_sufficient:\n  \"pptrBase + (1 << 22) \\<le> kernelELFBase\"\n  unfolding pptrBase_def canonical_bit_def kernelELFBase_def kernelELFPAddrBase_def pptrTop_def\n  by (simp add: mask_def Kernel_Config.physBase_def)\n\nlemma kernel_elf_window_at_least_page:\n  \"kernelELFBase + 2 ^ 12 \\<le> kdevBase\"\n  unfolding kernelELFBase_def kernelELFPAddrBase_def kdevBase_def pptrTop_def\n  by (simp add: mask_def Kernel_Config.physBase_def)", "property": "Memory Window Sizing: Ensures that the kernel's memory window is sufficiently large, with the base address of the kernel ELF plus 2^22 being less than or equal to the kernel ELF base, and the kernel ELF base plus at least one page (2^12) being less than or equal to the device base. This guarantees that the kernel and its associated data fit within the allocated memory regions without overlap.", "title": "./spec/machine/RISCV64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " 22 is kernel_window_bits, defined in Init_A. To be folded in AInvs. "}
{"spec": "lemma kernelELFBase_no_overflow:\n  \"kernelELFBase < kernelELFBase + 2 ^ 12\"\n  unfolding kernelELFBase_def kernelELFPAddrBase_def pptrTop_def\n  by (simp add: mask_def Kernel_Config.physBase_def)\n\nend\nend", "property": "Kernel ELF Base Address: The base address of the kernel ELF is less than the base address plus 2^12, ensuring that the address space does not overflow.", "title": "./spec/machine/RISCV64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " This doesn't follow from alignment, because we need <, not \\<le> "}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified part of the machine state @{typ\n  machine_state_rest} and cannot fail. We could express the latter by type (leaving out the failure\n  flag), but if we later wanted to implement them, we'd have to set up a new Hoare logic framework\n  for that type. So instead, we provide a wrapper for these operations that explicitly ignores the\n  fail flag and sets it to False. Similarly, these operations never return an empty set of follow-on\n  states, which would require the operation to fail. So we explicitly make this (non-existing) case\n  a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\\<close>\n\ncontext Arch begin global_naming AARCH64", "property": "Machine Operations: Perform operations on the underspecified part of the machine state, ensuring that they do not fail and always return a non-empty set of follow-on states. These operations are designed to avoid the need for additional axioms by explicitly setting the failure flag to False and handling the non-existing case as a null operation.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition loadWord :: \"machine_word \\<Rightarrow> machine_word machine_monad\" where\n  \"loadWord p \\<equiv> do\n     m \\<leftarrow> gets underlying_memory;\n     assert (p && mask 3 = 0);\n     return (word_rcat (map (\\<lambda>i. m (p + (7 - of_int i))) [0 .. 7]))\n   od\"\n\ndefinition storeWord :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"storeWord p w \\<equiv> do\n     assert (p && mask 3 = 0);\n     modify (underlying_memory_update\n              (fold (\\<lambda>i m. m((p + (of_int i)) := word_rsplit w ! (7 - nat i))) [0 .. 7]))\n   od\"\n\nlemma upto0_7_def:\n  \"[0..7] = [0,1,2,3,4,5,6,7]\" by eval\n\nlemma loadWord_storeWord_is_return:\n  \"p && mask 3 = 0 \\<Longrightarrow> (do w \\<leftarrow> loadWord p; storeWord p w od) = return ()\"\n  by (auto simp: loadWord_def storeWord_def bind_def assert_def return_def word_rsplit_rcat_size\n                 modify_def gets_def get_def eval_nat_numeral put_def upto0_7_def word_size)\n\nconsts' memory_regions :: \"(paddr \\<times> paddr) list\"\ndefinition getMemoryRegions :: \"(paddr * paddr) list machine_monad\" where\n  \"getMemoryRegions \\<equiv> return memory_regions\"", "property": "Memory Operations: Enable the loading and storing of machine words in memory, ensuring that the memory addresses are properly aligned. Additionally, provide a mechanism to retrieve the defined memory regions.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition storeWordVM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"storeWordVM w p \\<equiv> return ()\"", "property": "Store Word in Virtual Machine: The operation is defined to store a machine word at a specified address in the virtual machine, but it is currently a no-op and does nothing.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "This instruction is required in the simulator, only."}
{"spec": "consts' configureTimer_impl :: \"unit machine_rest_monad\"\nconsts' configureTimer_val :: \"machine_state \\<Rightarrow> irq\"\ndefinition configureTimer :: \"irq machine_monad\" where\n  \"configureTimer \\<equiv> do\n     machine_op_lift configureTimer_impl;\n     gets configureTimer_val\n   od\"\n\nconsts' initTimer_impl :: \"unit machine_rest_monad\"\ndefinition initTimer :: \"unit machine_monad\" where\n  \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts' resetTimer_impl :: \"unit machine_rest_monad\"\ndefinition resetTimer :: \"unit machine_monad\" where\n  \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"", "property": "Timer Operations: Configure, initialize, and reset the timer. These operations allow for the setup, initialization, and resetting of the timer, ensuring that the system can manage time-based events and interrupts effectively.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\" where\n  debugPrint_def[simp]:\n  \"debugPrint \\<equiv> \\<lambda>message. return ()\"", "property": "Debug Print: Outputs a debug message, which is defined to have no effect in the machine monad.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition IRQ :: \"irq \\<Rightarrow> irq\" where\n  \"IRQ \\<equiv> id\"\n\nconsts' setIRQTrigger_impl :: \"irq \\<Rightarrow> bool \\<Rightarrow> unit machine_rest_monad\"\ndefinition setIRQTrigger :: \"irq \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\" where\n  \"setIRQTrigger irq trigger \\<equiv> machine_op_lift (setIRQTrigger_impl irq trigger)\"\n\nconsts' plic_complete_claim_impl :: \"irq \\<Rightarrow> unit machine_rest_monad\"\ndefinition plic_complete_claim :: \"irq \\<Rightarrow> unit machine_monad\" where\n  \"plic_complete_claim irq \\<equiv> machine_op_lift (plic_complete_claim_impl irq)\"", "property": "Interrupt Controller Operations: Manage interrupt requests by setting the trigger mode for a specific interrupt and completing the claim for an interrupt. These operations ensure that interrupts are handled correctly and efficiently, maintaining the system's responsiveness and reliability.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition non_kernel_IRQs :: \"irq set\" where\n  \"non_kernel_IRQs = {irqVGICMaintenance, irqVTimerEvent}\"", "property": "Non-Kernel Interrupts: Defines a set of interrupts that can occur in user mode but not while the kernel is running, specifically including maintenance and timer event interrupts.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Interrupts that cannot occur while the kernel is running (e.g. at preemption points),\n  but that can occur from user mode."}
{"spec": "definition getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\" where\n  \"getActiveIRQ in_kernel \\<equiv> do\n     is_masked \\<leftarrow> gets $ irq_masks;\n     modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n     active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n     if is_masked active_irq \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n     then return None\n     else return (Some active_irq)\n   od\"\n\ndefinition maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\" where\n  \"maskInterrupt m irq \\<equiv> modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"\n\ndefinition ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\" where\n  \"ackInterrupt \\<equiv> \\<lambda>irq. return ()\"\n\ndefinition setInterruptMode :: \"irq \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> unit machine_monad\" where\n  \"setInterruptMode \\<equiv> \\<lambda>irq levelTrigger polarityLow. return ()\"", "property": "Interrupt Handling:\n- Get Active IRQ: Determines the active interrupt request (IRQ) by updating the IRQ state and checking if the IRQ is masked or if it is a non-kernel IRQ while in kernel mode. If the IRQ is valid, it returns the active IRQ; otherwise, it returns None.\n- Mask Interrupt: Updates the masking status of a specific IRQ, allowing or preventing its processing.\n- Acknowledge Interrupt: Acknowledges an interrupt, indicating that it has been processed.\n- Set Interrupt Mode: Configures the triggering mode and polarity for a specific IRQ.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "@{term getActiveIRQ} is oracle-based and deterministic to allow information flow proofs. It\nupdates the IRQ state to the reflect the passage of time since last the IRQ, then it gets the active\nIRQ (if there is one)."}
{"spec": "type_synonym user_regs = \"register \\<Rightarrow> machine_word\"", "property": "User-Level Register Management: Provides a type alias for a function that maps registers to machine words, enabling the manipulation and access of user-level registers within the system.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "type_synonym fpu_regs = 64", "property": "FPU Register Management: The system manages 64 general FPU registers, ensuring that floating-point operations are supported and state is maintained effectively.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " There are 64 general FPU registers saved. "}
{"spec": "datatype fpu_state = FPUState (fpuRegs : \"fpu_regs \\<Rightarrow> 64 word\")\n                              (fpuSr : \"32 word\")\n                              (fpuCr : \"32 word\")\n\ndatatype user_context = UserContext (fpu_state : fpu_state) (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\" where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\" where\n  \"modify_registers f uc \\<equiv> UserContext (fpu_state uc) (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\" where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext (fpu_state s) ((user_regs s) (r := v)))\"\n\ndefinition getRestartPC :: \"machine_word user_monad\" where\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition setNextPC :: \"machine_word \\<Rightarrow> unit user_monad\" where\n  \"setNextPC \\<equiv> setRegister NextIP\"", "property": "User Monad and Register Operations: Provides functions to get and set the values of user registers, including the ability to modify multiple registers at once and to specifically handle the program counter for restart and next instructions.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  We use Haskell naming convention here, as we translate the Haskell FPUState directly\n  to this one for use in the abstract and executable specs."}
{"spec": "consts' enableFpuEL01_impl :: \"unit machine_rest_monad\"\ndefinition enableFpuEL01 :: \"unit machine_monad\" where\n  \"enableFpuEL01 \\<equiv> machine_op_lift enableFpuEL01_impl\"\n\ndefinition getFPUState :: \"fpu_state user_monad\" where\n  \"getFPUState \\<equiv> gets fpu_state\"\n\ndefinition setFPUState :: \"fpu_state \\<Rightarrow> unit user_monad\" where\n  \"setFPUState fc \\<equiv> modify (\\<lambda>s. UserContext fc (user_regs s))\"\n\nconsts' nativeThreadUsingFPU_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\nconsts' nativeThreadUsingFPU_val :: \"machine_state \\<Rightarrow> bool\"\ndefinition nativeThreadUsingFPU :: \"machine_word \\<Rightarrow> bool machine_monad\" where\n  \"nativeThreadUsingFPU thread_ptr \\<equiv> do\n       machine_op_lift (nativeThreadUsingFPU_impl thread_ptr);\n       gets nativeThreadUsingFPU_val\n  od\"\n\nconsts' switchFpuOwner_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition switchFpuOwner :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"switchFpuOwner new_owner cpu \\<equiv> machine_op_lift (switchFpuOwner_impl new_owner cpu)\"\n\n\nconsts' fpuThreadDeleteOp_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition fpuThreadDeleteOp :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"fpuThreadDeleteOp thread_ptr \\<equiv> machine_op_lift (fpuThreadDeleteOp_impl thread_ptr)\"\n\n\ndefinition isFpuEnable :: \"bool machine_monad\" where\n  \"isFpuEnable \\<equiv> return True\"", "property": "FPU Management: Enables, retrieves, and sets the FPU state, checks if a native thread is using the FPU, switches the FPU owner, and performs cleanup operations for FPU-related resources.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' FAR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getFAR :: \"machine_word machine_monad\" where\n  \"getFAR \\<equiv> gets FAR_val\"\n\nconsts' DFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getDFSR :: \"machine_word machine_monad\" where\n  \"getDFSR \\<equiv> gets DFSR_val\"\n\nconsts' IFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getIFSR :: \"machine_word machine_monad\" where\n  \"getIFSR \\<equiv> gets IFSR_val\"", "property": "Fault Register Access: Retrieve the values of fault-related registers (FAR, DFSR, IFSR) from the machine state.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' HSR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getHSR :: \"machine_word machine_monad\" where\n  \"getHSR \\<equiv> gets HSR_val\"\n\nconsts' ESR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getESR :: \"machine_word machine_monad\" where\n  \"getESR \\<equiv> gets ESR_val\"\n\nconsts' SCTLR_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition getSCTLR :: \"machine_word machine_monad\" where\n  \"getSCTLR \\<equiv> gets SCTLR_val\"\n\nconsts' setHCR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition setHCR :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"setHCR w \\<equiv> machine_op_lift (setHCR_impl w)\"\n\nconsts' setSCTLR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition setSCTLR :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"setSCTLR w \\<equiv> machine_op_lift (setSCTLR_impl w)\"\n\nconsts' addressTranslateS1_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\nconsts' addressTranslateS1_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition addressTranslateS1 :: \"machine_word \\<Rightarrow> machine_word machine_monad\" where\n  \"addressTranslateS1 w \\<equiv> do\n    machine_op_lift (addressTranslateS1_impl w);\n    gets (addressTranslateS1_val w)\n  od\"", "property": "Control Register Operations: Provide mechanisms to get and set the values of hardware control registers such as HSR, ESR, and SCTLR. Additionally, support address translation for stage 1, allowing the retrieval of translated addresses.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' gic_vcpu_ctrl_hcr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_hcr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_hcr \\<equiv> gets gic_vcpu_ctrl_hcr_val\"\n\nconsts' set_gic_vcpu_ctrl_hcr_impl :: \"32 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_hcr :: \"32 word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_hcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_hcr_impl w)\"\n\nconsts' gic_vcpu_ctrl_vmcr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_vmcr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_vmcr \\<equiv> gets gic_vcpu_ctrl_vmcr_val\"\n\nconsts' set_gic_vcpu_ctrl_vmcr_impl :: \"32 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_vmcr :: \"32 word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_vmcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vmcr_impl w)\"\n\nconsts' gic_vcpu_ctrl_apr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_apr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_apr \\<equiv> gets gic_vcpu_ctrl_apr_val\"\n\nconsts' set_gic_vcpu_ctrl_apr_impl :: \"32 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_apr :: \"32 word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_apr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_apr_impl w)\"\n\nconsts' gic_vcpu_ctrl_vtr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_vtr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_vtr \\<equiv> gets gic_vcpu_ctrl_vtr_val\"\n\nconsts' set_gic_vcpu_ctrl_vtr_impl :: \"32 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_vtr :: \"32 word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_vtr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vtr_impl w)\"\n\nconsts' gic_vcpu_ctrl_misr_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_misr :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_misr \\<equiv> gets gic_vcpu_ctrl_misr_val\"\n\nconsts' gic_vcpu_ctrl_eisr0_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_eisr0 :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_eisr0 \\<equiv> gets gic_vcpu_ctrl_eisr0_val\"\n\nconsts' gic_vcpu_ctrl_eisr1_val :: \"machine_state \\<Rightarrow> 32 word\"\ndefinition get_gic_vcpu_ctrl_eisr1 :: \"32 word machine_monad\" where\n  \"get_gic_vcpu_ctrl_eisr1 \\<equiv> gets gic_vcpu_ctrl_eisr1_val\"\n\nconsts' get_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\nconsts' gic_vcpu_ctrl_lr_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition get_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word machine_monad\" where\n  \"get_gic_vcpu_ctrl_lr n \\<equiv> do\n     machine_op_lift (get_gic_vcpu_ctrl_lr_impl n);\n     gets (gic_vcpu_ctrl_lr_val n)\n   od\"\n\nconsts' set_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition set_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"set_gic_vcpu_ctrl_lr n w  \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_lr_impl n w)\"", "property": "GIC vCPU Control Interface: Provides operations to get and set various control registers (HCR, VMCR, APR, VTR, MISR, EISR0, EISR1, and LR) for the GIC vCPU interface. These operations allow for the manipulation and retrieval of 32-bit values from the machine state, enabling precise control over the virtual CPU's interrupt handling and configuration.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' check_export_arch_timer_impl :: \"unit machine_rest_monad\"\ndefinition check_export_arch_timer :: \"unit machine_monad\" where\n  \"check_export_arch_timer \\<equiv> machine_op_lift check_export_arch_timer_impl\"\n\nconsts' read_cntpct_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition read_cntpct :: \"64 word machine_monad\" where\n  \"read_cntpct \\<equiv> gets read_cntpct_val\"", "property": "Virtual Timer Interface: Provides operations to check the export of architectural timer and read the value of the virtual timer counter.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' vcpuHardwareReg_val :: \"vcpureg \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition readVCPUHardwareReg :: \"vcpureg \\<Rightarrow> machine_word machine_monad\" where\n  \"readVCPUHardwareReg reg \\<equiv> gets (vcpuHardwareReg_val reg)\"\n\nconsts' writeVCPUHardwareReg_impl :: \"vcpureg \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition writeVCPUHardwareReg :: \"vcpureg \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"writeVCPUHardwareReg reg val \\<equiv> machine_op_lift (writeVCPUHardwareReg_impl reg val)\"", "property": "Hypervisor Banked Registers Access: Provides mechanisms to read and write the values of VCPU hardware registers. The `readVCPUHardwareReg` function retrieves the value of a specified VCPU register, while the `writeVCPUHardwareReg` function updates the value of a specified VCPU register.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts' initL2Cache_impl :: \"unit machine_rest_monad\"\ndefinition initL2Cache :: \"unit machine_monad\" where\n  \"initL2Cache \\<equiv> machine_op_lift initL2Cache_impl\"\n\nconsts' isb_impl :: \"unit machine_rest_monad\"\ndefinition isb :: \"unit machine_monad\" where\n  \"isb \\<equiv> machine_op_lift isb_impl\"\n\nconsts' dsb_impl :: \"unit machine_rest_monad\"\ndefinition dsb :: \"unit machine_monad\" where\n  \"dsb \\<equiv> machine_op_lift dsb_impl\"\n\nconsts' invalidateTranslationASID_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateTranslationASID :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateTranslationASID asid \\<equiv> machine_op_lift (invalidateTranslationASID_impl asid)\"\n\nconsts' invalidateTranslationSingle_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateTranslationSingle :: \"machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateTranslationSingle r \\<equiv> machine_op_lift (invalidateTranslationSingle_impl r)\"\n\nconsts' cleanByVA_PoU_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanByVA_PoU :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanByVA_PoU vaddr paddr = machine_op_lift (cleanByVA_PoU_impl vaddr paddr)\"\n\nconsts' cleanInvalidateCacheRange_RAM_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanInvalidateCacheRange_RAM ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanInvalidateCacheRange_RAM vstart vend pstart =\n     machine_op_lift (cleanInvalidateCacheRange_RAM_impl vstart vend pstart)\"\n\nconsts' cleanCacheRange_RAM_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanCacheRange_RAM ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanCacheRange_RAM vstart vend pstart =\n     machine_op_lift (cleanCacheRange_RAM_impl vstart vend pstart)\"\n\nconsts' cleanCacheRange_PoU_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition cleanCacheRange_PoU ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"cleanCacheRange_PoU vstart vend pstart =\n     machine_op_lift (cleanCacheRange_PoU_impl vstart vend pstart)\"\n\nconsts' invalidateCacheRange_RAM_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateCacheRange_RAM ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateCacheRange_RAM vstart vend pstart =\n     machine_op_lift (invalidateCacheRange_RAM_impl vstart vend pstart)\"\n\nconsts' invalidateCacheRange_I_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition invalidateCacheRange_I ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"invalidateCacheRange_I vstart vend pstart =\n     machine_op_lift (invalidateCacheRange_I_impl vstart vend pstart)\"\n\nconsts' branchFlushRange_impl ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition branchFlushRange ::\n  \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"branchFlushRange vstart vend pstart = machine_op_lift (branchFlushRange_impl vstart vend pstart)\"\n\nlemmas cache_machine_op_defs =\n  invalidateTranslationASID_def\n  invalidateTranslationSingle_def\n  cleanByVA_PoU_def\n  cleanInvalidateCacheRange_RAM_def\n  cleanCacheRange_RAM_def\n  cleanCacheRange_PoU_def\n  invalidateCacheRange_RAM_def\n  invalidateCacheRange_I_def\n  branchFlushRange_def", "property": "Cache and Barrier Operations: Provide mechanisms to initialize the L2 cache, perform instruction and data synchronization barriers, and manage cache coherence through various operations such as invalidating translations, cleaning, and invalidating cache ranges. These operations ensure that the memory and cache states are consistent and synchronized, maintaining the integrity and performance of the system.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory. Do not yet flush the cache.\\<close>\ndefinition clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\" where\n  \"clearMemory ptr bytelength \\<equiv>\n     mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"", "property": "Clear Memory: Clear a specified range of memory by setting each word in the range to zero, preparing it for reuse as user memory without flushing the cache.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "definition clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\" where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Clear Memory: Clears a specified number of bits starting from a given memory address.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "Haskell simulator interface stub."}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Clear and initialize memory to be used as user memory, ensuring it is properly prepared for subsequent operations.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Initialize memory to be used as user memory. Note that zeroing out the memory is redundant\n  in the specifications. In any case, we cannot abstract from the call to cleanCacheRange, which\n  appears in the implementation."}
{"spec": "definition freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\" where\n  \"freeMemory ptr bits \\<equiv>\n     mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Clear Memory: Zero out the memory region specified by the pointer and size to avoid garbage, ensuring that the memory content is predictable and consistent in the specifications.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Free memory that had been initialized as user memory. While freeing memory is a no-op in the\n  implementation, we zero out the underlying memory in the specifications to avoid garbage. If we\n  know that there is no garbage, we can compute from the implementation state what the exact memory\n  content in the specifications is."}
{"spec": "consts' setVSpaceRoot_impl :: \"paddr \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition setVSpaceRoot :: \"paddr \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\" where\n  \"setVSpaceRoot pt asid \\<equiv> machine_op_lift $ setVSpaceRoot_impl pt asid\"\n\nend\nend", "property": "Set Virtual Space Root: Configures the virtual memory space by setting the root page table and associated address space identifier.", "title": "./spec/machine/AARCH64/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Integer Literal Representation: Defines the representation of C integer literals as 32-bit signed integers, providing a standardized format for integer values in the system.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming AARCH64\n\nvalue_type irq_len = Kernel_Config.irqBits \n\n\n\ndefinition paddrBase :: machine_word where\n  \"paddrBase \\<equiv> 0\"\n\ndefinition pptrBaseOffset :: machine_word where\n  \"pptrBaseOffset = pptrBase - paddrBase\"\n\ndefinition paddrTop :: machine_word where\n  \"paddrTop = pptrTop - pptrBaseOffset\"\n\ndefinition ptrFromPAddr :: \"paddr \\<Rightarrow> machine_word\" where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBaseOffset\"\n\ndefinition addrFromPPtr :: \"machine_word \\<Rightarrow> paddr\" where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBaseOffset\"\n\ndefinition addrFromKPPtr :: \"machine_word \\<Rightarrow> paddr\" where\n  \"addrFromKPPtr pptr \\<equiv> pptr - kernelELFBaseOffset\"\n\ndefinition minIRQ :: \"irq\" where\n  \"minIRQ \\<equiv> 0\"\n\ndefinition irqVGICMaintenance :: irq where\n  \"irqVGICMaintenance \\<equiv> 25\"\n\ndefinition irqVTimerEvent :: irq where\n  \"irqVTimerEvent \\<equiv> 27\"\n\ndefinition pageColourBits :: nat where\n  \"pageColourBits \\<equiv> undefined\" \\<comment> \\<open>not implemented on this platform\\<close>", "property": "Platform Constants: Define and initialize various platform-specific constants, including base addresses, offsets, top addresses, and interrupt request (IRQ) values. These constants are used to manage memory addresses and IRQs, ensuring consistent and predictable behavior across the system.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "definition vs_index_bits :: nat where\n  \"vs_index_bits \\<equiv> if config_ARM_PA_SIZE_BITS_40 then 10 else (9::nat)\"\n\nend", "property": "Page Table Sizes: The number of bits used for the virtual space index in the page table is determined by the configuration, specifically whether the physical address size is 40 bits, in which case 10 bits are used, or 9 bits otherwise.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Page table sizes", "comment": ""}
{"spec": "declare AARCH64.vs_index_bits_def[code]\n\ncontext Arch begin global_naming AARCH64\n\nlemma vs_index_bits_ge0[simp, intro!]: \"0 < vs_index_bits\"\n  by (simp add: vs_index_bits_def)", "property": "Virtual Space Index Bits: The number of bits used for the virtual space index is greater than zero, ensuring a valid and non-zero size for page table entries.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Page table sizes", "comment": " Need to declare code equation outside Arch locale "}
{"spec": "typedef vs_index_len = \"{n :: nat. n < vs_index_bits}\" by auto\n\nend\n\ninstantiation AARCH64.vs_index_len :: len0\nbegin\n  interpretation Arch .\n  definition len_of_vs_index_len: \"len_of (x::vs_index_len itself) \\<equiv> CARD(vs_index_len)\"\n  instance ..\nend\n\ninstantiation AARCH64.vs_index_len :: len\nbegin\n  interpretation Arch .\n  instance\n  proof\n   show \"0 < LENGTH(vs_index_len)\"\n     by (simp add: len_of_vs_index_len type_definition.card[OF type_definition_vs_index_len])\n  qed\nend\n\ncontext Arch begin global_naming AARCH64\n\ntype_synonym vs_index = \"vs_index_len word\"\n\ntype_synonym pt_index_len = 9\ntype_synonym pt_index = \"pt_index_len word\"", "property": "Page Table Index Sizes: Define the size of virtual space index and page table index types, ensuring that the virtual space index length is less than a symbolic value (vs_index_bits) and the page table index length is fixed at 9 bits. This allows for flexible and precise management of memory addressing and page table structures.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Page table sizes", "comment": " A dependent-ish type in Isabelle. We use typedef here instead of value_type so that we can\n   retain a symbolic value (vs_index_bits) for the size of the type instead of getting a plain\n   number such as 9 or 10. "}
{"spec": "lemma length_vs_index_len[simp]:\n  \"LENGTH(vs_index_len) = vs_index_bits\"\n  by (simp add: len_of_vs_index_len type_definition.card[OF type_definition_vs_index_len])", "property": "Length of vs_index_len: The length of the `vs_index_len` is equal to the number of bits in `vs_index_bits`, ensuring consistency and correctness in the page table size definitions.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "Page table sizes", "comment": "Sanity check:"}
{"spec": "value_type pt_array_len = \"(2::nat) ^ LENGTH(pt_index_len)\"\nvalue_type vs_array_len = \"(2::nat) ^ vs_index_bits\"\n\nend\n\nend", "property": "Page Table Array Sizes: Define the sizes of C arrays for page tables and virtual space, where `pt_array_len` is calculated as 2 raised to the power of `LENGTH(pt_index_len)`, and `vs_array_len` is calculated as 2 raised to the power of `vs_index_bits`.", "title": "./spec/machine/AARCH64/Platform.thy", "chapter": "Platform Definitions", "section": "C array sizes corresponding to page table sizes", "comment": ""}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming AARCH64", "property": "Architectural Constraints: Define and enforce constraints specific to the AARCH64 architecture, ensuring that the kernel configuration adheres to the architectural requirements and limitations.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma irqVTimerEvent_le_maxIRQ[simp, intro!]:\n  \"irqVTimerEvent \\<le> maxIRQ\"\n  by (simp add: irqVTimerEvent_def Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_less_2p_irqBits:\n  \"(maxIRQ::nat) < 2^irqBits\"\n  by (simp add: Kernel_Config.maxIRQ_def Kernel_Config.irqBits_def)", "property": "Max IRQ Constraints: The maximum interrupt request (IRQ) number is less than \\(2^{irqBits}\\), and the virtual timer event IRQ is less than or equal to the maximum IRQ.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ conditions "}
{"spec": "lemma LENGTH_irq_len_irqBits[simp]: (* [simp] will fire only for simp del: len_of_numeral_defs *)\n  \"LENGTH(irq_len) = irqBits\"\n  using irq_len_def irq_len_val\n  by simp\n\nlemma maxIRQ_less_2p_irq_len:\n  \"(maxIRQ::nat) < 2^LENGTH(irq_len)\"\n  using maxIRQ_less_2p_irqBits\n  by (simp del: len_of_numeral_defs)", "property": "IRQ Length and Maximum IRQ Value: The length of the IRQ representation is defined by `irqBits`, and the maximum IRQ value is less than \\(2^{irqBits}\\).", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " follows from value_type definition of irq_len "}
{"spec": "lemma of_nat_maxIRQ[simp]:\n  \"of_nat maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma of_int_maxIRQ[simp]:\n  \"of_int maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "MaxIRQ Representation: The maximum interrupt request (maxIRQ) is represented as a generic numeral, allowing for rules about type casts, unat, and uint operations without explicitly mentioning specific numbers.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ as a generic numeral allows us to write rules about casts/unat/uint etc without\n   mentioning numbers: "}
{"spec": "lemma unat_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> unat (maxIRQ::'a word) = maxIRQ\"\n  by (metis maxIRQ_less_2p_irq_len Word.of_nat_unat of_nat_inverse of_nat_maxIRQ unat_ucast_up_simp)", "property": "Unat Conversion for maxIRQ: Ensures that the conversion of `maxIRQ` to its natural number representation using `unat` is safe and maintains the value, provided that the length of `irq_len` is less than or equal to the length of the word type.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma uint_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> uint (maxIRQ::'a word) = maxIRQ\"\n  by (metis Kernel_Config.maxIRQ_def of_nat_numeral uint_nat unat_maxIRQ)", "property": "Uint Conversion for maxIRQ: Ensures that the conversion of the maximum interrupt request (maxIRQ) to an unsigned integer is safe and retains its value, provided the length of the interrupt request does not exceed the word length.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma ucast_maxIRQ[simp]:\n  \"\\<lbrakk> LENGTH(irq_len) \\<le> LENGTH('a::len); LENGTH(irq_len) \\<le> LENGTH('b::len) \\<rbrakk> \\<Longrightarrow>\n   UCAST ('a \\<rightarrow> 'b) maxIRQ = maxIRQ\"\n  by (metis of_nat_maxIRQ ucast_nat_def unat_maxIRQ)", "property": "Property: Ucast Preservation of maxIRQ: The value of `maxIRQ` is preserved when cast between types of equal or greater length, ensuring that the maximum interrupt request number remains consistent across different type representations.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma maxIRQ_less_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   (maxIRQ < (ucast irq :: 'a word)) = (maxIRQ < irq)\" for irq::irq\n  by (simp add: word_less_nat_alt unat_ucast_up_simp)", "property": "Property: Maximum IRQ Comparison: Ensures that the comparison between the maximum IRQ and an upcasted IRQ value remains consistent, provided the target word length is not less than the source IRQ length. This property guarantees the safety and correctness of IRQ comparisons across different word sizes.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma maxIRQ_le_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   ((ucast irq :: 'a word) \\<le> Kernel_Config.maxIRQ) = (irq \\<le> Kernel_Config.maxIRQ)\" for irq::irq\n  by (simp add: word_le_nat_alt unat_ucast_up_simp)", "property": "Property: \nMax IRQ Value Preservation: Ensures that the upcast of an IRQ value to a larger word size does not exceed the maximum IRQ value, maintaining the integrity of the IRQ range.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma le_maxIRQ_machine_less_irqBits_val[simplified]:\n  \"w \\<le> maxIRQ \\<Longrightarrow> unat w < 2^LENGTH(irq_len)\" for w::machine_word\n  using maxIRQ_less_2p_irq_len\n  by (simp add: word_le_nat_alt)\n\nlemma irq_machine_le_maxIRQ_irq:\n  \"irq \\<le> Kernel_Config.maxIRQ \\<Longrightarrow> (ucast irq::irq) \\<le> maxIRQ\" for irq::machine_word\n  by (simp add: Kernel_Config.maxIRQ_def word_le_nat_alt unat_ucast)\n\nlemma maxIRQ_eq_ucast_irq_32_signed_uint:\n  \"(maxIRQ = (ucast b :: 32 signed word)) = (uint b = maxIRQ)\" for b::irq\n  unfolding Kernel_Config.maxIRQ_def\n  apply uint_arith\n  apply (simp add: uint_up_ucast is_up)\n  done\n\nlemma sint_maxIRQ_32[simp]:\n  \"sint (maxIRQ :: 32 signed word) = maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_machine[simp]:\n  \"scast (maxIRQ::32 signed word) = (maxIRQ::machine_word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_irq[simp]:\n  \"scast (maxIRQ :: 32 signed word) = (maxIRQ::irq)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_machine:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = x\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_irq:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = (ucast x :: irq)\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_1_plus_eq_Suc_machine[simp]:\n  \"unat (1 + Kernel_Config.maxIRQ :: machine_word) = Suc Kernel_Config.maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "Max IRQ Value Properties: The maximum IRQ value (`maxIRQ`) is constrained and related to the bit length of the IRQ, ensuring that any word less than or equal to `maxIRQ` has a natural number representation less than \\(2^{LENGTH(irq\\_len)}\\). Additionally, the `maxIRQ` value can be cast and manipulated between different word types (signed, unsigned, and machine words) while preserving its value and properties.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " The following are instances -- for some we could derive general rules, but the number of\n   instances is limited and the concrete proofs are much simpler: "}
{"spec": "lemma cacheLineBits_sanity:\n  \"cacheLineBits \\<in> {2..12}\"\n  by (simp add: cacheLineBits_def Kernel_Config.CONFIG_L1_CACHE_LINE_SIZE_BITS_def)\n\nend\nend", "property": "Cache Line Bits Sanity: The value of `cacheLineBits` must be within the range of 2 to 12, ensuring it is suitable for use in cache operations without conflicting with other values.", "title": "./spec/machine/AARCH64/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Folding cacheLineBits_val in C functions only works reliably if cacheLineBits is not 1 and\n   not too large to conflict with other values used inside cache ops.\n   12 is ptBits, which is only available after ExecSpec. Anything > 1 and smaller than ptBits\n   works. "}
{"spec": "text \\<open>\n  Most of the machine operations below work on the underspecified\n  part of the machine state @{typ machine_state_rest} and cannot fail.\n  We could express the latter by type (leaving out the failure flag),\n  but if we later wanted to implement them,\n  we'd have to set up a new hoare-logic\n  framework for that type. So instead, we provide a wrapper for these\n  operations that explicitly ignores the fail flag and sets it to\n  False. Similarly, these operations never return an empty set of\n  follow-on states, which would require the operation to fail.\n  So we explicitly make this (non-existing) case a null operation.\n\n  All this is done only to avoid a large number of axioms (2 for each operation).\n\\<close>\n\ncontext Arch begin global_naming ARM_HYP", "property": "Machine Operations: Perform operations on the underspecified part of the machine state, ensuring that they do not fail and always return a non-empty set of follow-on states. These operations are wrapped to explicitly ignore the failure flag and set it to False, maintaining consistency and predictability in the system's behavior.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  memory_regions :: \"(paddr \\<times> paddr) list\" \n  initTimer_impl :: \"unit machine_rest_monad\"\ndefinition\n  initTimer :: \"unit machine_monad\"\nwhere \"initTimer \\<equiv> machine_op_lift initTimer_impl\"\n\nconsts'\n  resetTimer_impl :: \"unit machine_rest_monad\"\n\ndefinition\n  resetTimer :: \"unit machine_monad\"\nwhere \"resetTimer \\<equiv> machine_op_lift resetTimer_impl\"\n\nconsts'\n  writeTTBR0_impl :: \"paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  writeTTBR0 :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere \"writeTTBR0 pd \\<equiv> machine_op_lift (writeTTBR0_impl pd)\"\n\n\nconsts'\n  setHardwareASID_impl :: \"hardware_asid \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setHardwareASID:: \"hardware_asid \\<Rightarrow> unit machine_monad\"\nwhere \"setHardwareASID a \\<equiv> machine_op_lift (setHardwareASID_impl a)\"", "property": "Machine Operations: Provide a set of machine-level operations, including initializing and resetting the timer, writing to the Translation Table Base Register 0 (TTBR0), and setting the hardware ASID. These operations are lifted to the machine monad for execution in the machine context, ensuring that they interact correctly with the underlying hardware.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": ""}
{"spec": "consts'\n  isb_impl :: \"unit machine_rest_monad\"\ndefinition\n  isb :: \"unit machine_monad\"\nwhere \"isb \\<equiv> machine_op_lift isb_impl\"\n\nconsts'\n  dsb_impl :: \"unit machine_rest_monad\"\ndefinition\n  dsb :: \"unit machine_monad\"\nwhere \"dsb \\<equiv> machine_op_lift dsb_impl\"\n\nconsts'\n  dmb_impl :: \"unit machine_rest_monad\"\ndefinition\n  dmb :: \"unit machine_monad\"\nwhere \"dmb \\<equiv> machine_op_lift dmb_impl\"\n\nconsts'\n  setCurrentPDPL2_impl :: \"paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setCurrentPDPL2 :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere \"setCurrentPDPL2 pd \\<equiv> machine_op_lift (setCurrentPDPL2_impl pd)\"\n\nconsts'\n  invalidateLocalTLB_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB :: \"unit machine_monad\"\nwhere \"invalidateLocalTLB \\<equiv> machine_op_lift invalidateLocalTLB_impl\"\n\n\nconsts'\n  invalidateLocalTLB_ASID_impl :: \"hardware_asid \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB_ASID :: \"hardware_asid \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateLocalTLB_ASID a \\<equiv> machine_op_lift (invalidateLocalTLB_ASID_impl a)\"", "property": "Memory Barrier Operations: Provide mechanisms to enforce memory ordering and synchronization, including instruction stream barriers (ISB), data synchronization barriers (DSB), and data memory barriers (DMB). Additionally, operations are defined to set the current page directory pointer for level 2 translation (PDPL2) and to invalidate local translation lookaside buffer (TLB) entries, either globally or for a specific address space identifier (ASID).", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " Memory Barriers "}
{"spec": "consts'\n  invalidateLocalTLB_VAASID_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateLocalTLB_VAASID :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateLocalTLB_VAASID w \\<equiv> machine_op_lift (invalidateLocalTLB_VAASID_impl w)\"\n\nconsts'\n  cleanByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanByVA w p \\<equiv> machine_op_lift (cleanByVA_impl w p)\"\n\nconsts'\n  cleanByVA_PoU_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanByVA_PoU :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanByVA_PoU w p \\<equiv> machine_op_lift (cleanByVA_PoU_impl w p)\"\n\nconsts'\n  invalidateByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateByVA w p \\<equiv> machine_op_lift (invalidateByVA_impl w p)\"\n\nconsts'\n  invalidateByVA_I_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateByVA_I :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateByVA_I w p \\<equiv> machine_op_lift (invalidateByVA_I_impl w p)\"\n\nconsts'\n  invalidate_I_PoU_impl :: \"unit machine_rest_monad\"\ndefinition\n  invalidate_I_PoU :: \"unit machine_monad\"\nwhere \"invalidate_I_PoU \\<equiv> machine_op_lift invalidate_I_PoU_impl\"\n\nconsts'\n  cleanInvalByVA_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanInvalByVA :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanInvalByVA w p \\<equiv> machine_op_lift (cleanInvalByVA_impl w p)\"\n\nconsts'\n  branchFlush_impl :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  branchFlush :: \"machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"branchFlush w p \\<equiv> machine_op_lift (branchFlush_impl w p)\"\n\nconsts'\n  clean_D_PoU_impl :: \"unit machine_rest_monad\"\ndefinition\n  clean_D_PoU :: \"unit machine_monad\"\nwhere \"clean_D_PoU \\<equiv> machine_op_lift clean_D_PoU_impl\"\n\nconsts'\n  cleanInvalidate_D_PoC_impl :: \"unit machine_rest_monad\"\ndefinition\n  cleanInvalidate_D_PoC :: \"unit machine_monad\"\nwhere \"cleanInvalidate_D_PoC \\<equiv> machine_op_lift cleanInvalidate_D_PoC_impl\"\n\nconsts'\n  cleanInvalidateL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanInvalidateL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanInvalidateL2Range w p \\<equiv> machine_op_lift (cleanInvalidateL2Range_impl w p)\"\n\nconsts'\n  invalidateL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  invalidateL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"invalidateL2Range w p \\<equiv> machine_op_lift (invalidateL2Range_impl w p)\"\n\nconsts'\n  cleanL2Range_impl :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  cleanL2Range :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere \"cleanL2Range w p \\<equiv> machine_op_lift (cleanL2Range_impl w p)\"\n\nconsts'\n  initL2Cache_impl :: \"unit machine_rest_monad\"\ndefinition\n  initL2Cache :: \"unit machine_monad\"\nwhere \"initL2Cache \\<equiv> machine_op_lift initL2Cache_impl\"\n\ndefinition\n  clearExMonitor :: \"unit machine_monad\"\nwhere \"clearExMonitor \\<equiv> modify (\\<lambda>s. s \\<lparr> exclusive_state := default_exclusive_state \\<rparr>)\"\n\nconsts'\n  flushBTAC_impl :: \"unit machine_rest_monad\"\ndefinition\n  flushBTAC :: \"unit machine_monad\"\nwhere \"flushBTAC \\<equiv> machine_op_lift flushBTAC_impl\"\n\nconsts'\n  initIRQController_impl :: \"unit machine_rest_monad\"\ndefinition\n  initIRQController :: \"unit machine_monad\"\nwhere \"initIRQController \\<equiv> machine_op_lift initIRQController_impl\"\n\ndefinition\n  IRQ :: \"irq \\<Rightarrow> irq\"\nwhere \"IRQ \\<equiv> id\"\n\nconsts'\n  writeContextID_impl :: \"unit machine_rest_monad\"\ndefinition\n  writeContextID :: \"unit machine_monad\"\nwhere \"writeContextID \\<equiv> machine_op_lift writeContextID_impl\"\n\nlemmas cache_machine_op_defs = isb_def dsb_def dmb_def writeContextID_def flushBTAC_def\n                               clearExMonitor_def cleanL2Range_def invalidateL2Range_def\n                               cleanInvalidateL2Range_def cleanInvalidate_D_PoC_def\n                               clean_D_PoU_def branchFlush_def cleanInvalByVA_def\n                               invalidate_I_PoU_def invalidateByVA_I_def invalidateByVA_def\n                               cleanByVA_PoU_def cleanByVA_def invalidateLocalTLB_VAASID_def\n                               invalidateLocalTLB_ASID_def invalidateLocalTLB_def\nconsts'\n  IFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  DFSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  FAR_val :: \"machine_state \\<Rightarrow> machine_word\"\n\ndefinition\n  getIFSR :: \"machine_word machine_monad\"\n  where \"getIFSR \\<equiv> gets IFSR_val\"\n\ndefinition\n  getDFSR :: \"machine_word machine_monad\"\n  where \"getDFSR \\<equiv> gets DFSR_val\"\n\ndefinition\n  getFAR :: \"machine_word machine_monad\"\n  where \"getFAR \\<equiv> gets FAR_val\"\n\ndefinition\n  debugPrint :: \"unit list \\<Rightarrow> unit machine_monad\"\nwhere\n  debugPrint_def[simp]:\n \"debugPrint \\<equiv> \\<lambda>message. return ()\"\n\nconsts'\n  ackInterrupt_impl :: \"irq \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  ackInterrupt :: \"irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"ackInterrupt irq \\<equiv> machine_op_lift (ackInterrupt_impl irq)\"\n\nconsts'\n  TPIDRURO_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  getTPIDRURO :: \"machine_word machine_monad\"\nwhere \"getTPIDRURO \\<equiv> gets TPIDRURO_val\"\n\nconsts'\n  setTPIDRURO_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setTPIDRURO :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setTPIDRURO w \\<equiv> machine_op_lift (setTPIDRURO_impl w)\"\n\n\\<comment> \\<open>Interrupt controller operations\\<close>", "property": "Machine Operations: Provide a set of functions to manage and control various aspects of the machine, including cache operations (cleaning, invalidating, and initializing), TLB operations, branch flushing, interrupt handling, and system register access. These operations ensure that the machine state is maintained correctly and efficiently, supporting the overall stability and performance of the system.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " C implementation takes one argument, which is w || a "}
{"spec": "definition\n  \"non_kernel_IRQs = {irqVGICMaintenance, irqVTimerEvent}\"", "property": "Non-Kernel Interrupts: Defines a set of interrupts that are not allowed to occur while the kernel is running but can occur during user mode.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Interrupts that cannot occur while the kernel is running (e.g. at preemption points),\n  but that can occur from user mode.\n"}
{"spec": "definition\n  getActiveIRQ :: \"bool \\<Rightarrow> (irq option) machine_monad\"\nwhere\n  \"getActiveIRQ in_kernel \\<equiv> do\n    is_masked \\<leftarrow> gets $ irq_masks;\n    modify (\\<lambda>s. s \\<lparr> irq_state := irq_state s + 1 \\<rparr>);\n    active_irq \\<leftarrow> gets $ irq_oracle \\<circ> irq_state;\n    if is_masked active_irq \\<or> (in_kernel \\<and> active_irq \\<in> non_kernel_IRQs)\n    then return None\n    else return (Some active_irq)\n  od\"\n\ndefinition\n  maskInterrupt :: \"bool \\<Rightarrow> irq \\<Rightarrow> unit machine_monad\"\nwhere\n  \"maskInterrupt m irq \\<equiv>\n  modify (\\<lambda>s. s \\<lparr> irq_masks := (irq_masks s) (irq := m) \\<rparr>)\"\n\ndefinition\n  lineStart :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"lineStart addr = (addr >> cacheLineBits) << cacheLineBits\"", "property": "Active IRQ Retrieval: Determines the active interrupt request (IRQ) by updating the IRQ state to reflect the passage of time and checking if the IRQ is masked or in a non-kernel state. If the IRQ is not masked and is in a valid state, it returns the active IRQ; otherwise, it returns None.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  @{term getActiveIRQ} is now derministic.\n  It 'updates' the irq state to the reflect the passage of\n  time since last the irq was gotten, then it gets the active\n  IRQ (if there is one).\n"}
{"spec": "definition\n  cacheRangeOp :: \"(machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad)\n                 \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cacheRangeOp operation vstart vend pstart \\<equiv>\n    let pend = pstart + (vend - vstart);\n        vptrs = [lineStart vstart, lineStart vstart + of_nat cacheLine .e. lineStart vend];\n        pptrs = [lineStart pstart, lineStart pstart + of_nat cacheLine .e. lineStart pend]\n    in mapM_x (\\<lambda>(v, p). operation v p) (zip vptrs pptrs)\"\n\ndefinition\n  cleanCacheRange_PoC :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_PoC vstart vend pstart \\<equiv> cacheRangeOp cleanByVA vstart vend pstart\"\n\ndefinition\n  cleanInvalidateCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanInvalidateCacheRange_RAM vstart vend pstart \\<equiv> do\n    cleanCacheRange_PoC vstart vend pstart;\n    dsb;\n    cleanInvalidateL2Range pstart (pstart + (vend - vstart));\n    cacheRangeOp cleanInvalByVA vstart vend pstart;\n    dsb\n  od\"\n\ndefinition\n  cleanCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_RAM vstart vend pstart \\<equiv> do\n    cleanCacheRange_PoC vstart vend pstart;\n    dsb;\n    cleanL2Range pstart (pstart + (vend - vstart))\n  od\"\n\ndefinition\n  cleanCacheRange_PoU :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"cleanCacheRange_PoU vstart vend pstart \\<equiv> cacheRangeOp cleanByVA_PoU vstart vend pstart\"\n\ndefinition\n  invalidateCacheRange_RAM :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"invalidateCacheRange_RAM vstart vend pstart \\<equiv> do\n    when (vstart \\<noteq> lineStart vstart) $\n        cleanCacheRange_RAM vstart vstart pstart;\n    when (vend + 1 \\<noteq> lineStart (vend + 1)) $\n        cleanCacheRange_RAM (lineStart vend) (lineStart vend)\n           (pstart + ((lineStart vend) - vstart));\n    invalidateL2Range pstart (pstart + (vend - vstart));\n    cacheRangeOp invalidateByVA vstart vend pstart;\n    dsb\n  od\"\n\ndefinition\n  invalidateCacheRange_I :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"invalidateCacheRange_I vstart vend pstart \\<equiv> invalidate_I_PoU\"", "property": "Cache Operations: Perform operations on cache lines that intersect a specified virtual and physical address range. These operations include cleaning, invalidating, or both, and may involve multiple steps such as cleaning by virtual address, data synchronization barriers (DSB), and L2 cache operations to ensure the coherence and consistency of the cache.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": "\n  Performs the given operation on every cache line that intersects the\n  supplied range.\n"}
{"spec": "definition\n  branchFlushRange :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"branchFlushRange vstart vend pstart \\<equiv> cacheRangeOp branchFlush vstart vend pstart\"\n\ndefinition\n  cleanCaches_PoU :: \"unit machine_monad\"\nwhere\n  \"cleanCaches_PoU \\<equiv> do\n    dsb;\n    clean_D_PoU;\n    dsb;\n    invalidate_I_PoU;\n    dsb\n  od\"\n\ndefinition\n  cleanInvalidateL1Caches :: \"unit machine_monad\"\nwhere\n  \"cleanInvalidateL1Caches \\<equiv> do\n    dsb;\n    cleanInvalidate_D_PoC;\n    dsb;\n    invalidate_I_PoU;\n    dsb\n  od\"", "property": "Cache Management: Perform cache operations to maintain data and instruction coherence. These include flushing specific ranges of the branch cache, cleaning and invalidating data and instruction caches, and ensuring memory barriers (DSB) between operations to synchronize the processor's view of memory.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "The Operations", "comment": " for other than A53 and A35: \"cacheRangeOp invalidateByVA_I vstart vend pstart\" "}
{"spec": "text \\<open>Clear memory contents to recycle it as user memory. Do not yet flush the cache.\\<close>\ndefinition\n  clearMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"clearMemory ptr bytelength \\<equiv>\n    mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size .e. ptr + (of_nat bytelength) - 1]\"\n\ndefinition\n  clearMemoryVM :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n  \"clearMemoryVM ptr bits \\<equiv> return ()\"", "property": "Memory Clearance: Clear the contents of a specified memory region by setting each word to zero, preparing it for reuse as user memory. The operation does not flush the cache.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": ""}
{"spec": "abbreviation (input) \"initMemory == clearMemory\"", "property": "Memory Initialization: Clear the memory to be used as user memory, ensuring it is properly initialized and ready for use. This includes a call to cleanCacheRange to maintain consistency between the cache and the memory.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Initialize memory to be used as user memory.\n  Note that zeroing out the memory is redundant in the specifications.\n  In any case, we cannot abstract from the call to cleanCacheRange,\n  which appears in the implementation.\n"}
{"spec": "definition\n  freeMemory :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit machine_monad\"\n  where\n \"freeMemory ptr bits \\<equiv>\n  mapM_x (\\<lambda>p. storeWord p 0) [ptr, ptr + word_size  .e.  ptr + 2 ^ bits - 1]\"", "property": "Memory Clearance: Zero out the memory region specified by the pointer and the number of bits, ensuring that the freed memory contains no garbage and can be safely reused.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "Memory Clearance", "comment": "\n  Free memory that had been initialized as user memory.\n  While freeing memory is a no-(in) the implementation,\n  we zero out the underlying memory in the specifications to avoid garbage.\n  If we know that there is no garbage,\n  we can compute from the implementation state\n  what the exact memory content in the specifications is.\n"}
{"spec": "consts'\n  writeContextIDAndPD_impl :: \"hardware_asid \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  writeContextIDAndPD :: \"hardware_asid \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere \"writeContextIDAndPD a b \\<equiv> machine_op_lift (writeContextIDAndPD_impl a b)\"\n\nconsts'\n  HSR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  HDFAR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  SCTLR_val :: \"machine_state \\<Rightarrow> machine_word\"\n  ACTLR_val :: \"machine_state \\<Rightarrow> machine_word\"\n\ndefinition\n  getHSR :: \"machine_word machine_monad\"\nwhere \"getHSR \\<equiv> gets HSR_val\"\n\ndefinition\n  getHDFAR :: \"machine_word machine_monad\"\nwhere \"getHDFAR \\<equiv> gets HDFAR_val\"\n\nconsts'\n  setHCR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setHCR :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setHCR w \\<equiv> machine_op_lift (setHCR_impl w)\"\n\nconsts'\n  addressTranslateS1_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\n  addressTranslateS1_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition\n  addressTranslateS1 :: \"machine_word \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"addressTranslateS1 w \\<equiv> do\n    machine_op_lift (addressTranslateS1_impl w);\n    gets (addressTranslateS1_val w)\n  od\"\n\ndefinition\n  getSCTLR :: \"machine_word machine_monad\"\nwhere \"getSCTLR \\<equiv> gets SCTLR_val\"\n\nconsts'\n  setSCTLR_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  setSCTLR :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"setSCTLR w \\<equiv> machine_op_lift (setSCTLR_impl w)\"\n\ndefinition\n  vgic_irq_active :: \"machine_word\"\nwhere\n  \"vgic_irq_active \\<equiv> 2 << 28\"\n\ndefinition\n  vgic_irq_mask :: \"machine_word\"\nwhere\n  \"vgic_irq_mask \\<equiv> 3 << 28\"\n\nconsts'\n  gic_vcpu_ctrl_hcr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_hcr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_hcr \\<equiv> gets gic_vcpu_ctrl_hcr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_hcr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_hcr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_hcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_hcr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_vmcr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_vmcr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_vmcr \\<equiv> gets gic_vcpu_ctrl_vmcr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_vmcr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_vmcr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_vmcr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vmcr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_apr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_apr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_apr \\<equiv> gets gic_vcpu_ctrl_apr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_apr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_apr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_apr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_apr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_vtr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_vtr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_vtr \\<equiv> gets gic_vcpu_ctrl_vtr_val\"\n\nconsts'\n  set_gic_vcpu_ctrl_vtr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_vtr :: \"machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_vtr w \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_vtr_impl w)\"\n\nconsts'\n  gic_vcpu_ctrl_misr_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_misr :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_misr \\<equiv> gets gic_vcpu_ctrl_misr_val\"\n\nconsts'\n  gic_vcpu_ctrl_eisr0_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_eisr0 :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_eisr0 \\<equiv> gets gic_vcpu_ctrl_eisr0_val\"\n\nconsts'\n  gic_vcpu_ctrl_eisr1_val :: \"machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_eisr1 :: \"machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_eisr1 \\<equiv> gets gic_vcpu_ctrl_eisr1_val\"\n\nconsts'\n  get_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> unit machine_rest_monad\"\n  gic_vcpu_ctrl_lr_val :: \"machine_word \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition\n  get_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"get_gic_vcpu_ctrl_lr n \\<equiv> do\n      machine_op_lift (get_gic_vcpu_ctrl_lr_impl n);\n      gets (gic_vcpu_ctrl_lr_val n)\n    od\"\n\nconsts'\n  set_gic_vcpu_ctrl_lr_impl :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_gic_vcpu_ctrl_lr :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_gic_vcpu_ctrl_lr n w  \\<equiv> machine_op_lift (set_gic_vcpu_ctrl_lr_impl n w)\"", "property": "Machine Operations: Provides a set of operations to manage and interact with the machine state, including reading and writing various control registers (HSR, HDFAR, SCTLR, HCR, and GIC vCPU control registers), performing address translations, and handling interrupts. These operations ensure that the system can effectively manage hardware resources and maintain the correct state for virtualization and interrupt handling.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "consts'\n  cntv_cval_64_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition\n  get_cntv_cval_64 :: \"64 word machine_monad\"\nwhere\n  \"get_cntv_cval_64 \\<equiv> gets cntv_cval_64_val\"\n\nconsts'\n  set_cntv_cval_64_impl :: \"64 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_cntv_cval_64 :: \"64 word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_cntv_cval_64 w \\<equiv> machine_op_lift (set_cntv_cval_64_impl w)\"\n\nconsts'\n  cntv_off_64_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition\n  get_cntv_off_64 :: \"64 word machine_monad\"\nwhere\n  \"get_cntv_off_64 \\<equiv> gets cntv_off_64_val\"\n\nconsts'\n  set_cntv_off_64_impl :: \"64 word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  set_cntv_off_64 :: \"64 word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_cntv_off_64 w \\<equiv> machine_op_lift (set_cntv_off_64_impl w)\"\n\nconsts'\n  read_cntpct_val :: \"machine_state \\<Rightarrow> 64 word\"\ndefinition\n  read_cntpct :: \"64 word machine_monad\"\nwhere\n  \"read_cntpct \\<equiv> gets read_cntpct_val\"", "property": "Hypervisor Banked Registers Access: Provides operations to get and set the values of hypervisor banked registers, including `cntv_cval_64`, `cntv_off_64`, and `read_cntpct`. These operations allow for the retrieval and modification of specific 64-bit register values in the machine state.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "consts'\n  vcpuHardwareReg_val :: \"vcpureg \\<Rightarrow> machine_state \\<Rightarrow> machine_word\"\ndefinition\n  readVCPUHardwareReg :: \"vcpureg \\<Rightarrow> machine_word machine_monad\"\nwhere\n  \"readVCPUHardwareReg reg \\<equiv> gets (vcpuHardwareReg_val reg)\"\n\nconsts'\n  writeVCPUHardwareReg_impl :: \"vcpureg \\<Rightarrow> machine_word \\<Rightarrow> unit machine_rest_monad\"\ndefinition\n  writeVCPUHardwareReg :: \"vcpureg \\<Rightarrow> machine_word \\<Rightarrow> unit machine_monad\"\nwhere\n  \"writeVCPUHardwareReg reg val \\<equiv> machine_op_lift (writeVCPUHardwareReg_impl reg val)\"", "property": "Hypervisor Banked Registers Access: Provides mechanisms to read and write hardware registers specific to a virtual CPU (vCPU) in the machine state. Reading a vCPU hardware register retrieves its current value, while writing updates the register with a new value.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "type_synonym user_regs = \"register \\<Rightarrow> machine_word\"\n\ndatatype user_context = UserContext (user_regs : user_regs)\n\ntype_synonym 'a user_monad = \"(user_context, 'a) nondet_monad\"\n\ndefinition getRegister :: \"register \\<Rightarrow> machine_word user_monad\" where\n  \"getRegister r \\<equiv> gets (\\<lambda>s. user_regs s r)\"\n\ndefinition modify_registers :: \"(user_regs \\<Rightarrow> user_regs) \\<Rightarrow> user_context \\<Rightarrow> user_context\" where\n  \"modify_registers f uc \\<equiv> UserContext (f (user_regs uc))\"\n\ndefinition setRegister :: \"register \\<Rightarrow> machine_word \\<Rightarrow> unit user_monad\" where\n  \"setRegister r v \\<equiv> modify (\\<lambda>s. UserContext ((user_regs s) (r := v)))\"\n\ndefinition\n  \"getRestartPC \\<equiv> getRegister FaultIP\"\n\ndefinition\n  \"setNextPC \\<equiv> setRegister NextIP\"\n\nend\n\ntranslations\n  (type) \"'a ARM_HYP.user_monad\" <= (type) \"(ARM_HYP.register \\<Rightarrow> machine_word, 'a) nondet_monad\"\n\n\nend", "property": "User Register Management: Provides operations to get and set the values of user-level registers, including getting the restart program counter and setting the next program counter, allowing for the manipulation and control of the user context.", "title": "./spec/machine/ARM_HYP/MachineOps.thy", "chapter": "Machine Operations", "section": "User Monad", "comment": ""}
{"spec": "(* representation of C int literals, the default for any unadorned numeral *)\ntype_synonym int_literal_len = \"32 signed\"\ntype_synonym int_word = \"int_literal_len word\"", "property": "Integer Literal Representation: Defines the representation of C integer literals as 32-bit signed words.", "title": "./spec/machine/ARM_HYP/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "context Arch begin global_naming ARM_HYP\n\nvalue_type irq_len = Kernel_Config.irqBits (* IRQ_CNODE_SLOT_BITS *)\ntype_synonym irq = \"irq_len word\"\ntype_synonym paddr = word32\n\nabbreviation (input) \"toPAddr \\<equiv> id\"\nabbreviation (input) \"fromPAddr \\<equiv> id\"\n\ndefinition pageColourBits :: nat where\n  \"pageColourBits \\<equiv> 2\"\n\ndefinition cacheLineBits :: nat where\n  \"cacheLineBits = CONFIG_L1_CACHE_LINE_SIZE_BITS\"\n\ndefinition cacheLine :: nat where\n  \"cacheLine = 2^cacheLineBits\"", "property": "Platform Constants: Define and specify the bit lengths and sizes for IRQs, physical addresses, page colors, and cache lines. These constants ensure consistent and predictable behavior of the platform-specific hardware features.", "title": "./spec/machine/ARM_HYP/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": ""}
{"spec": "definition pptrBase :: word32 where\n  \"pptrBase \\<equiv> 0xe0000000\"\n\nabbreviation (input) \"paddrBase \\<equiv> physBase\"\n\ndefinition pptrBaseOffset :: machine_word where\n  \"pptrBaseOffset = pptrBase - paddrBase\"\n\ndefinition pptrTop :: \"32 word\" where\n  \"pptrTop \\<equiv> 0xfff00000\"\n\ndefinition paddrTop :: \"32 word\" where\n  \"paddrTop \\<equiv> pptrTop - pptrBaseOffset\"\n\ndefinition kernelELFPAddrBase :: word32 where\n  \"kernelELFPAddrBase \\<equiv> physBase\"\n\ndefinition kernelELFBase :: word32 where\n  \"kernelELFBase \\<equiv> pptrBase + (kernelELFPAddrBase && mask 22)\"\n\ndefinition kernelELFBaseOffset :: word32 where\n  \"kernelELFBaseOffset \\<equiv> kernelELFBase - kernelELFPAddrBase\"\n\ndefinition ptrFromPAddr :: \"paddr \\<Rightarrow> word32\" where\n  \"ptrFromPAddr paddr \\<equiv> paddr + pptrBaseOffset\"\n\ndefinition addrFromPPtr :: \"word32 \\<Rightarrow> paddr\" where\n  \"addrFromPPtr pptr \\<equiv> pptr - pptrBaseOffset\"\n\ndefinition addrFromKPPtr :: \"word32 \\<Rightarrow> paddr\" where\n  \"addrFromKPPtr kpptr \\<equiv> kpptr - kernelELFBaseOffset\"\n\ndefinition minIRQ :: \"irq\" where\n  \"minIRQ \\<equiv> 0\"\n\ndefinition irqVGICMaintenance :: \"irq\" where\n  \"irqVGICMaintenance \\<equiv> 25\"\n\ndefinition irqVTimerEvent :: \"irq\" where\n  \"irqVTimerEvent  \\<equiv> 27\"\n\nend\n\nend", "property": "Platform Constants: Define the base and top addresses for physical and virtual memory, as well as offsets and conversions between them. Additionally, specify specific IRQ values for system interrupts.", "title": "./spec/machine/ARM_HYP/Platform.thy", "chapter": "Platform Definitions", "section": "Platform Constants", "comment": " The first virtual address of the kernel's physical memory window "}
{"spec": "(* Architecture-specific lemmas constraining Kernel_Config definitions *)\n\ntheory Arch_Kernel_Config_Lemmas\nimports\n  Kernel_Config_Lemmas\n  Platform\nbegin\n\ncontext Arch begin global_naming ARM_HYP", "property": "Architectural Constraints: Define and enforce architectural-specific constraints on kernel configurations, ensuring that the system adheres to the requirements and limitations of the ARM_HYP architecture.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma physBase_aligned:\n  \"is_aligned physBase 25\"\n  by (simp add: is_aligned_def Kernel_Config.physBase_def)", "property": "Physical Base Alignment: The physical base address is aligned to a 25-bit boundary, ensuring proper alignment for memory operations.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " note: 25 = pageBitsForSize ARMSuperSection, we do not have access to ASpec at this point "}
{"spec": "lemma irqVTimerEvent_le_maxIRQ[simp, intro!]:\n  \"irqVTimerEvent \\<le> maxIRQ\"\n  by (simp add: irqVTimerEvent_def Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_less_2p_irqBits:\n  \"(maxIRQ::nat) < 2^irqBits\"\n  by (simp add: Kernel_Config.maxIRQ_def Kernel_Config.irqBits_def)", "property": "Max IRQ Value: The maximum IRQ value is less than \\(2^{irqBits}\\), ensuring that the system can handle a defined range of interrupts without exceeding the allocated bits for IRQ representation. Additionally, the virtual timer event IRQ is guaranteed to be within the range of the maximum IRQ value.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ conditions "}
{"spec": "lemma LENGTH_irq_len_irqBits[simp]: (* [simp] will fire only for simp del: len_of_numeral_defs *)\n  \"LENGTH(irq_len) = irqBits\"\n  using irq_len_def irq_len_val\n  by simp\n\nlemma maxIRQ_less_2p_irq_len:\n  \"(maxIRQ::nat) < 2^LENGTH(irq_len)\"\n  using maxIRQ_less_2p_irqBits\n  by (simp del: len_of_numeral_defs)\n\nlemma unat_2p_irqBits_machine[simp]:\n  \"unat (2 ^ irqBits :: machine_word) = 2 ^ irqBits\"\n  by (simp add: Kernel_Config.irqBits_def)", "property": "IRQ Length and Maximum IRQ Value: The length of the IRQ representation is defined by `irqBits`, and the maximum IRQ value is less than \\(2^{irqBits}\\). Additionally, the unsigned integer representation of \\(2^{irqBits}\\) as a machine word is equal to \\(2^{irqBits}\\).", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " follows from value_type definition of irq_len "}
{"spec": "lemma of_nat_maxIRQ[simp]:\n  \"of_nat maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma of_int_maxIRQ[simp]:\n  \"of_int maxIRQ = (maxIRQ::'a::len word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)", "property": "Max IRQ Value Conversion: The maximum interrupt request (IRQ) value can be converted to a word of any length without loss of information, ensuring consistency in numeric representations.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " maxIRQ as a generic numeral allows us to write rules about casts/unat/uint etc without\n   mentioning numbers: "}
{"spec": "lemma unat_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> unat (maxIRQ::'a word) = maxIRQ\"\n  by (metis maxIRQ_less_2p_irq_len Word.of_nat_unat of_nat_inverse of_nat_maxIRQ unat_ucast_up_simp)", "property": "Unat Conversion for maxIRQ: Ensures that the conversion of `maxIRQ` to its natural number representation using `unat` is safe and equivalent to `maxIRQ` itself, provided that the length of `irq_len` is less than or equal to the bit length of the word type.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma uint_maxIRQ[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow> uint (maxIRQ::'a word) = maxIRQ\"\n  by (metis Kernel_Config.maxIRQ_def of_nat_numeral uint_nat unat_maxIRQ)", "property": "Uint Conversion for maxIRQ: Ensures that the conversion of `maxIRQ` to its unsigned integer representation is safe and retains the original value, provided that the length of `irq_len` does not exceed the bit width of the word type.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma ucast_maxIRQ[simp]:\n  \"\\<lbrakk> LENGTH(irq_len) \\<le> LENGTH('a::len); LENGTH(irq_len) \\<le> LENGTH('b::len) \\<rbrakk> \\<Longrightarrow>\n   UCAST ('a \\<rightarrow> 'b) maxIRQ = maxIRQ\"\n  by (metis of_nat_maxIRQ ucast_nat_def unat_maxIRQ)", "property": "Property: Ucast Preservation of maxIRQ: The value of `maxIRQ` is preserved under unsigned casting between types, provided the target type has a bit length greater than or equal to the bit length of `irq_len`.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't use maxIRQ at lower than irq_len "}
{"spec": "lemma maxIRQ_less_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   (maxIRQ < (ucast irq :: 'a word)) = (maxIRQ < irq)\" for irq::irq\n  by (simp add: word_less_nat_alt unat_ucast_up_simp)", "property": "Max IRQ Comparison: Ensures that the comparison between the maximum IRQ value and an upcasted IRQ value remains consistent, provided the length of the upcasted word is greater than or equal to the length of the original IRQ type.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma maxIRQ_le_upcast[simp]:\n  \"LENGTH(irq_len) \\<le> LENGTH('a::len) \\<Longrightarrow>\n   ((ucast irq :: 'a word) \\<le> Kernel_Config.maxIRQ) = (irq \\<le> Kernel_Config.maxIRQ)\" for irq::irq\n  by (simp add: word_le_nat_alt unat_ucast_up_simp)", "property": "Property: \nIRQ Upcasting Safety: Ensures that upcasting an IRQ to a larger word size does not change the comparison result with the maximum IRQ value, maintaining the safety and correctness of IRQ handling.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Safe for [simp] because we don't cast down from irq type "}
{"spec": "lemma le_maxIRQ_machine_less_irqBits_val[simplified]:\n  \"w \\<le> maxIRQ \\<Longrightarrow> unat w < 2^LENGTH(irq_len)\" for w::machine_word\n  using maxIRQ_less_2p_irq_len\n  by (simp add: word_le_nat_alt)\n\nlemma irq_machine_le_maxIRQ_irq:\n  \"irq \\<le> Kernel_Config.maxIRQ \\<Longrightarrow> (ucast irq::irq) \\<le> maxIRQ\" for irq::machine_word\n  by (simp add: Kernel_Config.maxIRQ_def word_le_nat_alt unat_ucast)\n\nlemma maxIRQ_eq_ucast_irq_32_signed_uint:\n  \"(maxIRQ = (ucast b :: 32 signed word)) = (uint b = maxIRQ)\" for b::irq\n  unfolding Kernel_Config.maxIRQ_def\n  apply uint_arith\n  apply (simp add: uint_up_ucast is_up)\n  done\n\nlemma sint_maxIRQ_32[simp]:\n  \"sint (maxIRQ :: 32 signed word) = maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_machine[simp]:\n  \"scast (maxIRQ::32 signed word) = (maxIRQ::machine_word)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma scast_maxIRQ_32_irq[simp]:\n  \"scast (maxIRQ :: 32 signed word) = (maxIRQ::irq)\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_machine:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = x\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_ucast_toEnum_eq_irq:\n  \"x \\<le> maxIRQ \\<Longrightarrow> toEnum (unat x) = (ucast x :: irq)\" for x::machine_word\n  by (simp add: word_le_nat_alt Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_1_plus_eq_Suc_machine[simp]:\n  \"unat (1 + maxIRQ :: machine_word) = Suc Kernel_Config.maxIRQ\"\n  by (simp add: Kernel_Config.maxIRQ_def)\n\nlemma maxIRQ_le_mask_irq_len:\n  \"x \\<le> maxIRQ \\<longrightarrow> x \\<le> mask irq_len\" for x :: machine_word\n  using le_maxIRQ_machine_less_irqBits_val\n  by (fastforce simp add: word_le_nat_alt word_less_nat_alt irq_len_val mask_def)", "property": "IRQ and Machine Word Properties: These lemmas establish relationships and constraints between the maximum IRQ value, machine words, and their representations. They ensure that values within the defined range for IRQs are correctly cast, compared, and manipulated, maintaining consistency and correctness in the system's handling of interrupts and related operations.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " The following are instances -- for some we could derive general rules, but the number of\n   instances is limited and the concrete proofs are much simpler: "}
{"spec": "lemma cacheLineBits_sanity:\n  \"cacheLineBits \\<in> {2..12}\"\n  by (simp add: cacheLineBits_def Kernel_Config.CONFIG_L1_CACHE_LINE_SIZE_BITS_def)\n\nend\nend", "property": "Cache Line Bits Sanity: The value of `cacheLineBits` must be within the range of 2 to 12, ensuring it is suitable for use in cache operations and does not conflict with other values.", "title": "./spec/machine/ARM_HYP/Arch_Kernel_Config_Lemmas.thy", "chapter": "", "section": "", "comment": " Folding cacheLineBits_val in C functions only works reliably if cacheLineBits is not 1 and\n   not too large to conflict with other values used inside cache ops.\n   12 is ptBits, which is only available after ExecSpec. Anything > 1 and smaller than ptBits\n   works. "}
{"spec": "theory Example2\nimports Isolation_S\nbegin\n\nlemma direct_caps_of_update [simp]:\n  \"direct_caps_of (s(x := y)) =\n  (direct_caps_of s)(x:= case y of None \\<Rightarrow> {} | Some (Entity c) \\<Rightarrow> c)\"\n  by (rule ext, simp add: direct_caps_of_def split:option.splits)\n\nlemma direct_caps_of_empty [simp]:\n  \"direct_caps_of Map.empty = ( \\<lambda> x. {})\"\n  by (simp add: direct_caps_of_def fun_eq_iff)\n\ndefinition \"id\\<^sub>0 \\<equiv> 0\"\ndefinition \"id\\<^sub>1 \\<equiv> 1\"\ndefinition \"id\\<^sub>2 \\<equiv> 2\"\ndefinition \"id\\<^sub>3 \\<equiv> 3\"\ndefinition \"id\\<^sub>4 \\<equiv> 4\"\ndefinition \"id\\<^sub>5 \\<equiv> 5\"", "property": "Direct Caps Update: The direct capabilities of a state are updated by replacing the capabilities associated with a specific entity. If the entity is `None`, the capabilities are set to an empty set; if the entity is `Some (Entity c)`, the capabilities are set to `c`. This ensures that the direct capabilities reflect the current state of entities accurately.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  e0_caps :: \"cap set\"\nwhere\n  \"e0_caps \\<equiv> range create_cap \\<union> {full_cap 0}\"\n\ndefinition\n  s0  :: \"state\"\nwhere\n  \"s0  \\<equiv> [0 \\<mapsto> Entity e0_caps]\"\n\ndefinition\n  s1  :: \"state\"\nwhere\n  \"s1  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> null_entity]\"\n\ndefinition\n  s2  :: \"state\" where\n  \"s2  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2}]\"\n\ndefinition\n  s3  :: \"state\" where\n  \"s3  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>}]\"\n\ndefinition\n  s4  :: \"state\" where\n  \"s4  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  s5  :: \"state\" where\n  \"s5  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1, write_cap 2}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  s6  :: \"state\" where\n  \"s6  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1, write_cap 2}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2, read_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  s7  :: \"state\" where \"s7  \\<equiv> s4\"\n\ndefinition\n  s8  :: \"state\" where\n  \"s8  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1, full_cap 3}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity,\n          3 \\<mapsto> null_entity]\"\n\ndefinition\n  s9  :: \"state\" where\n  \"s9  \\<equiv> [0 \\<mapsto> Entity (e0_caps \\<union> {full_cap 1}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity,\n          3 \\<mapsto> null_entity]\"\n\ndefinition\n  s10 :: \"state\" where \"s10 \\<equiv> s4\"\n\ndefinition\n  s   :: \"state\" where\n  \"s   \\<equiv> [0 \\<mapsto> Entity (e0_caps - {create_cap 1, create_cap 2}),\n          1 \\<mapsto> Entity {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2},\n          2 \\<mapsto> null_entity]\"\n\ndefinition\n  op0  :: \"sysOPs\" where\n  \"op0  \\<equiv> SysCreate  0 (full_cap 0) (create_cap 1)\"\ndefinition\n  op1  :: \"sysOPs\" where\n  \"op1  \\<equiv> SysGrant   0 (full_cap 1) (create_cap 2) UNIV\"\ndefinition\n  op2  :: \"sysOPs\" where\n  \"op2  \\<equiv> SysGrant   0 (full_cap 1) (full_cap   1) {Write, Store}\"\ndefinition\n  op3  :: \"sysOPs\" where\n  \"op3  \\<equiv> SysCreate  1 \\<lparr>target = 1, rights = {Write, Store}\\<rparr> (create_cap 2)\"\ndefinition\n  op4  :: \"sysOPs\" where\n  \"op4  \\<equiv> SysTake    0 (full_cap 1) (full_cap   2) {Write}\"\ndefinition\n  op5  :: \"sysOPs\" where\n  \"op5  \\<equiv> SysCopy    1 \\<lparr>target = 1, rights = {Write, Store}\\<rparr> (full_cap   2) {Read}\"\ndefinition\n  op6  :: \"sysOPs\" where\n  \"op6  \\<equiv> SysRevoke  0 (write_cap 2)\"\ndefinition\n  op7  :: \"sysOPs\" where\n  \"op7  \\<equiv> SysCreate  0 (full_cap 0) (create_cap 3)\"\ndefinition\n  op8  :: \"sysOPs\" where\n  \"op8  \\<equiv> SysRemove  0 (full_cap 0) (full_cap 3)\"\ndefinition\n  op9  :: \"sysOPs\" where\n  \"op9  \\<equiv> SysDestroy  0 (create_cap 3)\"\ndefinition\n  op10 :: \"sysOPs\" where\n  \"op10 \\<equiv> SysRemoveSet 0 (full_cap 0) {full_cap 1, create_cap 1, create_cap 2}\"\n\ndefinition ops :: \"sysOPs list\" where", "property": "Entity and Capability Management: The system allows the creation, granting, revoking, and removal of capabilities for entities. Entity 0 (e0) initially has full rights to itself and the ability to create capabilities for all of memory. Through a series of operations, the system can manage and modify the capabilities of different entities, ensuring that each entity has the appropriate set of rights and permissions.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " e0 has create caps to all of memory, and full rights to itself. "}
{"spec": "\"ops \\<equiv> [op10, op9, op8, op7, op3, op2, op1, op0]\"", "property": "Operation Sequence: Define a sequence of operations, excluding op6 and op5, to be used in the system.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " since the CDT isn't defined, op6 is skipped\n  \"ops \\<equiv> [op10, op9, op8, op7, op6, op5, op4, op3, op2, op1, op0]\"\n"}
{"spec": "lemma is_entity_s0_e0 [simp]:\n  \"is_entity s0 0\"\n  by (simp add: is_entity_def s0_def)\n\nlemma is_entity_s1_e0 [simp]:\n  \"is_entity s1 0\"\n  by (simp add: is_entity_def s1_def)\n\nlemma is_entity_s2_e0 [simp]:\n  \"is_entity s2 0\"\n  by (simp add: is_entity_def s2_def)\n\nlemma is_entity_s3_e0 [simp]:\n  \"is_entity s3 0\"\n  by (simp add: is_entity_def s3_def)\n\nlemma is_entity_s4_e0 [simp]:\n  \"is_entity s4 0\"\n  by (simp add: is_entity_def s4_def)\n\nlemma is_entity_s5_e0 [simp]:\n  \"is_entity s5 0\"\n  by (simp add: is_entity_def s5_def)\n\nlemma is_entity_s6_e0 [simp]:\n  \"is_entity s6 0\"\n  by (simp add: is_entity_def s6_def)\n\nlemma is_entity_s8_e0 [simp]:\n  \"is_entity s8 0\"\n  by (simp add: is_entity_def s8_def)\n\nlemma is_entity_s9_e0 [simp]:\n  \"is_entity s9 0\"\n  by (simp add: is_entity_def s9_def)\n\nlemma is_entity_s_e0 [simp]:\n  \"is_entity s 0\"\n  by (simp add: is_entity_def s_def)\n\n\nlemma is_entity_s0_e1 [simp]:\n  \"\\<not> is_entity s0 1\"\n  by (simp add: is_entity_def s0_def)\n\nlemma is_entity_s1_e1 [simp]:\n  \"is_entity s1 1\"\n  by (simp add: is_entity_def s1_def)\n\nlemma is_entity_s2_e1 [simp]:\n  \"is_entity s2 1\"\n  by (simp add: is_entity_def s2_def)\n\nlemma is_entity_s3_e1 [simp]:\n  \"is_entity s3 1\"\n  by (simp add: is_entity_def s3_def)\n\nlemma is_entity_s4_e1 [simp]:\n  \"is_entity s4 1\"\n  by (simp add: is_entity_def s4_def)\n\nlemma is_entity_s5_e1 [simp]:\n  \"is_entity s5 1\"\n  by (simp add: is_entity_def s5_def)\n\n\nlemma is_entity_s3_e2 [simp]:\n  \"\\<not> is_entity s3 2\"\n  by (simp add: is_entity_def s3_def)\n\nlemma is_entity_s4_e3 [simp]:\n  \"\\<not> is_entity s4 3\"\n  by (simp add: is_entity_def s4_def)", "property": "Entity Existence: The lemmas define the existence of entities in different states, where certain states contain specific entities and others do not. For each state \\( s_i \\), the lemmas specify whether an entity \\( e_j \\) exists or not.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " is_entity lemmas "}
{"spec": "lemma direct_caps_of_s0_e0_caps [simp]:\n  \"direct_caps_of s0 0 = e0_caps\"\n  by (simp add: direct_caps_of_def s0_def e0_caps_def)\n\nlemma direct_caps_of_s1_e0_caps [simp]:\n  \"direct_caps_of s1 0 = e0_caps \\<union> {full_cap 1}\"\n  by (simp add: direct_caps_of_def s1_def e0_caps_def)\n\nlemma direct_caps_of_s2_e0_caps [simp]:\n  \"direct_caps_of s2 0 = e0_caps \\<union> {full_cap 1}\"\n  by (simp add: direct_caps_of_def s2_def e0_caps_def)\n\nlemma direct_caps_of_s4_e0_caps [simp]:\n  \"direct_caps_of s4 0 = e0_caps \\<union> {full_cap 1}\"\n  by (simp add: direct_caps_of_def s4_def e0_caps_def)\n\nlemma direct_caps_of_s5_e0_caps [simp]:\n  \"direct_caps_of s5 0 = e0_caps \\<union> {full_cap 1, write_cap 2}\"\n  by (simp add: direct_caps_of_def s5_def e0_caps_def)\n\nlemma direct_caps_of_s6_e0_caps [simp]:\n  \"direct_caps_of s6 0 = e0_caps \\<union> {full_cap 1, write_cap 2}\"\n  by (simp add: direct_caps_of_def s6_def e0_caps_def)\n\nlemma direct_caps_of_s8_e0_caps [simp]:\n  \"direct_caps_of s8 0 = e0_caps \\<union> {full_cap 1, full_cap 3}\"\n  by (simp add: direct_caps_of_def s8_def e0_caps_def)\n\nlemma direct_caps_of_s9_e0_caps [simp]:\n  \"direct_caps_of s9 0 = e0_caps \\<union> {full_cap 1}\"\n  by (simp add: direct_caps_of_def s9_def e0_caps_def)\n\n\nlemma direct_caps_of_s2_e1 [simp]:\n  \"direct_caps_of s2 1 = {create_cap 2}\"\n  by (simp add: direct_caps_of_def s2_def)\n\nlemma direct_caps_of_s3_e1 [simp]:\n  \"direct_caps_of s3 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>}\"\n  by (simp add: direct_caps_of_def s3_def)\n\nlemma direct_caps_of_s4_e1 [simp]:\n  \"direct_caps_of s4 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  by (simp add: direct_caps_of_def s4_def)\n\nlemma direct_caps_of_s6_e1 [simp]:\n  \"direct_caps_of s5 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  by (simp add: direct_caps_of_def s5_def)\n\nlemma direct_caps_of_s9_e1 [simp]:\n  \"direct_caps_of s9 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  by (simp add: direct_caps_of_def s9_def)\n\n\nlemma full_cap_e0_caps_in_caps_of_s0_e0_caps [simp]:\n  \"full_cap 0 \\<in> caps_of s0 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e1_in_caps_of_s1_e0_caps [simp]:\n  \"full_cap 1 \\<in> caps_of s1 0\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma full_cap_e1_in_caps_of_s2_e0_caps [simp]:\n  \"full_cap 1 \\<in> caps_of s2 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e0_caps_in_caps_of_s4_e0_caps [simp]:\n  \"full_cap 0 \\<in> caps_of s4 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e1_in_caps_of_s4_e0_caps [simp]:\n  \"full_cap 1 \\<in> caps_of s4 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e2_in_caps_of_s4_e1 [simp]:\n  \"full_cap 2 \\<in> caps_of s4 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma full_cap_e1_in_caps_of_s5_e0_caps [simp]:\n  \"full_cap 1 \\<in> caps_of s5 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma full_cap_e2_in_caps_of_s5_e0_caps [simp]:\n  \"full_cap 2 \\<in> caps_of s5 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma full_cap_e0_caps_in_caps_of_s8_e0_caps [simp]:\n  \"full_cap 0 \\<in> caps_of s8 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma create_cap_in_caps_of_s0_e0_caps [simp]:\n  \"create_cap i \\<in> caps_of s0 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma create_cap_in_caps_of_s1_e0_caps [simp]:\n  \"create_cap i \\<in> caps_of s1 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma create_cap_in_caps_of_s2_e1 [simp]:\n  \"create_cap 2 \\<in> caps_of s2 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma create_cap_in_caps_of_s3_e1 [simp]:\n  \"create_cap 2 \\<in> caps_of s3 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma create_cap_in_caps_of_s4_e3 [simp]:\n  \"create_cap 3 \\<in> caps_of s4 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma create_cap_in_caps_of_s9_e3 [simp]:\n  \"create_cap 3 \\<in> caps_of s9 0\"\n  by (rule direct_cap_in_cap, simp add: e0_caps_def)\n\nlemma write_store_e1_in_caps_of_s3_e1 [simp]:\n  \"\\<lparr>target = 1, rights = {Write, Store}\\<rparr>  \\<in> caps_of s3 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma write_store_e1_in_caps_of_s5_e1 [simp]:\n  \"\\<lparr>target = 1, rights = {Write, Store}\\<rparr> \\<in> caps_of s5 1\"\n  by (rule direct_cap_in_cap, simp)\n\nlemma write_cap_e2_in_caps_of_s6_e0_caps [simp]:\n  \"write_cap 2 \\<in> caps_of s6 0\"\n  by (rule direct_cap_in_cap, simp)", "property": "Direct and Indirect Capabilities: The lemmas define the direct and indirect capabilities associated with different states (s0, s1, s2, etc.) and their respective indices. Each state has a specific set of capabilities, which may include full, create, and write/store rights, and these capabilities are combined or extended in subsequent states.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " direct_caps_of, caps_of and similar lemmas "}
{"spec": "lemma op0_legal:\n  \"legal op0 s0\"\n  by  (clarsimp simp: op0_def all_rights_def)\n\nlemma execute_op0_safe:\n  \"step op0 s0 \\<subseteq> ({s0, s1})\"\n  by (fastforce simp: op0_def step_def createOperation_def s0_def s1_def\n                 split: if_split_asm)\n\nlemma execute_op0_live:\n  \"step op0 s0 \\<supseteq> ({s0, s1})\"\n  apply clarsimp\n  apply (rule conjI)\n   apply (simp add: step_def)\n  apply (simp add: step_def op0_legal)\n  apply (rule disjI2)\n  apply (clarsimp simp: op0_def createOperation_def)\n  apply (rule ext)\n  apply (clarsimp simp: s0_def s1_def)\n  done\n\nlemma execute_op0:\n  \"step op0 s0 = ({s0, s1})\"\n  apply rule\n   apply (rule execute_op0_safe)\n  apply (rule execute_op0_live)\n  done", "property": "Operation Execution: The operation `op0` is legal and its execution from state `s0` results in either the original state `s0` or a new state `s1`.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " \"op0 \\<equiv> SysCreate 0 (full_cap 0) (create_cap 1)\" "}
{"spec": "lemma op1_legal:\n  \"legal op1 s1\"\n  by  (clarsimp simp: op1_def all_rights_def)\n\nlemma execute_op1_safe:\n  \"step op1 s1 \\<subseteq> ({s1, s2})\"\n  by (clarsimp simp: op1_def step_def grantOperation_def diminish_def\n                     s1_def s2_def create_cap_def null_entity_def\n              split: if_split_asm)\n\nlemma execute_op1_live:\n  \"step op1 s1 \\<supseteq> ({s1, s2})\"\n  apply clarsimp\n  apply (rule conjI)\n   apply (simp add: step_def)\n  apply (simp add: step_def op1_legal)\n  apply (rule disjI2)\n  apply (clarsimp simp: op1_def grantOperation_def)\n  apply (rule ext)\n  apply (clarsimp simp: s1_def s2_def null_entity_def)\n  done\n\nlemma execute_op1:\n  \"step op1 s1 = ({s1, s2})\"\n  apply rule\n   apply (rule execute_op1_safe)\n  apply (rule execute_op1_live)\n  done", "property": "Operation Execution: The operation `op1` is legal and its execution from state `s1` results in a state transition to either `s1` or `s2`. This ensures that the operation is both safe and live, maintaining the integrity and consistency of the system states.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " \"op1 \\<equiv> SysGrant  0 (full_cap 1) (create_cap 2) UNIV\" "}
{"spec": "lemma op2_legal:\n  \"legal op2 s2\"\n  by  (clarsimp simp: op2_def all_rights_def)\n\nlemma execute_op2_safe:\n  \"step op2 s2 \\<subseteq> ({s2, s3})\"\n  apply clarsimp\n  apply (rule ext)\n  apply (auto simp: op2_def step_def grantOperation_def diminish_def s2_def s3_def full_cap_def all_rights_def\n             split: if_split_asm)\n  done\n\nlemma execute_op2_live:\n  \"step op2 s2 \\<supseteq> ({s2, s3})\"\n  apply clarsimp\n  apply (simp add: step_def op2_legal)\n  apply (rule disjI2)\n  apply (simp add: op2_def)\n  apply (rule ext)\n  apply (fastforce simp: s2_def s3_def grantOperation_def diminish_def all_rights_def full_cap_def)\n  done\n\nlemma execute_op2:\n  \"step op2 s2 = ({s2, s3})\"\n  apply rule\n   apply (rule execute_op2_safe)\n  apply (rule execute_op2_live)\n  done", "property": "Operation Execution Safety and Liveness: The operation `op2` is legal and its execution from state `s2` results in a transition to either state `s2` or state `s3`, ensuring both safety and liveness.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " \"op2 \\<equiv> SysGrant  0 (full_cap 1) (full_cap   1) {Write, Store}\" "}
{"spec": "lemma op3_legal:\n  \"legal op3 s3\"\n  by  (clarsimp simp: op3_def all_rights_def)\n\nlemma execute_op3_safe:\n  \"step op3 s3 \\<subseteq> ({s3, s4})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: op3_def step_def createOperation_def s3_def s4_def\n             split: if_split_asm)\n  done\n\nlemma execute_op3_live:\n  \"step op3 s3 \\<supseteq> ({s3, s4})\"\n  apply clarsimp\n  apply (simp add: step_def op3_legal)\n  apply (rule disjI2)\n  apply (clarsimp simp: op3_def createOperation_def)\n  apply (rule ext)\n  apply (fastforce simp: s3_def s4_def)\n  done\n\nlemma execute_op3:\n  \"step op3 s3 = ({s3, s4})\"\n  apply rule\n   apply (rule execute_op3_safe)\n  apply (rule execute_op3_live)\n  done", "property": "Operation Execution: The operation `op3` is legal and its execution from state `s3` results in a transition to either state `s3` or state `s4`. This ensures that the operation is both safe and live, maintaining the integrity and predictability of the system's state transitions.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " \"op3 \\<equiv> SysCreate 1 (full_cap 1) (create_cap 2)\" "}
{"spec": "lemma op4_legal:\n  \"legal op4 s4\"\n  by  (clarsimp simp: op4_def all_rights_def)\n\nlemma execute_op4_safe:\n  \"step op4 s4 \\<subseteq> ({s4, s5})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s4_def s5_def op4_def step_def takeOperation_def\n                    diminish_def all_rights_def write_cap_def\n             split: if_split_asm)\n  done\n\nlemma execute_op4_live:\n  \"step op4 s4 \\<supseteq> ({s4, s5})\"\n  apply clarsimp\n  apply (simp add: op4_legal step_def)\n  apply (rule disjI2)\n  apply (simp add: op4_def)\n  apply (rule ext)\n  apply (fastforce simp: s4_def s5_def takeOperation_def diminish_def all_rights_def write_cap_def)\n  done\n\nlemma execute_op4:\n  \"step op4 s4 = ({s4, s5})\"\n  apply rule\n   apply (rule execute_op4_safe)\n  apply (rule execute_op4_live)\n  done", "property": "SysTake Operation: The operation `op4` is legal and its execution transitions the system state from `s4` to either `s4` or `s5`, ensuring that the system remains in a valid state.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op4 \\<equiv> SysTake    0 (full_cap 1) (full_cap   2) {Write} "}
{"spec": "lemma op5_legal:\n  \"legal op5 s5\"\n  by  (clarsimp simp: op5_def all_rights_def)\n\nlemma execute_op5_safe:\n  \"step op5 s5 \\<subseteq> ({s5, s6})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s5_def s6_def op5_def step_def copyOperation_def diminish_def all_rights_def read_cap_def\n             split: if_split_asm)\n  done\n\nlemma execute_op5_live:\n  \"step op5 s5 \\<supseteq> ({s5, s6})\"\n  apply clarsimp\n  apply (simp add: step_def op5_legal)\n  apply (rule disjI2)\n  apply (simp add: op5_def)\n  apply (rule ext)\n  apply (fastforce simp: s5_def s6_def copyOperation_def diminish_def all_rights_def read_cap_def)\n  done\n\nlemma execute_op5:\n  \"step op5 s5 = ({s5, s6})\"\n  apply rule\n   apply (rule execute_op5_safe)\n  apply (rule execute_op5_live)\n  done", "property": "SysCopy Operation: The operation `op5` is legal and, when executed, transitions the system state from `s5` to either `s5` or `s6`. This ensures that the system remains in a valid state after the copy operation, maintaining the integrity and consistency of the system.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op5  \\<equiv> SysCopy    1 (full_cap 1) (full_cap   2) {Read} "}
{"spec": "lemma op6_legal:\n  \"legal op6 s6\"\n  by  (clarsimp simp: op6_def all_rights_def)\n\nlemma execute_op6_safe:\n  \"step op6 s6 \\<subseteq> ({s6, s7})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s6_def s7_def s4_def op7_def step_def revokeOperation_def\n          split: if_split_asm)\n  oops\n\nlemma execute_op6_live:\n  \"step op6 s6 \\<supseteq> ({s6, s7})\"\n  apply (insert op6_legal)\n  oops (*\n  apply (auto simp: step_def op6_legal op6_def s6_def s7_def s4_def revokeOperation_def fun_eq_iff)\n  done*)", "property": "SysRevoke Operation: The operation `op6` is legal and, when executed, transitions the system state from `s6` to a set of states that includes `s6` and `s7`. This ensures that the revocation of a capability is performed safely and maintains the integrity of the system.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op6  \\<equiv> SysRevoke  0 (read_cap 2) "}
{"spec": "lemma execute_op6_live:\n  \"s7 \\<in> step op6 s6\"\n  oops\n\nlemma execute_op6:\n  \"step op6 s6 = ({s6, s7})\"\n  oops", "property": "Step Execution: The execution of operation `op6` from state `s6` results in a transition to a set of possible states, including `s6` and `s7`.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " Since cdt is not defined, this proof can't be done "}
{"spec": "lemma op7_legal:\n  \"legal op7 s7\"\n  by  (clarsimp simp: s7_def op7_def all_rights_def)\n\nlemma execute_op7_safe:\n  \"step op7 s7 \\<subseteq> ({s7, s8})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s7_def s8_def s4_def op7_def step_def createOperation_def\n             split: if_split_asm)\n  done\n\nlemma execute_op7_live:\n  \"step op7 s7 \\<supseteq> ({s7, s8})\"\n  apply clarsimp\n  apply (simp add: step_def op7_legal)\n  apply (rule disjI2)\n  apply (simp add: op7_def)\n  apply (rule ext)\n  apply (fastforce simp: s7_def s8_def s4_def createOperation_def)\n  done\n\nlemma execute_op7:\n  \"step op7 s7 = ({s7, s8})\"\n  apply rule\n   apply (rule execute_op7_safe)\n  apply (rule execute_op7_live)\n  done", "property": "Operation Execution: The execution of operation `op7` in state `s7` results in either the original state `s7` or a new state `s8`. This ensures that the operation is both safe and live, maintaining the integrity and consistency of the system.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op7  \\<equiv> SysCreate  0 (full_cap 0) (create_cap 3) "}
{"spec": "lemma op8_legal:\n  \"legal op8 s8\"\n  by  (clarsimp simp: op8_def)\n\nlemma execute_op8_safe:\n  \"step op8 s8 \\<subseteq> ({s8, s9})\"\n  apply clarsimp\n  apply (rule ext)\n  apply (insert op8_legal)\n  apply (fastforce simp: step_def op8_def s8_def s9_def removeOperation_def\n                        full_cap_def create_cap_def all_rights_def e0_caps_def)\n  done\n\nlemma execute_op8_live:\n  \"step op8 s8 \\<supseteq> ({s8, s9})\"\n  apply (simp add: step_def op8_legal op8_def)\n  apply (rule disjI2)\n  apply (rule ext)\n  apply (clarsimp simp: removeOperation_def)\n  apply (fastforce simp: s8_def s9_def full_cap_def create_cap_def all_rights_def e0_caps_def)\n  done\n\nlemma execute_op8:\n  \"step op8 s8 = ({s8, s9})\"\n  apply rule\n   apply (rule execute_op8_safe)\n  apply (rule execute_op8_live)\n  done", "property": "Operation Execution: The operation `op8` is legal and its execution on state `s8` results in a transition to either state `s8` or state `s9`.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op8  \\<equiv> SysRemove  0 (full_cap 0) (full_cap 3) "}
{"spec": "lemma op9_legal:\n  \"legal op9 s9\"\n  apply (simp add: op9_def)\n  apply (fastforce simp: s9_def e0_caps_def null_entity_def split:if_split_asm)\n  done\n\nlemma execute_op9_safe:\n  \"step op9 s9 \\<subseteq> ({s9, s10})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s9_def s10_def s4_def op9_def step_def destroyOperation_def\n             split: if_split_asm)\n  done\n\nlemma execute_op9_live:\n  \"step op9 s9 \\<supseteq> ({s9, s10})\"\n  apply (simp add: step_def op9_legal)\n  apply (rule disjI2)\n  apply (simp add: op9_def)\n  apply (rule ext)\n  apply (clarsimp simp: destroyOperation_def step_def op9_def s9_def s10_def s4_def)\n  done\n\nlemma execute_op9:\n  \"step op9 s9 = ({s9, s10})\"\n  apply rule\n   apply (rule execute_op9_safe)\n  apply (rule execute_op9_live)\n  done", "property": "Operation Safety and Liveness: The operation `op9` is legal and its execution from state `s9` results in a transition to either state `s9` or `s10`, ensuring both safety and liveness.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op9  \\<equiv> SysDelete  0 (create_cap 3) "}
{"spec": "lemma op10_legal:\n  \"legal op10 s10\"\n  by  (clarsimp simp: s10_def op10_def all_rights_def)\n\nlemma e0_caps_diminished [simp]:\n  \"e0_caps - {full_cap 1, create_cap 1, create_cap 2} = e0_caps - {create_cap 1, create_cap 2}\"\n  by (fastforce simp: e0_caps_def create_cap_def full_cap_def all_rights_def)\n\n\nlemma execute_op10_safe:\n  \"step op10 s10 \\<subseteq> ({s10, s})\"\n  apply (clarsimp, rule ext)\n  apply (auto simp: s10_def op10_def step_def removeSetOperation_def s4_def s_def\n              split: if_split_asm)\n  done\n\nlemma execute_op10_live:\n  \"step op10 s10 \\<supseteq> ({s10, s})\"\n  apply clarsimp\n  apply (rule conjI)\n   apply (simp add: step_def)\n  apply (simp add: step_def op10_legal)\n  apply (rule disjI2)\n  apply (clarsimp simp: s10_def op10_def removeSetOperation_def)\n  apply (rule ext)\n  apply (fastforce simp: s4_def s_def)\n  done\n\nlemma execute_op10:\n  \"step op10 s10 = ({s10, s})\"\n  apply rule\n   apply (rule execute_op10_safe)\n  apply (rule execute_op10_live)\n  done\n\n\nlemma execute_ops:\n  \"s \\<in> execute ops s0\"\n  apply (clarsimp simp: ops_def)\n  apply (insert execute_op0_live execute_op1_live execute_op2_live execute_op3_live\n                execute_op4_live execute_op5_live                  execute_op7_live\n                execute_op8_live execute_op9_live execute_op10_live)\n  apply (simp add: s7_def)\n  apply fastforce\n  done", "property": "System Operation Safety and Liveness: The operation `op10` is legal and its execution from state `s10` results in a transition to either the same state `s10` or a new state `s`. This ensures that the system maintains safety and liveness, guaranteeing that the operation does not lead to an undefined or inconsistent state.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": " op10 \\<equiv> SysRemoveSet 0 (full_cap 0) {full_cap 1, create_cap 1, create_cap 2} "}
{"spec": "lemma store_not_in_create_cap [simp]:\n  \"Store \\<notin> rights (create_cap i)\"\n  by (simp add: create_cap_def)\n\nlemma store_not_in_create_cap2 [simp]:\n  \"Store \\<in> rights c \\<Longrightarrow> c \\<noteq> create_cap i\"\n  by (clarsimp simp: create_cap_def)", "property": "Store Exclusion in Capabilities: The `create_cap` function does not include the `Store` right in the created capability. If a capability includes the `Store` right, it cannot be the result of the `create_cap` function.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma store_connected_direct_s_helper1:\n  \"{c'.(c' = \\<lparr>target = 0, rights = UNIV\\<rparr> \\<or> c' \\<in> range create_cap) \\<and>\n        c' \\<noteq> \\<lparr>target = 1, rights = {Create}\\<rparr> \\<and> c' \\<noteq> \\<lparr>target = 2, rights = {Create}\\<rparr> \\<and>\n        Store \\<in> rights c'} = {full_cap 0}\"\n by (auto simp: create_cap_def full_cap_def all_rights_def e0_caps_def)\n\nlemma store_connected_direct_s_helper2:\n  \"{c'. (c' = \\<lparr>target = 2, rights = {Create}\\<rparr> \\<or> c' = \\<lparr>target = 1, rights = {Write, Store}\\<rparr> \\<or>\n         c' = \\<lparr>target = 2, rights = UNIV\\<rparr>)    \\<and>  Store \\<in> rights c'}\n   = {\\<lparr>target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  by (auto simp: create_cap_def full_cap_def all_rights_def e0_caps_def)\n\n\nlemma store_connected_direct_s:\n  \"store_connected_direct s = {(0,0), (1,1), (1,2)}\"\n  by (fastforce simp: store_connected_direct_def s_def e0_caps_def\n                      full_cap_def all_rights_def create_cap_def null_entity_def\n                      store_connected_direct_s_helper1 store_connected_direct_s_helper2\n               split: if_split_asm)", "property": "Store Connected Direct: The store-connected relationship is defined for specific capability configurations, where the set of store-connected pairs is {(0,0), (1,1), (1,2)}. This ensures that the store operations are restricted to these specific target and source pairs, maintaining the integrity and security of the system.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma into_rtrancl [rule_format]:\n  \"(a,b) \\<in> r^* \\<Longrightarrow> (\\<forall>x. (x,b) \\<in> r \\<longrightarrow> x = b) \\<longrightarrow> a = b\"\n  apply (erule converse_rtrancl_induct)\n   apply simp\n  apply clarsimp\n  done\n\nlemma into_rtrancl2 [rule_format]:\n  \" \\<And> B. \\<lbrakk>(a,b) \\<in> r^*; b \\<in> B\\<rbrakk> \\<Longrightarrow> (\\<forall>x.(x,b) \\<in> r \\<longrightarrow> x \\<in> B) \\<longrightarrow> a \\<in> B\"\n  thm rtrancl_induct converse_rtrancl_induct\n  apply (erule converse_rtrancl_induct)\n   apply clarsimp\n  apply clarsimp\n  oops\n\nlemma store_connected_id:\n \"{(0::word32, 0), (1, 1), (1, 2)}\\<^sup>* = {(1, 2)}\\<^sup>* \"\n  apply rule\n   apply clarsimp\n   apply (erule rtranclE)\n    apply simp\n   apply (fastforce dest: into_rtrancl)\n  apply clarsimp\n  apply (erule rtranclE)\n   apply simp\n  apply (fastforce dest: into_rtrancl)\n  done\n\nlemma store_connected_s: \"store_connected s = {(1,2)} \\<union> Id\"\n  apply simp\n  apply (rule equalityI)\n  apply (insert store_connected_direct_s)\n   apply (simp add: store_connected_def)\n   apply clarsimp\n   apply (erule converse_rtranclE)\n    apply simp\n   apply clarsimp\n   apply (erule rtranclE)\n    apply fastforce\n   apply (simp add: store_connected_id)\n   apply (drule rtranclD)\n   apply (safe, simp_all, (erule tranclE, simp, fastforce)+)\n  apply (fastforce simp: store_connected_def)\n  done", "property": "Reflexive Transitive Closure Properties: The lemmas establish properties of the reflexive transitive closure of a relation, including conditions under which elements in the closure are equal and conditions for membership in a set. Specifically, they show that if a pair is in the reflexive transitive closure and certain conditions on the relation hold, then the elements of the pair must be equal or belong to a specific set. Additionally, the lemmas demonstrate the equivalence of certain sets under the reflexive transitive closure.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma caps_of_s_e0_caps: \"caps_of s 0 = e0_caps - {create_cap 1, create_cap 2}\"\n  apply (clarsimp simp: caps_of_def store_connected_s Collect_disj_eq)\n  apply (simp add: s_def)\n  done\n\nlemma caps_of_s_e0_caps_2: \"caps_of s 0 = {full_cap 0} \\<union> ( range create_cap - {create_cap 1, create_cap 2})\"\n  by (fastforce simp: caps_of_s_e0_caps e0_caps_def full_cap_def create_cap_def)\n\n\nlemma caps_of_s_e1: \"caps_of s 1 = {create_cap 2, \\<lparr> target = 1, rights = {Write, Store}\\<rparr>, full_cap 2}\"\n  apply (clarsimp simp: caps_of_def store_connected_s Collect_disj_eq)\n  apply (simp add: s_def null_entity_def)\n  done\n\nlemma caps_of_s_e2: \"caps_of s 2 = {}\"\n  apply (simp add: caps_of_def store_connected_s)\n  apply (simp add: s_def null_entity_def)\n  done\n\nlemma caps_of_s_e3: \"\\<lbrakk>e \\<noteq> 0; e \\<noteq> 1\\<rbrakk> \\<Longrightarrow> caps_of s e = {}\"\n  apply (simp add: caps_of_def store_connected_s)\n  apply (simp add: s_def null_entity_def)\n  done", "property": "Caps of State: The capabilities associated with each entity in the state `s` are defined as follows:\n- Entity 0 has all initial capabilities except for `create_cap 1` and `create_cap 2`.\n- Entity 1 has specific capabilities including `create_cap 2`, a capability with target 1 and rights {Write, Store}, and `full_cap 2`.\n- Entities 2 and any other entities (except 0 and 1) have no capabilities.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma extra_rights_create_cap:\n  \"extra_rights (create_cap i) = full_cap i\"\n  by (simp add: create_cap_def full_cap_def extra_rights_def)\n\n\nlemma extra_rights_full_cap:\n  \"extra_rights (full_cap i) = full_cap i\"\n  by (simp add: full_cap_def extra_rights_def)\n\nlemma extra_rights_take_cap:\n  \"extra_rights (take_cap i) = take_cap i\"\n  by (simp add: take_cap_def extra_rights_def)\n\nlemma extra_rights_grant_cap:\n  \"extra_rights (grant_cap i) = grant_cap i\"\n  by (simp add: take_cap_def extra_rights_def)\n\nlemma caps_of'_s_e0_caps_helper:\n  \"extra_rights ` (range create_cap - {create_cap 1, create_cap 2}) =\n  range full_cap - {full_cap 1, full_cap 2}\"\n  apply rule\n   apply (fastforce simp: create_cap_def extra_rights_def all_rights_def full_cap_def)\n  apply rule\n  apply (erule DiffE)\n  apply clarsimp\n  apply (rule image_eqI)\n   apply (rule extra_rights_create_cap [THEN sym])\n  apply (simp add: full_cap_def create_cap_def)\n  done", "property": "Extra Rights Preservation: The extra rights of a capability are preserved when creating, taking, or granting the capability. Specifically, the extra rights of a created, taken, or granted capability are identical to the original capability, and the extra rights of capabilities in a specific range of created capabilities map to a corresponding range of full capabilities, excluding certain specific cases.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma extra_rights_increases_rights:\n  \"rights c \\<subseteq> rights (extra_rights c)\"\n  by (simp add: extra_rights_def all_rights_def)\n\nlemma cap_in_caps_take_cap:\n  \"\\<lbrakk>create_cap x \\<in> caps_of s y\\<rbrakk> \\<Longrightarrow> take_cap x \\<in>cap caps_of s y\"\n  apply (auto simp: cap_in_caps_def caps_of_def extra_rights_take_cap)\n  apply (rule exI, rule conjI, assumption)\n  apply (rule rev_bexI, simp)\n  apply (rule conjI)\n   apply (subgoal_tac \"target (full_cap x) = x\", simp+)\n  apply (simp add: extra_rights_create_cap all_rights_def)\n  done\n\n\nlemma e0_connected_to:\n  \"\\<lbrakk>x \\<noteq> 1; x \\<noteq> 2\\<rbrakk> \\<Longrightarrow> s \\<turnstile> 0 \\<leftrightarrow> x\"\n  apply (rule directly_tgs_connected_comm)\n  apply (simp add: directly_tgs_connected_def4)\n  apply (rule disjI1)\n  apply (rule cap_in_caps_take_cap)\n  apply (simp add: caps_of_s_e0_caps e0_caps_def create_cap_def)\n  done\n\nlemma e1_connected_to_e2:\n  \"s \\<turnstile> 1 \\<leftrightarrow> 2\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (rule disjI2)+\n  apply (simp add: shares_caps_def)\n  apply (simp add: store_connected_s)\n  done\n\nlemma e0_caps_not_connected_to_e1:\n  \"\\<not> (s \\<turnstile> 0 \\<leftrightarrow> 1)\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (rule conjI)\n   apply (simp add: cap_in_caps_def caps_of_s_e1)\n  apply (rule conjI)\n   apply (clarsimp simp add: cap_in_caps_def caps_of_s_e0_caps e0_caps_def)\n   apply (erule disjE)\n    apply (simp add: full_cap_def)\n   apply clarsimp\n  apply (rule conjI)\n     apply (clarsimp simp add: cap_in_caps_def caps_of_s_e0_caps e0_caps_def)\n   apply (erule disjE)\n    apply (simp add: full_cap_def)\n   apply clarsimp\n  apply (rule conjI)\n   apply (simp add: cap_in_caps_def caps_of_s_e1)\n  apply (simp add: shares_caps_def)\n  apply (simp add: store_connected_s)\n  done\n\nlemma e0_caps_not_connected_to_e2:\n  \"\\<not> (s \\<turnstile> 0 \\<leftrightarrow> 2)\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (rule conjI)\n   apply (simp add: cap_in_caps_def caps_of_s_e2)\n  apply (rule conjI)\n   apply (clarsimp simp add: cap_in_caps_def caps_of_s_e0_caps e0_caps_def)\n   apply (erule disjE)\n    apply (simp add: full_cap_def)\n   apply clarsimp\n  apply (rule conjI)\n     apply (clarsimp simp add: cap_in_caps_def caps_of_s_e0_caps e0_caps_def)\n   apply (erule disjE)\n    apply (simp add: full_cap_def)\n   apply clarsimp\n  apply (rule conjI)\n   apply (simp add: cap_in_caps_def caps_of_s_e2)\n  apply (simp add: shares_caps_def)\n  apply (simp add: store_connected_s)\n  done", "property": "Capability Rights and Connections:\n- Extra rights of a capability include all the original rights, ensuring that the new capability has at least the same permissions as the original.\n- The system enforces specific connectivity rules between different entities (e0, e1, e2), where e0 is connected to any other entity except e1 and e2, and e1 is connected to e2, but e0 is not connected to either e1 or e2. This ensures controlled and secure communication and access within the system.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma e1_connected_trans_to_e2:\n  \"s \\<turnstile> 1 \\<leftrightarrow>* 2\"\n  apply (insert e1_connected_to_e2)\n  apply (simp add: tgs_connected_def)\n  done\n\n\nlemma caps_of_to_e1:\n  \"\\<lbrakk>c \\<in> caps_of s x; target c = 1\\<rbrakk> \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (case_tac \"x = 0\")\n   apply (fastforce simp: caps_of_s_e0_caps_2)\n  apply (case_tac \"x = 1\")\n   apply (fastforce simp: caps_of_s_e1)\n  apply (fastforce simp: caps_of_s_e3)\n  done\n\nlemma caps_of_to_e2:\n  \"\\<lbrakk>c \\<in> caps_of s x; target c = 2\\<rbrakk> \\<Longrightarrow> x = 1\"\n  apply (case_tac \"x = 0\")\n   apply (fastforce simp: caps_of_s_e0_caps_2)\n  apply (case_tac \"x = 1\")\n   apply (fastforce simp: caps_of_s_e1)\n  apply (fastforce simp: caps_of_s_e3)\n  done\n\nlemma cap_in_caps_caps_of_e1:\n  \"c \\<in>cap caps_of s 1 \\<Longrightarrow> target c = 1 \\<or> target c = 2\"\n  by (clarsimp simp: cap_in_caps_def caps_of_s_e1)\n\nlemma cap_in_caps_caps_of_e2:\n  \"c \\<in>cap caps_of s 2 \\<Longrightarrow> False\"\n  by (clarsimp simp: cap_in_caps_def caps_of_s_e2)\n\nlemma cap_in_caps_caps_of_to_e1:\n  \"\\<lbrakk>c \\<in>cap caps_of s x; target c = 1\\<rbrakk> \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (drule (1) caps_of_to_e1, simp)\n  done\n\nlemma cap_in_caps_caps_of_to_e2:\n  \"\\<lbrakk>c \\<in>cap caps_of s x; target c = 2\\<rbrakk> \\<Longrightarrow> x = 1\"\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (erule (1) caps_of_to_e2)\n  done\n\nlemma e1_connected_to:\n  \"s \\<turnstile> 1 \\<leftrightarrow> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (erule disjE)\n   apply (erule cap_in_caps_caps_of_to_e1, simp)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, simp)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, simp)\n  apply (erule disjE)\n   apply (erule cap_in_caps_caps_of_to_e1, simp)\n  apply (fastforce simp: shares_caps_def store_connected_s)\n  done\n\n\nlemma e2_connected_to:\n  \"s \\<turnstile> 2 \\<leftrightarrow> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (simp add: directly_tgs_connected_def4)\n  apply (erule disjE, rule disjI1)\n   apply (erule cap_in_caps_caps_of_to_e2, simp)\n  apply (erule disjE, rule disjI1)\n   apply (drule cap_in_caps_caps_of_e2, simp)\n  apply (erule disjE, rule disjI1)\n   apply (drule cap_in_caps_caps_of_e2, simp)\n  apply (erule disjE, rule disjI1)\n   apply (erule cap_in_caps_caps_of_to_e2, simp)\n  apply (clarsimp simp: shares_caps_def store_connected_s)\n  done\n\n\nlemma directly_tgs_connected_in_inv_image:\n  \"(directly_tgs_connected s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  by (fastforce simp: inv_image_def\n              dest!: e1_connected_to e1_connected_to [OF directly_tgs_connected_comm]\n                     e2_connected_to e2_connected_to [OF directly_tgs_connected_comm])\n\nlemma connected_inv_image_trans:\n  \"trans (inv_image Id (\\<lambda> x. x=1 \\<or> x=2))\"\n  by (rule trans_inv_image [OF trans_Id])\n\nlemma eq_inv_image_connected:\n  \"(inv_image Id (\\<lambda> x. x=1 \\<or> x=2))\\<^sup>= = inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  by (fastforce simp: inv_image_def)\n\nlemma rtrancl_inv_image_connected:\n  \"(inv_image Id (\\<lambda> x. x=1 \\<or> x=2))\\<^sup>* = inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  apply (subst trancl_reflcl [symmetric])\n  apply (subst eq_inv_image_connected)\n  apply (rule trancl_id)\n  apply (rule connected_inv_image_trans)\n  done\n\nlemma tgs_connected_in_inv_image:\n  \"(tgs_connected s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  apply (simp add: tgs_connected_def)\n  apply (subst rtrancl_inv_image_connected [symmetric])\n  apply (rule rtrancl_mono)\n  apply (rule directly_tgs_connected_in_inv_image)\n  done\n\nlemma e0_not_connected_trans_e1:\n  \"\\<not> s \\<turnstile> 0 \\<leftrightarrow>* 1\"\n  apply clarsimp\n  apply (drule set_mp [OF tgs_connected_in_inv_image])\n  apply (simp add: inv_image_def)\n  done\n\nlemma e0_not_ever_connected_trans_e1:\n  \"s' \\<in> execute cmds s \\<Longrightarrow> \\<not> s' \\<turnstile> 0 \\<leftrightarrow>* 1\"\n  apply clarsimp\n  apply (drule (1) tgs_connected_preserved)\n  apply (simp add: e0_not_connected_trans_e1)\n  done\n\n\nlemma e0_e1_leakage:\n  \"s' \\<in> execute cmds s \\<Longrightarrow> \\<not> leak s' 0 1\"\n  apply (insert e0_not_connected_trans_e1)\n  apply (drule (2) leakage_rule)\n  done", "property": "TGS Connectedness and Leakage: The system ensures that the connectedness between entities 1 and 2 is preserved, and any entity connected to 1 or 2 must be either 1 or 2. Additionally, it guarantees that there is no leakage from entity 0 to entity 1, maintaining the integrity of the security properties.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma island_e0:\n  \"island s 0 = {i. i \\<noteq> 1 \\<and> i \\<noteq> 2}\"\n  apply rule\n   apply (clarsimp simp: island_def)\n   apply (insert tgs_connected_in_inv_image)[1]\n   apply fastforce\n  apply (clarsimp simp: island_def)\n  apply (drule (1) e0_connected_to)\n  apply (drule directly_tgs_connected_comm)\n  by (metis directly_tgs_connected_def2 tgs_connected_comm leakImplyConnectedTrans)\n\nlemma island_e1:\n  \"island s 1 = {1,2}\"\n  apply rule\n   apply (clarsimp simp: island_def)\n   apply (insert tgs_connected_in_inv_image)[1]\n   apply fastforce\n  apply (clarsimp simp: island_def)\n  apply (rule e1_connected_trans_to_e2)\n  done\n\nlemma island_e2:\n  \"island s 2 = {1,2}\"\n  apply rule\n   apply (clarsimp simp: island_def)\n   apply (insert tgs_connected_in_inv_image)[1]\n   apply fastforce\n  apply (clarsimp simp: island_def)\n  apply (rule e1_connected_trans_to_e2  [THEN tgs_connected_comm])\n  done\n\nlemma island_e3:\n  \"\\<lbrakk>x \\<noteq> 1; x \\<noteq> 2\\<rbrakk> \\<Longrightarrow> island s x =  {i. i \\<noteq> 1 \\<and> i \\<noteq> 2}\"\n  apply rule\n   apply (clarsimp simp: island_def)\n   apply (insert tgs_connected_in_inv_image)[1]\n   apply fastforce\n  apply (clarsimp simp: island_def)\n  apply (frule_tac x=x  in e0_connected_to, simp)\n  apply (frule_tac x=xa in e0_connected_to, simp)\n  apply (drule_tac x=0 and y=xa in directly_tgs_connected_comm)\n  apply (rule tgs_connected_comm)\n  apply (simp add: tgs_connected_def)\n  done", "property": "Island Formation: The island function defines the set of elements connected to a given element in the system. Specifically, elements 1 and 2 form an isolated island, while all other elements (excluding 1 and 2) form a separate island. This ensures that the connectivity and isolation properties are maintained within the system.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "lemma e1_flow_to:\n  \"s \\<turnstile> 1 \\<leadsto> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (rule ccontr)\n  apply (clarsimp simp: flow_def set_flow_def island_e1 island_e3)\n  apply (erule disjE, clarsimp)\n   apply (erule disjE)\n    apply (drule cap_in_caps_caps_of_to_e1, clarsimp+)\n   apply (drule cap_in_caps_caps_of_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_to_e2, clarsimp+)\n  apply (drule cap_in_caps_caps_of_e2, clarsimp+)\n  done\n\nlemma e2_flow_to:\n  \"s \\<turnstile> 2 \\<leadsto> x \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (rule ccontr)\n  apply (clarsimp simp: flow_def set_flow_def island_e2 island_e3)\n  apply (erule disjE, clarsimp)\n   apply (erule disjE)\n    apply (drule cap_in_caps_caps_of_to_e1, clarsimp+)\n   apply (drule cap_in_caps_caps_of_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_to_e2, clarsimp+)\n  apply (drule cap_in_caps_caps_of_e2, clarsimp+)\n  done\n\nlemma flow_to_e1:\n  \"s \\<turnstile> x \\<leadsto> 1 \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (rule ccontr)\n  apply (clarsimp simp: flow_def set_flow_def island_e1 island_e3)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_to_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e2, clarsimp+)\n  apply (drule cap_in_caps_caps_of_to_e2, clarsimp+)\n  done\n\nlemma flow_to_e2:\n  \"s \\<turnstile> x \\<leadsto> 2 \\<Longrightarrow> x = 1 \\<or> x = 2\"\n  apply (rule ccontr)\n  apply (clarsimp simp: flow_def set_flow_def island_e2 island_e3)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_to_e1, clarsimp+)\n  apply (erule disjE)\n   apply (drule cap_in_caps_caps_of_e2, clarsimp+)\n  apply (drule cap_in_caps_caps_of_to_e2, clarsimp+)\n  done\n\n\nlemma flow_in_inv_image:\n  \"(flow s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  by (fastforce simp: inv_image_def\n              dest!: e1_flow_to flow_to_e1\n                     e2_flow_to flow_to_e2)\n\n\nlemma flow_trans_in_inv_image:\n  \"(flow_trans s) \\<subseteq> inv_image Id (\\<lambda> x. x=1 \\<or> x=2)\"\n  apply (simp add: flow_trans_def)\n  apply (subst rtrancl_inv_image_connected [symmetric])\n  apply (rule rtrancl_mono)\n  apply (rule flow_in_inv_image)\n  done\n\nlemma e0_not_flow_trans_e1:\n  \"\\<not> s \\<turnstile> 0 \\<leadsto>* 1\"\n  apply clarsimp\n  apply (drule set_mp [OF flow_trans_in_inv_image])\n  apply (simp add: inv_image_def)\n  done\n\nlemma e1_not_flow_trans_e0:\n  \"\\<not> s \\<turnstile> 1 \\<leadsto>* 0\"\n  apply clarsimp\n  apply (drule set_mp [OF flow_trans_in_inv_image])\n  apply (simp add: inv_image_def)\n  done\n\nlemma e0_e1_isolated:\n  \"s' \\<in> execute cmds s \\<Longrightarrow> \\<not> s' \\<turnstile> 0 \\<leadsto>* 1 \\<and> \\<not> s' \\<turnstile> 1 \\<leadsto>* 0\"\n  apply (rule conjI)\n   apply (erule information_flow)\n   apply (rule e0_not_flow_trans_e1)\n  apply (erule information_flow)\n  apply (rule e1_not_flow_trans_e0)\n  done\n\nend", "property": "Information Flow Constraints: The flow and transitive flow relations are constrained such that only states 1 and 2 can flow to or from each other, ensuring that states 0 and 1, as well as states 1 and 0, are isolated in terms of information flow.", "title": "./spec/take-grant/Example2.thy", "chapter": "", "section": "", "comment": "*******************************"}
{"spec": "(* Title:   Confinement_S\n * Description: confinement proof of the security model\n *)\n\ntheory Confine_S\nimports System_S\nbegin", "property": "Confinement Proof: Ensures that the system adheres to the security model by preventing unauthorized access and information flow, maintaining the integrity and confidentiality of the system.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  extra_rights :: \"cap \\<Rightarrow> cap\" where\n  \"extra_rights c \\<equiv>\n  if (Create \\<in> rights c)\n  then c\\<lparr>rights := all_rights\\<rparr>\n  else c\"\n\n\nlemma extra_rights_idem [simp]:\n  \"(extra_rights (extra_rights c)) = (extra_rights c)\"\n  apply (clarsimp simp add: extra_rights_def)\n  done\n\nlemma extra_rights_image_idem [simp]:\n  \"(extra_rights ` (extra_rights ` S)) = (extra_rights ` S)\"\n  by (rule set_eqI) (simp add: image_iff)\n\nlemma extra_rights_empty_rights_ident [simp]:\n   \"extra_rights \\<lparr> target = e, rights = {} \\<rparr> = \\<lparr> target = e, rights = {} \\<rparr>\"\n  by (simp add: extra_rights_def)\n\nlemma entity_extra_rights [simp]:\n  \"target (extra_rights c) = target c\"\n  by (simp add: extra_rights_def)\n\nlemma rights_extra_rights:\n  \"rights (extra_rights c) =\n   (if Create \\<in> (rights c)\n    then all_rights\n    else rights c)\"\n  by (simp add: extra_rights_def)", "property": "Extra Rights Translation: If a capability includes the `Create` right, it is translated to have all possible rights; otherwise, the capability remains unchanged.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " These translate Create into all_rights "}
{"spec": "definition\n  cap_in_caps :: \"cap \\<Rightarrow> cap set \\<Rightarrow> bool\" (infix \"\\<in>cap\" 50) where\n  \"c \\<in>cap C \\<equiv> \\<exists>c' \\<in> C. target c = target c' \\<and> rights (extra_rights c) \\<subseteq> rights (extra_rights c')\"\n\nabbreviation not_cap_in_caps where\n  \"not_cap_in_caps x A \\<equiv> ~ (x \\<in>cap A)\" \\<comment> \\<open>non-membership\\<close>\n\nnotation (input) cap_in_caps (infix \":cap\" 50)\nnotation (latex output)  cap_in_caps (infix \"\\<in>\\<^sub>c\\<^sub>a\\<^sub>p\" 50)\n\nnotation\n  not_cap_in_caps  (\"(\\<notin>cap)\") and\n  not_cap_in_caps  (\"(_/ \\<notin>cap _)\" [51, 51] 50)\n\nnotation (latex output)\n  not_cap_in_caps  (\"(\\<notin>\\<^sub>c\\<^sub>a\\<^sub>p)\") and\n  not_cap_in_caps  (infix \"\\<notin>\\<^sub>c\\<^sub>a\\<^sub>p\" 50)", "property": "Cap Membership: A capability is considered to be in a set of capabilities if there exists a capability in the set with the same target and at least the same or more access rights.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " A cap is in a set, or a cap with more access is. "}
{"spec": "definition\n  caps_dominated_by :: \"cap set \\<Rightarrow> cap \\<Rightarrow> bool\" (infix \"\\<le>cap\" 50) where\n  \"caps \\<le>cap cap \\<equiv> \\<forall>cap' \\<in> caps. target cap' = target cap \\<longrightarrow> rights (extra_rights cap') \\<subseteq> rights (extra_rights cap)\"\n\nnotation (input) caps_dominated_by (infix \"<=cap\" 50)\nnotation (latex output) caps_dominated_by (infix \"\\<unlhd>\\<^sub>c\\<^sub>a\\<^sub>p\" 50)\n\ndefinition\n  shares_caps :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" where\n  \"shares_caps s e\\<^sub>x e\\<^sub>y \\<equiv> \\<exists>e\\<^sub>i . (e\\<^sub>x, e\\<^sub>i) \\<in> store_connected s \\<and> (e\\<^sub>y, e\\<^sub>i) \\<in> store_connected s\"\n\ndefinition\n  leak :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<rightarrow> _\") where\n  \"leak s e\\<^sub>x e\\<^sub>y \\<equiv> take_cap e\\<^sub>x \\<in>cap caps_of s e\\<^sub>y \\<or> grant_cap e\\<^sub>y \\<in>cap caps_of s e\\<^sub>x \\<or> shares_caps s e\\<^sub>x e\\<^sub>y\"\n\n\ndefinition\n  directly_tgs_connected :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"directly_tgs_connected s \\<equiv> {(e\\<^sub>x, e\\<^sub>y). leak s e\\<^sub>x e\\<^sub>y \\<or> leak s e\\<^sub>y e\\<^sub>x}\"\n\nlemma directly_tgs_connected_def2:\n  \"(e\\<^sub>x, e\\<^sub>y) \\<in> directly_tgs_connected s = (leak s e\\<^sub>x e\\<^sub>y \\<or> leak s e\\<^sub>y e\\<^sub>x)\"\n  by (simp add: directly_tgs_connected_def)\n\nabbreviation\n  in_directly_tgs_connected :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<leftrightarrow> _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x \\<leftrightarrow> y \\<equiv> (x,y) \\<in> directly_tgs_connected s\"\n\ndefinition\n  tgs_connected :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"tgs_connected s \\<equiv> (directly_tgs_connected s)\\<^sup>*\"\n\nabbreviation\n  in_tgs_connected :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<leftrightarrow>* _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x \\<leftrightarrow>* y == (x,y) \\<in> tgs_connected s\"\n\nnotation (latex output)\n  in_tgs_connected (\"_ \\<turnstile> _ \\<leftrightarrow>\\<^sup>* _\" [60,0,60] 61)\n\ntranslations\n  \"\\<not> (s \\<turnstile> x \\<leftrightarrow> y)\" <= \"(x,y) \\<notin> CONST directly_tgs_connected s\"\n  \"\\<not> (s \\<turnstile> x \\<leftrightarrow>* y)\" <= \"(x,y) \\<notin> CONST tgs_connected s\"\n\nlemma shares_caps_sym [simp]:\n \"shares_caps s y x = shares_caps s x y\"\n  by (auto simp: shares_caps_def)\n\nlemma directly_tgs_connected_def4:\n  \"s \\<turnstile> e\\<^sub>x \\<leftrightarrow> e\\<^sub>y = (take_cap e\\<^sub>x \\<in>cap caps_of s e\\<^sub>y \\<or> take_cap e\\<^sub>y \\<in>cap caps_of s e\\<^sub>x \\<or>\n                  grant_cap e\\<^sub>y \\<in>cap caps_of s e\\<^sub>x \\<or> grant_cap e\\<^sub>x \\<in>cap caps_of s e\\<^sub>y \\<or>\n                  shares_caps s e\\<^sub>x e\\<^sub>y)\"\n  by (auto simp: directly_tgs_connected_def leak_def)", "property": "Capability Dominance and Sharing: A set of capabilities is considered dominated by another capability if each capability in the set has equal or fewer rights to the target entity. Entities are connected through shared capabilities, and a leak exists between two entities if one can take or grant a capability from or to the other, or if they share a common store. The transitive closure of these direct connections defines the overall connectivity between entities.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " A set of caps \"caps\" have less (or equal) access to an entity as \"cap\" does. "}
{"spec": "definition\n  generalOperation ::\n  \"entity_id \\<Rightarrow> entity_id \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"generalOperation e\\<^sub>0 e\\<^sub>1 c r s \\<equiv>\n  s (e\\<^sub>1 \\<mapsto> Entity ( insert (diminish r (extra_rights c)) (direct_caps_of s e\\<^sub>1) ))\"\n\nlemma is_entity_general [simp]:\n  \"is_entity s e\\<^sub>1 \\<Longrightarrow> is_entity (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) e' = is_entity s e'\"\n  by (simp add: is_entity_def generalOperation_def)\n\ndefinition\n  make_entity :: \"entity_id \\<Rightarrow> modify_state\" where\n  \"make_entity n s \\<equiv>\n  s (n \\<mapsto> null_entity)\"\n\nlemma direct_caps_of_store_connected_eq:\n  \"\\<forall> e. direct_caps_of s e = direct_caps_of s' e\n  \\<Longrightarrow> store_connected s = store_connected s'\"\n  by (simp add: store_connected_def store_connected_direct_def\n                direct_caps_of_def)\n\nlemma direct_caps_of_caps_of_eq:\n  \"\\<forall> e. direct_caps_of s e = direct_caps_of s' e \\<Longrightarrow> caps_of s e = caps_of s' e\"\n  by (simp add: caps_of_def store_connected_def store_connected_direct_def\n                direct_caps_of_def)\n\nlemma direct_caps_of_caps_of_eq2:\n  \"\\<lbrakk>\\<forall> e. direct_caps_of s e = direct_caps_of s' e; c \\<in>cap caps_of s e\\<rbrakk> \\<Longrightarrow> c \\<in>cap caps_of s' e\"\n  apply (drule direct_caps_of_caps_of_eq)\n  apply (simp add: cap_in_caps_def)\n  by auto\n\nlemma direct_caps_of_directly_tgs_connected_eq:\n  \"\\<forall> e. direct_caps_of s e = direct_caps_of s' e \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y = s' \\<turnstile> x \\<leftrightarrow> y\"\n  apply (simp add: directly_tgs_connected_def4 shares_caps_def)\n  apply rule\n   apply (erule disjE, drule (1) direct_caps_of_caps_of_eq2, clarsimp)+\n   apply (drule direct_caps_of_store_connected_eq, clarsimp)\n  apply (erule disjE, drule direct_caps_of_caps_of_eq2 [rotated, where s=s' and s'=s], simp+)+\n  apply (drule direct_caps_of_store_connected_eq, simp)\n  done\n\nlemma direct_caps_of_make_entity:\n  \"\\<not> is_entity s n \\<Longrightarrow> direct_caps_of (make_entity n s) e = direct_caps_of s e\"\n  by (simp add: direct_caps_of_def make_entity_def is_entity_def\n                null_entity_def)\n\nlemma caps_of_make_entity:\n  \"\\<not> is_entity s n \\<Longrightarrow> caps_of (make_entity n s) e = caps_of s e\"\n  apply (rule direct_caps_of_caps_of_eq)\n  apply clarsimp\n  apply (erule direct_caps_of_make_entity)\n  done\n\nlemma caps_of_make_entity2:\n  \"\\<lbrakk>\\<not> is_entity s n; c \\<in> caps_of (make_entity n s) e\\<rbrakk> \\<Longrightarrow> c \\<in> caps_of s e\"\n  apply (drule caps_of_make_entity)\n  apply fastforce\n  done\n\nlemma directly_tgs_connected_make_entity:\n \"\\<not> is_entity s n \\<Longrightarrow> make_entity n s \\<turnstile> x \\<leftrightarrow> y = s \\<turnstile> x \\<leftrightarrow> y\"\n  apply (rule direct_caps_of_directly_tgs_connected_eq)\n  apply clarsimp\n  apply (drule (1) direct_caps_of_make_entity)\n  done\n\nlemma directly_tgs_connected_make_entity2:\n \"\\<lbrakk>\\<not> is_entity s n; make_entity n s \\<turnstile> x \\<leftrightarrow> y\\<rbrakk> \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y\"\n  apply (drule directly_tgs_connected_make_entity)\n  apply fastforce\n  done\n\nlemma diminish_extra_rights [simp]:\n  \"diminish (rights c) (extra_rights c) = c\"\n  by (simp add: diminish_def all_rights_def rights_extra_rights)\n\nlemma diminish_extra_rights2 [simp]:\n  \"diminish (r \\<inter> rights c) (extra_rights c) = diminish r c\"\n  apply (simp add: diminish_def extra_rights_def all_rights_def)\n  apply (simp add: Int_commute)\n  apply (subgoal_tac \"rights c \\<inter> (r \\<inter> rights c) = r \\<inter> rights c\")\n   apply simp\n  apply fastforce\n  done\n\nlemma create_general_helper:\n  \"Create \\<in> rights c\\<^sub>2 \\<Longrightarrow>\n   \\<lparr>target = target c\\<^sub>2, rights = UNIV\\<rparr> = c\\<^sub>2\\<lparr>rights := UNIV\\<rparr>\"\n  by auto\n\nlemma extra_rights_full_cap [simp]:\n  \"extra_rights (full_cap e) = full_cap e\"\n  by (simp add: extra_rights_def)\n\nlemma create_general_alt:\n  \"createOperation e c\\<^sub>1 c\\<^sub>2 s =\n   make_entity (target c\\<^sub>2)\n               (generalOperation  e (target c\\<^sub>1) (full_cap (target c\\<^sub>2)) (all_rights) s)\"\n  by (simp add: createOperation_def generalOperation_def make_entity_def)\n\nlemma create_general:\n  \"Create \\<in> rights c\\<^sub>2 \\<Longrightarrow> createOperation e c\\<^sub>1 c\\<^sub>2 s =\n   make_entity (target c\\<^sub>2)\n               (generalOperation  e (target c\\<^sub>1) c\\<^sub>2 (all_rights) s)\"\n  by (simp add: createOperation_def generalOperation_def make_entity_def\n                full_cap_def all_rights_def diminish_def\n                extra_rights_def create_general_helper null_entity_def)\n\nlemma take_general:\n  \"takeOperation e c\\<^sub>1 c\\<^sub>2 r s =\n   generalOperation (target c\\<^sub>1) e c\\<^sub>2 (r \\<inter> rights c\\<^sub>2) s\"\n  by (simp add: takeOperation_def generalOperation_def)\n\nlemma grant_general:\n  \"grantOperation e c\\<^sub>1 c\\<^sub>2 r s =\n   generalOperation e (target c\\<^sub>1) c\\<^sub>2 (r \\<inter> rights c\\<^sub>2) s\"\n  by (simp add: grantOperation_def generalOperation_def)\n\nlemma copy_general:\n  \"copyOperation e c\\<^sub>1 c\\<^sub>2 r s =\n   generalOperation e (target c\\<^sub>1) c\\<^sub>2 (r \\<inter> rights c\\<^sub>2) s\"\n  by (simp add: copyOperation_def generalOperation_def)", "property": "Entity and Capability Management: Allows the creation, modification, and transfer of capabilities between entities. The operations ensure that the rights and direct capabilities of entities are updated correctly, maintaining the integrity and security of the system. Subproperties include:\n- **Create Operation**: Creates a new entity with full rights based on a given capability.\n- **Take Operation**: Transfers a subset of rights from one entity to another.\n- **Grant Operation**: Grants a subset of rights from one entity to another.\n- **Copy Operation**: Copies a subset of rights from one entity to another.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Note: e\\<^sub>0 is unused. "}
{"spec": "lemma directly_tgs_connected_comm:\n  \"s \\<turnstile> x \\<leftrightarrow> y \\<Longrightarrow> s \\<turnstile> y \\<leftrightarrow> x\"\n  by(auto simp: directly_tgs_connected_def)\n\nlemma tgs_connected_refl [simp]:\n  \"s \\<turnstile> x \\<leftrightarrow>* x\"\n  by (metis tgs_connected_def rtrancl.rtrancl_refl)\n\nlemma tgs_connected_comm:\n  \"s \\<turnstile> x \\<leftrightarrow>* y \\<Longrightarrow> s \\<turnstile> y \\<leftrightarrow>* x\"\n  apply(simp add: tgs_connected_def)\n  apply(erule rtrancl_induct, simp)\n  apply(case_tac \"s \\<turnstile> z \\<leftrightarrow> y\")\n   apply(simp add: directly_tgs_connected_comm)\n  apply(simp add: directly_tgs_connected_comm)\n  done\n\nlemma tgs_connected_comm_eq:\n  \"s \\<turnstile> x \\<leftrightarrow>* y = s \\<turnstile> y \\<leftrightarrow>* x\"\n  by (metis tgs_connected_comm)\n\nlemmas tgs_connected_trans =\n       rtrancl_trans [where r=\"directly_tgs_connected s\"  for s, simplified tgs_connected_def[symmetric]]\n\nlemmas directly_tgs_connected_rtrancl_into_rtrancl =\n       rtrancl_into_rtrancl [where r=\"directly_tgs_connected s\" for s, simplified tgs_connected_def[symmetric]]\n\nlemma take_caps_directly_tgs_connected:\n  \"\\<lbrakk>c \\<in> caps_of s e; Take \\<in> rights c\\<rbrakk> \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\"\n  by (auto simp: directly_tgs_connected_def leak_def take_cap_def cap_in_caps_def extra_rights_def all_rights_def)\n\nlemma grant_caps_directly_tgs_connected:\n  \"\\<lbrakk>c \\<in> caps_of s e; Grant \\<in> rights c\\<rbrakk> \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\"\n  by (auto simp: directly_tgs_connected_def leak_def grant_cap_def cap_in_caps_def extra_rights_def all_rights_def)\n\nlemma create_caps_directly_tgs_connected:\n  \"\\<lbrakk>c \\<in> caps_of s e; Create \\<in> rights c\\<rbrakk> \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\"\n  by (auto simp: directly_tgs_connected_def leak_def cap_in_caps_def rights_extra_rights all_rights_def)\n\nlemma store_connected_directly_tgs_connected:\n  \"(x, y) \\<in> store_connected s \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y\"\n  by (auto simp: directly_tgs_connected_def leak_def shares_caps_def store_connected_def)", "property": "Directly TGS Connected and TGS Connected Properties: The directly_tgs_connected and tgs_connected relations are symmetric and reflexive, and tgs_connected is transitive. Additionally, certain capabilities (Take, Grant, Create) and store connections imply a directly_tgs_connected relationship.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas on the directly_tgs_connected predicate "}
{"spec": "lemma cap_in_caps_insert [simp]:\n  \"c \\<in>cap insert c' S = (target c = target c' \\<and>\n  rights (extra_rights c) \\<subseteq> rights (extra_rights c') \\<or> c \\<in>cap S)\"\n  by (simp add: cap_in_caps_def)\n\nlemma cap_in_caps_singleton [simp]:\n  \"c \\<in>cap {c'} = (target c = target c' \\<and> rights (extra_rights c) \\<subseteq> rights (extra_rights c'))\"\n  by (simp add: cap_in_caps_def)\n\nlemma not_in [simp]:\n  \"{} \\<le>cap c\"\n  by(simp add: caps_dominated_by_def)\n\nlemma extra_rights_diminish:\n  \"x \\<in> rights (extra_rights (diminish r c))\n   \\<Longrightarrow> x \\<in> rights (extra_rights c)\"\n  by (auto simp: rights_extra_rights all_rights_def split:if_split_asm)", "property": "Cap Rights and Insertion Properties: \n- A capability is in the set after insertion if it either matches the target and has a subset of the extra rights of the inserted capability, or it was already in the original set.\n- A capability is in a singleton set if it matches the target and its extra rights are a subset of the extra rights of the singleton capability.\n- The empty set is always dominated by any capability.\n- Diminishing a capability's rights results in a set of rights that is a subset of the original capability's rights.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas on caps "}
{"spec": "definition\n  in_store_connected :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" where\n  \"in_store_connected s x y \\<equiv> (x, y) \\<in> store_connected s\"", "property": "Store Connection: Determines if two entities are connected in the system's store.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas on system operations "}
{"spec": "lemma direct_caps_of_generalOp:\n  \"direct_caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) e =\n  (if e = e\\<^sub>1\n   then insert (diminish r (extra_rights c)) (direct_caps_of s (e\\<^sub>1))\n   else direct_caps_of s e)\"\n  by (clarsimp simp: generalOperation_def direct_caps_of_def split:option.splits)\n\nlemma direct_caps_of_generalOp2:\n  \"\\<lbrakk>c' \\<in> direct_caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x\\<rbrakk> \\<Longrightarrow>\n   c' \\<in> direct_caps_of s x \\<or> (c' \\<in>cap {c} \\<and> x = e\\<^sub>1)\"\n  apply (clarsimp simp: direct_caps_of_generalOp extra_rights_diminish\n           split:if_split_asm)\n  apply (drule extra_rights_diminish)\n  by simp\n\nlemma store_connected_direct_generalOp:\n  \"\\<lbrakk>(x, y) \\<in> store_connected_direct (generalOperation e\\<^sub>0 e\\<^sub>1 c r s)\\<rbrakk> \\<Longrightarrow>\n   (x, y) \\<in> store_connected_direct s \\<or>\n   (x = e\\<^sub>1 \\<and> y = target c \\<and> Store \\<in> rights (extra_rights c))\"\n  by (auto simp: store_connected_direct_def direct_caps_of_generalOp all_rights_def\n          split: if_split_asm)\n\nlemma store_connected_generalOp:\n  \"\\<lbrakk>(x, y) \\<in> store_connected (generalOperation e\\<^sub>0 e\\<^sub>1 c r s)\\<rbrakk> \\<Longrightarrow>\n   (x, y) \\<in> store_connected s \\<or>\n   ((x, e\\<^sub>1) \\<in> store_connected s \\<and>\n   (e\\<^sub>1, target c) \\<in> store_connected_direct (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) \\<and>\n   (target c, y) \\<in> store_connected s)\"\n  apply (unfold store_connected_def)\n  apply (erule rtrancl_induct)\n   apply clarsimp\n  apply (clarsimp)\n  apply (fold store_connected_def)\n  apply (subgoal_tac \"(y, z) \\<in> store_connected_direct s\")\n   apply (clarsimp simp: store_connected_def)\n   apply (erule disjE)\n    apply fastforce\n   apply clarsimp\n   apply (erule notE)\n   apply fastforce\n  apply (frule store_connected_direct_generalOp)\n  apply (clarsimp simp: store_connected_def)\n  done\n\n\nlemma store_connected_generalOp_not_new:\n  \"\\<lbrakk>(e\\<^sub>1, target c) \\<in> store_connected_direct (generalOperation e\\<^sub>0 e\\<^sub>1 c r s);\n   c \\<in> caps_of s e\\<^sub>0\\<rbrakk> \\<Longrightarrow>\n   (e\\<^sub>1, target c) \\<in> store_connected_direct s \\<or>\n   (e\\<^sub>0, target c) \\<in> store_connected s \\<or>\n   Create \\<in> rights c\"\n  apply (drule store_connected_direct_generalOp)\n  apply (clarsimp simp: rights_extra_rights split:if_split_asm)\n   apply (drule (1) store_caps_store_connected, simp)\n  done\n\nlemma store_connected_generalOp2:\n  \"\\<lbrakk>(x, y) \\<in> store_connected (generalOperation e\\<^sub>0 e\\<^sub>1 c r s);\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk> \\<Longrightarrow>\n   s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (drule store_connected_generalOp)\n  apply (erule disjE)\n   apply (simp add: tgs_connected_def)\n   apply (drule store_connected_directly_tgs_connected, simp)\n  apply clarsimp\n  apply (drule store_connected_directly_tgs_connected [where x=x and y=e\\<^sub>1])\n  apply (drule store_connected_directly_tgs_connected [where x=\"target c\" and y=y])\n  apply (drule (1) store_connected_generalOp_not_new)\n  apply (erule disjE)\n   apply (drule store_connected_direct_in_store_connected)\n   apply (drule store_connected_directly_tgs_connected [where x=e\\<^sub>1 and y=\"target c\"])\n   apply (simp add: tgs_connected_def)\n  apply (drule directly_tgs_connected_comm [where x=\"e\\<^sub>0\" and y=\"e\\<^sub>1\"])\n  apply (erule disjE)\n   apply (drule store_connected_directly_tgs_connected [where x=e\\<^sub>0 and y=\"target c\"])\n   apply (simp add: tgs_connected_def)\n  apply (drule (1) create_caps_directly_tgs_connected)\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma shares_caps_of_generalOp:\n  \"\\<lbrakk>shares_caps (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x y;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (clarsimp simp: shares_caps_def)\n  apply (frule (2) store_connected_generalOp2 [where x=x])\n  apply (drule (2) store_connected_generalOp2 [where x=y])\n  apply (drule tgs_connected_comm [where x=y])\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma caps_of_generalOp:\n  \"\\<lbrakk>c' \\<in> caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (simp add: caps_of_def[where e=x])\n  apply clarsimp\n  apply (frule (2) store_connected_generalOp2)\n  apply (drule direct_caps_of_generalOp2)\n  apply (erule disjE)\n   apply (drule direct_cap_in_cap)\n   apply (fastforce simp: cap_in_caps_def)\n  apply (subgoal_tac \"s \\<turnstile> x \\<leftrightarrow>* e\\<^sub>0\")\n   apply (subgoal_tac \"c' \\<in>cap caps_of s e\\<^sub>0\")\n    apply fastforce\n   apply (fastforce simp: cap_in_caps_def)\n  apply clarsimp\n  apply (drule directly_tgs_connected_comm [where x=\"e\\<^sub>0\" and y=\"e\\<^sub>1\"])\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma take_cap_generalOp:\n  \"\\<lbrakk>take_cap y \\<in>cap caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z.  s \\<turnstile> x \\<leftrightarrow>* z \\<and> take_cap y \\<in>cap caps_of s z\"\n  apply (simp add: cap_in_caps_def)\n  apply clarsimp\n  apply (drule (2) caps_of_generalOp)\n  apply (fastforce simp: cap_in_caps_def)\n  done\n\nlemma grant_cap_generalOp:\n  \"\\<lbrakk>grant_cap y \\<in>cap caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z.  s \\<turnstile> x \\<leftrightarrow>* z \\<and> grant_cap y \\<in>cap caps_of s z\"\n  apply (simp add: cap_in_caps_def)\n  apply clarsimp\n  apply (drule (2) caps_of_generalOp)\n  apply (fastforce simp: cap_in_caps_def)\n  done\n\nlemma take_cap_generalOp2:\n  \"\\<lbrakk>take_cap y \\<in>cap caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply (drule (2) take_cap_generalOp)\n  apply clarsimp\n  apply (subgoal_tac \"s \\<turnstile> z \\<leftrightarrow> y\")\n   apply (simp add: tgs_connected_def)\n  apply (simp add: directly_tgs_connected_def leak_def)\n  done\n\nlemma grant_cap_generalOp2:\n  \"\\<lbrakk>grant_cap y \\<in>cap caps_of (generalOperation e\\<^sub>0 e\\<^sub>1 c r s) x;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply (drule (2) grant_cap_generalOp)\n  apply clarsimp\n  apply (subgoal_tac \"s \\<turnstile> z \\<leftrightarrow> y\")\n   apply (simp add: tgs_connected_def)\n  apply (simp add: directly_tgs_connected_def leak_def)\n  done\n\nlemma generalOp_directly_tgs_connected:\n \"\\<lbrakk>generalOperation e\\<^sub>0 e\\<^sub>1 c r s \\<turnstile> x \\<leftrightarrow> y;\n   c \\<in> caps_of s e\\<^sub>0; s \\<turnstile> e\\<^sub>0 \\<leftrightarrow> e\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (simp add: directly_tgs_connected_def [where s=\"generalOperation e\\<^sub>0 e\\<^sub>1 c r s\"] leak_def)\n  apply safe\n       apply (rule tgs_connected_comm)\n       apply (drule (3) take_cap_generalOp2)\n      apply (drule (3) grant_cap_generalOp2)\n     apply (erule (2) shares_caps_of_generalOp)\n    apply (drule (3) take_cap_generalOp2)\n   apply (rule tgs_connected_comm)\n   apply (drule (3) grant_cap_generalOp2)\n  apply (erule (2) shares_caps_of_generalOp)\n  done", "property": "General Operation Impact on Capabilities and Store Connections: The general operation modifies the direct capabilities and store connections in a way that preserves the integrity of the system. Specifically, it updates the direct capabilities for a given endpoint, and ensures that any new store connections are consistent with the existing ones, maintaining the overall structure and security of the capability and store relationships.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas about the general operation "}
{"spec": "lemma create_legal_directly_tgs_connected:\n  \"legal (SysCreate e c\\<^sub>1 c\\<^sub>2) s \\<Longrightarrow> s  \\<turnstile> target c\\<^sub>1 \\<leftrightarrow> e\"\n  apply clarsimp\n  apply (rule directly_tgs_connected_comm)\n  apply (drule (1) create_caps_directly_tgs_connected)\n  apply (drule (1) store_caps_store_connected)\n  apply (drule (1) store_connected_directly_tgs_connected)\n  done\n\nlemma take_legal_directly_tgs_connected:\n  \"legal (SysTake e c\\<^sub>1 c\\<^sub>2 r) s \\<Longrightarrow> s  \\<turnstile> target c\\<^sub>1 \\<leftrightarrow> e\"\n  apply clarsimp\n  apply (rule directly_tgs_connected_comm)\n  apply (drule (2) take_caps_directly_tgs_connected)\n  done\n\nlemma grant_legal_directly_tgs_connected:\n  \"legal (SysGrant e c\\<^sub>1 c\\<^sub>2 r) s \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\\<^sub>1\"\n  apply clarsimp\n  apply (drule (2) grant_caps_directly_tgs_connected)\n  done\n\nlemma copy_legal_directly_tgs_connected:\n  \"legal (SysCopy e c\\<^sub>1 c\\<^sub>2 r) s \\<Longrightarrow> s \\<turnstile> e \\<leftrightarrow> target c\\<^sub>1\"\n  apply clarsimp\n  apply (drule (1) store_caps_store_connected)\n  apply (drule (1) store_connected_directly_tgs_connected)\n  done\n\nlemma caps_of_create:\n  \"\\<lbrakk>c' \\<in> caps_of (createOperation e c\\<^sub>1 c\\<^sub>2 s) x; legal (SysCreate e c\\<^sub>1 c\\<^sub>2) s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (frule create_legal_directly_tgs_connected)\n  apply (clarsimp simp: create_general)\n  apply (drule caps_of_make_entity2 [rotated], clarsimp)\n  apply (drule (1) caps_of_generalOp)\n   apply (drule (2) directly_tgs_connected_comm)\n  done\n\nlemma caps_of_take:\n  \"\\<lbrakk>c' \\<in> caps_of (takeOperation e c\\<^sub>1 c\\<^sub>2 r s) x; legal (SysTake e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (frule take_legal_directly_tgs_connected)\n  apply (clarsimp simp: take_general)\n  apply (drule (2) caps_of_generalOp)\n   apply (drule (1) directly_tgs_connected_comm)\n  done\n\nlemma caps_of_grant:\n  \"\\<lbrakk>c' \\<in> caps_of (grantOperation e c\\<^sub>1 c\\<^sub>2 r s) x; legal (SysGrant e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (frule grant_legal_directly_tgs_connected)\n  apply (clarsimp simp: grant_general)\n  apply (drule (2) caps_of_generalOp)\n   apply (drule (1) directly_tgs_connected_comm)\n  done\n\nlemma caps_of_copy:\n  \"\\<lbrakk>c' \\<in> caps_of (copyOperation e c\\<^sub>1 c\\<^sub>2 r s) x; legal (SysCopy e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. (x,z) \\<in> tgs_connected s \\<and> c' \\<in>cap caps_of s z\"\n  apply (frule copy_legal_directly_tgs_connected)\n  apply (clarsimp simp: copy_general)\n  apply (drule (2) caps_of_generalOp)\n   apply (drule (1) directly_tgs_connected_comm)\n  done\n\nlemma create_directly_tgs_connected:\n \"\\<lbrakk>createOperation e c\\<^sub>1 c\\<^sub>2 s \\<turnstile> x \\<leftrightarrow> y; legal (SysCreate e c\\<^sub>1 c\\<^sub>2) s\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (frule create_legal_directly_tgs_connected)\n  apply (clarsimp simp: create_general)\n  apply (drule directly_tgs_connected_make_entity2 [rotated], clarsimp)\n  apply (drule (1) generalOp_directly_tgs_connected)\n   apply (drule (2) directly_tgs_connected_comm)\n  done\n\nlemma take_directly_tgs_connected:\n \"\\<lbrakk>takeOperation e c\\<^sub>1 c\\<^sub>2 r s \\<turnstile> x \\<leftrightarrow> y; legal (SysTake e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (frule take_legal_directly_tgs_connected)\n  apply (clarsimp simp: take_general)\n  apply (drule (3) generalOp_directly_tgs_connected)\n  done\n\nlemma grant_directly_tgs_connected:\n \"\\<lbrakk>grantOperation e c\\<^sub>1 c\\<^sub>2 r s \\<turnstile> x \\<leftrightarrow> y; legal (SysGrant e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (frule grant_legal_directly_tgs_connected)\n  apply (clarsimp simp: grant_general)\n  apply (drule (3) generalOp_directly_tgs_connected)\n  done\n\nlemma copy_directly_tgs_connected:\n \"\\<lbrakk>copyOperation e c\\<^sub>1 c\\<^sub>2 r s \\<turnstile> x \\<leftrightarrow> y; legal (SysCopy e c\\<^sub>1 c\\<^sub>2 r) s\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply (frule copy_legal_directly_tgs_connected)\n  apply (clarsimp simp: copy_general)\n  apply (drule (3) generalOp_directly_tgs_connected)\n  done\n\n\n\nlemma create_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysCreate e c\\<^sub>1 c\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n   apply (erule disjE, fastforce simp: tgs_connected_def, clarsimp)\n   apply (drule create_directly_tgs_connected, clarsimp, assumption)\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma take_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysTake e c\\<^sub>1 c\\<^sub>2 r)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n   apply (erule disjE, fastforce simp: tgs_connected_def, clarsimp)\n   apply (drule take_directly_tgs_connected, clarsimp, assumption)\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma grant_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysGrant e c\\<^sub>1 c\\<^sub>2 r)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n   apply (erule disjE, fastforce simp: tgs_connected_def, clarsimp)\n   apply (drule grant_directly_tgs_connected, clarsimp, assumption)\n  apply (simp add: tgs_connected_def)\n  done\n\nlemma copy_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysCopy e c\\<^sub>1 c\\<^sub>2 r)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n   apply (erule disjE, fastforce simp: tgs_connected_def, clarsimp)\n   apply (drule copy_directly_tgs_connected, clarsimp, assumption)\n  apply (simp add: tgs_connected_def)\n  done", "property": "System Operations and TGS Connectedness: Ensures that if a system operation (create, take, grant, or copy) is legal, the target and endpoint remain directly TGS connected. Additionally, if the operation results in a new state where two entities are directly TGS connected, they were already TGS connected in the previous state. This property maintains the integrity and consistency of the TGS connections during system operations.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " results from general operation "}
{"spec": "lemma direct_caps_of_destroy:\n  \"c \\<in> direct_caps_of (s(e := None)) x \\<Longrightarrow> c \\<in> direct_caps_of s x\"\n  by (simp add: direct_caps_of_def split: option.splits split: if_split_asm)\n\nlemma store_connected_destroy:\n \"(x, y) \\<in> store_connected (s(e := None)) \\<Longrightarrow> (x, y) \\<in> store_connected s\"\n  apply (simp add: store_connected_def)\n  apply (erule rtrancl_induct)\n   apply simp\n  apply (fold store_connected_def)\n  apply (subgoal_tac \"(y,z) \\<in> store_connected_direct s\")\n   apply (fastforce simp: store_connected_def)\n  apply (simp add: store_connected_direct_def)\n  apply clarsimp\n  by (metis direct_caps_of_destroy)\n\nlemma shares_caps_destroy:\n  \"shares_caps (destroyOperation e c s) x y\n  \\<Longrightarrow> shares_caps s x y\"\n  apply (clarsimp simp: shares_caps_def destroyOperation_def)\n  apply (frule store_connected_destroy [where x=x])\n  apply (drule store_connected_destroy [where x=y])\n  by auto\n\nlemma caps_of_destroy:\n  \"c \\<in> caps_of (destroyOperation e' c' s) e \\<Longrightarrow>\n  c \\<in> caps_of s e\"\n  apply (clarsimp simp add: destroyOperation_def caps_of_def)\n  apply (rule_tac x=x in exI)\n  apply (drule direct_caps_of_destroy)\n  apply simp\n  apply (erule store_connected_destroy)\n  done\n\nlemma destroy_directly_tgs_connected:\n  \"\\<lbrakk>s' \\<in> step (SysDestroy e c) s; (x, y) \\<in> directly_tgs_connected s'\\<rbrakk> \\<Longrightarrow>\n  (x, y) \\<in> directly_tgs_connected s\"\n  apply(clarsimp simp: step_def split: if_split_asm)\n  apply(erule disjE, simp)\n  apply(simp add: directly_tgs_connected_def leak_def)\n  apply (erule disjE)\n   apply(fastforce simp add: cap_in_caps_def dest!: caps_of_destroy)\n  apply (erule disjE)\n   apply(fastforce simp add: cap_in_caps_def dest!: caps_of_destroy)\n  apply (erule disjE)\n   apply (drule shares_caps_destroy, simp)\n  apply (erule disjE)\n   apply(fastforce simp add: cap_in_caps_def dest!: caps_of_destroy)\n  apply (erule disjE)\n   apply(fastforce simp add: cap_in_caps_def dest!: caps_of_destroy)\n  apply (drule shares_caps_destroy, simp)\n  done\n\nlemma destroy_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysDestroy e c)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in>  directly_tgs_connected s\"\n  by(auto dest!: destroy_directly_tgs_connected)", "property": "Destroy Operation Preservation: The destroy operation preserves the relationships and properties of capabilities, ensuring that direct capability connections, store connections, shared capabilities, and directly TGS-connected pairs in the system state remain intact after the operation.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Lemmas about destroy "}
{"spec": "lemma direct_caps_of_remove:\n  \"c \\<in> direct_caps_of (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x \\<Longrightarrow>\n  c \\<in> direct_caps_of s x\"\n  by (clarsimp simp: removeOperation_simpler direct_caps_of_def\n              split: option.splits if_split_asm)\n\nlemma direct_caps_of_remove_eq:\n  \"direct_caps_of (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x =\n  ( if   is_entity s (target c\\<^sub>1) \\<and> x = target c\\<^sub>1\n   then  direct_caps_of s (target c\\<^sub>1) - {c\\<^sub>2}\n   else  direct_caps_of s x )\"\n  by(simp add: direct_caps_of_def is_entity_def removeOperation_def)\n\nlemma store_connected_remove [rule_format]:\n  \"(x, y) \\<in> store_connected (s(e \\<mapsto> Entity C')) \\<Longrightarrow>\n  s e = Some (Entity C) \\<longrightarrow> C' \\<subseteq> C \\<longrightarrow> (x, y) \\<in> store_connected s\"\n  apply (unfold store_connected_def)\n  apply (erule rtrancl_induct)\n   apply simp\n  apply clarsimp\n  apply (subgoal_tac \"(y,z) \\<in> store_connected_direct s\")\n   apply (erule rtrancl_trans)\n   apply fastforce\n  apply (fold store_connected_def)\n  apply (clarsimp simp add: store_connected_direct_def)\n  apply (fastforce simp: direct_caps_of_def\n                  split: option.splits if_split_asm)\n  done\n\nlemma caps_of_remove:\n  \"c \\<in> caps_of (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x \\<Longrightarrow>\n  c \\<in> caps_of s x\"\n  apply (clarsimp simp: caps_of_def)\n  apply (rule_tac x=xa in exI)\n  apply (drule direct_caps_of_remove)\n  apply (simp add: removeOperation_simpler\n            split: option.splits)\n  apply (erule (1) store_connected_remove)\n  apply blast\n  done", "property": "Remove Operation Effects on Capabilities: The removal of a capability through the `removeOperation` function affects the direct and overall capabilities associated with an entity. Specifically, the direct capabilities of the target entity are updated by removing the specified capability, while the overall set of capabilities remains a subset of the original, ensuring that no new capabilities are introduced and existing ones are appropriately adjusted.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " lemmas about remove "}
{"spec": "lemma caps_of_remove2:\n  \"caps_of (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x \\<subseteq> caps_of s x\"\n  apply(simp add: caps_of_def is_entity_def removeOperation_def direct_caps_of_def)\n  apply (clarsimp split: if_split_asm)\n   apply (auto dest!: store_connected_remove)\n  done\n\nlemma shares_caps_remove:\n  \"shares_caps (removeOperation e c\\<^sub>1 c\\<^sub>2 s) x y\n  \\<Longrightarrow> shares_caps s x y\"\n  apply (clarsimp simp: shares_caps_def removeOperation_simpler\n                 split:option.splits)\n  apply (frule (1) store_connected_remove [where x=x], clarsimp)\n  apply (drule (1) store_connected_remove [where x=y], clarsimp)\n  by auto\n\nlemma remove_directly_tgs_connected:\n  \"\\<lbrakk>s' \\<in> step (SysRemove e c\\<^sub>1 c\\<^sub>2) s; (x, y) \\<in> directly_tgs_connected s'\\<rbrakk> \\<Longrightarrow>\n  (x, y) \\<in> directly_tgs_connected s\"\n  apply(simp add: step_def split: if_split_asm)\n  apply(erule disjE, simp)\n  apply(simp add: directly_tgs_connected_def leak_def)\n  apply(simp add: cap_in_caps_def)\n  apply(clarsimp)\n  apply safe\n     prefer 3\n     apply (drule shares_caps_remove, simp)\n    prefer 5\n    apply (drule shares_caps_remove, simp)\n   apply(auto dest!: caps_of_remove)\n  done\n\nlemma remove_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysRemove e c\\<^sub>1 c\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in>  directly_tgs_connected s\"\n  by(auto dest!: remove_directly_tgs_connected)\n\nlemma direct_caps_of_removeSet:\n  \"c' \\<in> direct_caps_of (removeSetOperation e c C s) x \\<Longrightarrow>\n  c' \\<in> direct_caps_of s x\"\n  by (clarsimp simp: removeSetOperation_simpler direct_caps_of_def\n              split: option.splits if_split_asm)\n\nlemma caps_of_removeSet:\n  \"c' \\<in> caps_of (removeSetOperation e c C s) x \\<Longrightarrow>\n  c' \\<in> caps_of s x\"\n  apply (clarsimp simp: caps_of_def)\n  apply (rule_tac x=xa in exI)\n  apply (drule direct_caps_of_removeSet)\n  apply (simp add: removeSetOperation_simpler split: option.splits)\n  apply (erule (1) store_connected_remove)\n  apply blast\n  done\n\nlemma shares_caps_removeSet:\n  \"shares_caps (removeSetOperation e c C s) x y\n  \\<Longrightarrow> shares_caps s x y\"\n  apply (clarsimp simp: shares_caps_def removeSetOperation_simpler split:option.splits)\n  apply (frule (1) store_connected_remove [where x=x], clarsimp)\n  apply (drule (1) store_connected_remove [where x=y], clarsimp)\n  by auto\n\nlemma removeSet_connected:\n  \" \\<lbrakk>s' \\<in> step (SysRemoveSet e c C) s; s' \\<turnstile> x \\<leftrightarrow> y\\<rbrakk> \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y\"\n  apply(simp add: step_def split: if_split_asm)\n  apply(erule disjE, simp)\n  apply(simp add: directly_tgs_connected_def leak_def)\n  apply(simp add: cap_in_caps_def)\n  apply(clarsimp)\n  apply safe\n     prefer 3\n     apply (drule shares_caps_removeSet, simp)\n    prefer 5\n    apply (drule shares_caps_removeSet, simp)\n   apply (auto dest!: caps_of_removeSet)\n  done\n\nlemma removeSet_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; s' \\<turnstile> x \\<leftrightarrow> y; cmd = (SysRemoveSet n c C)\\<rbrakk>\n  \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow> y\"\n  by(auto dest!: removeSet_connected)", "property": "Cap Removal and Connection Preservation: The removal of capabilities (either individually or in a set) from the system state does not introduce new connections between entities. It ensures that any direct or shared capability connections present in the modified state were also present in the original state, preserving the integrity of the system's capability structure.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " Might equal either  \"caps s (target c\\<^sub>1) - {c\\<^sub>2}\" or \"caps s x\" depending if the caps are duplicated."}
{"spec": "lemma direct_caps_of_removeSetOfCaps:\n  \"c' \\<in> direct_caps_of (removeSetOfCaps cap_map s) x \\<Longrightarrow>\n  c' \\<in> direct_caps_of s x\"\n  by (clarsimp simp: removeSetOfCaps_def direct_caps_of_def\n              split: option.splits if_split_asm)\nthm store_connected_remove\n\nlemma store_connected_removeSetOfCaps:\n  \"(x, y) \\<in> store_connected (\\<lambda>e. if is_entity s e\n                                 then Some (Entity (direct_caps_of s e - cap_map e))\n                                 else None) \\<Longrightarrow>\n    (x, y) \\<in> store_connected s\"\n  apply (unfold store_connected_def)\n  apply (erule rtrancl_induct)\n   apply simp\n  apply (subgoal_tac \"(y,z) \\<in> store_connected_direct s\")\n   apply (erule rtrancl_trans)\n   apply fastforce\n  apply (fold store_connected_def)\n  apply (clarsimp simp add: store_connected_direct_def)\n  apply (fastforce simp: direct_caps_of_def\n                  split: option.splits if_split_asm)\n  done\n\nlemma caps_of_removeSetOfCaps:\n  \"c' \\<in> caps_of (removeSetOfCaps cap_map s) x \\<Longrightarrow>\n  c' \\<in> caps_of s x\"\n  apply (clarsimp simp: caps_of_def)\n  apply (rule_tac x=xa in exI)\n  apply (drule direct_caps_of_removeSetOfCaps)\n  apply (simp add: removeSetOfCaps_def split: option.splits)\n  apply (erule store_connected_removeSetOfCaps)\n  done\n\nlemma caps_of_revoke:\n  \"\\<lbrakk>s' \\<in> revokeOperation sub c\\<^sub>1 s ;  c \\<in> caps_of s' e \\<rbrakk>\n  \\<Longrightarrow> c \\<in> caps_of s e\"\n  apply (clarsimp simp: revokeOperation_def\n                 split: if_split_asm)\n  apply (drule (1) caps_of_removeSetOfCaps)\n  done\n\nlemma direct_caps_of_revoke:\n  \"\\<lbrakk>s' \\<in> revokeOperation e c s; c' \\<in> direct_caps_of s' x\\<rbrakk>\n   \\<Longrightarrow> c' \\<in> direct_caps_of s x\"\n  apply (clarsimp simp: revokeOperation_def\n                 split: if_split_asm)\n  apply (drule (1) direct_caps_of_removeSetOfCaps)\n  done\n\nlemma store_connected_revoke:\n \"\\<lbrakk>(x, y) \\<in> store_connected s'; s' \\<in> revokeOperation e c s\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> store_connected s\"\n  apply (simp add: store_connected_def)\n  apply (erule rtrancl_induct)\n   apply simp\n  apply (fold store_connected_def)\n  apply (subgoal_tac \"(y,z) \\<in> store_connected_direct s\")\n   apply (fastforce simp: store_connected_def)\n  apply (clarsimp simp: store_connected_direct_def)\n  apply (metis direct_caps_of_revoke)\n  done\n\nlemma shares_caps_revoke:\n  \"\\<lbrakk>shares_caps s' x y; s' \\<in> revokeOperation e c s\\<rbrakk>\n  \\<Longrightarrow> shares_caps s x y\"\n  apply (clarsimp simp: shares_caps_def)\n  apply (frule (1) store_connected_revoke [where x=x])\n  apply (drule (1) store_connected_revoke [where x=y])\n  by auto\n\nlemma removeOperation_entity_ids [simp]:\n  \"is_entity (removeOperation e c c' s) e' = is_entity s e'\"\n  by (simp add: is_entity_def removeOperation_def)\n\nlemma removeSetOfCaps_entity_ids [simp]:\n  \"is_entity (removeSetOfCaps cap_map s) e' = is_entity s e'\"\n  by (simp add: is_entity_def removeSetOfCaps_def)\n\nlemma revoke_entities:\n  \"s' \\<in> revokeOperation sub c\\<^sub>1 s \\<Longrightarrow> is_entity s' e = is_entity s e\"\n  by (clarsimp simp: revokeOperation_def split: if_split_asm)\n\nlemma revoke_directly_tgs_connected:\n  \"\\<lbrakk>s' \\<in> step (SysRevoke n c\\<^sub>1) s; (x, y) \\<in> directly_tgs_connected s'\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in>  directly_tgs_connected s\"\n  apply (simp add: step_def split: if_split_asm)\n  apply (erule disjE, simp)\n  apply (simp add: directly_tgs_connected_def leak_def)\n  apply (erule disjE)\n   apply(auto simp add: cap_in_caps_def dest!: caps_of_revoke)[1]\n  apply (erule disjE)\n   apply(auto simp add: cap_in_caps_def dest!: caps_of_revoke)[1]\n  apply (erule disjE)\n   apply (drule (1) shares_caps_revoke, simp)\n  apply (erule disjE)\n   apply(auto simp add: cap_in_caps_def dest!: caps_of_revoke)[1]\n  apply (erule disjE)\n   apply(auto simp add: cap_in_caps_def dest!: caps_of_revoke)[1]\n  apply (drule (1) shares_caps_revoke, simp)\n  done\n\nlemma revoke_conTrans:\n  \"\\<lbrakk>s' \\<in> step cmd s; (x, y) \\<in> directly_tgs_connected s'; cmd = (SysRevoke n c\\<^sub>1)\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in>  directly_tgs_connected s\"\n  by(auto dest!: revoke_directly_tgs_connected)", "property": "Revoke Operation Properties: The revoke operation ensures that the capabilities and connectivity in the system are preserved. Specifically, it maintains the direct and indirect capabilities, store connectivity, and shared capabilities between entities. Additionally, it preserves the entity identifiers and the directly connected entities in the system, ensuring that the system's integrity and structure are maintained after a capability is revoked.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " lemmas about revoke "}
{"spec": "lemma is_entity_grant [simp]:\n  \"is_entity s (target c\\<^sub>1) \\<Longrightarrow>\n  is_entity (grantOperation e c\\<^sub>1 c\\<^sub>2 r s) e' = is_entity s e'\"\n  by (simp add: is_entity_def grantOperation_def)\n\nlemma is_entity_destroy:\n  \"is_entity (destroyOperation e' c s) e \\<Longrightarrow> is_entity s e\"\n  by (simp add: destroyOperation_def is_entity_def split: if_split_asm)", "property": "Entity Preservation: The grant and destroy operations maintain the entity status of other entities in the system, ensuring that the existence of an entity is not affected by these operations.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": " lemmas about grant "}
{"spec": "lemma connected_tgs_connected:\n  \"\\<lbrakk>s' \\<in> step cmd s; (e\\<^sub>x, e\\<^sub>y) \\<in> directly_tgs_connected s'\\<rbrakk> \\<Longrightarrow>\n  (e\\<^sub>x, e\\<^sub>y) \\<in> tgs_connected s\"\n  apply(case_tac \"(e\\<^sub>x, e\\<^sub>y) \\<in> directly_tgs_connected s\")\n   apply(simp add: tgs_connected_def)\n   apply(case_tac cmd)\n         apply(rule create_conTrans, fastforce+)\n        apply(rule take_conTrans, fastforce+)\n       apply(rule grant_conTrans, fastforce+)\n      apply(frule copy_conTrans, fastforce+)\n     apply(frule remove_conTrans, fastforce+)\n    apply(frule removeSet_conTrans, fastforce+)\n   apply(frule revoke_conTrans, fastforce+)\n  apply(frule destroy_conTrans, fastforce+)\n  done\n\nlemma tgs_connected_preserved_step:\n  \"\\<lbrakk>s' \\<in> step cmd s; s' \\<turnstile> x \\<leftrightarrow>* z\\<rbrakk> \\<Longrightarrow> s \\<turnstile> x \\<leftrightarrow>* z\"\n  thm rtrancl_induct [where r=\"directly_tgs_connected s'\" and a=x and b=z and P=\"\\<lambda>z. (x, z) \\<in> (directly_tgs_connected s)\\<^sup>*\", simplified,\n                      simplified tgs_connected_def [symmetric]]\n  apply(erule rtrancl_induct [where r=\"directly_tgs_connected s'\",\n                              simplified tgs_connected_def [symmetric]], simp)\n  apply(case_tac \"s \\<turnstile> y \\<leftrightarrow>* z\")\n   apply (erule (1) tgs_connected_trans)\n  apply (simp add: connected_tgs_connected)\n  done\n\nlemma leakImplyConnected:\n  \"leak s\\<^sub>i e\\<^sub>x e\\<^sub>i \\<Longrightarrow> (e\\<^sub>x, e\\<^sub>i) \\<in> directly_tgs_connected s\\<^sub>i\"\n by(simp add: directly_tgs_connected_def)\n\nlemma leakImplyConnectedTrans:\n  \"leak s\\<^sub>i e\\<^sub>x e\\<^sub>i \\<Longrightarrow> (e\\<^sub>x, e\\<^sub>i) \\<in> tgs_connected s\\<^sub>i\"\n  by(simp add: tgs_connected_def, frule leakImplyConnected, auto)\n\n\nlemma tgs_connected_preserved [rule_format]:\n  \"\\<forall>s'. s' \\<in> execute cmds s \\<longrightarrow>\n    s' \\<turnstile> x \\<leftrightarrow>* y \\<longrightarrow>\n    s \\<turnstile> x \\<leftrightarrow>* y\"\n  apply(induct_tac cmds, simp)\n  apply clarsimp\n  apply(rename_tac cmd cmds s'' s')\n  apply(erule_tac x=s' in allE)\n  apply(simp add: tgs_connected_preserved_step)\n  done\n\nlemma leak_conTrans [rule_format]:\n  \"\\<lbrakk>s \\<in> execute cmds s\\<^sub>0; leak s x y\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> tgs_connected s\\<^sub>0\"\n  by (auto intro: leakImplyConnectedTrans tgs_connected_preserved)\n\nlemma leakage_rule:\n  \"\\<lbrakk>s' \\<in> execute cmds s; \\<not> s \\<turnstile> x \\<leftrightarrow>* y\\<rbrakk> \\<Longrightarrow> \\<not> (s' \\<turnstile> x \\<rightarrow> y)\"\n  by(auto simp add: leak_conTrans)", "property": "Transitive Connectedness Preservation: The transitive connectedness between entities is preserved through the execution of commands. If two entities are transitively connected in a state after command execution, they were also transitively connected in the initial state.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": "*******************************************\n ********************************************\n ***** Connected transitively preserved *****\n ********************************************\n *******************************************"}
{"spec": "lemma caps_of_op:\n  \"\\<lbrakk>s' \\<in> step cmd s; c' \\<in> caps_of s' x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z. s \\<turnstile> x \\<leftrightarrow>* z \\<and> c' \\<in>cap caps_of s z\"\n  apply (simp add: step_def split:if_split_asm)\n   prefer 2\n   apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n  apply (erule disjE)\n   apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n  apply (case_tac cmd)\n         apply (simp add: caps_of_create)\n        apply (simp add: caps_of_take)\n       apply (simp add: caps_of_grant)\n      apply (simp add: caps_of_copy)\n     apply (clarsimp, drule caps_of_remove)\n     apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n    apply (clarsimp, drule caps_of_removeSet)\n    apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n   apply (clarsimp, drule (1) caps_of_revoke)\n   apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n  apply (clarsimp, drule caps_of_destroy)\n  apply (fastforce simp: cap_in_caps_def tgs_connected_def rights_extra_rights)\n  done\n\nlemma authority_confinement_induct_step:\n  \"\\<lbrakk>s' \\<in> step cmd s;\n    \\<forall>e\\<^sub>i. s \\<turnstile> e\\<^sub>x \\<leftrightarrow>* e\\<^sub>i \\<longrightarrow> caps_of s e\\<^sub>i \\<le>cap c\\<rbrakk>\n  \\<Longrightarrow> caps_of s' e\\<^sub>x \\<le>cap c\"\n  apply (clarsimp simp: caps_dominated_by_def)\n  apply (drule (1) caps_of_op)\n  apply (fastforce simp: cap_in_caps_def)\n  done\n\nlemma authority_confinement_helper:\n  \"s' \\<in> execute cmds s \\<longrightarrow>\n   (\\<forall>e\\<^sub>i. s \\<turnstile> e\\<^sub>x \\<leftrightarrow>* e\\<^sub>i \\<longrightarrow> caps_of s e\\<^sub>i \\<le>cap c) \\<longrightarrow>\n   (\\<forall>e\\<^sub>i. s' \\<turnstile> e\\<^sub>x \\<leftrightarrow>* e\\<^sub>i \\<longrightarrow> caps_of s' e\\<^sub>i \\<le>cap c)\"\nproof (induct cmds arbitrary: s')\ncase Nil\n  show ?case by clarsimp\nnext\ncase (Cons cmd cmds s')\nshow ?case\n  apply clarsimp\n  apply (rule authority_confinement_induct_step, assumption)\n  apply clarsimp\n  apply (rule Cons.hyps[rule_format], simp_all)\n  apply (drule(1) tgs_connected_preserved_step)\n  apply (simp add: tgs_connected_def)\n  done\nqed\n\nlemma authority_confinement:\n  \"\\<lbrakk>s' \\<in> execute cmds s;\n    \\<forall>e\\<^sub>i. s \\<turnstile> e\\<^sub>x \\<leftrightarrow>* e\\<^sub>i \\<longrightarrow> caps_of s e\\<^sub>i \\<le>cap c\\<rbrakk>\n  \\<Longrightarrow> caps_of s' e\\<^sub>x \\<le>cap c\"\n  by (erule authority_confinement_helper [rule_format, where e\\<^sub>x=e\\<^sub>x], simp_all)\n\nend", "property": "Authority Confinement: Ensures that the capabilities of an entity in the system remain within a specified limit after executing a series of commands. This property maintains the integrity and security of the system by confining the authority of entities, preventing them from gaining more capabilities than initially allowed.", "title": "./spec/take-grant/Confine_S.thy", "chapter": "", "section": "", "comment": "******************************************\n *******************************************\n *****      Authority confinement     *****\n *******************************************\n ******************************************"}
{"spec": "(* Title:   System_S\n * Description: High-level security model of the kernel.\n *)", "property": "High-Level Security Model: Defines the security policies and mechanisms that govern the behavior of the kernel, ensuring that the system's integrity, confidentiality, and availability are maintained.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym entity_id = word32 (* kernel objects - identified by a UID *)\n\ndatatype\n  right = Read      (* Authorise reading of information *)\n         | Write    (* Authorise writing of information *)\n         | Take     (* Having sufficient authority to take a capability from another entity *)\n         | Grant    (* Having sufficient authority to propagate a capability to another entity *)\n         | Create   (* Confers the authority to create new entities *)\n         | Store    (* Simulates CNodeCap - get caps of said entity *)\n\nrecord cap =\n  target :: entity_id      (* The entity over which it has control *)\n  rights :: \"right set\"    (* The control it has over that entity  *)\n\ndatatype entity = Entity \"cap set\"\ndeclare entity.splits [split]\n\ntype_synonym state = \"entity_id \\<Rightarrow> entity option\"\n\ntype_synonym modify_state   = \"state \\<Rightarrow> state\"\ntype_synonym modify_state_n = \"state \\<Rightarrow> state set\"\ntype_synonym mask = \"right set\"\n\ndefinition\n  null_entity :: \"entity\" where\n  \"null_entity \\<equiv> Entity {}\"\n\ndefinition\n  all_rights :: \"right set\" where\n  \"all_rights \\<equiv> UNIV\"\n\nlemma all_rights_def2:\n  \"all_rights = {Read, Write, Take, Grant, Create, Store}\"\n  apply (clarsimp simp: all_rights_def, rule, simp_all, rule, simp)\n  apply (metis right.exhaust)\n  done\n\ndefinition\n  entity_ids :: \"state \\<Rightarrow> entity_id set\" where\n  \"entity_ids s \\<equiv> dom s\"\n\ndefinition\n  is_entity :: \"state \\<Rightarrow> entity_id \\<Rightarrow> bool\" where\n  \"is_entity s e \\<equiv> s e \\<noteq> None\"\n\ndefinition\n  exist :: \"state \\<Rightarrow> cap \\<Rightarrow> bool\" where\n  \"exist s c \\<equiv> is_entity s (target c)\"", "property": "System Entity Rights and Capabilities: Defines system entities with unique identifiers and a set of rights that include read, write, take, grant, create, and store. Each capability is associated with a target entity and a set of these rights, allowing for fine-grained control over the actions that can be performed on or by the entities.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " System entities: Definition of entities that constitute the system\n "}
{"spec": "definition\n  direct_caps :: \"entity \\<Rightarrow> cap set\"\nwhere\n  \"direct_caps e \\<equiv> case e of (Entity c) \\<Rightarrow> c\"\n\ndefinition\n  direct_caps_of :: \"state \\<Rightarrow> entity_id \\<Rightarrow> cap set\"\nwhere\n  \"direct_caps_of s p \\<equiv>\n  case s p of\n    None \\<Rightarrow> {}\n  | Some (Entity e) \\<Rightarrow> e\"\n\ndefinition\n  store_connected_direct :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"store_connected_direct s \\<equiv> {(e\\<^sub>x, e\\<^sub>y). \\<exists>cap. cap \\<in> direct_caps_of s e\\<^sub>x \\<and>\n                                               Store \\<in> rights cap \\<and>\n                                               target cap = e\\<^sub>y}\"\n\ndefinition\n  store_connected :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"store_connected s \\<equiv> (store_connected_direct s)^*\"\n\ndefinition", "property": "Entity Capabilities and Store Connections: Defines the direct capabilities associated with an entity and determines the store-connected relationships between entities based on their capabilities. The store-connected relationship is transitive, capturing all indirect connections through a series of store capabilities.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Manipulating entities. "}
{"spec": "caps_of :: \"state \\<Rightarrow> entity_id \\<Rightarrow> cap set\" where\n  \"caps_of s e  \\<equiv> \\<Union>(direct_caps_of s ` {e' . (e,e') \\<in> store_connected s})\"\n\nlemma caps_rel:\n  \"caps_of s e = \\<Union>(direct_caps_of s ` store_connected s `` {e})\"\n  by (simp add: caps_of_def Image_def)\n\ndefinition  (* All the different capabilities of the system *)\n  all_caps_of :: \"state \\<Rightarrow> cap set\" where\n  \"all_caps_of s \\<equiv> \\<Union>e. direct_caps_of s e\"\n\ndefinition\n  read_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"read_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Read}\\<rparr>\"\n\ndefinition\n  write_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"write_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Write}\\<rparr>\"\n\ndefinition\n  take_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"take_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Take}\\<rparr>\"\n\ndefinition\n  grant_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"grant_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Grant}\\<rparr>\"\n\ndefinition\n  create_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"create_cap e\\<^sub>x \\<equiv> \\<lparr>target = e\\<^sub>x, rights = {Create}\\<rparr>\"\n\ndefinition\n  store_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"store_cap e \\<equiv> \\<lparr>target = e, rights = {Store}\\<rparr>\"\n\ndefinition\n  full_cap :: \"entity_id \\<Rightarrow> cap\" where\n  \"full_cap e \\<equiv> \\<lparr>target = e, rights = all_rights \\<rparr>\"", "property": "Entity Capabilities: Returns the set of all capabilities an entity has access to, either directly or through store connections. This ensures a comprehensive view of the entity's permissions and access rights within the system.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " returns all capabilities an entity has access to\n    (via store or directly) "}
{"spec": "datatype sysOPs =\n    SysCreate entity_id cap cap\n  | SysTake   entity_id cap cap mask\n  | SysGrant  entity_id cap cap mask\n  | SysCopy   entity_id cap cap mask\n  | SysRemove entity_id cap cap\n  | SysRemoveSet entity_id cap \"cap set\"\n  | SysRevoke entity_id cap\n  | SysDestroy entity_id cap", "property": "System Operations: Define a set of primitive kernel operations for managing entities and their capabilities, including creating, taking, granting, copying, removing, revoking, and destroying capabilities, as well as handling sets of capabilities. These operations ensure the proper management and control of system resources and permissions.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " System operations: primitive kernel operations "}
{"spec": "primrec\n  legal :: \"sysOPs \\<Rightarrow> state \\<Rightarrow> bool\"\nwhere\n  \"legal (SysCreate e c\\<^sub>1 c\\<^sub>2) s = (is_entity s e \\<and> is_entity s (target c\\<^sub>1) \\<and> \\<not> (is_entity s (target c\\<^sub>2)) \\<and>\n                                   {c\\<^sub>1, c\\<^sub>2} \\<subseteq> caps_of s e \\<and>\n                                   Write \\<in> rights c\\<^sub>1 \\<and> Store \\<in> rights c\\<^sub>1 \\<and> Create \\<in> rights c\\<^sub>2)\"\n\n| \"legal (SysTake  e c\\<^sub>1 c\\<^sub>2 r) s = (is_entity s e \\<and>  is_entity s (target c\\<^sub>1) \\<and>\n                                  c\\<^sub>1 \\<in> caps_of s e \\<and> c\\<^sub>2 \\<in> caps_of s (target c\\<^sub>1) \\<and> Take \\<in> rights c\\<^sub>1)\"\n\n| \"legal (SysGrant e c\\<^sub>1 c\\<^sub>2 r) s = (is_entity s e \\<and>  is_entity s (target c\\<^sub>1) \\<and>\n                                  {c\\<^sub>1,c\\<^sub>2} \\<subseteq> caps_of s e \\<and> Grant \\<in> rights c\\<^sub>1)\"\n\n| \"legal (SysCopy  e c\\<^sub>1 c\\<^sub>2 r) s   = (is_entity s e \\<and>  is_entity s (target c\\<^sub>1) \\<and>\n                                  {c\\<^sub>1,c\\<^sub>2} \\<subseteq> caps_of s e \\<and> Store \\<in> rights c\\<^sub>1)\"\n\n| \"legal (SysRemove e c\\<^sub>1 c\\<^sub>2) s = (is_entity s e \\<and> c\\<^sub>1 \\<in> caps_of s e)\"\n\n| \"legal (SysRemoveSet e c C) s = (is_entity s e \\<and> c \\<in> caps_of s e)\"\n\n| \"legal (SysRevoke e c) s = (is_entity s e \\<and> c \\<in> caps_of s e)\"\n\n| \"legal (SysDestroy e c) s = (is_entity s e \\<and> c \\<in> caps_of s e \\<and> {Create} = rights c \\<and>\n                              target c \\<notin> target ` (all_caps_of s - {c}))\"", "property": "Operation Legality: Determines if a system operation is allowed based on the current state, ensuring that the involved entities and capabilities meet specific conditions, such as existence, ownership, and required rights.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " determine if an operation is allowed in the given state_s "}
{"spec": "definition\n  diminish :: \"right set \\<Rightarrow> cap \\<Rightarrow> cap\" where\n  \"diminish R cap \\<equiv> cap \\<lparr> rights := rights cap \\<inter> R \\<rparr>\"\n\ndefinition\n  createOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> modify_state\" where\n  \"createOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity (insert (full_cap (target c\\<^sub>2))\n                                (direct_caps_of s (target c\\<^sub>1))),\n     target c\\<^sub>2 \\<mapsto> null_entity)\"\n\nlemma createOperation_def2:\n  \"createOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  let new_cap = \\<lparr> target = target c\\<^sub>2, rights = all_rights \\<rparr>;\n      newTarget = ({new_cap} \\<union> direct_caps_of s (target c\\<^sub>1) )\n  in\n  s (target c\\<^sub>1 \\<mapsto> Entity newTarget, target c\\<^sub>2 \\<mapsto> null_entity)\"\n  by (simp add: createOperation_def Let_def full_cap_def null_entity_def)\n\ndefinition\n  takeOperation :: \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"takeOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (e \\<mapsto> Entity (insert (diminish R c\\<^sub>2) (direct_caps_of s e)))\"\n\nlemma takeOperation_def2:\n  \"takeOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (e \\<mapsto> Entity ({diminish R c\\<^sub>2} \\<union> direct_caps_of s e))\"\n  by (clarsimp simp: takeOperation_def caps_of_def)\n\ndefinition\n  grantOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"grantOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity (insert (diminish R c\\<^sub>2) (direct_caps_of s (target c\\<^sub>1)) )) \"\n\nlemma grantOperation_def2:\n  \"grantOperation e c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity ( {diminish R c\\<^sub>2} \\<union> direct_caps_of s (target c\\<^sub>1)))\"\n  by (clarsimp simp: grantOperation_def caps_of_def)\n\ndefinition\n  copyOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> right set \\<Rightarrow> modify_state\" where\n  \"copyOperation sRef c\\<^sub>1 c\\<^sub>2 R s \\<equiv>\n  s (target c\\<^sub>1 \\<mapsto> Entity (insert (diminish R c\\<^sub>2) (direct_caps_of s (target c\\<^sub>1)))) \"\n\ndefinition\n  removeOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap \\<Rightarrow> modify_state\" where\n  \"removeOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  if is_entity s (target c\\<^sub>1)\n  then\n     s ((target c\\<^sub>1) \\<mapsto> Entity ((direct_caps_of s (target c\\<^sub>1)) - {c\\<^sub>2} ))\n  else\n     s\"\n\nlemma removeOperation_simpler:\n  \"removeOperation e c\\<^sub>1 c\\<^sub>2 s \\<equiv>\n  (case s (target c\\<^sub>1) of\n    None \\<Rightarrow> s\n  | Some (Entity caps) \\<Rightarrow> s (target c\\<^sub>1 \\<mapsto> Entity (caps - {c\\<^sub>2})))\"\n  by (rule eq_reflection, simp add: removeOperation_def is_entity_def direct_caps_of_def\n                             split: if_split_asm option.splits)\n\ndefinition\n  removeSetOperation ::\n  \"entity_id \\<Rightarrow> cap \\<Rightarrow> cap set \\<Rightarrow> modify_state\" where\n  \"removeSetOperation e c C s \\<equiv>\n  if is_entity s (target c) then\n   s ((target c) \\<mapsto> Entity ((direct_caps_of s (target c)) - C ))\n  else\n   s\"\n\nlemma removeSetOperation_simpler:\n  \"removeSetOperation e c caps s \\<equiv>\n  (case s (target c) of\n    None \\<Rightarrow> s\n  | Some (Entity caps') \\<Rightarrow> s (target c \\<mapsto> Entity (caps' - caps)))\"\n  by (auto simp: removeSetOperation_def is_entity_def direct_caps_of_def\n         intro!: eq_reflection\n          split: if_split_asm option.splits)\n\nlemma removeSetOperation_fold_removeOperation:\n  \"removeSetOperation e c (set caps) s = fold (removeOperation e c) caps s\"\n  apply (subst foldr_fold [symmetric])\n   apply (fastforce simp: removeOperation_def direct_caps_of_def is_entity_def)\n  apply (rule sym)\n  apply (induct caps)\n   apply (fastforce simp: removeSetOperation_def removeOperation_def direct_caps_of_def is_entity_def)\n  apply (fastforce simp: removeSetOperation_def removeOperation_def direct_caps_of_def is_entity_def)\n  done\n\ndefinition\n  removeSetOfCaps :: \"(entity_id \\<Rightarrow> cap set) \\<Rightarrow> modify_state\"\nwhere\n  \"removeSetOfCaps cap_map s \\<equiv> \\<lambda>e.\n     if is_entity s e\n     then Some (Entity ((direct_caps_of s e) - cap_map e ))\n     else None\"\n\ndefinition\n  caps_to_entity :: \"entity_id \\<Rightarrow> entity_id \\<Rightarrow> state \\<Rightarrow> cap set\"\nwhere\n  \"caps_to_entity e e' s \\<equiv> {cap. cap \\<in> direct_caps_of s e' \\<and> target cap = e}\"\n\ndefinition\n  revokeOperation :: \"entity_id \\<Rightarrow> cap \\<Rightarrow> modify_state_n\" where\n  \"revokeOperation e c s \\<equiv>\n    {s'. \\<exists>cap_map. \\<forall>e'. cap_map e' \\<subseteq> caps_to_entity (target c) e' s \\<and>\n         s' = removeSetOfCaps cap_map s}\"\n\ndefinition\n  destroyOperation :: \"entity_id \\<Rightarrow> cap \\<Rightarrow> modify_state\" where\n  \"destroyOperation e c s \\<equiv> s(target c := None)\"", "property": "System Operations on Capabilities: These operations modify the system state by creating, diminishing, granting, copying, and removing capabilities. Specifically, they manage the rights and direct capabilities of entities, ensuring that the system's security and integrity are maintained through controlled access and modification of capabilities.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Following functions define how each of the sysOPs modifies the\n * system state_s\n "}
{"spec": "primrec\n  step' :: \"sysOPs \\<Rightarrow> modify_state_n\"\nwhere\n  \"step' (SysCreate    e c\\<^sub>1 c\\<^sub>2) s   = {createOperation e c\\<^sub>1 c\\<^sub>2 s}\"\n| \"step' (SysTake      e c\\<^sub>1 c\\<^sub>2 R) s = {takeOperation  e c\\<^sub>1 c\\<^sub>2 R s}\"\n| \"step' (SysGrant     e c\\<^sub>1 c\\<^sub>2 R) s = {grantOperation  e c\\<^sub>1 c\\<^sub>2 R s}\"\n| \"step' (SysCopy      e c\\<^sub>1 c\\<^sub>2 R) s = {copyOperation e c\\<^sub>1 c\\<^sub>2 R s}\"\n| \"step' (SysRemove    e c\\<^sub>1 c\\<^sub>2)   s = {removeOperation e c\\<^sub>1 c\\<^sub>2 s}\"\n| \"step' (SysRemoveSet e c C)    s = {removeSetOperation e c C s}\"\n| \"step' (SysRevoke    e c) s      =  revokeOperation e c s\"\n| \"step' (SysDestroy   e c) s      = {destroyOperation e c s}\"", "property": "Non-deterministic System Call Execution: Execute a single system operation non-deterministically, where each operation (create, take, grant, copy, remove, remove set, revoke, destroy) is performed based on the provided parameters and the current state.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Non deterministically executing system calls:\n * How we execute a single operation\n "}
{"spec": "definition\n  step :: \"sysOPs \\<Rightarrow> modify_state_n\" where\n  \"step cmd s \\<equiv> if legal cmd s then (step' cmd s) \\<union> {s} else {s}\"", "property": "System Operation Step: Execute a system operation only if it is legal in the current state. If the operation is legal, update the state accordingly; otherwise, the state remains unchanged.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " single operation is allowed only if it is legal in the current state_s "}
{"spec": "primrec\n  execute :: \"sysOPs list \\<Rightarrow> state \\<Rightarrow> state set\"\nwhere\n  \"execute [] s = {s}\"\n| \"execute (cmd#cmds) s = \\<Union> (step cmd ` ( execute cmds s ))\"", "property": "Execution of Command List: Execute a list of commands in reverse order, where each command transitions the system state, and the final state set is the union of all possible states resulting from the execution of each command.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " execution of a list of commands (from back of list)\n "}
{"spec": "lemma Int_all_rights [simp]: \"c \\<inter> all_rights = c\"\n  by (simp add: all_rights_def)\n\nlemma is_entity_dom: \"is_entity s e = (e \\<in> dom s)\"\n  by (simp add: is_entity_def dom_def)\n\nlemma is_entity_imp_not_None:\n  \"is_entity s e \\<Longrightarrow> s e \\<noteq> None\"\n  by (simp add: is_entity_def)\n\nlemma store_connected_refl [simp]:\n  \"(e, e) \\<in> store_connected s\"\n  by (simp add: store_connected_def)\n\nlemma no_caps_of_imp_not_connected [rule_format]:\n  \"\\<lbrakk>(e, x) \\<in> store_connected s\\<rbrakk>\n  \\<Longrightarrow> direct_caps_of s e = {} \\<longrightarrow> x = e\"\n  apply (unfold store_connected_def)\n  apply (erule rtrancl.induct)\n   apply simp\n  apply (clarsimp simp: store_connected_direct_def direct_caps_of_def)\n  done\n\nlemma no_direct_caps_of_no_caps_of:\n  \"(direct_caps_of s e = {}) = (caps_of s e = {})\"\n  apply (rule iffI)\n   apply (clarsimp simp add: caps_of_def)\n   apply (drule (1) no_caps_of_imp_not_connected)\n   apply simp\n  apply (clarsimp simp add: caps_of_def store_connected_def)\n  done\n\nlemma no_direct_caps_of_imp_no_caps_of:\n  \"direct_caps_of s e = {} \\<Longrightarrow> caps_of s e = {}\"\n  by (rule no_direct_caps_of_no_caps_of [THEN iffD1])\n\nlemma no_caps_of_imp_no_direct_caps_of:\n  \"caps_of s e = {} \\<Longrightarrow> direct_caps_of s e = {}\"\n  by (rule no_direct_caps_of_no_caps_of [THEN iffD2])\n\nlemma store_connected_direct_in_store_connected:\n  \"(x, y) \\<in> store_connected_direct s \\<Longrightarrow> (x, y) \\<in> store_connected s\"\n  by (simp add: store_connected_def)\n\nlemma no_diminish [simp]:\n  \"diminish all_rights c = c\"\n  by (simp add: diminish_def)\n\nlemma no_diminish_image [simp]:\n  \"diminish all_rights ` C = C\"\n  by (fastforce)\n\nlemma diminish_diminish [simp]:\n  \"diminish dimR2 (diminish dimR1 sc) = diminish (dimR1 \\<inter> dimR2) sc\"\n  by (clarsimp simp add: diminish_def Int_assoc)\n\nlemma diminish_range_diminish [simp]:\n  \"diminish dimR2 ` diminish dimR1 ` ssc = diminish (dimR1 \\<inter> dimR2) ` ssc\"\n  apply (rule set_eqI)\n  apply (rule iffI)\n   apply (clarsimp)\n  apply (clarsimp simp del: diminish_diminish simp add: diminish_diminish [symmetric])\n  done\n\nlemma execute_not_empty:\n  \"execute ops s \\<noteq> {}\"\n  apply (induct ops)\n   apply (simp)\n  apply (simp add: step_def del: if_image_distrib, fast)\n  done\n\nlemma execute_append [intro]:\n  \"\\<And> s s' s'' opsA. \\<lbrakk> s'' \\<in> execute opsA s; s' \\<in> execute opsB s'' \\<rbrakk> \\<Longrightarrow> s' \\<in> execute (opsB @ opsA) s\"\n  apply (induct opsB)\n   apply (simp)\n  apply (atomize)\n  apply (clarsimp)\n  apply (rule bexI)\n   apply (assumption)\n  by (drule spec | drule(1) mp)+", "property": "Properties of the Model:\n\n- **Entity and Store Relationships**: Defines relationships and properties between entities and the store, including entity existence, connectedness, and capability ownership. Ensures that if an entity is in the store, it is not `None`, and if an entity has no direct capabilities, it also has no indirect capabilities.\n\n- **Capability Rights and Diminishment**: Establishes that the intersection of any capability with all rights remains the same, and the diminish operation on a set of capabilities with all rights does not change the set. Also, the order of applying diminish operations is associative.\n\n- **Execution Properties**: Ensures that the execution of a sequence of operations on a state is non-empty, and the result of executing a concatenated sequence of operations is equivalent to executing each sequence in succession.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": "**************************\n * Lemmas about the model. *\n **************************"}
{"spec": "lemma heapAdd_read_cap [simp]:\n  \"target (read_cap e) = e\"\n  by (simp add: read_cap_def)\n\nlemma rights_read_cap [simp]:\n  \"rights (read_cap e) = {Read}\"\n  by (simp add: read_cap_def)\n\nlemma heapAdd_write_cap [simp]:\n  \"target (write_cap e) = e\"\n  by (simp add: write_cap_def)\n\nlemma rights_write_cap [simp]:\n  \"rights (write_cap e) = {Write}\"\n  by (simp add: write_cap_def)\n\nlemma heapAdd_take_cap [simp]:\n  \"target (take_cap e) = e\"\n  by (simp add: take_cap_def)\n\nlemma rights_take_cap [simp]:\n  \"rights (take_cap e) = {Take}\"\n  by (simp add: take_cap_def)\n\nlemma heapAdd_grant_cap [simp]:\n  \"target (grant_cap e) = e\"\n  by (simp add: grant_cap_def)\n\nlemma rights_grant_cap [simp]:\n  \"rights (grant_cap e) = {Grant}\"\n  by (simp add: grant_cap_def)\n\nlemma heapAdd_create_cap [simp]:\n  \"target (create_cap e) = e\"\n  by (simp add: create_cap_def)\n\nlemma rights_create_cap [simp]:\n  \"rights (create_cap e) = {Create}\"\n  by (simp add: create_cap_def)\n\nlemma heapAdd_store_cap [simp]:\n  \"target (store_cap e) = e\"\n  by (simp add: store_cap_def)\n\nlemma rights_store_cap [simp]:\n  \"rights (store_cap e) = {Store}\"\n  by (simp add: store_cap_def)\n\nlemma heapAdd_full_cap [simp]:\n  \"target (full_cap e) = e\"\n  by (simp add: full_cap_def)\n\nlemma rights_full_cap [simp]:\n  \"rights (full_cap e) = all_rights\"\n  by (simp add: full_cap_def)\n\nlemma entity_diminish [simp]:\n  \"target (diminish R c) = target c\"\n  by (simp add: diminish_def)\n\nlemma rights_diminish [simp]:\n  \"rights (diminish R c) = rights c \\<inter> R\"\n  by (simp add: diminish_def)", "property": "Capability Rights and Target Consistency: The target of a capability remains consistent across various operations, and the rights associated with each capability are defined and maintained according to the operation performed. Subproperties include:\n- The target of read, write, take, grant, create, store, and full capabilities is the same as the entity they reference.\n- The rights of read, write, take, grant, create, and store capabilities are restricted to specific sets of rights (e.g., {Read}, {Write}, {Take}, {Grant}, {Create}, {Store}).\n- The full capability includes all possible rights.\n- Diminishing a capability's rights results in the intersection of the original rights and the specified set of rights, while the target remains unchanged.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Lemma on caps "}
{"spec": "lemma caps_of_imp_some_direct_cap:\n  \"c \\<in> caps_of s e \\<Longrightarrow> \\<exists>e'. c \\<in> direct_caps_of s e'\"\n  by (auto simp: caps_of_def)\n\nlemma caps_of_imp_some_store_connected_direct_cap:\n  \"c \\<in> caps_of s e \\<Longrightarrow> \\<exists>e'. (e, e') \\<in> store_connected s \\<and> c \\<in> direct_caps_of s e'\"\n  by (auto simp: caps_of_def)\n\nlemma direct_cap_in_cap:\n  \"c \\<in> direct_caps_of s e \\<Longrightarrow> c \\<in> caps_of s e\"\n  by (auto simp: caps_of_def store_connected_def)\n\nlemma all_caps_ofE [elim!]:\n  \"\\<lbrakk> c \\<in> all_caps_of s; \\<And>e'. c \\<in> direct_caps_of s e' \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"\n  by (fastforce simp add: all_caps_of_def)\n\nlemma all_caps_ofI [intro]:\n  \"c \\<in> direct_caps_of s e' \\<Longrightarrow> c \\<in> all_caps_of s\"\n  by (fastforce simp add: all_caps_of_def)", "property": "Capability Relationships: Establishes the relationship between capabilities in `caps_of` and `direct_caps_of`, ensuring that any capability in `caps_of` is also present in `direct_caps_of` for some endpoint, and vice versa. Additionally, it defines the conditions under which a capability is included in `all_caps_of`.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Lemmas on caps_of "}
{"spec": "lemma entity_not_not_entity:\n  \"\\<lbrakk>is_entity s e\\<^sub>1; \\<not> is_entity s e\\<^sub>2\\<rbrakk> \\<Longrightarrow> e\\<^sub>1 \\<noteq> e\\<^sub>2\"\n  by (auto simp: is_entity_def)\n\nlemma no_direct_caps_of_in_nonEntity:\n  \"\\<not> is_entity s e \\<Longrightarrow> direct_caps_of s e = {}\"\n  by (auto simp: direct_caps_of_def is_entity_def split:option.splits)\n\nlemma not_is_entity_imp_no_direct_caps_of:\n  \"\\<not> is_entity s e \\<Longrightarrow> caps_of s e = {}\"\n  by (drule no_direct_caps_of_in_nonEntity, erule no_direct_caps_of_imp_no_caps_of)\n\nlemma direct_caps_of_imp_is_entity:\n  \"c \\<in> direct_caps_of s e \\<Longrightarrow> is_entity s e\"\n  by (auto intro: classical dest: no_direct_caps_of_in_nonEntity)\n\nlemma caps_of_imp_is_entity:\n  \"c \\<in> caps_of s e \\<Longrightarrow> is_entity s e\"\n  by (auto intro: classical dest: not_is_entity_imp_no_direct_caps_of)", "property": "Entity and Capability Relationships: Ensures that only entities can have associated capabilities, and non-entities do not possess any direct or indirect capabilities.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Lemmas on entities "}
{"spec": "lemma store_caps_of_store_connected_direct:\n  \"\\<lbrakk>c \\<in> direct_caps_of s e; Store \\<in> rights c\\<rbrakk>\n  \\<Longrightarrow> (e, target c) \\<in> store_connected_direct s\"\n  by (fastforce simp: store_connected_direct_def)\n\nlemma store_caps_store_connected:\n  \"\\<lbrakk>c \\<in> caps_of s e; Store \\<in> rights c\\<rbrakk> \\<Longrightarrow> (e, target c) \\<in> store_connected s\"\n  apply (clarsimp simp: store_connected_def caps_of_def)\n  by (frule (1) store_caps_of_store_connected_direct, simp)\n\nend", "property": "Store-Connected Relationship: If a capability with store rights is present in the direct or overall caps of a source endpoint, then the source and the target of the capability are store-connected.", "title": "./spec/take-grant/System_S.thy", "chapter": "", "section": "", "comment": " Lemmas on store_connected "}
{"spec": "(* Title:   Confinement_S\n * Description: Rephrasing of the confinement proof using the concept of islands.\n *)\n\ntheory Islands_S\nimports Confine_S\nbegin\n\ndefinition\n  island :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id set\" where\n  \"island s x \\<equiv> {e\\<^sub>i. s \\<turnstile> x \\<leftrightarrow>* e\\<^sub>i}\"\n\ndefinition\n  island_caps :: \"state \\<Rightarrow> entity_id \\<Rightarrow> cap set\" where\n  \"island_caps s x \\<equiv> \\<Union>(caps_of s ` island s x)\"\n\nlemma island_caps_def2:\n  \"island_caps s x \\<equiv> \\<Union> e \\<in> island s x. caps_of s e\"\n  by(simp add: island_caps_def)\n\nlemma island_caps_def3:\n  \"island_caps s x =  \\<Union>(direct_caps_of s ` island s x)\"\n  apply (clarsimp simp: island_caps_def)\n  apply rule\n   apply (clarsimp simp: island_def caps_of_def)\n   apply (drule store_connected_directly_tgs_connected)\n   apply (metis directly_tgs_connected_rtrancl_into_rtrancl)\n  apply (fastforce simp: caps_of_def store_connected_def)\n  done\n\nlemma island_caps_dom:\n  \"island_caps s e\\<^sub>x \\<le>cap c =\n  (\\<forall>e\\<^sub>i. (e\\<^sub>x, e\\<^sub>i) \\<in> tgs_connected s \\<longrightarrow> caps_of s e\\<^sub>i \\<le>cap c)\"\n  by (auto simp add: island_caps_def caps_dominated_by_def island_def)\n\nlemma authority_confinement_islands:\n  \"\\<lbrakk>s' \\<in> execute cmds s;\n    island_caps s x \\<le>cap c\\<rbrakk>\n  \\<Longrightarrow> island_caps s' x \\<le>cap c\"\n  apply (simp add: island_caps_dom)\n  apply clarsimp\n  apply (frule (1) tgs_connected_preserved)\n  apply (subst (asm) tgs_connected_comm_eq)\n  apply (erule authority_confinement)\n  apply clarsimp\n  apply (erule_tac x=e\\<^sub>i' in allE)\n  apply (erule impE)\n  apply (metis (opaque_lifting, no_types) tgs_connected_comm_eq tgs_connected_def rtrancl_trans)\n  apply clarsimp\n  done\n\nend", "property": "Authority Confinement in Islands: Ensures that the capabilities within an island remain confined and dominated by a specified capability after executing a set of commands. This property maintains the integrity and security of the system by preventing unauthorized access or modification of capabilities within the island.", "title": "./spec/take-grant/Islands_S.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Isolation_S\nimports Islands_S\nbegin\n\ndefinition\n  set_flow :: \"state \\<Rightarrow> (entity_id set \\<times> entity_id set) set\" where\n  \"set_flow s \\<equiv> {(X,Y). \\<exists>x \\<in> X. \\<exists>y \\<in> Y.\n                        (read_cap x \\<in>cap caps_of s y \\<or>\n                        write_cap y \\<in>cap caps_of s x)}\"\n\nlemma set_flow_def2:\n  \"(X, Y) \\<in> set_flow s = (\\<exists>x \\<in> X. \\<exists>y \\<in> Y.\n                        (read_cap x \\<in>cap caps_of s y \\<or>\n                        write_cap y \\<in>cap caps_of s x))\"\n  by (simp add: set_flow_def)\n\ndefinition\n  flow :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" where\n  \"flow s \\<equiv>  {(x,y). (island s x, island s y) \\<in> set_flow s}\"\n\nlemma flow_def2:\n  \"(x, y) \\<in> flow s = ((island s x, island s y) \\<in> set_flow s)\"\n  by (simp add: flow_def)\n\n\nabbreviation\n  in_flow :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<leadsto> _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x \\<leadsto> y \\<equiv> (x,y) \\<in> flow s\"\n\ndefinition\n  flow_trans :: \"state \\<Rightarrow> (entity_id \\<times> entity_id) set\" (\"flow\\<^sup>*\") where\n  \"flow_trans s \\<equiv> (flow s)\\<^sup>*\"\n\nabbreviation\n  in_flow_trans :: \"state \\<Rightarrow> entity_id \\<Rightarrow> entity_id \\<Rightarrow> bool\" (\"_ \\<turnstile> _ \\<leadsto>* _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x \\<leadsto>* y == (x,y) \\<in> flow_trans s\"\n\nnotation (latex output)\n  in_flow_trans (\"_ \\<turnstile> _ \\<leadsto>\\<^sup>* _\" [60,0,60] 61)\n\ntranslations\n  \"\\<not> (s \\<turnstile> x \\<leadsto> y)\" <= \"(x,y) \\<notin> CONST flow s\"\n  \"\\<not> (s \\<turnstile> x \\<leadsto>* y)\" <= \"(x,y) \\<notin> CONST flow_trans s\"", "property": "Flow and Transitive Flow: Define the flow and transitive flow relationships between entities in a state, where an entity can read or write to another if it has the corresponding capability. The flow relationship is based on the capabilities of the entities, and the transitive flow extends this to include indirect flows through intermediate entities.", "title": "./spec/take-grant/Isolation_S.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "lemma rights_extra_rights_read_cap [simp]:\n  \"rights (extra_rights (read_cap e)) = {Read}\"\n  by (simp add: rights_extra_rights)\n\nlemma rights_extra_rights_write_cap [simp]:\n  \"rights (extra_rights (write_cap e)) = {Write}\"\n  by (simp add: rights_extra_rights)\n\nlemma flow_trans_refl [simp]:\n  \"s \\<turnstile> x \\<leadsto>* x\"\n  by (metis flow_trans_def rtrancl.rtrancl_refl)\n\nlemma flow_connected_step:\n  \"\\<lbrakk>s' \\<turnstile> x \\<leadsto>* y; s' \\<in> step cmd s\\<rbrakk> \\<Longrightarrow>\n    s \\<turnstile> x \\<leadsto>* y\"\n  apply (erule rtrancl_induct [where r=\"flow s'\",\n                              simplified flow_trans_def[symmetric]])\n   apply simp\n  apply (subgoal_tac \"s \\<turnstile> y \\<leadsto> z\")\n   apply (fastforce simp: flow_trans_def rtrancl.rtrancl_into_rtrancl)\n  apply (clarsimp simp: flow_def island_def set_flow_def)\n  apply (frule_tac x=y in tgs_connected_preserved_step, simp)\n  apply (frule_tac x=z in tgs_connected_preserved_step, simp)\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (erule disjE)\n   apply clarsimp\n   apply (drule (1) caps_of_op)\n   apply (clarsimp simp: cap_in_caps_def)\n   apply (metis (no_types) tgs_connected_trans subsetD)\n  apply clarsimp\n  apply (drule (1) caps_of_op)\n  apply (clarsimp simp: cap_in_caps_def)\n  apply (metis (no_types) tgs_connected_trans subsetD)\n  done\n\nlemma flow_connected [rule_format]:\n  \"\\<forall>s'.  s' \\<in> execute cmds s \\<longrightarrow>\n    s' \\<turnstile> x \\<leadsto>* y \\<longrightarrow>\n    s \\<turnstile> x \\<leadsto>* y\"\n  apply (induct_tac cmds, simp)\n  apply clarsimp\n  apply (drule (1) flow_connected_step)\n  apply auto\n  done\n\nlemma information_flow:\n  \"\\<lbrakk>s' \\<in> execute cmds s;\n  \\<not> s \\<turnstile> x \\<leadsto>* y\\<rbrakk> \\<Longrightarrow>\n  \\<not> s' \\<turnstile> x \\<leadsto>* y\"\n  by (auto simp: flow_connected)\n\nend", "property": "Information Flow Preservation: Ensures that if there is no information flow from \\( x \\) to \\( y \\) in the initial state \\( s \\), then there will be no information flow from \\( x \\) to \\( y \\) in any state \\( s' \\) resulting from the execution of a sequence of commands.", "title": "./spec/take-grant/Isolation_S.thy", "chapter": "", "section": "", "comment": " Proof "}
{"spec": "theory Example\nimports System_S\nbegin\n\ndefinition \"id0 \\<equiv> 0\"\ndefinition  \"id1 \\<equiv> 1\"\ndefinition  \"id2 \\<equiv> 2\"\n\ndefinition \"e0 \\<equiv> Entity {\\<lparr> target = id1, rights = {Store}\\<rparr>}\"\ndefinition \"e1 \\<equiv> Entity {\\<lparr> target = id2, rights = {Grant}\\<rparr>}\"\ndefinition \"e2 \\<equiv> Entity {}\"\n\nlemmas id_defs = id0_def id1_def id2_def\nlemmas entity_defs = e0_def e1_def e2_def\n\ndefinition example_state :: \"state\" where\n\"example_state \\<equiv> [0 \\<mapsto> e0, 1 \\<mapsto> e1, 2 \\<mapsto> e2] \"\n\nlemma de0:\n  \"direct_caps_of example_state id0 =\n   {\\<lparr> target = id1, rights = {Store}\\<rparr>}\"\n  by (simp add: direct_caps_of_def example_state_def\n                id_defs entity_defs\n         split: option.splits)\n\nlemma de1:\n  \"direct_caps_of example_state id1 =\n   {\\<lparr> target = id2, rights = {Grant}\\<rparr>}\"\n  by (simp add: direct_caps_of_def example_state_def\n                id_defs entity_defs\n         split: option.splits)\n\nlemma de2: \"direct_caps_of example_state id2 = {}\"\n  by (simp add: direct_caps_of_def example_state_def\n                id_defs entity_defs\n         split: option.splits)\n\n\nlemma scd:\n  \"store_connected_direct example_state = {(id0,id1)}\"\n  by (auto simp: store_connected_direct_def direct_caps_of_def\n                 example_state_def id_defs entity_defs\n          split: if_split_asm option.splits\n           cong: conj_cong)\n\nlemma sc:\n  \"store_connected example_state = {(id0,id1)} \\<union> Id\"\n  apply simp\n  apply (rule equalityI)\n  apply (insert scd)\n   apply (simp add: store_connected_def)\n   apply clarsimp\n   apply (erule converse_rtranclE)\n    apply simp\n   apply clarsimp\n   apply (erule rtranclE)\n    apply simp\n   apply clarsimp\n  apply (fastforce simp: store_connected_def)\n  done\n\nlemma sc': \"store_connected example_state = Id \\<union> {(0,1)}\"\n  by (clarsimp simp: sc id_defs)\n\nlemma ce0:\n  \"caps_of example_state id0 =\n   {\\<lparr>target = id1, rights = {Store}\\<rparr>,\n    \\<lparr>target = id2, rights = {Grant}\\<rparr>}\"\n  by (fastforce simp: caps_of_def sc Collect_disj_eq de0 de1)\n\nlemma ce1:\n  \"caps_of example_state id1 =\n   {\\<lparr> target = id2, rights = {Grant}\\<rparr>}\"\n  apply (clarsimp simp: caps_of_def sc Collect_disj_eq de0 de1)\n  apply (simp add: id0_def id1_def)\n  done\n\nlemma ce2: \"caps_of example_state id2 = {}\"\n  apply (simp add: caps_of_def sc)\n  apply (rule allI)\n  apply (rule conjI)\n   apply (simp add: id0_def id2_def)\n  apply (simp add: de2)\n  done\n\nend", "property": "Entity Capabilities and Store-Connected Relations: Defines the capabilities and store-connected relations for entities in the example state. Each entity has a set of direct capabilities, and the store-connected relation determines the transitive closure of store rights, allowing the identification of all entities that can be reached through a chain of store rights.", "title": "./spec/take-grant/Example.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Defines the instances of pspace_storable objects.\n*)\n\nchapter \"Storable Object Instances\"\n\ntheory ObjectInstances_H\nimports\n  Structures_H\n  State_H\n  PSpaceStorable_H\n  Config_H\nbegin\n\narch_requalify_consts (H)\n  VPtr\n  newContext\n\nlemma projectKO_eq2:\n  \"((obj,s') \\<in> fst (projectKO ko s)) = (projectKO_opt ko = Some obj \\<and> s' = s)\"\n  by (auto simp: projectKO_def fail_def return_def split: option.splits)\n\n\n\\<comment> \\<open>-----------------------------------\\<close>\n\ninstantiation endpoint :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_ep:\n  \"projectKO_opt e \\<equiv> case e of KOEndpoint e \\<Rightarrow> Some e | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_ep [simp]:\n  \"injectKO e \\<equiv> KOEndpoint e\"\n\ndefinition\n  koType_ep [simp]:\n  \"koType (t::endpoint itself) \\<equiv> EndpointT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_ep split: kernel_object.splits)\n\nend\n\ninstantiation notification :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_ntfn:\n  \"projectKO_opt e \\<equiv> case e of KONotification e \\<Rightarrow> Some e | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_ntfn [simp]:\n  \"injectKO e \\<equiv> KONotification e\"\n\ndefinition\n  koType_ntfn [simp]:\n  \"koType (t::notification itself) \\<equiv> NotificationT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_ntfn split: kernel_object.splits)\n\nend\n\n\ninstantiation cte :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_cte:\n  \"projectKO_opt e \\<equiv> case e of KOCTE e \\<Rightarrow> Some e | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_cte [simp]:\n  \"injectKO c \\<equiv> KOCTE c\"\n\ndefinition\n  koType_cte [simp]:\n  \"koType (t::cte itself) \\<equiv> CTET\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_cte split: kernel_object.splits)\n\nend\n\ninstantiation user_data_device :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_user_data_device:\n  \"projectKO_opt e \\<equiv> case e of KOUserDataDevice \\<Rightarrow> Some UserDataDevice | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_user_data_device [simp]:\n  \"injectKO (t :: user_data_device) \\<equiv> KOUserDataDevice\"\n\ndefinition\n  koType_user_data_device [simp]:\n  \"koType (t::user_data_device itself) \\<equiv> UserDataDeviceT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_user_data_device split: kernel_object.splits)\nend\n\ninstantiation user_data :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_user_data:\n  \"projectKO_opt e \\<equiv> case e of KOUserData \\<Rightarrow> Some UserData | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_user_data [simp]:\n  \"injectKO (t :: user_data) \\<equiv> KOUserData\"\n\ndefinition\n  koType_user_data [simp]:\n  \"koType (t::user_data itself) \\<equiv> UserDataT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_user_data split: kernel_object.splits)\n\nend\n\n\ninstantiation tcb :: pre_storable\nbegin\n\ndefinition\n  projectKO_opt_tcb:\n  \"projectKO_opt e \\<equiv> case e of KOTCB e \\<Rightarrow> Some e | _ \\<Rightarrow> None\"\n\ndefinition\n  injectKO_tcb [simp]:\n  \"injectKO t \\<equiv> KOTCB t\"\n\ndefinition\n  koType_tcb [simp]:\n  \"koType (t::tcb itself) \\<equiv> TCBT\"\n\ninstance\n  by (intro_classes,\n      auto simp: projectKO_opt_tcb split: kernel_object.splits)\n\nend\n\n\nlemmas projectKO_opts_defs =\n  projectKO_opt_tcb projectKO_opt_cte projectKO_opt_ntfn projectKO_opt_ep\n  projectKO_opt_user_data projectKO_opt_user_data_device\n\nlemmas injectKO_defs =\n  injectKO_tcb injectKO_cte injectKO_ntfn injectKO_ep injectKO_user_data injectKO_user_data_device\n\nlemmas koType_defs =\n  koType_tcb koType_cte koType_ntfn koType_ep koType_user_data koType_user_data_device\n\n\\<comment> \\<open>-----------------------------------\\<close>\n\ninstantiation endpoint :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY Endpoint\n\ninstance\n  apply (intro_classes)\n  apply simp\n  apply (case_tac ko, auto simp: projectKO_opt_ep updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\ninstantiation notification :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY Notification\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_ntfn updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\ninstantiation cte :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY CTE\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_cte updateObject_cte\n                                 in_monad projectKO_eq2 typeError_def alignError_def\n                           split: kernel_object.splits if_split_asm)\n  done\n\nend\n\n\ninstantiation user_data :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY UserData\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_user_data updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\ninstantiation user_data_device :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY UserDataDevice\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_user_data_device updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\ninstantiation tcb :: pspace_storable\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Instances.lhs instanceproofs bodies_only ONLY TCB\n\ninstance\n  apply (intro_classes)\n  apply (case_tac ko, auto simp: projectKO_opt_tcb updateObject_default_def\n                                 in_monad projectKO_eq2\n                           split: kernel_object.splits)\n  done\n\nend\n\n\nend", "property": "Storable Object Instances: Defines the instances of pspace_storable objects, including endpoints, notifications, CTEs, user data, user data devices, and TCBs. Each instance provides methods for projecting and injecting kernel objects, and specifies the object type, ensuring that these objects can be managed and manipulated within the kernel's physical space.", "title": "./spec/design/skel/ObjectInstances_H.thy", "chapter": "Storable Object Instances", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels.lhs ArchLabels= ONLY GenInvocationLabels InvocationLabel\n#INCLUDE_HASKELL SEL4/API/InvocationLabels.lhs instanceproofs\n\nend", "property": "System Call Enumeration: Defines a comprehensive list of all system call labels, providing a clear and structured reference for invoking various kernel operations.", "title": "./spec/design/skel/InvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of all system call labels.\n"}
{"spec": "theory PSpaceStorable_H\nimports\n  Structures_H\n  KernelStateData_H\n  \"Lib.DataMap\"\nbegin\n\narch_requalify_types (H)\n  arch_kernel_object_type\n\narch_requalify_consts (H)\n  archTypeOf\n\nlemma UserData_singleton [simp]:\n  \"(v = UserData) = True\" \"(UserData = v) = True\"\n  by (cases v, simp)+\n\nlemma UserDataDevice_singleton [simp]:\n  \"(v = UserDataDevice) = True\" \"(UserDataDevice = v) = True\"\n  by (cases v, simp)+\n\ndatatype\n  kernel_object_type =\n    EndpointT\n  | NotificationT\n  | CTET\n  | TCBT\n  | UserDataT\n  | UserDataDeviceT\n  | KernelDataT\n  | ArchT arch_kernel_object_type\n\nprimrec\n  koTypeOf :: \"kernel_object \\<Rightarrow> kernel_object_type\"\nwhere\n  \"koTypeOf (KOEndpoint e) = EndpointT\"\n| \"koTypeOf (KONotification e) = NotificationT\"\n| \"koTypeOf (KOCTE e) = CTET\"\n| \"koTypeOf (KOTCB e) = TCBT\"\n| \"koTypeOf (KOUserData) = UserDataT\"\n| \"koTypeOf (KOUserDataDevice) = UserDataDeviceT\"\n| \"koTypeOf (KOKernelData) = KernelDataT\"\n| \"koTypeOf (KOArch e) = ArchT (archTypeOf e)\"\n\ndefinition\n  typeError :: \"unit list \\<Rightarrow> kernel_object \\<Rightarrow> 'a kernel\" where\n  \"typeError t1 t2 \\<equiv> fail\"\n\ndefinition\n  alignError :: \"nat \\<Rightarrow> 'a kernel\" where\n  \"alignError n \\<equiv> fail\"\n\ndefinition\n  alignCheck :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> unit kernel\" where\n  \"alignCheck x n \\<equiv> unless ((x && mask n) = 0) $ alignError n\"\n\ndefinition\n  magnitudeCheck :: \"machine_word \\<Rightarrow> machine_word option \\<Rightarrow> nat \\<Rightarrow> unit kernel\"\nwhere\n \"magnitudeCheck x y n \\<equiv> case y of None \\<Rightarrow> return ()\n               | Some z \\<Rightarrow> when (z - x < 1 << n) fail\"\n\nclass pre_storable =\n  fixes injectKO :: \"'a \\<Rightarrow> kernel_object\"\n  fixes projectKO_opt :: \"kernel_object \\<Rightarrow> 'a option\"\n  fixes koType :: \"'a itself \\<Rightarrow> kernel_object_type\"\n\n  assumes project_inject: \"(projectKO_opt ko = Some v) = (injectKO v = ko)\"\n  assumes project_koType: \"(\\<exists>v. projectKO_opt ko = Some (v::'a)) = (koTypeOf ko = koType TYPE('a))\"\nbegin\n\ndefinition\n  projectKO :: \"kernel_object \\<Rightarrow> 'a kernel\"\nwhere\n  \"projectKO e \\<equiv>\n  case projectKO_opt e of None \\<Rightarrow> fail | Some k \\<Rightarrow> return k\"\n\ndefinition\n  objBits :: \"'a \\<Rightarrow> nat\"\nwhere\n  \"objBits v \\<equiv> objBitsKO (injectKO v)\"\n\ndefinition\n  loadObject_default :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word option \\<Rightarrow> kernel_object \\<Rightarrow> 'a kernel\"\nwhere\n  \"loadObject_default ptr ptr' next obj \\<equiv> do\n     assert (ptr = ptr');\n     val \\<leftarrow> projectKO obj;\n     alignCheck ptr (objBits val);\n     magnitudeCheck ptr next (objBits val);\n     return val\n  od\"\n\ndefinition\n  updateObject_default :: \"'a \\<Rightarrow> kernel_object \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word option \\<Rightarrow> kernel_object kernel\"\nwhere\n  \"updateObject_default val oldObj ptr ptr' next \\<equiv> do\n     assert (ptr = ptr');\n     (_ :: 'a) \\<leftarrow> projectKO oldObj;\n     alignCheck ptr (objBits val);\n     magnitudeCheck ptr next (objBits val);\n     return (injectKO val)\n  od\"\n\nend\n\nclass pspace_storable = pre_storable +\n  fixes makeObject :: 'a\n\n  \\<comment>\\<open>\n    `loadObject` is only used in the generic definition of `getObject`. It\n    describes how to extract a value of type `'a` from memory.\n\n    If `(obj, _) \\<in> loadObjext p before after ko` within `getObject`, then:\n      - @{term \"p :: machine_word\"} is the addres that we want to read an\n        instance of `'a` from.\n      - @{term \"before :: machine_word\"} is the address of the nearest\n        object at or before `p`.\n      - @{term \"after :: machine_word option\"} is the address of the nearest\n        object after `p`, if any (for checking overlap).\n      - @{term \"ko :: kernel_object\"} is the object currently at `before`.\n      - @{term \"obj :: 'a\"} is the value extracted from `ko`.\n\n    Graphically, the \"memory\" looks like this:\n\n    before  p              after\n    |-------|--+-----+-----|---|\n    |       +~~+ <---+---------- The span of obj, the object we want to extract.\n    +~~~~~~~~~~~~~~~~+ <-------- The span of ko, the existing object that spans obj.\n\n                           +~~~+ The span of whatever object comes after obj.\n                                 We don't care about this beyond making sure\n                                 it doesn't overlap with ko.\n\n    In almost every case, the object in memory (ko) is the same type of object\n    as the one being loaded (obj). For example, for a reply object our parameters\n    look like this:\n\n    p, before\n    |-----------|\n    +~~~~~~~~~~~+ <- The span of two objects:\n                     - ko, the existing object (which should be a reply object).\n                     - obj, the object that we want to load from memory. This will\n                       just be ko projected through @{term projectKO}.\n\n    In these simple cases, @{term loadObject_default} is a good specification\n    for how to load an instance of `'a` from memory.\n\n    The only interesting case is when we're loading a CTE, which might be\n    inside a TCB. Then memory looks like this:\n\n    before  p\n    |-------|--+-----+\n    |       +~~+ <---+---- The span of obj, i.e. the CTE which we're reading from\n    |                |     memory.\n    +~~~~~~~~~~~~~~~~+ <-- The span of ko, i.e. the TCB surrounding and containing\n                           obj.\n\n    In this case, the process for extracting the CTE from the surrounding TCB\n    is more involved. See `loadObject_cte` in `ObjectInstances_H`.\n  \\<close>\n  fixes loadObject :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word option \\<Rightarrow> kernel_object \\<Rightarrow> 'a kernel\"\n\n  \\<comment>\\<open>\n    `updateObject` is only used in the generic definition of `setObject`,\n    but it shows up in a few lemma statements as well. It describes how to update\n    the kernel object contents of memory depending on what's already in that\n    memory.\n\n    If `(ko', _) \\<in> updateObject v ko p before after s` within `setObject`, then:\n      - @{term \"v :: 'a\"} is the new object you want to write at pointer\n        @{term \"p :: machine_word\"}.\n      - @{term \"before :: machine_word\"} is the address of the nearest\n        object at or before `p`.\n      - @{term \"ko :: kernel_object\"} is the object currently at `before`.\n      - @{term \"after :: machine_word option\"} should be the address of the nearest\n        object after `p`, if any (for checking overlap).\n      - The returned value @{term \"ko' :: kernel_object\"} is the old object `ko`,\n        updated as required by `v`. This value gets inserted by `setObject` into\n        memory at the address `before`.\n\n    Graphically, the \"memory\" looks like this:\n\n    before  p              after\n    |-------|--+-----+-----|---|\n    |       +~~+ <---+---------- The span of v, the object we want to insert.\n    +~~~~~~~~~~~~~~~~+ <-------- The span of ko, the existing object that spans v.\n                                 This is also the span of ko', which will be what\n                                 gets put into memory after the update.\n\n                           +~~~+ The span of whatever object comes after ko.\n                                 We don't care about this beyond making sure\n                                 it doesn't overlap with ko before or after it\n                                 gets updated with v.\n\n    In almost every case, the object in memory (ko) is the same type of object\n    as the one being inserted (v). For example, for a reply object our parameters\n    look like this:\n\n    p, before\n    |-----------|\n    +~~~~~~~~~~~+ <- The span of three objects:\n                     - v, the new reply object we want to insert.\n                     - ko, the existing object (which should be a reply object).\n                     - ko', the new object (which should be a reply object if\n                       the previous one was).\n\n    In these simple cases, @{term updateObject_default} is a good specification\n    for how to update the existing kernel object.\n\n    The only interesting case is when we're updating a CTE, which might be\n    inside a TCB. Then memory looks like this:\n\n    before  p\n    |-------|--+-----+\n    |       +~~+ <---+---- The span of v, i.e. the CTE which we're inserting into\n    |                |     memory.\n    +~~~~~~~~~~~~~~~~+ <-- The span of ko, i.e. the TCB surrounding and containing v.\n                           This is also the span of ko', which is \"just\" a copy\n                           of ko with the relevant CTE updated.\n\n    In this case, the process for updating the surrounding TCB is more involved.\n    See `updateObject_cte` in `ObjectInstances_H`.\n  \\<close>\n  fixes updateObject :: \"'a \\<Rightarrow> kernel_object \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow>\n                              machine_word option \\<Rightarrow> kernel_object kernel\"\n\n  \\<comment>\\<open>\n    If updating an object succeeds, then the type of the updated object (ko')\n    should be the same as the original object (ko).\n  \\<close>\n  assumes updateObject_type:\n  \"(ko', s') \\<in> fst (updateObject v ko p p' p'' s) \\<Longrightarrow> koTypeOf ko' = koTypeOf ko\"\n\nend", "property": "Pspace Storable Objects: Defines a framework for managing kernel objects in memory, including loading and updating objects while ensuring type and alignment constraints. The framework ensures that the type of an object remains consistent after updates and that objects are correctly aligned and do not overlap with adjacent objects in memory.", "title": "./spec/design/skel/PSpaceStorable_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"CNodes\"\n\ntheory CNode_H\nimports\n  FaultMonad_H\n  ThreadDecls_H\n  RetypeDecls_H\n  TCBDecls_H\n  CSpaceDecls_H\n  EndpointDecls_H\n  PSpaceFuns_H\nbegin\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs\n\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs decls_only NOT cteRevoke\n\nfunction\n  cteRevoke :: \"machine_word \\<Rightarrow> unit kernel_p\"\nwhere\n \"cteRevoke p s =\n\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY cteRevoke\n\n  p s\"\nby auto\n\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs bodies_only NOT finaliseSlot cteRevoke cteDeleteOne noReplyCapsFor\n\nend", "property": "CNode Operations: Provides functions to manage capabilities within CNodes, including revoking a capability at a specified location. This ensures that the system can dynamically modify and control the capabilities stored in CNodes, maintaining the integrity and security of the capability space.", "title": "./spec/design/skel/CNode_H.thy", "chapter": "CNodes", "section": "", "comment": ""}
{"spec": "theory InterruptDecls_H\nimports\n  RetypeDecls_H\n  KI_Decls_H\nbegin\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs\n#INCLUDE_HASKELL SEL4/Object/Interrupt.lhs Arch=ArchInterrupt_H decls_only NOT deletedIRQHandler\n\nend", "property": "Interrupt Declarations: Define the structures and declarations for interrupt objects, including their properties and methods, to manage and handle interrupts within the system.", "title": "./spec/design/skel/InterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"CSpace\"\n\ntheory CSpace_H\nimports CSpaceDecls_H Object_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/CSpace.lhs bodies_only NOT resolveAddressBits\n\n\nfunction\n  resolveAddressBits ::\n  \"capability \\<Rightarrow> cptr \\<Rightarrow> nat \\<Rightarrow>\n   (lookup_failure, (machine_word * nat)) kernel_f\"\nwhere\n \"resolveAddressBits a b c =\n#INCLUDE_HASKELL SEL4/Kernel/CSpace.lhs BODY resolveAddressBits\na b c\"\n  by auto\n\ntermination\n  apply (relation \"measure (snd o snd)\")\n  apply (auto simp add: in_monad split: if_split_asm)\n  done\n\ndefs\n  resolveAddressBits_decl_def:\n  \"CSpaceDecls_H.resolveAddressBits \\<equiv> resolveAddressBits\"\ndeclare resolveAddressBits_decl_def[simp]\n\nend", "property": "Resolve Address Bits: The function resolves the address bits of a capability based on the provided cptr and bit count, returning the corresponding machine word and bit count. This ensures that the capability's address is correctly interpreted within the CSpace.", "title": "./spec/design/skel/CSpace_H.thy", "chapter": "CSpace", "section": "", "comment": ""}
{"spec": "definition\n  ptrBits_def[simp]:\n \"ptrBits \\<equiv> to_bl\"\n\n#INCLUDE_HASKELL SEL4/Model/PSpace.lhs ONLY ptrBitsForSize", "property": "Convert Pointer to Bit List: The function `ptrBits` converts a pointer into its bit representation, returning the result as a list of bits.", "title": "./spec/design/skel/PSpaceStruct_H.thy", "chapter": "", "section": "", "comment": "Helper Functions"}
{"spec": "#INCLUDE_HASKELL SEL4/Model/PSpace.lhs Data.Map=DataMap ONLY PSpace\n\nend", "property": "Physical Memory Management: Manages the allocation, deallocation, and organization of physical memory, ensuring efficient and secure memory usage.", "title": "./spec/design/skel/PSpaceStruct_H.thy", "chapter": "", "section": "", "comment": "Physical Memory Structures"}
{"spec": "chapter \"Function Declarations for Threads\"\n\ntheory ThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\n  ArchThreadDecls_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs decls_only NOT transferCapsToSlots\n\nend", "property": "Function Declarations for Threads: Defines the necessary function declarations for thread management, including structures, fault handling, kernel initialization, and architecture-specific thread operations.", "title": "./spec/design/skel/ThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "(*\n    The fault datatype.\n*)\n\nchapter \"Fault Structures\"\n\ntheory Fault_H\nimports ArchFault_H\nbegin\n\narch_requalify_types (H)\n  arch_fault\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Types.lhs\n#INCLUDE_HASKELL SEL4/API/Failures.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Failures.lhs bodies_only\n\nend", "property": "Fault Structures: Define and handle different types of faults, including architecture-specific faults, to ensure the system can properly identify, report, and manage errors and exceptions.", "title": "./spec/design/skel/Fault_H.thy", "chapter": "Fault Structures", "section": "", "comment": ""}
{"spec": "chapter \"Function Declarations for Retyping Objects\"\n\ntheory RetypeDecls_H\nimports\n  ArchRetypeDecls_H\n  Structures_H\n  FaultMonad_H\n  Invocations_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType.lhs decls_only\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt.lhs decls_only ONLY deletedIRQHandler\n\nend", "property": "Object Retyping Function Declarations: Define the necessary functions and data structures for redefining object types, including handling interrupts and managing object types.", "title": "./spec/design/skel/RetypeDecls_H.thy", "chapter": "Function Declarations for Retyping Objects", "section": "", "comment": ""}
{"spec": "end", "property": "Collection of SEL4 Model Modules: Aggregates and organizes the various SEL4 model modules into a cohesive framework for system specification and verification.", "title": "./spec/design/skel/Object_H.thy", "chapter": "", "section": "", "comment": "\n  this theory collects the SEL4.Model.* modules\n"}
{"spec": "requalify_consts\n  activateIdleThread", "property": "Activate Idle Thread: Enables the activation of an idle thread, ensuring that the system can efficiently manage resources and maintain optimal performance when no other threads are ready to run.", "title": "./spec/design/skel/Thread_H.thy", "chapter": "", "section": "", "comment": " match Haskell, expects these under Arch. "}
{"spec": "requalify_consts (aliasing)\n  configureIdleThread\n  switchToIdleThread\n  switchToThread\n\ncontext begin global_naming global\n\nrequalify_consts (aliasing)\n  ThreadDecls_H.configureIdleThread\n  ThreadDecls_H.switchToIdleThread\n  ThreadDecls_H.switchToThread\n\nend\nend\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs Arch=Arch bodies_only NOT doNormalTransfer doIPCTransfer doReplyTransfer doNormalTransfer transferCaps transferCapsToSlots\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs Arch=Arch ONLY transferCapsToSlots\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs Arch=Arch bodies_only ONLY doNormalTransfer doIPCTransfer doReplyTransfer doNormalTransfer transferCaps\n\nend", "property": "Namespace Disambiguation: Resolve naming conflicts between architecture-specific and non-architecture-specific constants by requalifying them with their respective namespaces.", "title": "./spec/design/skel/Thread_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "chapter \"Function Declarations for Notifications\"\n\ntheory NotificationDecls_H imports    \"FaultMonad_H\"\n begin\n\n#INCLUDE_HASKELL SEL4/Object/Notification.lhs decls_only\n\nend", "property": "Notification Function Declarations: Define the necessary functions for managing notifications, including creating, binding, and unbinding notification objects, as well as handling notification events.", "title": "./spec/design/skel/NotificationDecls_H.thy", "chapter": "Function Declarations for Notifications", "section": "", "comment": ""}
{"spec": "chapter \"Deleting Capabilities\"\n\ntheory Delete_H\nimports\n  CNode_H\n  Interrupt_H\n  Endpoint_H\n  Thread_H\nbegin\n\ndefinition\n  slotsPointed :: \"capability \\<Rightarrow> machine_word set\"\nwhere\n \"slotsPointed cap \\<equiv> case cap of\n   CNodeCap ptr a b c   \\<Rightarrow> {ptr}\n | ThreadCap ptr        \\<Rightarrow> {ptr}\n | Zombie ptr bits num  \\<Rightarrow> {ptr}\n | _                    \\<Rightarrow> {}\"\n\nprimrec\n  sethelper :: \"bool \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\nwhere\n  \"sethelper True  s = {}\"\n| \"sethelper False s = s\"\n\nfunction\n  finaliseSlot' :: \"machine_word \\<Rightarrow> bool \\<Rightarrow> (bool * capability) kernel_p\"\nwhere\n \"finaliseSlot' x b s =\n(\\<lambda> finaliseSlot.\n(\\<lambda> cteDelete.\n(\\<lambda> reduceZombie.\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY finaliseSlot\n)\n(\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY reduceZombie\n)\n)\n(\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY cteDelete\n)\n)\nfinaliseSlot' x b s\"\n\n  by auto\n\ndefs\n  finaliseSlot_def:\n \"finaliseSlot \\<equiv> finaliseSlot'\"\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs\n\nfunction\n  cteDeleteOne' :: \"machine_word \\<Rightarrow> unit kernel\"\nwhere\n \"cteDeleteOne' x s =\n(\\<lambda> cteDeleteOne.\n(\\<lambda> deletingIRQHandler.\n(\\<lambda> cancelIPC.\n(\\<lambda> suspend.\n(\\<lambda> finaliseCap.\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY cteDeleteOne\n)\n(\n#INCLUDE_HASKELL SEL4/Object/ObjectType.lhs Arch=Arch BODY finaliseCap\n)\n)\n(\n#INCLUDE_HASKELL SEL4/Kernel/Thread.lhs BODY suspend\n)\n)\n(\n#INCLUDE_HASKELL SEL4/Object/Endpoint.lhs BODY cancelIPC\n)\n)\n(\n#INCLUDE_HASKELL SEL4/Object/Interrupt.lhs BODY deletingIRQHandler\n)\n)\ncteDeleteOne' x s\"\n\n  by auto\n\ndefs\n  cteDeleteOne_def1:\n \"cteDeleteOne \\<equiv> cteDeleteOne'\"\n\ntermination cteDeleteOne'\n  by (rule cteDeleteOne'.termination[OF wf_empty], simp+)\n\nlemma cteDeleteOne_def:\n \"cteDeleteOne =\n(\n#INCLUDE_HASKELL SEL4/Object/CNode.lhs BODY cteDeleteOne\n)\"\n  apply (rule ext)+\n  apply (subst cteDeleteOne_def1)\n  apply (subst cteDeleteOne'.simps)\n  apply (unfold finaliseCap_def suspend_def cancelIPC_def\n                deletingIRQHandler_def cteDeleteOne_def1)\n  apply (rule refl)\n  done\n\nlemma card_reduce:\n  \"(s :: ('a :: finite) set) \\<inter> s' = {} \\<Longrightarrow> card (UNIV - (s \\<union> s')) < card (UNIV - s) = (s' \\<noteq> {})\"\n  apply (case_tac \"s' \\<subseteq> s\")\n   apply (simp add: Un_absorb2)\n   apply (simp add: Int_absorb1)\n  apply (clarsimp simp: subset_iff)\n  apply (subst psubset_card_mono)\n    apply simp\n   apply blast\n  apply blast\n  done\n\nlemma isCapDs:\n  \"isUntypedCap cap \\<Longrightarrow> \\<exists>dev ptr size freeIndex. cap = UntypedCap dev ptr size freeIndex\"\n  \"isEndpointCap cap \\<Longrightarrow> \\<exists>ptr bdg cans canr cang cangr. cap = EndpointCap ptr bdg cans canr cang cangr\"\n  \"isNotificationCap cap \\<Longrightarrow> \\<exists>ptr bdg cans canr. cap = NotificationCap ptr bdg cans canr\"\n  \"isCNodeCap cap \\<Longrightarrow> \\<exists>ptr bits grd gsize. cap = CNodeCap ptr bits grd gsize\"\n  \"isThreadCap cap \\<Longrightarrow> \\<exists>ptr. cap = ThreadCap ptr\"\n  \"isArchObjectCap cap \\<Longrightarrow> \\<exists>archcap. cap = ArchObjectCap archcap\"\n  \"isZombie cap \\<Longrightarrow> \\<exists>ptr bits num. cap = Zombie ptr bits num\"\n  apply (case_tac cap, simp_all add: isUntypedCap_def)\n  apply (case_tac cap, simp_all add: isEndpointCap_def)\n  apply (case_tac cap, simp_all add: isNotificationCap_def)\n  apply (case_tac cap, simp_all add: isCNodeCap_def)\n  apply (case_tac cap, simp_all add: isThreadCap_def)\n  apply (case_tac cap, simp_all add: isArchObjectCap_def)\n  apply (case_tac cap, simp_all add: isZombie_def)\n  done\n\nend", "property": "Capability Deletion: Deletes a capability from a CNode, handling various types of capabilities including CNodeCap, ThreadCap, and Zombie. The deletion process involves finalizing the slot, reducing zombies, and managing related IRQ handlers, IPC cancellations, and thread suspensions to ensure the system's integrity and consistency.", "title": "./spec/design/skel/Delete_H.thy", "chapter": "Deleting Capabilities", "section": "", "comment": ""}
{"spec": "(*\n    Hypervisor code.\n*)\n\ntheory Hypervisor_H\nimports\n  CNode_H\n  ArchHypervisor_H\n  KernelInitMonad_H\nbegin\n\narch_requalify_consts (H)\n  handleHypervisorFault\n\nend", "property": "Hypervisor Fault Handling: Manages and processes hypervisor faults, ensuring the system can respond appropriately to exceptions and errors at the hypervisor level.", "title": "./spec/design/skel/Hypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "requalify_types (in Arch)\n  copy_register_sets irqcontrol_invocation\n  invocation\n\n#INCLUDE_HASKELL SEL4/API/Invocation.lhs Arch=Arch NOT GenInvocationLabels InvocationLabel\n#INCLUDE_HASKELL SEL4/API/InvocationLabels.lhs ONLY invocationType genInvocationType", "property": "Arch-Prefixed Invocation Types: Define and requalify types for invocation structures, including `copy_register_sets` and `irqcontrol_invocation`, with an `Arch` prefix to ensure compatibility and proper scoping within the architecture-specific context.", "title": "./spec/design/skel/Invocations_H.thy", "chapter": "", "section": "", "comment": " Haskell expects these with Arch prefix "}
{"spec": "context Arch begin\ncontext begin global_naming global\nrequalify_types (aliasing)\n  Invocations_H.invocation\nend\nend\n\nend", "property": "Disambiguation of Names: Ensures that naming conflicts between architecture-specific and non-architecture-specific constants with the same names are resolved, maintaining clarity and preventing ambiguity in the code.", "title": "./spec/design/skel/Invocations_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "(*\n   Types visible in the API.\n*)\n\nchapter \"Types visible in the API\"\n\ntheory Types_H\nimports\n  MachineExports\n  ArchTypes_H\nbegin\n\narch_requalify_types (H)\n  object_type\n  paddr\n  vptr\n\narch_requalify_consts (H)\n  getObjectSize\n  fromAPIType\n  toAPIType\n  isFrameType\n  pageType\n  tcbBlockSizeBits\n\narch_requalify_facts (H)\n  tcbBlockSizeBits_def\n\n#INCLUDE_HASKELL SEL4/API/Types.lhs all_bits NOT wordsFromBootInfo messageInfoFromWord wordFromMessageInfo ObjectType getObjectSize fromAPIType toAPIType isFrameType pageType\n#INCLUDE_HASKELL SEL4/API/Types.lhs all_bits ONLY wordsFromBootInfo messageInfoFromWord wordFromMessageInfo\n\nend", "property": "API-Visible Types: Define and requalify a set of types, constants, and facts that are visible and usable in the API, ensuring consistent and accessible data representations and operations for system components.", "title": "./spec/design/skel/Types_H.thy", "chapter": "Types visible in the API", "section": "", "comment": ""}
{"spec": "record init_data =\n  initFreeMemory   :: \"region list\"\n  initSlotPosCur :: \"machine_word\"\n  initSlotPosMax   :: \"machine_word\"\n  initBootInfo    :: \"biframe_data\"\n  initBootInfoFrame       :: paddr\n  initKernelState :: kernel_state\n\ntype_synonym 'a kernel_init_state = \"(init_data, 'a) nondet_monad\"\n\ntranslations\n  (type) \"'c kernel_init_state\" <= (type) \"(init_data, 'c) nondet_monad\"\n\ntype_synonym 'a kernel_init = \"(init_failure + 'a) kernel_init_state\"\n\ntranslations\n  (type) \"'a kernel_init\" <= (type) \"(init_failure + 'a) kernel_init\"\n\ndefinition\n  noInitFailure :: \"'a kernel_init_state \\<Rightarrow> 'a kernel_init\"\nwhere\n  noInitFailure_def[simp]:\n  \"noInitFailure \\<equiv> liftE\"\n\n\n\ndefinition\n  doKernelOp :: \"'a kernel \\<Rightarrow> 'a kernel_init\"\nwhere\n \"doKernelOp kop \\<equiv> doE\n    ms \\<leftarrow> liftE $ gets initKernelState;\n    (r, ms') \\<leftarrow> liftE $ select_f (kop ms);\n    liftE $ modify (\\<lambda>ks. ks \\<lparr> initKernelState := ms' \\<rparr>);\n    returnOk r\n  odE\"\n\nconsts\n  itASID :: asid\n  biCapNull :: machine_word\n  biCapITTCB :: machine_word\n  biCapITCNode :: machine_word\n  biCapITPD :: machine_word\n  biCapIRQControl :: machine_word\n  biCapASIDControl :: machine_word\n  biCapITASIDPool :: machine_word\n  biCapIOPort :: machine_word\n  biCapIOSpace :: machine_word\n  biCapBIFrame :: machine_word\n  biCapITIPCBuf :: machine_word\n  biCapDynStart :: machine_word\n  biFrameSizeBits :: nat\n  nopBIFrameData :: biframe_data\n\ndefinition\n  runInit :: \"machine_word \\<Rightarrow> 'a kernel_init \\<Rightarrow> 'b kernel\"\nwhere\n  \"runInit initOffset doInit \\<equiv> do\n    ks \\<leftarrow> get;\n    initData \\<leftarrow> return \\<lparr> initFreeMemory = [],\n                   initSlotPosCur = 0,\n                   initSlotPosMax = bit (pageBits),\n                   initBootInfo = nopBIFrameData,\n                   initBootInfoFrame = 0,\n                   initKernelState = ks \\<rparr>;\n    (ret, initData') \\<leftarrow> select_f (doInit initData);\n    (case ret of\n      Inr a \\<Rightarrow> fail\n    | Inl _ \\<Rightarrow> fail)\n  od\"\n\nend", "property": "Initialization State Management: Manages the initialization state by encapsulating it within a monad, allowing for operations to be performed on the kernel state during initialization. It ensures that the kernel state is updated and maintained correctly, handling potential initialization failures.", "title": "./spec/design/skel/KernelInitMonad_H.thy", "chapter": "", "section": "", "comment": "This is a similar way of getting around StateT as with the kernel\nstate, we add an extra field to the record that Haskell expects to store the\ninner monad state."}
{"spec": "requalify_consts (in Arch)\n  deleteGhost\n\ndefinition deleteRange :: \"( machine_word , 'a ) DataMap.map \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> ( machine_word , 'a ) DataMap.map\"\nwhere \"deleteRange m ptr bits \\<equiv>\n        let inRange = (\\<lambda> x. x && ((- mask bits) - 1) = fromPPtr ptr) in\n        data_map_filterWithKey (\\<lambda> x _. Not (inRange x)) m\"\n\n#INCLUDE_HASKELL SEL4/Model/PSpace.lhs decls_only Data.Map=DataMap NOT PSpace ptrBits ptrBitsForSize lookupAround maybeToMonad lookupAround2 typeError alignError alignCheck sizeCheck objBits deleteRange\n\nconsts\nlookupAround2 :: \"('k :: {linorder,finite}) \\<Rightarrow> ( 'k , 'a ) DataMap.map \\<Rightarrow> (('k * 'a) option * 'k option)\"\n\n#INCLUDE_HASKELL SEL4/Model/PSpace.lhs bodies_only Data.Map=DataMap NOT PSpace ptrBits ptrBitsForSize lookupAround maybeToMonad typeError alignError alignCheck sizeCheck objBits deletionIsSafe deletionIsSafe_delete_locale cNodePartialOverlap pointerInUserData ksASIDMapSafe deleteRange\n\nend", "property": "DataMap Range Deletion: Remove a range of entries from a DataMap based on a specified pointer and bit size, ensuring that only the entries within the specified range are deleted.", "title": "./spec/design/skel/PSpaceFuns_H.thy", "chapter": "", "section": "", "comment": " Haskell expects this with Arch prefix "}
{"spec": "consts\ninsertNewCaps :: \"object_type \\<Rightarrow> machine_word \\<Rightarrow> machine_word list \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> unit kernel\"\n\nconsts\ncreateObjects :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> Structures_H.kernel_object \\<Rightarrow> nat \\<Rightarrow> machine_word list kernel\"\n\nconsts\ncreateObjects' :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> kernel_object \\<Rightarrow> nat \\<Rightarrow> unit kernel\"\n\nconsts\ncreateNewCaps :: \"object_type \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> capability list kernel\"\n\nconsts\nArch_createNewCaps :: \"object_type \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_capability list kernel\"\n\ndefs insertNewCaps_def:\n\"insertNewCaps newType srcSlot destSlots regionBase magnitudeBits dev \\<equiv> (do\n    caps \\<leftarrow> createNewCaps newType regionBase (length destSlots) magnitudeBits dev;\n    zipWithM_x (insertNewCap srcSlot) destSlots caps\n  od)\"\n\ndefs createNewCaps_def:\n\"createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    (case toAPIType t of\n          Some TCBObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject ::tcb)) 0;\n            curdom \\<leftarrow> curDomain;\n            mapM_x (\\<lambda>tptr. threadSet (tcbDomain_update (\\<lambda>_. curdom)) tptr) addrs;\n            return $ map (\\<lambda> addr. ThreadCap addr) addrs\n          od)\n        | Some EndpointObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject ::endpoint)) 0;\n            return $ map (\\<lambda> addr. EndpointCap addr 0 True True True True) addrs\n          od)\n        | Some NotificationObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject ::notification)) 0;\n            return $ map (\\<lambda> addr. NotificationCap addr 0 True True) addrs\n          od)\n        | Some ArchTypes_H.CapTableObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject ::cte)) userSize;\n            modify (\\<lambda> ks. ks \\<lparr> gsCNodes := (\\<lambda> addr.\n              if addr `~elem~` map fromPPtr addrs then Just userSize\n              else gsCNodes ks addr)\\<rparr>);\n            return $ map (\\<lambda> addr. CNodeCap addr userSize 0 0) addrs\n          od)\n        | Some ArchTypes_H.Untyped \\<Rightarrow>\n            return $ map\n                (\\<lambda> n. UntypedCap dev (regionBase + n * 2 ^ (fromIntegral userSize)) userSize 0)\n                [0  .e.  (fromIntegral numObjects) - 1]\n        | None \\<Rightarrow>   (do\n            archCaps \\<leftarrow> Arch_createNewCaps t regionBase numObjects userSize dev;\n            return $ map ArchObjectCap archCaps\n          od)\n        )\"\n\ndefs createObjects_def:\n\"createObjects ptr numObjects val gSize \\<equiv> (do\n        oBits \\<leftarrow> return ( objBitsKO val);\n        gBits \\<leftarrow> return ( oBits + gSize);\n        createObjects' ptr numObjects val gSize;\n        return (map (\\<lambda> n. (ptr + n `~shiftL~` gBits))\n                [0  .e.  (of_nat numObjects) - 1])\n  od)\"\n\ndefs createObjects'_def:\n\"createObjects' ptr numObjects val gSize\\<equiv> (do\n        oBits \\<leftarrow> return ( objBitsKO val);\n        gBits \\<leftarrow> return ( oBits + gSize);\n        unless (fromPPtr ptr && mask gBits = 0) $\n            alignError gBits;\n        ps \\<leftarrow> gets ksPSpace;\n        end \\<leftarrow> return ( fromPPtr ptr + fromIntegral ((numObjects `~shiftL~` gBits) - 1));\n        (before, _) \\<leftarrow> return ( lookupAround2 end (psMap ps));\n        (case before of\n              None \\<Rightarrow>   return ()\n            | Some (x, _) \\<Rightarrow>   haskell_assert (x < fromPPtr ptr)\n                []\n            );\n        addresses \\<leftarrow> return ( map\n                (\\<lambda> n. fromPPtr ptr + n `~shiftL~` oBits)\n                [0  .e.  (fromIntegral numObjects `~shiftL~` gSize) - 1]);\n        map' \\<leftarrow> return ( foldR\n               (\\<lambda> addr map. data_map_insert addr val map)\n               (psMap ps) addresses);\n        ps' \\<leftarrow> return ( ps \\<lparr> psMap := map' \\<rparr>);\n        modify (\\<lambda> ks. ks \\<lparr> ksPSpace := ps'\\<rparr>)\nod)\"\n\n\nend", "property": "Object and Capability Creation: Create and initialize new objects and their corresponding capabilities, ensuring proper allocation and configuration in the system. This includes creating TCBs, endpoints, notifications, CNodes, untyped memory, and architecture-specific objects, and setting up their initial states and capabilities.", "title": "./spec/design/skel/Intermediate_H.thy", "chapter": "", "section": "", "comment": "\n * Intermediate function bodies that were once in the Haskell spec, but are\n * now no longer.\n *\n * The idea is that these \"Old Haskell\" specs allow us to have refinement as\n * follows:\n *\n *  C <---> Haskell <---> Old Haskell <---> Abstract\n *\n * This provides a stepping stone for refactoring the Haskell without breaking\n * the upper proofs until a later time.\n "}
{"spec": "(*\n   datatypes/records for the various kernel data structures.\n*)\n\nchapter \"Kernel Data Structures\"\n\ntheory Structures_H\nimports\n  Config_H\n  State_H\n  Fault_H\n  Types_H\n  ArchStructures_H\nbegin\n\narch_requalify_types (H)\n  arch_capability\n  arch_kernel_object\n  asid\n  arch_tcb\n\narch_requalify_consts (H)\n  archObjSize\n  nullPointer\n  newArchTCB\n  fromPPtr\n  PPtr\n  atcbContextGet\n  atcbContextSet\n\n#INCLUDE_HASKELL SEL4/Object/Structures.lhs decls_only NOT isNullCap isUntypedCap isIRQControlCap isReplyCap isDomainCap isNotificationCap\n#INCLUDE_HASKELL SEL4/Object/Structures.lhs bodies_only NOT kernelObjectTypeName isNullCap isUntypedCap isIRQControlCap isReplyCap isDomainCap isNotificationCap\n\n\nend", "property": "Kernel Data Structures: Define and requalify various kernel data structures, including capabilities, kernel objects, ASIDs, and TCBs, to ensure they are properly typed and initialized for use within the kernel.", "title": "./spec/design/skel/Structures_H.thy", "chapter": "Kernel Data Structures", "section": "", "comment": ""}
{"spec": "definition\n  withoutFailure :: \"'a kernel \\<Rightarrow> ('f, 'a) kernel_f\"\nwhere\n  withoutFailure_def[simp]:\n  \"withoutFailure \\<equiv> liftE\"\n\ndefinition\n  throw :: \"'f \\<Rightarrow> ('f, 'a) kernel_f\"\nwhere\n  throw_def[simp]:\n  \"throw \\<equiv> throwError\"\n\ndefinition\n  catchFailure :: \"('f, 'a) kernel_f \\<Rightarrow> ('f \\<Rightarrow> 'a kernel) \\<Rightarrow> 'a kernel\"\nwhere\n  catchFailure_def[simp]:\n \"catchFailure \\<equiv> catch\"\n\ndefinition\n  rethrowFailure :: \"('f1 \\<Rightarrow> 'f2) \\<Rightarrow> ('f1, 'a) kernel_f \\<Rightarrow> ('f2, 'a) kernel_f\"\nwhere\n \"rethrowFailure f m \\<equiv> m <handle2> (throwError \\<circ> f)\"\n\ndefinition\n  ignoreFailure :: \"( 'f , unit ) kernel_f \\<Rightarrow> unit kernel\"\nwhere\n  \"ignoreFailure x \\<equiv> (catchFailure x (const (return ())))\"\n\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures.lhs\n#INCLUDE_HASKELL SEL4/Model/Failures.lhs NOT KernelF withoutFailure catchFailure throw rethrowFailure nullCapOnFailure nothingOnFailure ignoreFailure emptyOnFailure\n\ndefinition\n  nullCapOnFailure :: \"('f, capability) kernel_f \\<Rightarrow> capability kernel\"\nwhere\n \"nullCapOnFailure m \\<equiv> m <catch> (\\<lambda>x. return NullCap)\"\n\ndefinition\n  emptyOnFailure :: \"('f, 'a list) kernel_f \\<Rightarrow> 'a list kernel\"\nwhere\n \"emptyOnFailure m \\<equiv> m <catch> (\\<lambda>x. return [])\"\n\ndefinition\n  nothingOnFailure :: \"('f, 'a option) kernel_f \\<Rightarrow> 'a option kernel\"\nwhere\n \"nothingOnFailure m \\<equiv> m <catch> (\\<lambda>x. return Nothing)\"", "property": "Fault Handling: Provides mechanisms for handling and propagating failures in kernel operations, including lifting kernel functions to handle failures, throwing errors, catching and rethrowing failures, and providing default values (such as `NullCap`, empty lists, or `Nothing`) when a failure occurs.", "title": "./spec/design/skel/FaultMonad_H.thy", "chapter": "The Fault Monad", "section": "", "comment": ""}
{"spec": "type_synonym 'a kernel_p = \"(irq + 'a) kernel\"\n\ntranslations\n  (type) \"'a kernel_p\" <= (type) \"(irq + 'a) kernel\"\n\ndefinition\n  withoutPreemption :: \"'a kernel \\<Rightarrow> 'a kernel_p\"\nwhere\n  withoutPreemption_def[simp]:\n \"withoutPreemption \\<equiv> liftE\"\n\ndefinition\n  workUnitsLimit :: machine_word\nwhere\n  \"workUnitsLimit \\<equiv> 0x64\"\n\ndefinition\n  preemptionPoint :: \"unit kernel_p\"\nwhere\n  \"preemptionPoint \\<equiv> doE\n     liftE $ modifyWorkUnits (\\<lambda>u. u + 1);\n     workUnits <- liftE $ getWorkUnits;\n     whenE (workUnitsLimit <= workUnits) $ doE\n       liftE $ setWorkUnits 0;\n       preempt <- liftE $ doMachineOp (getActiveIRQ True);\n       case preempt of\n           Some irq => throwError irq\n           | None => returnOk ()\n     odE\n   odE\"\n\n\nend", "property": "Preemption Control: Manages preemption by incrementing the work units, checking against a limit, and potentially triggering a preemption if the limit is reached. This ensures that the system remains responsive and fair in scheduling.", "title": "./spec/design/skel/FaultMonad_H.thy", "chapter": "The Fault Monad", "section": "", "comment": ""}
{"spec": "chapter \"Notifications\"\n\ntheory Notification_H imports    \"NotificationDecls_H\"\n    \"TCB_H\"\n  TCB_H\n  ThreadDecls_H\n  CSpaceDecls_H\n  ObjectInstances_H\nbegin\n\narch_requalify_consts (H)\n  badgeRegister\n\n#INCLUDE_HASKELL SEL4/Object/Notification.lhs bodies_only\n\nend", "property": "Notifications: Enable threads to manage and interact with notifications, including binding and unbinding notification pointers, and handling badge registers for communication.", "title": "./spec/design/skel/Notification_H.thy", "chapter": "Notifications", "section": "", "comment": ""}
{"spec": "chapter \"Endpoints\"\n\ntheory Endpoint_H\nimports\n  EndpointDecls_H\n  TCB_H\n  ThreadDecls_H\n  CSpaceDecls_H\n  FaultHandlerDecls_H\n  Notification_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Endpoint.lhs bodies_only\n\nend", "property": "Endpoint Management: Enables the creation, manipulation, and communication through endpoints, facilitating inter-thread messaging and synchronization.", "title": "./spec/design/skel/Endpoint_H.thy", "chapter": "Endpoints", "section": "", "comment": ""}
{"spec": "chapter \"Function Declarations for CSpace\"\n\ntheory CSpaceDecls_H\nimports FaultMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/CSpace.lhs decls_only\n\nend", "property": "Function Declarations for CSpace: Defines the necessary functions for managing capabilities within the CSpace, providing the foundational operations required for capability manipulation and interaction.", "title": "./spec/design/skel/CSpaceDecls_H.thy", "chapter": "Function Declarations for CSpace", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (aliasing, H)\n  gpRegisters\n  frameRegisters\n  tlsBaseRegister\n\nabbreviation \"mapMaybe \\<equiv> option_map\"\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= bodies_only NOT liftFnMaybe assertDerived archThreadGet archThreadSet asUser sanitiseRegister getSanitiseRegisterInfo\n\ndefs asUser_def:\n\"asUser tptr f\\<equiv> (do\n        uc \\<leftarrow> threadGet  (atcbContextGet o tcbArch) tptr;\n        (a, uc') \\<leftarrow> select_f (f uc);\n        threadSet (\\<lambda> tcb. tcb \\<lparr> tcbArch := atcbContextSet uc' (tcbArch tcb)\\<rparr>) tptr;\n        return a\nod)\"\n\nend", "property": "Requalification of Constants: Requalifies abstract specification constants with design-specific versions, ensuring that the constants used in the architecture-specific code are consistent and correctly mapped to their design counterparts.", "title": "./spec/design/skel/TCB_H.thy", "chapter": "", "section": "", "comment": " clobbers previously requalified abstract spec constants with design spec versions "}
{"spec": "requalify_consts\n  cteRightsBits cteGuardBits", "property": "Architectural Constants: Define and requalify constants for CTE (Capability Table Entry) rights and guard bits, ensuring consistent and correct usage across the architecture.", "title": "./spec/design/skel/Retype_H.thy", "chapter": "", "section": "", "comment": " match Haskell, expects these under Arch. "}
{"spec": "requalify_consts (aliasing)\n  deriveCap finaliseCap postCapDeletion isCapRevocable\n  hasCancelSendRights sameRegionAs isPhysicalCap\n  sameObjectAs updateCapData maskCapRights\n  createObject capUntypedPtr capUntypedSize\n  performInvocation decodeInvocation prepareThreadDelete\n\ncontext begin global_naming global\n\nrequalify_consts (aliasing)\n  RetypeDecls_H.deriveCap RetypeDecls_H.finaliseCap RetypeDecls_H.postCapDeletion\n  RetypeDecls_H.isCapRevocable\n  RetypeDecls_H.hasCancelSendRights RetypeDecls_H.sameRegionAs RetypeDecls_H.isPhysicalCap\n  RetypeDecls_H.sameObjectAs RetypeDecls_H.updateCapData RetypeDecls_H.maskCapRights\n  RetypeDecls_H.createObject RetypeDecls_H.capUntypedPtr RetypeDecls_H.capUntypedSize\n  RetypeDecls_H.performInvocation RetypeDecls_H.decodeInvocation\nend\n\nend\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType.lhs Arch=Arch bodies_only\n\nend", "property": "Namespace Disambiguation: Disambiguates names between architecture-specific and non-architecture-specific constants to prevent naming conflicts.", "title": "./spec/design/skel/Retype_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "(*\n    VSpace lookup code.\n*)\n\ntheory VSpace_H\nimports\n  CNode_H\n  ArchVSpace_H\n  KernelInitMonad_H\nbegin\n\narch_requalify_consts (H)\n  mapKernelWindow\n  activateGlobalVSpace\n  initIRQController\n  createIPCBufferFrame\n  createBIFrame\n  createFramesOfRegion\n  createITPDPTs\n  writeITPDPTs\n  createITASIDPool\n  writeITASIDPool\n  createDeviceFrames\n  handleVMFault\n  isValidVTableRoot\n  checkValidIPCBuffer\n  lookupIPCBuffer\n  vptrFromPPtr\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace.lhs Arch= ONLY initKernelVM initPlatform initCPU\n\nend", "property": "VSpace Initialization and Management: Initialize and manage the virtual space, including creating and activating the global virtual space, initializing the IRQ controller, creating and managing frames for IPC buffers, device frames, and other regions, and handling VM faults. This ensures that the virtual memory is properly set up and maintained for efficient and secure operation.", "title": "./spec/design/skel/VSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "requalify_consts\n  checkIRQ\n  handleReservedIRQ\n  maskIrqSignal", "property": "IRQ Management: Ensures proper handling and masking of interrupts, including checking and managing reserved IRQs.", "title": "./spec/design/skel/Interrupt_H.thy", "chapter": "", "section": "", "comment": " match Haskell, expects these under Arch. "}
{"spec": "requalify_consts (aliasing)\n  decodeIRQControlInvocation\n  invokeIRQHandler\n  performIRQControl\n  initInterruptController\n\ncontext begin global_naming global\nrequalify_consts (aliasing)\n  InterruptDecls_H.decodeIRQControlInvocation\n  InterruptDecls_H.invokeIRQHandler\n  InterruptDecls_H.performIRQControl\n  InterruptDecls_H.initInterruptController\n\nend\nend", "property": "Disambiguate Constants: Resolve name clashes between architecture-specific and non-architecture-specific constants by requalifying them with their respective namespaces.", "title": "./spec/design/skel/Interrupt_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "arch_requalify_consts (aliasing, H)\n  maxIRQ\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs\n#INCLUDE_HASKELL SEL4/Object/Interrupt.lhs bodies_only\n\nend", "property": "Override Configuration Constants: Requalify and constrain kernel configuration constants, such as `maxIRQ`, using definitions from the hardware abstraction layer (H). This ensures that the constants are consistent with the hardware specifications.", "title": "./spec/design/skel/Interrupt_H.thy", "chapter": "", "section": "", "comment": " override Kernel_Config const with constrained abbreviation from Hardware_H "}
{"spec": "#INCLUDE_HASKELL SEL4/API/Syscall.lhs ONLY Event Syscall\n\nend", "property": "Event Handling: The kernel reacts to both user-level and machine-generated events, processing them through system calls to manage and respond to various conditions and requests.", "title": "./spec/design/skel/Event_H.thy", "chapter": "", "section": "", "comment": "\n  \\label{sec:Event_H}\n\n  These are the user-level and machine generated events the kernel reacts to.\n"}
{"spec": "theory Config_H\nimports Types_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Config.lhs NOT numDomains timeSlice resetChunkBits retypeFanOutLimit\n\nend", "property": "Configuration Parameters: Define and import configuration parameters for the system, such as the number of domains, time slice duration, reset chunk bits, and retype fan-out limit. These parameters are essential for configuring the system's behavior and resource management.", "title": "./spec/design/skel/Config_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"System Calls\"\n\ntheory Syscall_H\nimports Kernel_H Event_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Model/Syscall.lhs\n#INCLUDE_HASKELL SEL4/API/Syscall.lhs decls_only NOT Event Syscall\n#INCLUDE_HASKELL SEL4/API/Syscall.lhs bodies_only\n\nend", "property": "System Calls: Define and implement the interface for system calls, allowing user-level applications to request services from the kernel. This includes handling various operations such as process management, memory management, and I/O operations, ensuring that the kernel can securely and efficiently manage system resources and provide necessary services to user-space applications.", "title": "./spec/design/skel/Syscall_H.thy", "chapter": "System Calls", "section": "", "comment": ""}
{"spec": "type_synonym ready_queue = tcb_queue", "property": "Ready Queue Definition: Defines a ready queue as a type synonym for a thread control block (TCB) queue, facilitating the management and scheduling of threads in the kernel.", "title": "./spec/design/skel/KernelStateData_H.thy", "chapter": "Kernel State and Monads", "section": "", "comment": ""}
{"spec": "record kernel_state =\n  ksPSpace             :: pspace\n  gsUserPages          :: \"machine_word \\<Rightarrow> vmpage_size option\"\n  gsCNodes             :: \"machine_word \\<Rightarrow> nat option\"\n  gsUntypedZeroRanges  :: \"(machine_word \\<times> machine_word) set\"\n  gsMaxObjectSize      :: nat\n  ksDomScheduleIdx     :: nat\n  ksDomSchedule        :: \"(domain \\<times> machine_word) list\"\n  ksCurDomain          :: domain\n  ksDomainTime         :: machine_word\n  ksReadyQueues        :: \"domain \\<times> priority \\<Rightarrow> ready_queue\"\n  ksReadyQueuesL1Bitmap :: \"domain \\<Rightarrow> machine_word\"\n  ksReadyQueuesL2Bitmap :: \"domain \\<times> nat \\<Rightarrow> machine_word\"\n  ksCurThread          :: machine_word\n  ksIdleThread         :: machine_word\n  ksSchedulerAction    :: scheduler_action\n  ksInterruptState     :: interrupt_state\n  ksWorkUnitsCompleted :: machine_word\n  ksArchState          :: Arch.kernel_state\n  ksMachineState       :: machine_state\n\ncontext Arch begin\ncontext begin global_naming global\nrequalify_types KernelStateData_H.kernel_state\nend\nend\n\ntype_synonym 'a kernel = \"(kernel_state, 'a) nondet_monad\"\n\ntranslations\n  (type) \"'c kernel\" <= (type) \"(kernel_state, 'c) nondet_monad\"", "property": "Kernel State and Monad Structure: The kernel state encapsulates various components including physical space, user pages, CNodes, untyped zero ranges, maximum object size, domain scheduling information, current and idle threads, scheduler actions, interrupt state, work units completed, and architecture-specific and machine states. This structure allows for the management and manipulation of the kernel's operational environment within a nondeterministic monad, facilitating state transitions and computations.", "title": "./spec/design/skel/KernelStateData_H.thy", "chapter": "Kernel State and Monads", "section": "", "comment": "We pull a fast one on haskell here ... although Haskell expects\na KernelMonad which is a StateT monad in KernelData that wraps a MachineMonad,\nwe push the extra MachineMonad data into the KernelState. Fortunately the\nupdate and accessor functions all still work."}
{"spec": "definition\n  doMachineOp :: \"(machine_state, 'a) nondet_monad  \\<Rightarrow> 'a kernel\"\nwhere\n \"doMachineOp mop \\<equiv> do\n    ms \\<leftarrow> gets ksMachineState;\n    (r, ms') \\<leftarrow> select_f (mop ms);\n    modify (\\<lambda>ks. ks \\<lparr> ksMachineState := ms' \\<rparr>);\n    return r\n  od\"\n\n#INCLUDE_HASKELL SEL4/Model/StateData.lhs decls_only ONLY capHasProperty ksReadyQueues_asrt ready_qs_runnable idleThreadNotQueued\n#INCLUDE_HASKELL SEL4/Model/StateData.lhs NOT doMachineOp KernelState ReadyQueue Kernel assert stateAssert findM funArray newKernelState capHasProperty ksReadyQueues_asrt ready_qs_runnable idleThreadNotQueued\n\nend", "property": "Execute Machine Operations: Perform a machine operation within the kernel, updating the machine state and returning the result. This ensures that the kernel's machine state is correctly modified and maintained.", "title": "./spec/design/skel/KernelStateData_H.thy", "chapter": "Kernel State and Monads", "section": "", "comment": ""}
{"spec": "chapter \"Function Declarations for TCBs\"\n\ntheory TCBDecls_H\nimports FaultMonad_H Invocations_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs decls_only \\\n  NOT archThreadGet archThreadSet sanitiseRegister getSanitiseRegisterInfo\n\nend", "property": "Function Declarations for TCBs: Defines the function declarations related to thread control blocks (TCBs) without including architecture-specific functions such as `archThreadGet`, `archThreadSet`, `sanitiseRegister`, and `getSanitiseRegisterInfo`.", "title": "./spec/design/skel/TCBDecls_H.thy", "chapter": "Function Declarations for TCBs", "section": "", "comment": ""}
{"spec": "chapter \"Kernel\"\n\ntheory Kernel_H\nimports\n  KernelInit_H\n  Thread_H\n  FaultHandler_H\n  CSpace_H\n  Hypervisor_H\nbegin\nend", "property": "Kernel Integration: Integrates various kernel components including initialization, thread management, fault handling, capability space management, and hypervisor functionalities to form a cohesive system.", "title": "./spec/design/skel/Kernel_H.thy", "chapter": "Kernel", "section": "", "comment": ""}
{"spec": "chapter \"Function Declarations for Endpoints\"\n\ntheory EndpointDecls_H\nimports FaultMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Object/Endpoint.lhs decls_only\n\nend", "property": "Endpoint Function Declarations: Define the necessary functions for managing and interacting with endpoints, facilitating communication and synchronization between threads.", "title": "./spec/design/skel/EndpointDecls_H.thy", "chapter": "Function Declarations for Endpoints", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (aliasing, H)\n  syscallMessage\n  exceptionMessage\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures.lhs\n\n#INCLUDE_HASKELL SEL4/Kernel/FaultHandler.lhs bodies_only\n#INCLUDE_HASKELL SEL4/API/Faults.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults.lhs bodies_only\n\nend", "property": "Clobber Constants: Requalify previously defined abstract specification constants with design-specific versions, ensuring that the system uses the updated constants for fault handling and system calls.", "title": "./spec/design/skel/FaultHandler_H.thy", "chapter": "", "section": "", "comment": " clobbers previously requalified abstract spec constants with design spec versions "}
{"spec": "(*\n    Declarations from SEL4.Kernel.FaultHandler\n*)\n\nchapter \"Function Declarations for Fault Handlers\"\n\ntheory FaultHandlerDecls_H\nimports Structures_H FaultMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/FaultHandler.lhs decls_only\n\nend", "property": "Function Declarations for Fault Handlers: Defines the necessary function declarations to handle faults within the kernel, providing a structured interface for fault management and ensuring that fault handling mechanisms are properly integrated into the system.", "title": "./spec/design/skel/FaultHandlerDecls_H.thy", "chapter": "Function Declarations for Fault Handlers", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4.lhs decls_only NOT callKernel\n\n#INCLUDE_HASKELL SEL4.lhs NOT kernelExitAssertions fastpathKernelAssertions\n\nend", "property": "API Module Collection: Aggregates all API modules, providing a comprehensive set of functions and declarations for the system.", "title": "./spec/design/skel/API_H.thy", "chapter": "", "section": "", "comment": "collects all API modules"}
{"spec": "chapter \"Initialisation\"\n\ntheory KI_Decls_H\nimports\n  ThreadDecls_H\n  KernelInitMonad_H\nbegin\n\n#INCLUDE_HASKELL SEL4/Kernel/Init.lhs decls_only NOT isAligned funArray newKernelState distinct rangesBy doKernelOp runInit\n\nend", "property": "System Initialization: Initializes the kernel state and sets up the necessary data structures and configurations to prepare the system for operation.", "title": "./spec/design/skel/KI_Decls_H.thy", "chapter": "Initialisation", "section": "", "comment": ""}
{"spec": "chapter \"Untyped Objects\"\n\ntheory Untyped_H\nimports\n  RetypeDecls_H\n  CSpaceDecls_H\n  CNode_H\n  Invocations_H\n  InvocationLabels_H\n  Config_H\nbegin\n\narch_requalify_consts (H)\n  minUntypedSizeBits\n  maxUntypedSizeBits\n\nconsts\n  cNodeOverlap :: \"(machine_word \\<Rightarrow> nat option) \\<Rightarrow> (machine_word \\<Rightarrow> bool) \\<Rightarrow> bool\"\n\n#INCLUDE_HASKELL SEL4/Object/Untyped.lhs decls_only ONLY archOverlap\n\n#INCLUDE_HASKELL SEL4/Object/Untyped.lhs NOT cNodeOverlap canonicalAddressAssert archOverlap\n\nend", "property": "Untyped Objects: Define and manage untyped memory regions with specified size constraints, ensuring that these regions do not overlap with critical system structures.", "title": "./spec/design/skel/Untyped_H.thy", "chapter": "Untyped Objects", "section": "", "comment": ""}
{"spec": "context Arch begin\nrequalify_facts (aliasing)\n   newKernelState_def\nrequalify_consts (aliasing)\n   newKernelState\n\ncontext begin global_naming global\nrequalify_facts (aliasing)\n   KernelInit_H.newKernelState_def\nrequalify_consts (aliasing)\n   KernelInit_H.newKernelState\nend\nend\n\nend", "property": "Disambiguation of Constants: Resolve name clashes between architecture-specific and non-architecture-specific constants by requalifying and aliasing them, ensuring clear and unambiguous references in the code.", "title": "./spec/design/skel/KernelInit_H.thy", "chapter": "", "section": "", "comment": " disambiguate name clash between Arch and non-arch consts with same names "}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/ARM.hs\n\nend (* context Arch *)\n\nend", "property": "Architectural Physical Memory Management: Provides arch-specific ghost update functions for managing physical memory, ensuring that the memory state is correctly maintained and updated according to the architectural requirements.", "title": "./spec/design/skel/ARM/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/ARM.lhs CONTEXT Arch decls_only\n\nend\nend", "property": "Function Declarations for Threads: Defines the necessary function declarations for thread management in the ARM architecture, providing the structural and operational foundations for thread-related functionalities within the kernel.", "title": "./spec/design/skel/ARM/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify ARM_H (in Arch)\ninstantiation ARM_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [PageDirectoryObject,\n      SmallPageObject,\n      LargePageObject,\n      SectionObject,\n      SuperSectionObject,\n      PageTableObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation ARM_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation ARM_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Defines the enumeration of object types, including both API object types and ARM-specific object types such as PageDirectory, SmallPage, LargePage, Section, SuperSection, and PageTable. Ensures that the object types are exhaustively covered and distinct, supporting comprehensive type handling and validation.", "title": "./spec/design/skel/ARM/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/ARM.lhs CONTEXT ARM_H NOT ArmVSpaceRegionUse\n\nend\n\nend", "property": "Architecture-Specific Kernel State and Monads: Defines the architecture-specific kernel state and monads, incorporating necessary imports and context for the ARM architecture. This ensures that the kernel state and monads are tailored to the specific requirements and structures of the ARM architecture, providing a foundation for the rest of the system.", "title": "./spec/design/skel/ARM/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_H bodies_only\n\n\nend\nend", "property": "VSpace Lookup: Provides mechanisms for handling and translating virtual memory faults, ensuring that the system can properly manage and respond to memory access errors.", "title": "./spec/design/skel/ARM/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation ARM_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pde updateObject_pde\n  loadObject_pte updateObject_pte\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Management: The ASID pool is represented as a fixed-size array of `Nothing` values, ensuring a safe and consistent structure for managing ASID mappings. The loading and updating of the ASID pool object are handled using default methods, maintaining the integrity and consistency of the ASID pool within the kernel.", "title": "./spec/design/skel/ARM/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Main Setup_Locale\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/ARM.lhs CONTEXT ARM_H ONLY ArmVSpaceRegionUse\n\nend\nend", "property": "Common, Architecture-Specific Data Types: Define and share architecture-specific data types between the specification and abstract models, ensuring consistency and reusability across different parts of the system.", "title": "./spec/design/skel/ARM/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  Untyped_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/ARM.lhs CONTEXT ARM_H bodies_only ArchInv=ArchRetypeDecls_H.ARM ArchLabels=ArchInvocationLabels_H.ARM NOT checkPDAt checkPTAt checkPDASIDMapMembership checkValidMappingSize vptrFromPPtr\n\ndefs checkValidMappingSize_def:\n  \"checkValidMappingSize sz \\<equiv> stateAssert\n    (\\<lambda>s. 2 ^ pageBitsForSize sz <= gsMaxObjectSize s) []\"\n\nend\nend", "property": "VSpace Lookup and Validation: Ensures that the size of a mapping is valid by checking that the size does not exceed the maximum object size supported by the system.", "title": "./spec/design/skel/ARM/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/ARM.lhs RegisterSet= CONTEXT ARM_H\n\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\nend\nend", "property": "Architectural Thread Management: Provides functions for getting and setting thread-specific architectural state, ensuring that the thread's state is correctly managed and updated according to the architecture-specific requirements.", "title": "./spec/design/skel/ARM/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchVSpaceDecls_H\nimports ArchRetypeDecls_H InvocationLabels_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT ARM_H\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/ARM.lhs CONTEXT ARM_H decls_only ArchInv=\n\nend\nend", "property": "Retyping Objects: Allows the redefinition of an object's type within the system, enabling the transformation of one type of object into another. This ensures flexibility and dynamic resource management in the kernel.", "title": "./spec/design/skel/ARM/ArchVSpaceDecls_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "definition\n  canonicalAddressAssert :: \"machine_word => bool\" where\n  canonicalAddressAssert_def[simp]:\n  \"canonicalAddressAssert p = True\"\n\nend", "property": "Canonical Address Assertion: The function `canonicalAddressAssert` always returns true, indicating that the provided machine word is considered to be in a canonical form.", "title": "./spec/design/skel/ARM/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/ARM.lhs CONTEXT ARM_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Define an enumeration of architecture-specific system call labels, providing a structured and standardized way to reference and invoke system calls within the ARM architecture.", "title": "./spec/design/skel/ARM/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/ARM.lhs CONTEXT ARM_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch-Specific Invocation Label Requalification: The code requalifies arch-specific invocation labels within the Arch context, ensuring that the enum instance proofs are correctly handled outside of the Arch locale.", "title": "./spec/design/skel/ARM/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext ((K 0) aLU initContext)\"\n\nend\nend", "property": "Definition of New User Context: Defines a new user context with all registers initialized to zero.", "title": "./spec/design/skel/ARM/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/ARM.lhs\n\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs bodies_only\n\nend\n\n\nend", "property": "Fault Handling: Defines the structure and behavior of fault handlers specific to the ARM architecture, including the declaration and implementation of fault types and their corresponding handling mechanisms.", "title": "./spec/design/skel/ARM/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_H decls_only\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_H instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_H bodies_only\n\ndatatype arch_kernel_object_type =\n    PDET\n  | PTET\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPDE e) = PDET\"\n| \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend\nend", "property": "Architectural Kernel Object Types: Defines three types of architectural kernel objects—PDET, PTET, and ASIDPoolT—each representing different components of the memory management system. The `archTypeOf` function determines the type of a given architectural kernel object, enabling the system to manage and manipulate these objects based on their specific roles in the architecture.", "title": "./spec/design/skel/ARM/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=ARM CONTEXT ARM_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Architectural Constants and Definitions: Define and requalify architectural constants and functions, including word bits, pointer conversions, and null pointer representation, to ensure consistency and compatibility across different architectures.", "title": "./spec/design/skel/ARM/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs Arch= CONTEXT ARM_H bodies_only ArchInv=\n\nend\nend", "property": "Architectural Interrupt Handling: Defines the handling and management of interrupts specific to the ARM architecture, including operations such as enabling, disabling, and configuring interrupts. This ensures that the system can efficiently manage hardware interrupts and maintain the integrity of the interrupt handling mechanisms.", "title": "./spec/design/skel/ARM/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  KI_Decls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/ARM.lhs CONTEXT ARM_H Arch.Types= ArchInv= bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/ARM.lhs bodies_only CONTEXT ARM_H NOT isPDFlushLabel isPageFlushLabel\n\nend\nend", "property": "Retyping Objects: Allows the redefinition of object types in the system, enabling the transformation of one type of object into another while preserving the underlying memory and maintaining the integrity of the system.", "title": "./spec/design/skel/ARM/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewPageCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        when (\\<not>dev) $\n          mapM_x (\\<lambda>addr. doMachineOp $\n                            cleanCacheRange_RAM addr\n                                                (addr + mask (pageBitsForSize pSize))\n                                                (addrFromPPtr addr)) addrs;\n        return $ map (\\<lambda>n. PageCap dev (PPtr (fromPPtr n)) VMReadWrite pSize Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects tableBits objectProto cap initialiseMappings \\<equiv> (do\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      initialiseMappings pts;\n      mapM_x (\\<lambda>addr. doMachineOp $\n                       cleanCacheRange_PoU addr (addr + mask tableBits) (addrFromPPtr addr)) addrs;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 0 ARMSmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 4 ARMLargePage\n        | SectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 8 ARMSection\n        | SuperSectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 12 ARMSuperSection\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects ptBits (makeObject::pte) PageTableCap\n              (\\<lambda>pts. return ())\n        | PageDirectoryObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pdBits (makeObject::pde) PageDirectoryCap\n              (\\<lambda>pds. do objSize \\<leftarrow> return (((1::nat) `~shiftL~` pdBits));\n                        mapM_x copyGlobalMappings pds\n                     od)\n        )\"\n\nend\nend\n\nend", "property": "Create New Memory Objects: Generate new memory objects (pages or tables) and their corresponding capabilities based on the specified type, region base, number of objects, and device status. The function initializes the mappings, updates the user pages, and performs cache cleaning as necessary.", "title": "./spec/design/skel/ARM/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/ARM.lhs CONTEXT ARM_H ARMHardware=ARM bodies_only\n\nend\nend", "property": "Thread Management: Defines the architecture-specific thread management and operations, including thread creation, scheduling, and context switching, ensuring that threads are managed efficiently and in accordance with the architectural requirements.", "title": "./spec/design/skel/ARM/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/API/Invocation/ARM.lhs CONTEXT ARM_H ONLY isPDFlushLabel isPageFlushLabel\n\nend\nend", "property": "Arch-Specific Invocation Labels: Define and handle architecture-specific invocation labels for operations such as page directory and page flushes, ensuring that the system can perform these operations in a manner consistent with the underlying architecture.", "title": "./spec/design/skel/ARM/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": "\n  Arch-specific functions on invocation labels\n"}
{"spec": "(*\n  Hypervisor stub for ARM\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  KI_Decls_H\n  InterruptDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_H decls_only ArchInv= ArchLabels=\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_H bodies_only ArchInv= ArchLabels=\n\nend\nend", "property": "Hypervisor Stub for ARM: Provides the necessary declarations and implementations for hypervisor functionality specific to the ARM architecture, ensuring that the hypervisor can manage and interact with ARM-specific hardware features.", "title": "./spec/design/skel/ARM/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs CONTEXT ARM_H decls_only ArchInv=\n\nend\n\nend", "property": "Architectural Interrupt Declarations: Define and declare interrupt-related objects and their properties for the ARM architecture, ensuring proper handling and management of interrupts within the system.", "title": "./spec/design/skel/ARM/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs Platform=Platform.ARM CONTEXT ARM_H NOT getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory writeTTBR0 setGlobalPD  setTTBCR setHardwareASID invalidateLocalTLB invalidateLocalTLB_ASID invalidateLocalTLB_VAASID cleanByVA cleanByVA_PoU invalidateByVA invalidateByVA_I invalidate_I_PoU cleanInvalByVA branchFlush clean_D_PoU cleanInvalidate_D_PoC cleanInvalidate_D_PoU cleanInvalidateL2Range invalidateL2Range cleanL2Range isb dsb dmb getIFSR getDFSR getFAR HardwareASID wordFromPDE wordFromPTE VMFaultType VMPageSize HypFaultType pageBits pageBitsForSize toPAddr cacheLineBits cacheLine lineStart cacheRangeOp cleanCacheRange_PoC cleanInvalidateCacheRange_RAM cleanCacheRange_RAM cleanCacheRange_PoU invalidateCacheRange_RAM invalidateCacheRange_I branchFlushRange cleanCaches_PoU cleanInvalidateL1Caches addrFromPPtr ptrFromPAddr initIRQController setIRQTrigger MachineData paddrBase pptrBase pptrTop paddrTop kernelELFPAddrBase kernelELFBase kernelELFBaseOffset pptrBaseOffset addrFromKPPtr\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_H instanceproofs NOT HardwareASID VMFaultType VMPageSize HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_H ONLY wordFromPDE wordFromPTE", "property": "Hardware Operations: Provides a set of hardware-specific operations for managing memory, interrupts, and cache on ARM architecture, including memory initialization, interrupt handling, and cache management. These operations ensure efficient and secure manipulation of the hardware resources.", "title": "./spec/design/skel/ARM/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ == Kernel_Config.maxIRQ\"", "property": "Max IRQ Value: Defines the maximum value for an interrupt request (IRQ) in the system, which is provided by the Kernel_Config.", "title": "./spec/design/skel/ARM/Hardware_H.thy", "chapter": "", "section": "", "comment": " Kernel_Config provides a generic numeral, Haskell expects type irq "}
{"spec": "abbreviation (input) initIRQController where\n  \"initIRQController \\<equiv> ARM.initIRQController\"\n\nend\nend", "property": "Initialization of IRQ Controller: Provides the ARM/ARM_HYP machine operation for initializing the IRQ controller, ensuring that the system can handle interrupts effectively.", "title": "./spec/design/skel/ARM/Hardware_H.thy", "chapter": "", "section": "", "comment": " provide ARM/ARM_HYP machine op in _H global_prefix for arch-split "}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/X64.hs\n\nend (* context Arch *)\n\nend", "property": "Arch-Specific Ghost Update Functions: Define and implement architecture-specific ghost update functions for managing physical memory. These functions ensure that the memory management operations are correctly reflected in the system's ghost state, maintaining the integrity and consistency of the memory model.", "title": "./spec/design/skel/X64/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/X64.lhs CONTEXT X64_H decls_only\n\nend (* context X64 *)\n\nend", "property": "Function Declarations for Threads: Defines the necessary function declarations for thread management and operations specific to the X64 architecture, providing the foundational structure for thread-related functionalities in the kernel.", "title": "./spec/design/skel/X64/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify X64_H (in Arch)\ninstantiation X64_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [PDPointerTableObject,\n      PML4Object,\n      HugePageObject,\n      SmallPageObject,\n      LargePageObject,\n      PageTableObject,\n      PageDirectoryObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation X64_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation X64_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Defines the enumeration of object types, including specific types such as PDPointerTableObject, PML4Object, HugePageObject, SmallPageObject, LargePageObject, PageTableObject, and PageDirectoryObject. Ensures that the enumeration is complete and distinct, supporting both standard and alternative enumeration methods.", "title": "./spec/design/skel/X64/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "chapter \"ArchHook\"\n\ntheory ArchHook_H\nimports KernelStateData_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  cEntryHook :: \"unit kernel\"\nwhere\n  \"cEntryHook\\<equiv> return ()\"\n\ndefinition\n  cExitHook :: \"unit kernel\"\nwhere\n  \"cExitHook\\<equiv> return ()\"\n\nend\nend", "property": "ArchHook Definitions: Defines entry and exit hooks for architectural operations, which are currently implemented as no-ops. These hooks can be used to insert custom behavior at the beginning and end of architectural operations.", "title": "./spec/design/skel/X64/ArchHook_H.thy", "chapter": "ArchHook", "section": "", "comment": ""}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/X64.lhs CONTEXT X64_H NOT X64VSpaceRegionUse\n\nend\nend", "property": "Architecture-Specific Kernel State and Monads: Defines the architecture-specific kernel state and monads, incorporating necessary imports and context for the X64 architecture. This ensures that the kernel's state and operations are tailored to the specific requirements and capabilities of the X64 architecture.", "title": "./spec/design/skel/X64/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/Failures/X64.lhs CONTEXT X64_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/X64.lhs CONTEXT X64_H bodies_only\n\nend\nend", "property": "VSpace Lookup: Provides the mechanisms for looking up virtual memory space, enabling the system to manage and access memory regions effectively.", "title": "./spec/design/skel/X64/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation X64_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pte updateObject_pte\n  loadObject_pde updateObject_pde\n  loadObject_pdpte updateObject_pdpte\n  loadObject_pml4e updateObject_pml4e\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Management: The ASID pool is initialized with a function array of `Nothing` values, and the loading and updating of the ASID pool object are handled by default methods. This ensures that the ASID pool is consistently managed and updated within the kernel.", "title": "./spec/design/skel/X64/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Main Setup_Locale\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/X64.lhs CONTEXT X64_H ONLY X64VSpaceRegionUse\n\nend (* context X64 *)\n\nend", "property": "Architecture-Specific Data Types: Define and share architecture-specific data types between the specification and abstract layers, ensuring consistency and compatibility across different architectural contexts.", "title": "./spec/design/skel/X64/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  Untyped_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/X64.lhs CONTEXT X64_H bodies_only ArchInv=ArchRetypeDecls_H NOT checkPML4At checkPDPTAt checkPDAt checkPTAt checkValidMappingSize\n#INCLUDE_HASKELL SEL4/Object/IOPort/X64.lhs CONTEXT X64_H bodies_only ArchInv=ArchRetypeDecls_H\n\ndefs checkValidMappingSize_def:\n  \"checkValidMappingSize sz \\<equiv> stateAssert\n    (\\<lambda>s. 2 ^ pageBitsForSize sz <= gsMaxObjectSize s) []\"\n\nend\n\nend", "property": "VSpace Lookup and Validation: Ensures that the mapping size for a virtual space is valid by checking that the size is within the allowed maximum object size.", "title": "./spec/design/skel/X64/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/X64.lhs RegisterSet= CONTEXT X64_H\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\nend\nend", "property": "Architectural TCB Operations: Define and implement architecture-specific operations for thread control blocks, including getting and setting thread state, tailored for the x64 architecture.", "title": "./spec/design/skel/X64/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchVSpaceDecls_H\nimports ArchRetypeDecls_H InvocationLabels_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT X64_H\n#INCLUDE_HASKELL_PREPARSE SEL4/API/InvocationLabels/X64.lhs CONTEXT X64\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/X64.lhs CONTEXT X64_H decls_only ArchInv=\n#INCLUDE_HASKELL SEL4/Object/IOPort/X64.lhs CONTEXT X64_H decls_only ArchInv=\n\nend (* context X64 *)\n\nend", "property": "Retyping Objects: Define and manage the reconfiguration of objects within the system, including structures, invocation labels, and virtual space operations, to ensure they meet the required architectural specifications.", "title": "./spec/design/skel/X64/ArchVSpaceDecls_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "definition\n  canonicalAddressAssert :: \"machine_word => bool\" where\n  canonicalAddressAssert_def[simp]:\n  \"canonicalAddressAssert p = True\"\n\nend", "property": "Canonical Address Assertion: Ensures that a given machine word is considered canonical, which may be defined or delayed differently across various architectures.", "title": "./spec/design/skel/X64/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/X64.lhs CONTEXT X64_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Define a set of labels for architecture-specific system calls, providing a standardized way to identify and invoke these operations within the system.", "title": "./spec/design/skel/X64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/X64.lhs CONTEXT X64_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch-Specific Invocation Label Requalification: Ensures that the invocation labels specific to the architecture are requalified and properly integrated within the architectural context, facilitating the correct handling of architecture-specific operations.", "title": "./spec/design/skel/X64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext FPUNullState ((K 0) aLU initContext)\"\n\nend\nend", "property": "Register Set Initialization: Defines a new user context with an initial state, setting the floating-point unit (FPU) to a null state and initializing the general-purpose registers.", "title": "./spec/design/skel/X64/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/X64.lhs\n\n#INCLUDE_HASKELL SEL4/API/Faults/X64.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/X64.lhs bodies_only\n\nend\n\nend", "property": "Fault Handling: Defines the architecture-specific fault handling mechanisms, including the declaration and implementation of fault types and their corresponding failure handling logic.", "title": "./spec/design/skel/X64/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/X64.lhs CONTEXT X64_H decls_only\n#INCLUDE_HASKELL SEL4/Object/Structures/X64.lhs CONTEXT X64_H instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/X64.lhs CONTEXT X64_H bodies_only\n\ndatatype arch_kernel_object_type =\n    PDET\n  | PTET\n  | PDPTET\n  | PML4ET\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPDE e) = PDET\"\n| \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOPDPTE e) = PDPTET\"\n| \"archTypeOf (KOPML4E e) = PML4ET\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend\nend", "property": "Arch Kernel Object Types: Defines a set of arch kernel object types, including PDET, PTET, PDPTET, PML4ET, and ASIDPoolT, and provides a function to determine the type of a given arch kernel object.", "title": "./spec/design/skel/X64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=X64 CONTEXT X64_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Architectural Constants and Register Set Definitions: Define and requalify architectural constants and register set operations for the X64 architecture, including definitions for pointer conversion and null pointer.", "title": "./spec/design/skel/X64/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/X64.lhs CONTEXT X64_H bodies_only ArchInv= Arch=\n\nend\n\nend", "property": "Architectural Interrupt Handling: Defines the architecture-specific interrupt handling mechanisms, including declarations and configurations for interrupts on the x64 platform. This ensures that the system can manage and respond to hardware interrupts effectively, maintaining the stability and responsiveness of the operating system.", "title": "./spec/design/skel/X64/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  KI_Decls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/X64.lhs CONTEXT X64_H Arch.Types=ArchTypes_H ArchInv=ArchRetypeDecls_H NOT bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/X64.lhs CONTEXT X64_H bodies_only\n\nend (* context X64 *)\nend", "property": "Retyping Objects: Define and manage the reconfiguration of object types, allowing for the transformation of one type of object into another within the system. This ensures flexibility and adaptability in the use of system resources.", "title": "./spec/design/skel/X64/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewPageCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        return $ map (\\<lambda>n. PageCap (PPtr (fromPPtr n)) VMReadWrite VMNoMap pSize dev Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects tableBits objectProto cap initialiseMappings \\<equiv> (do\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      initialiseMappings pts;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 0 X64SmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev ptTranslationBits X64LargePage\n        | HugePageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev (ptTranslationBits + ptTranslationBits) X64HugePage\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects ptBits (makeObject::pte) PageTableCap\n              (\\<lambda>pts. return ())\n        | PageDirectoryObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pdBits (makeObject::pde) PageDirectoryCap\n              (\\<lambda>pts. return ())\n        | PDPointerTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pdptBits (makeObject::pdpte) PDPointerTableCap\n              (\\<lambda>pts. return ())\n        | PML4Object \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pml4Bits (makeObject::pml4e) PML4Cap\n              (\\<lambda>pms. mapM_x copyGlobalMappings pms)\n        )\"\n\nend\nend\n\nend", "property": "Create New Memory Objects: Generate new memory objects (pages or tables) and their corresponding capabilities based on the specified type, region base, number of objects, and other parameters. The function initializes the memory objects and updates the kernel state to reflect the new mappings, ensuring that the system can manage and access the newly created memory regions effectively.", "title": "./spec/design/skel/X64/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\nbegin\n\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/X64.lhs CONTEXT X64_H Arch=MachineOps ArchReg=MachineTypes bodies_only\n\nend (* context X64 *)\n\nend", "property": "Thread Architecture: Defines the architecture-specific thread operations and structures for the x64 platform, including thread control block (TCB) declarations and virtual space management.", "title": "./spec/design/skel/X64/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "end", "property": "No specific code or comments are provided for the x64 section, so there is no property to summarize.", "title": "./spec/design/skel/X64/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": " None for x64 "}
{"spec": "(*\n  Hypervisor stub for X64\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  KI_Decls_H\n  InterruptDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/X64.lhs Arch= CONTEXT X64_H decls_only ArchInv= ArchLabels=\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/X64.lhs Arch= CONTEXT X64_H bodies_only ArchInv= ArchLabels=\n\nend\nend", "property": "Hypervisor Stub for X64: Provides the necessary declarations and implementations for hypervisor functionalities specific to the X64 architecture, ensuring that the hypervisor can manage and interact with virtualized resources effectively.", "title": "./spec/design/skel/X64/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/X64.lhs CONTEXT X64_H decls_only ArchInv= Arch=MachineOps\n\nend (* context X64 *)\n\nend", "property": "Architectural Interrupt Declarations: Define and declare the necessary components and operations for handling interrupts in the x64 architecture, ensuring that the system can manage and respond to hardware interrupts effectively.", "title": "./spec/design/skel/X64/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs Platform=Platform.X64 CONTEXT X64_H NOT getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory wordFromPDE wordFromPTE VMFaultType HypFaultType VMMapType VMPageSize pageBits pageBitsForSize paddrBase pptrBase pptrTop pptrBaseOffset kernelELFBaseOffset kernelELFPAddrBase kernelELFBase toPAddr addrFromPPtr ptrFromPAddr addrFromKPPtr setCurrentUserCR3 getCurrentUserCR3 invalidateTLB invalidateTLBEntry mfence wordFromPML4E wordFromPDPTE firstValidIODomain numIODomainIDBits hwASIDInvalidate getFaultAddress irqIntOffset maxPCIBus maxPCIDev maxPCIFunc ioapicIRQLines ioapicMapPinToVector irqStateIRQIOAPICNew irqStateIRQMSINew updateIRQState in8 out8 in16 out16 in32 out32 invalidatePageStructureCache writeCR3 invalidateASID invalidateTranslationSingleASID invalidateLocalPageStructureCacheASID ptTranslationBits nativeThreadUsingFPU switchFpuOwner\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs CONTEXT X64_H instanceproofs NOT VMFaultType VMPageSize VMPageEntry VMMapType HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs CONTEXT X64_H ONLY wordFromPDE wordFromPTE wordFromPML4E wordFromPDPTE", "property": "Hardware Abstraction and Memory Management: Provides a comprehensive set of functions for hardware-level operations, including memory management, interrupt handling, timer configuration, and I/O operations. These functions ensure that the system can interact with the underlying hardware efficiently and safely, supporting critical tasks such as memory initialization, page table manipulation, and interrupt management.", "title": "./spec/design/skel/X64/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ \\<equiv> Platform.X64.maxIRQ\"\n\nend (* context X64 *)\n\nend", "property": "Maximum IRQ Definition: The maximum interrupt request (IRQ) number is defined based on the platform-specific value for x64 architectures.", "title": "./spec/design/skel/X64/Hardware_H.thy", "chapter": "", "section": "", "comment": " Unlike on Arm architectures, maxIRQ comes from Platform definitions.\n   We provide this abbreviation to match arch-split expectations. "}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/RISCV64.hs\n\nend (* context Arch *)\n\nend", "property": "Arch-specific Ghost Update Functions: Define and implement architecture-specific ghost update functions for managing physical memory in the RISC-V64 architecture.", "title": "./spec/design/skel/RISCV64/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/RISCV64.hs CONTEXT RISCV64_H decls_only\n\nend (* context RISCV64 *)\n\nend", "property": "Function Declarations for Threads: Defines the necessary function declarations and context setup for thread management in the RISCV64 architecture, ensuring that the kernel has the required functions to handle thread operations.", "title": "./spec/design/skel/RISCV64/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify RISCV64_H (in Arch)\ninstantiation RISCV64_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [HugePageObject,\n      SmallPageObject,\n      LargePageObject,\n      PageTableObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation RISCV64_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation RISCV64_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Defines the enumeration of object types for the RISCV64_H architecture, including API object types and specific memory objects such as HugePage, SmallPage, LargePage, and PageTable. Ensures that all possible object types are covered and can be uniquely identified.", "title": "./spec/design/skel/RISCV64/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/RISCV64.hs CONTEXT RISCV64_H NOT RISCVVSpaceRegionUse\n\nend\nend", "property": "Architecture-Specific Kernel State and Monads: Defines the architecture-specific kernel state and monads, incorporating necessary imports and context for the RISCV64 architecture. This ensures that the kernel's state and operations are tailored to the specific requirements and capabilities of the RISCV64 architecture.", "title": "./spec/design/skel/RISCV64/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/Failures/RISCV64.hs CONTEXT RISCV64_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/RISCV64.hs CONTEXT RISCV64_H bodies_only\n\nend\nend", "property": "VSpace Lookup: Provides the necessary definitions and context for handling architecture-specific failures in the RISCV64 architecture, ensuring that the system can properly manage and respond to various fault conditions.", "title": "./spec/design/skel/RISCV64/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation RISCV64_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pte updateObject_pte\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Initialization and Management: The ASID pool is initialized with a function array where each entry is set to `Nothing`. The loading and updating of the ASID pool object are handled by default methods, ensuring that the ASID pool can be managed within the kernel's memory space.", "title": "./spec/design/skel/RISCV64/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Setup_Locale\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/RISCV64.hs CONTEXT RISCV64_H ONLY RISCVVSpaceRegionUse\n\nend\n\nend", "property": "Architecture-Specific Data Types: Define and share common, architecture-specific data types between the specification and abstract models, ensuring consistency and reusability across different components of the system.", "title": "./spec/design/skel/RISCV64/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  Untyped_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/RISCV64.hs CONTEXT RISCV64_H bodies_only ArchInv=ArchRetypeDecls_H ONLY pteAtIndex getPPtrFromHWPTE isPageTablePTE ptBitsLeft\n\nfun\n  lookupPTSlotFromLevel :: \"nat => machine_word => machine_word => (nat * machine_word) kernel\"\nwhere\n  \"lookupPTSlotFromLevel 0 ptPtr vPtr =\n     return (ptBitsLeft 0, ptSlotIndex 0 ptPtr vPtr)\"\n| \"lookupPTSlotFromLevel level ptPtr vPtr = do\n     pte <- pteAtIndex level ptPtr vPtr;\n     if isPageTablePTE pte\n     then do\n       checkPTAt (getPPtrFromHWPTE pte);\n       lookupPTSlotFromLevel (level - 1) (getPPtrFromHWPTE pte) vPtr\n     od\n     else return (ptBitsLeft level, ptSlotIndex level ptPtr vPtr)\n   od\"\n\nfun\n  lookupPTFromLevel :: \"nat => machine_word => machine_word => machine_word =>\n    (lookup_failure, machine_word) kernel_f\"\nwhere\n  \"lookupPTFromLevel level ptPtr vPtr targetPtPtr = doE\n    assertE (ptPtr \\<noteq> targetPtPtr);\n    unlessE (0 < level) $ throw InvalidRoot;\n    slot <- returnOk $ ptSlotIndex level ptPtr vPtr;\n    pte <- withoutFailure $ getObject slot;\n    unlessE (isPageTablePTE pte) $ throw InvalidRoot;\n    ptr <- returnOk (getPPtrFromHWPTE pte);\n    if ptr = targetPtPtr\n        then returnOk slot\n        else doE\n          liftE $ checkPTAt ptr;\n          lookupPTFromLevel (level - 1) ptr vPtr targetPtPtr\n        odE\n  odE\"\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/RISCV64.hs CONTEXT RISCV64_H bodies_only ArchInv=ArchRetypeDecls_H NOT lookupPTSlotFromLevel lookupPTFromLevel pteAtIndex getPPtrFromHWPTE isPageTablePTE ptBitsLeft checkPTAt\n\nend\n\nend", "property": "VSpace Lookup: Recursively traverses the page table hierarchy to find the appropriate slot or pointer based on the given virtual address and level, ensuring that the page table entries are valid and correctly point to the next level of the hierarchy.", "title": "./spec/design/skel/RISCV64/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/RISCV64.hs RegisterSet= CONTEXT RISCV64_H\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\nend\nend", "property": "Architectural TCB Operations: Provides functions for getting and setting thread control block (TCB) architectural state, allowing for the manipulation of register sets and other architecture-specific properties.", "title": "./spec/design/skel/RISCV64/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchVSpaceDecls_H\nimports ArchRetypeDecls_H InvocationLabels_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT RISCV64_H\n#INCLUDE_HASKELL_PREPARSE SEL4/API/InvocationLabels/RISCV64.hs CONTEXT RISCV64\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/RISCV64.hs CONTEXT RISCV64_H decls_only ArchInv= NOT lookupPTSlotFromLevel lookupPTFromLevel\n\nend (* context RISCV64 *)\n\nend", "property": "Object Retyping: Allows the redefinition of an object's type and structure, enabling the transformation of one type of object into another. This process ensures that the system can dynamically adapt and manage memory and resources efficiently.", "title": "./spec/design/skel/RISCV64/ArchVSpaceDecls_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "consts canonicalAddressAssert :: \"machine_word => bool\"\n\nend", "property": "Canonical Address Assertion: Ensures that a given machine word represents a canonical address, which may be defined or delayed differently across various architectures.", "title": "./spec/design/skel/RISCV64/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/RISCV64.hs CONTEXT RISCV64_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Define a set of architecture-specific labels for system calls, providing a standardized way to identify and handle different types of system calls in the RISCV64 architecture.", "title": "./spec/design/skel/RISCV64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/RISCV64.hs CONTEXT RISCV64_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch-Specific Invocation Label Requalification: Requalifies the `arch_invocation_label` type within the Arch context, ensuring that it adheres to the specific requirements and constraints of the RISCV64 architecture.", "title": "./spec/design/skel/RISCV64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext ((K 0) aLU initContext)\"\n\nend\nend", "property": "Register Set Initialization: Define a new user context with all registers initialized to zero. This ensures that the initial state of the user context is well-defined and consistent, providing a clean starting point for thread execution.", "title": "./spec/design/skel/RISCV64/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/RISCV64.hs\n\n#INCLUDE_HASKELL SEL4/API/Faults/RISCV64.hs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/RISCV64.hs bodies_only\n\nend\n\nend", "property": "Fault Handling: Defines the fault handling mechanisms and associated failures for the RISC-V64 architecture, ensuring that the system can properly manage and respond to various types of faults.", "title": "./spec/design/skel/RISCV64/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/RISCV64.hs CONTEXT RISCV64_H decls_only\n#INCLUDE_HASKELL SEL4/Object/Structures/RISCV64.hs CONTEXT RISCV64_H instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/RISCV64.hs CONTEXT RISCV64_H bodies_only\n\ndatatype arch_kernel_object_type =\n    PTET\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend\nend", "property": "Architectural Kernel Object Types: Defines two types of architectural kernel objects, Page Table Entry (PTE) and ASID Pool, and provides a function to determine the type of a given architectural kernel object.", "title": "./spec/design/skel/RISCV64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=RISCV64 CONTEXT RISCV64_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Requalification and Import of Word and Register Set Definitions: Requalifies and imports word and register set definitions for the RISCV64 architecture, ensuring that these definitions are available in the current context. Defines pointer conversion functions and a null pointer value, facilitating machine word operations and register manipulations specific to the RISCV64 architecture.", "title": "./spec/design/skel/RISCV64/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/RISCV64.hs CONTEXT RISCV64_H bodies_only ArchInv= Arch= NOT plic_complete_claim\n\nend\n\nend", "property": "Architectural Interrupt Handling: Defines the handling and management of interrupts specific to the RISCV64 architecture, including operations for claiming and completing interrupt requests.", "title": "./spec/design/skel/RISCV64/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  KI_Decls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/RISCV64.hs CONTEXT RISCV64_H Arch.Types=ArchTypes_H ArchInv=ArchRetypeDecls_H NOT bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/RISCV64.hs CONTEXT RISCV64_H bodies_only\n\nend (* context RISCV64 *)\nend", "property": "Retyping Objects: Allows the transformation of an object's type, enabling the modification of its structure and capabilities to fit different roles or requirements within the system.", "title": "./spec/design/skel/RISCV64/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewFrameCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        return $ map (\\<lambda>n. FrameCap  (PPtr (fromPPtr n)) VMReadWrite pSize dev Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects tableBits objectProto cap initialiseMappings \\<equiv> (do\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      initialiseMappings pts;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev 0 RISCVSmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev ptTranslationBits RISCVLargePage\n        | HugePageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev (ptTranslationBits + ptTranslationBits) RISCVHugePage\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects ptBits (makeObject::pte) PageTableCap\n              (\\<lambda>pts. return ())\n        )\"\n\nend\nend\n\nend", "property": "Create New Capabilities: Generate new capabilities for different types of objects (frames or tables) based on the specified region, number of objects, and object type. For frame objects, it creates user data or device data frames with specified sizes and sets their permissions. For table objects, it initializes mappings and generates corresponding capabilities.", "title": "./spec/design/skel/RISCV64/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/RISCV64.hs CONTEXT RISCV64_H Arch=MachineOps ArchReg=MachineTypes bodies_only\n\nend (* context RISCV64 *)\n\nend", "property": "Thread Management: Defines the architecture-specific thread management operations and data structures for the RISCV64 architecture, ensuring proper handling of thread states and behaviors within the kernel.", "title": "./spec/design/skel/RISCV64/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "end", "property": "No specific property can be derived from the provided code snippet, as it only contains an `end` statement and no functional or behavioral definitions.", "title": "./spec/design/skel/RISCV64/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": " None for RISCV64 "}
{"spec": "(*\n  Hypervisor stub for RISCV64\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  KI_Decls_H\n  InterruptDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/RISCV64.hs Arch= CONTEXT RISCV64_H decls_only ArchInv= ArchLabels=\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/RISCV64.hs Arch= CONTEXT RISCV64_H bodies_only ArchInv= ArchLabels=\n\nend\nend", "property": "Hypervisor Stub for RISCV64: Provides the necessary declarations and implementations for hypervisor functionality specific to the RISCV64 architecture, ensuring that the hypervisor can manage and interact with virtual machines effectively.", "title": "./spec/design/skel/RISCV64/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/RISCV64.hs CONTEXT RISCV64_H decls_only ArchInv= Arch=MachineOps NOT plic_complete_claim\n\nend (* context RISCV64 *)\n\nend", "property": "Architectural Interrupt Declarations: Define the declarations and operations for handling interrupts in the RISCV64 architecture, including the necessary context and global naming conventions.", "title": "./spec/design/skel/RISCV64/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs Platform=Platform.RISCV64 CONTEXT RISCV64_H NOT plic_complete_claim getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory setHardwareASID wordFromPDE wordFromPTE VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize toPAddr addrFromPPtr ptrFromPAddr sfence physBase paddrBase pptrBase pptrBaseOffset pptrTop pptrUserTop kernelELFBase kernelELFBaseOffset kernelELFPAddrBase addrFromKPPtr ptTranslationBits vmFaultTypeFSR read_stval setVSpaceRoot hwASIDFlush setIRQTrigger\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64_H instanceproofs NOT plic_complete_claim HardwareASID VMFaultType VMPageSize VMPageEntry HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64_H ONLY wordFromPTE", "property": "Hardware Abstraction: Provides a set of hardware-specific operations and constants for the RISCV64 architecture, including memory management, interrupt handling, timer configuration, and virtual memory operations. These functions and values enable the operating system to interact with the underlying hardware effectively, ensuring proper resource management and system stability.", "title": "./spec/design/skel/RISCV64/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ \\<equiv> Platform.RISCV64.maxIRQ\"\n\nend (* context RISCV64 *)\n\nend", "property": "Max IRQ Definition: The maximum interrupt request (IRQ) number is defined according to the platform-specific definitions for the RISCV64 architecture.", "title": "./spec/design/skel/RISCV64/Hardware_H.thy", "chapter": "", "section": "", "comment": " Unlike on Arm architectures, maxIRQ comes from Platform definitions.\n   We provide this abbreviation to match arch-split expectations. "}
{"spec": "chapter \"VCPU\"\n\ntheory VCPU_H\nimports\n  Hardware_H\n  Structures_H\n  Invocations_H\n  TCB_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT AARCH64_H\n#INCLUDE_HASKELL SEL4/Object/VCPU/AARCH64.hs CONTEXT AARCH64_H ArchInv=Arch \\\n  NOT vcpuUpdate vgicUpdate vgicUpdateLR vcpuSaveReg vcpuRestoreReg \\\n    vcpuSaveRegRange vcpuRestoreRegRange vcpuWriteReg vcpuReadReg saveVirtTimer \\\n    restoreVirtTimer vcpuDisable vcpuEnable vcpuRestore vcpuSave vcpuSwitch \\\n    vcpuInvalidateActive vcpuCleanInvalidateActive countTrailingZeros virqType \\\n    virqSetEOIIRQEN vgicMaintenance vppiEvent irqVPPIEventIndex armvVCPUSave \\\n    curVCPUActive\n\nend\nend", "property": "VCPU Management: Provides functionalities for managing virtual CPUs, including enabling, disabling, saving, restoring, and switching VCPUs, as well as handling virtual interrupts and maintaining VCPU state.", "title": "./spec/design/skel/AARCH64/VCPU_H.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/AARCH64.hs decls_only ONLY pTablePartialOverlap\n#INCLUDE_HASKELL SEL4/Model/PSpace/AARCH64.hs NOT pTablePartialOverlap\n\nend (* context Arch *)\n\nend", "property": "Arch-Specific Physical Memory Management: Provides functions for managing physical memory, including handling page table partial overlaps, ensuring that memory is correctly allocated and managed according to the architecture's specifications.", "title": "./spec/design/skel/AARCH64/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/AARCH64.hs CONTEXT AARCH64_H decls_only\n\nend (* context AARCH64 *)\n\nend", "property": "Function Declarations for Threads: Defines the necessary function declarations and context for thread management in an AARCH64 architecture, ensuring that the kernel can handle thread-related operations effectively.", "title": "./spec/design/skel/AARCH64/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify AARCH64_H (in Arch)\ninstantiation AARCH64_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [HugePageObject,\n      VSpaceObject,\n      SmallPageObject,\n      LargePageObject,\n      PageTableObject,\n      VCPUObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation AARCH64_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation AARCH64_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Defines the enumeration of object types for the AARCH64 architecture, including specific types such as HugePageObject, VSpaceObject, SmallPageObject, LargePageObject, PageTableObject, and VCPUObject. Ensures that all and any properties over the object types are correctly defined and that the enumeration is distinct and complete.", "title": "./spec/design/skel/AARCH64/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/AARCH64.hs CONTEXT AARCH64_H NOT ArmVSpaceRegionUse\n\nend\nend", "property": "Architecture-Specific Kernel State and Monads: Defines the architecture-specific kernel state and monads, incorporating the necessary components from various architectural structures and types to support the SEL4 model.", "title": "./spec/design/skel/AARCH64/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/Failures/AARCH64.hs CONTEXT AARCH64_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/AARCH64.hs CONTEXT AARCH64_H bodies_only\n\nend\nend", "property": "VSpace Lookup: Provides mechanisms for handling and translating virtual memory faults in the AARCH64 architecture, ensuring that the system can respond appropriately to memory access errors.", "title": "./spec/design/skel/AARCH64/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation AARCH64_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pte updateObject_pte\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Management: The ASID pool is represented as a fixed-size array of `Nothing` values, ensuring a safe and consistent structure for managing ASID mappings. The load and update operations for the ASID pool are defined to use default implementations, maintaining the integrity and simplicity of the ASID pool's state.", "title": "./spec/design/skel/AARCH64/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Setup_Locale\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/AARCH64.hs CONTEXT AARCH64_H ONLY ArmVSpaceRegionUse\n\n#INCLUDE_HASKELL SEL4/API/Invocation/AARCH64.hs CONTEXT AARCH64_H ONLY FlushType\n\nend\n\nend", "property": "Common, Architecture-Specific Data Types: Define and share architecture-specific data types, such as ArmVSpaceRegionUse and FlushType, between the specification and abstract layers to ensure consistent representation and handling of architecture-specific concepts.", "title": "./spec/design/skel/AARCH64/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/AARCH64.hs CONTEXT AARCH64_H bodies_only ArchInv=ArchRetypeDecls_H ONLY pteAtIndex getPPtrFromHWPTE isPageTablePTE ptBitsLeft\n\nfun\n  lookupPTSlotFromLevel :: \"nat => machine_word => machine_word => (nat * machine_word) kernel\"\nwhere\n  \"lookupPTSlotFromLevel 0 ptPtr vPtr =\n     return (ptBitsLeft 0, ptSlotIndex 0 ptPtr vPtr)\"\n| \"lookupPTSlotFromLevel level ptPtr vPtr = do\n     pte <- pteAtIndex level ptPtr vPtr;\n     if isPageTablePTE pte\n     then do\n       checkPTAt NormalPT_T (getPPtrFromPTE pte);\n       lookupPTSlotFromLevel (level - 1) (getPPtrFromPTE pte) vPtr\n     od\n     else return (ptBitsLeft level, ptSlotIndex level ptPtr vPtr)\n   od\"\n\nfun\n  lookupPTFromLevel :: \"nat => machine_word => machine_word => machine_word =>\n    (lookup_failure, machine_word) kernel_f\"\nwhere\n  \"lookupPTFromLevel level ptPtr vPtr targetPtPtr = doE\n    assertE (ptPtr \\<noteq> targetPtPtr);\n    unlessE (0 < level) $ throw InvalidRoot;\n    slot <- returnOk $ ptSlotIndex level ptPtr vPtr;\n    pte <- withoutFailure $ getObject slot;\n    unlessE (isPageTablePTE pte) $ throw InvalidRoot;\n    ptr <- returnOk (getPPtrFromPTE pte);\n    if ptr = targetPtPtr\n        then returnOk slot\n        else doE\n          liftE $ checkPTAt NormalPT_T ptr;\n          lookupPTFromLevel (level - 1) ptr vPtr targetPtPtr\n        odE\n  odE\"\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/AARCH64.hs CONTEXT AARCH64_H bodies_only ArchInv=ArchRetypeDecls_H NOT lookupPTSlotFromLevel lookupPTFromLevel pteAtIndex getPPtrFromHWPTE isPageTablePTE ptBitsLeft checkPTAt checkValidMappingSize\n\ndefs checkValidMappingSize_def:\n  \"checkValidMappingSize sz \\<equiv> stateAssert (\\<lambda>s. 2 ^ sz <= gsMaxObjectSize s) []\"\n\nend\n\nend", "property": "VSpace Lookup: Recursively traverses the page table hierarchy to find the appropriate slot for a given virtual address, ensuring that each level is a valid page table and stopping at the target level or when a non-page-table PTE is encountered. Subproperties include:\n- **PT Slot Lookup**: Determines the slot index at a specific level of the page table hierarchy.\n- **PT Hierarchy Traversal**: Recursively checks each level of the page table, validating the PTEs and continuing to the next level until the target is found or a non-page-table PTE is encountered.", "title": "./spec/design/skel/AARCH64/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/AARCH64.hs RegisterSet= CONTEXT AARCH64_H\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\nend\nend", "property": "Architectural Thread Management: Provides functions for getting and setting architectural-specific thread states, including register sets, ensuring that the thread's state is correctly managed and updated according to the architecture's requirements.", "title": "./spec/design/skel/AARCH64/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "consts'\npageBase :: \"('a :: len word) \\<Rightarrow> nat \\<Rightarrow> 'a word\"\n\nend (* context AARCH64 *)\n\nend", "property": "Page Base Calculation: Compute the base address of a page given a word and an offset, ensuring that the result is within the constraints of the specified word length.", "title": "./spec/design/skel/AARCH64/ArchVSpaceDecls_H.thy", "chapter": "", "section": "", "comment": " no \"wordlike\" class with a direct translation available, use more constrained spec "}
{"spec": "consts canonicalAddressAssert :: \"machine_word => bool\"\n\nend", "property": "Canonical Address Assertion: Ensures that a given machine word represents a canonical address, with the definition and validation potentially varying across different architectures.", "title": "./spec/design/skel/AARCH64/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/AARCH64.hs CONTEXT AARCH64_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Enumerate labels for architecture-specific system calls, providing a structured way to identify and handle different types of system calls in the AARCH64 architecture.", "title": "./spec/design/skel/AARCH64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/AARCH64.hs CONTEXT AARCH64_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch-Specific Invocation Label Requalification: The code requalifies arch-specific invocation labels within the Arch context, ensuring that the enum instances are correctly defined and used outside of the generic Arch locale.", "title": "./spec/design/skel/AARCH64/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition newFPUState :: \"fpu_state\" where\n  \"newFPUState \\<equiv> FPUState (K 0) 0 0 \"\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext newFPUState ((K 0) aLU initContext)\"\n\nend\nend", "property": "Register Initialization: Defines the initial state for the FPU and user context, setting all registers to a default value of 0. This ensures that the system starts in a known and consistent state.", "title": "./spec/design/skel/AARCH64/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/AARCH64.hs\n\n#INCLUDE_HASKELL SEL4/API/Faults/AARCH64.hs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/AARCH64.hs bodies_only\n\nend\n\nend", "property": "Fault Handling: Define and manage fault handlers for the AARCH64 architecture, ensuring that the system can appropriately respond to and handle various types of faults.", "title": "./spec/design/skel/AARCH64/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64_H decls_only \\\n  NOT VPPIEventIRQ VirtTimer\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64_H instanceproofs \\\n  NOT VPPIEventIRQ VirtTimer\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64_H bodies_only \\\n  NOT makeVCPUObject", "property": "Architectural Structures: Define and initialize the architectural-specific structures and objects for the AARCH64 architecture, including ASID pools and TCBs, while excluding VPPIEventIRQ and VirtTimer.", "title": "./spec/design/skel/AARCH64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "defs makeVCPUObject_def:\n\"makeVCPUObject \\<equiv>\n    VCPUObj_ \\<lparr>\n          vcpuTCBPtr= Nothing\n        , vcpuVGIC= VGICInterface_ \\<lparr>\n                          vgicHCR= vgicHCREN\n                        , vgicVMCR= 0\n                        , vgicAPR= 0\n                        , vgicLR= (\\<lambda>_. 0)\n                        \\<rparr>\n        , vcpuRegs= funArray (const 0)  aLU  [(VCPURegSCTLR, sctlrEL1VM)]\n        , vcpuVPPIMasked= (\\<lambda>_. False)\n        , vcpuVTimer= VirtTimer 0\n        \\<rparr>\"\n\ndatatype arch_kernel_object_type =\n    PTET\n  | VCPUT\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOVCPU e) = VCPUT\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend", "property": "Create VCPU Object: Defines the creation of a VCPU object with specific initial values for its components, including an empty TCB pointer, a VGIC interface with default settings, a set of registers initialized to zero with specific exceptions, a VPPIMasked function that always returns false, and a virtual timer initialized to zero.", "title": "./spec/design/skel/AARCH64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": " we define makeVCPUObject_def manually because we want a total function vgicLR "}
{"spec": "arch_requalify_types (H)\n  vcpu\n\nend", "property": "Architectural Requalification: The requalification of types is architecture-specific, allowing for the handling of unique architectural features such as vCPU. This ensures that the system can adapt to the specific requirements and capabilities of different architectures.", "title": "./spec/design/skel/AARCH64/ArchStructures_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, as some arches don't have vcpu "}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=AARCH64 CONTEXT AARCH64_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Architectural Constants and Utilities: Defines and requalifies architectural constants, including word bits, and provides utility functions for pointer manipulation, such as converting to and from physical pointers and defining a null pointer.", "title": "./spec/design/skel/AARCH64/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/AARCH64.hs CONTEXT AARCH64_H bodies_only ArchInv= Arch= NOT plic_complete_claim\n\nend\n\nend", "property": "Architectural Interrupt Handling: Defines the architecture-specific interrupt handling mechanisms for AARCH64, including declarations and configurations for interrupt objects and hypervisor interactions.", "title": "./spec/design/skel/AARCH64/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  KI_Decls_H\n  VCPU_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/AARCH64.hs CONTEXT AARCH64_H Arch.Types=ArchTypes_H ArchInv=ArchRetypeDecls_H NOT bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/AARCH64.hs CONTEXT AARCH64_H bodies_only \\\n  NOT isVSpaceFlushLabel isPageFlushLabel\n\nend (* context AARCH64 *)\nend", "property": "Retyping Objects: Allows the reclassification and reinitialization of objects in the system, enabling the transformation of one type of object into another while preserving the system's integrity and security.", "title": "./spec/design/skel/AARCH64/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewFrameCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        when (\\<not>dev) $\n          mapM_x (\\<lambda>addr. doMachineOp $\n                            cleanCacheRange_RAM addr\n                                                (addr + mask (pageBitsForSize pSize))\n                                                (addrFromPPtr addr)) addrs;\n        return $ map (\\<lambda>n. FrameCap  (PPtr (fromPPtr n)) VMReadWrite pSize dev Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects ptType objectProto cap initialiseMappings \\<equiv> (do\n      tableBits \\<leftarrow> return (ptBits ptType);\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      modify (\\<lambda>ks. ks \\<lparr>ksArchState :=\n                         ksArchState ks \\<lparr>gsPTTypes := (\\<lambda>addr.\n                                           if addr `~elem~` map fromPPtr addrs then Just ptType\n                                           else gsPTTypes (ksArchState ks) addr)\\<rparr>\\<rparr>);\n      initialiseMappings pts;\n      mapM_x (\\<lambda>addr. doMachineOp $\n                       cleanCacheRange_PoU addr (addr + mask tableBits) (addrFromPPtr addr)) addrs;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev 0 ARMSmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev (ptTranslationBits NormalPT_T) ARMLargePage\n        | HugePageObject \\<Rightarrow>\n            createNewFrameCaps regionBase numObjects dev (2 * ptTranslationBits NormalPT_T) ARMHugePage\n        | VSpaceObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects VSRootPT_T (makeObject::pte)\n              (\\<lambda>base addr. PageTableCap base VSRootPT_T addr)\n              (\\<lambda>pts. return ())\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects NormalPT_T (makeObject::pte)\n              (\\<lambda>base addr. PageTableCap base NormalPT_T addr)\n              (\\<lambda>pts. return ())\n        | VCPUObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject :: vcpu)) 0;\n            return $ map (\\<lambda>addr. VCPUCap addr) addrs\n            od)\n        )\"\n\nend\nend\n\nend", "property": "Create New Capabilities: Generates new capabilities based on the specified type, region base, and number of objects. This includes creating frame or table capabilities, updating kernel state, and performing necessary cache operations to ensure the integrity and readiness of the newly created memory regions.", "title": "./spec/design/skel/AARCH64/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/AARCH64.hs CONTEXT AARCH64_H Arch=MachineOps ArchReg=MachineTypes bodies_only\n\nend (* context AARCH64 *)\n\nend", "property": "Thread Management: Defines the architecture-specific operations and data structures for managing threads, including thread control block (TCB) declarations, virtual space management, and hypervisor interactions.", "title": "./spec/design/skel/AARCH64/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/API/Invocation/AARCH64.hs CONTEXT AARCH64_H \\\n  ONLY isVSpaceFlushLabel isPageFlushLabel\n\nend\nend", "property": "Arch-specific Invocation Labels: Determine if an invocation label corresponds to a virtual space flush or a page flush, enabling the system to handle architecture-specific memory management operations.", "title": "./spec/design/skel/AARCH64/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": "\n  Arch-specific functions on invocation labels\n"}
{"spec": "(*\n  Hypervisor function definitions for AARCH64\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  FaultHandlerDecls_H\n  InterruptDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/VCPU/AARCH64.hs CONTEXT AARCH64_H decls_only \\\n  ONLY countTrailingZeros irqVPPIEventIndex\n#INCLUDE_HASKELL SEL4/Object/VCPU/AARCH64.hs CONTEXT AARCH64_H bodies_only \\\n  ONLY countTrailingZeros irqVPPIEventIndex\n#INCLUDE_HASKELL SEL4/Object/VCPU/AARCH64.hs CONTEXT AARCH64_H ArchInv=Arch \\\n  ONLY vcpuUpdate vgicUpdate vgicUpdateLR vcpuSaveReg vcpuRestoreReg \\\n    vcpuSaveRegRange vcpuRestoreRegRange vcpuWriteReg vcpuReadReg saveVirtTimer \\\n    restoreVirtTimer vcpuDisable vcpuEnable vcpuRestore armvVCPUSave \\\n    vcpuSave vcpuSwitch vcpuInvalidateActive vcpuCleanInvalidateActive \\\n    virqType virqSetEOIIRQEN vgicMaintenance vppiEvent curVCPUActive\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/AARCH64.hs Arch= CONTEXT AARCH64_H decls_only ArchInv= ArchLabels=\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/AARCH64.hs Arch= CONTEXT AARCH64_H bodies_only ArchInv= ArchLabels=\n\nend\nend", "property": "Hypervisor Functions for AARCH64: Provides a set of functions to manage virtual CPUs, including updating, saving, restoring, enabling, and disabling vCPUs, as well as handling virtual interrupts and timer operations. These functions ensure the proper state management and control of virtual CPUs in the hypervisor environment.", "title": "./spec/design/skel/AARCH64/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/AARCH64.hs CONTEXT AARCH64_H decls_only ArchInv= Arch=MachineOps NOT plic_complete_claim\n\nend (* context AARCH64 *)\n\nend", "property": "Architectural Interrupt Declarations: Define the declarations and operations for managing interrupts on the AARCH64 architecture, ensuring that the system can handle and process interrupts effectively.", "title": "./spec/design/skel/AARCH64/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs Platform=Platform.AARCH64 CONTEXT AARCH64_H \\\n  NOT PT_Type plic_complete_claim getMemoryRegions getDeviceRegions getKernelDevices \\\n  loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt \\\n  configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory \\\n  clearMemoryVM initMemory freeMemory setHardwareASID wordFromPDE wordFromPTE \\\n  VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize toPAddr \\\n  addrFromPPtr ptrFromPAddr sfence physBase paddrBase pptrBase pptrBaseOffset \\\n  pptrUserTop kernelELFBase kernelELFBaseOffset kernelELFPAddrBase \\\n  addrFromKPPtr ptTranslationBits vmFaultTypeFSR setVSpaceRoot \\\n  setIRQTrigger \\\n  config_ARM_PA_SIZE_BITS_40 fpuThreadDeleteOp isFpuEnable \\\n  hcrVCPU hcrNative sctlrDefault vgicHCREN gicVCPUMaxNumLR sctlrEL1VM \\\n  get_gic_vcpu_ctrl_hcr set_gic_vcpu_ctrl_hcr get_gic_vcpu_ctrl_vmcr \\\n  set_gic_vcpu_ctrl_vmcr get_gic_vcpu_ctrl_apr set_gic_vcpu_ctrl_apr \\\n  get_gic_vcpu_ctrl_vtr get_gic_vcpu_ctrl_eisr0 get_gic_vcpu_ctrl_eisr1 \\\n  get_gic_vcpu_ctrl_misr get_gic_vcpu_ctrl_lr set_gic_vcpu_ctrl_lr read_cntpct \\\n  check_export_arch_timer \\\n  isb dsb dmb \\\n  invalidateTranslationASID invalidateTranslationSingle \\\n  cleanByVA_PoU cleanInvalidateCacheRange_RAM cleanCacheRange_RAM cleanCacheRange_PoU \\\n  invalidateCacheRange_RAM invalidateCacheRange_I branchFlushRange \\\n  enableFpuEL01 \\\n  getFAR getDFSR getIFSR getHSR setHCR getESR  getSCTLR setSCTLR \\\n  addressTranslateS1 \\\n  readVCPUHardwareReg writeVCPUHardwareReg vcpuBits\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64_H instanceproofs NOT plic_complete_claim HardwareASID VMFaultType VMPageSize VMPageEntry HypFaultType\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64_H ONLY wordFromPTE", "property": "Hardware Abstraction: Provides a comprehensive set of functions and constants for managing AARCH64 hardware, including memory operations, interrupt handling, timer configuration, and cache management. These abstractions enable the operating system to interact with the underlying hardware effectively, ensuring proper resource management and system stability.", "title": "./spec/design/skel/AARCH64/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ \\<equiv> Kernel_Config.maxIRQ\"\n\nend (* context AARCH64 *)\n\nend", "property": "Max IRQ Value: Defines the maximum value for an interrupt request (IRQ) in the system, ensuring that the kernel can handle and manage interrupts within a specified range.", "title": "./spec/design/skel/AARCH64/Hardware_H.thy", "chapter": "", "section": "", "comment": " Kernel_Config provides a generic numeral, Haskell expects type irq "}
{"spec": "chapter \"VCPU\"\n\ntheory VCPU_H\nimports\n  Hardware_H\n  Structures_H\n  Invocations_H\n  TCB_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL_PREPARSE SEL4/Object/Structures.lhs CONTEXT ARM_HYP_H\n#INCLUDE_HASKELL SEL4/Object/VCPU/ARM.lhs CONTEXT ARM_HYP_H ArchInv=Arch NOT vcpuUpdate vgicUpdate vgicUpdateLR vcpuSaveReg vcpuRestoreReg vcpuSaveRegRange vcpuRestoreRegRange vcpuWriteReg vcpuReadReg saveVirtTimer restoreVirtTimer vcpuDisable vcpuEnable vcpuRestore vcpuSave vcpuSwitch vcpuInvalidateActive vcpuCleanInvalidateActive countTrailingZeros virqSetEOIIRQEN vgicMaintenance vppiEvent irqVPPIEventIndex armvVCPUSave\n\nend\nend", "property": "VCPU Management: Provides functions for managing virtual CPUs, including enabling, disabling, saving, restoring, and switching VCPUs, as well as handling virtual interrupts and maintaining the state of the virtual CPU.", "title": "./spec/design/skel/ARM_HYP/VCPU_H.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "(* Arch-specific ghost update functions for physical memory *)\n\ntheory ArchPSpace_H\nimports\n  ObjectInstances_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/PSpace/ARM.hs\n\nend (* context Arch *)\n\nend", "property": "Arch-Specific Ghost Update Functions: Define and implement architecture-specific ghost update functions for managing physical memory, ensuring that the model accurately reflects the state and behavior of the system's memory.", "title": "./spec/design/skel/ARM_HYP/ArchPSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n    Declarations from SEL4.Kernel.Thread.\n*)\n\nchapter \"Function Declarations for Threads\"\n\ntheory ArchThreadDecls_H\nimports\n  Structures_H\n  FaultMonad_H\n  KernelInitMonad_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/ARM.lhs CONTEXT Arch decls_only\n\nend\nend", "property": "Function Declarations for Threads: Provides the necessary function declarations for thread management in the ARM architecture, ensuring that the system can handle thread-related operations effectively.", "title": "./spec/design/skel/ARM_HYP/ArchThreadDecls_H.thy", "chapter": "Function Declarations for Threads", "section": "", "comment": ""}
{"spec": "qualify ARM_HYP_H (in Arch)\ninstantiation ARM_HYP_H.object_type :: enum\nbegin\ninterpretation Arch .\ndefinition\n  enum_object_type: \"enum_class.enum \\<equiv>\n    map APIObjectType (enum_class.enum :: apiobject_type list) @\n     [PageDirectoryObject,\n      SmallPageObject,\n      LargePageObject,\n      SectionObject,\n      SuperSectionObject,\n      PageTableObject,\n      VCPUObject\n    ]\"\n\ndefinition\n  \"enum_class.enum_all (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Ball UNIV P\"\n\ndefinition\n  \"enum_class.enum_ex (P :: object_type \\<Rightarrow> bool) \\<longleftrightarrow> Bex UNIV P\"\n\n  instance\n    apply intro_classes\n     apply (safe, simp)\n     apply (case_tac x)\n    apply (simp_all add: enum_object_type)\n    apply (auto intro: distinct_map_enum\n                 simp: enum_all_object_type_def enum_ex_object_type_def)\n    done\nend\n\n\ninstantiation ARM_HYP_H.object_type :: enum_alt\nbegin\ninterpretation Arch .\ndefinition\n  enum_alt_object_type: \"enum_alt \\<equiv>\n    alt_from_ord (enum :: object_type list)\"\ninstance ..\nend\n\ninstantiation ARM_HYP_H.object_type :: enumeration_both\nbegin\ninterpretation Arch .\ninstance by (intro_classes, simp add: enum_alt_object_type)\nend\n\nend", "property": "Object Type Enumeration: Defines the enumeration of object types, including API object types and specific ARM hypervisor object types such as PageDirectory, SmallPage, LargePage, Section, SuperSection, PageTable, and VCPU. Ensures that all possible object types are covered and can be checked for properties using `enum_all` and `enum_ex`.", "title": "./spec/design/skel/ARM_HYP/ArchTypes_H.thy", "chapter": "", "section": "", "comment": "object\\_type instance proofs"}
{"spec": "(*\n    Kernel state and kernel monads, imports everything that SEL4.Model needs.\n*)\n\nchapter \"Architecture Specific Kernel State and Monads\"\n\ntheory ArchStateData_H\nimports\n  Arch_Structs_B\n  ArchTypes_H\n  ArchStructures_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/ARM.lhs CONTEXT ARM_HYP_H NOT ArmVSpaceRegionUse\n\nend\n\nend", "property": "Architecture-Specific Kernel State and Monads: Defines the architecture-specific kernel state and monads, incorporating necessary imports and context for the ARM architecture. This ensures that the kernel is tailored to the specific requirements and capabilities of the ARM architecture, providing a foundation for architecture-specific operations and state management.", "title": "./spec/design/skel/ARM_HYP/ArchStateData_H.thy", "chapter": "Architecture Specific Kernel State and Monads", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchFault_H\nimports Types_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_HYP_H decls_only\n#INCLUDE_HASKELL SEL4/API/Failures/ARM.lhs CONTEXT ARM_HYP_H bodies_only\n\n\nend\nend", "property": "VSpace Lookup: Provides mechanisms for handling and translating virtual memory faults, ensuring that the system can respond appropriately to memory access violations and maintain the integrity of the virtual address space.", "title": "./spec/design/skel/ARM_HYP/ArchFault_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "instantiation ARM_HYP_H.asidpool :: pspace_storable\nbegin\ninterpretation Arch .\n\ndefinition\n  makeObject_asidpool: \"(makeObject :: asidpool)  \\<equiv> ASIDPool $\n        funArray (const Nothing)\"\n\ndefinition\n  loadObject_asidpool[simp]:\n \"(loadObject p q n obj) :: asidpool kernel \\<equiv>\n    loadObject_default p q n obj\"\n\ndefinition\n  updateObject_asidpool[simp]:\n \"updateObject (val :: asidpool) \\<equiv>\n    updateObject_default val\"\n\ninstance\n  apply (intro_classes)\n  apply (clarsimp simp add: updateObject_default_def in_monad projectKO_opts_defs\n                            projectKO_eq2\n                     split: kernel_object.splits arch_kernel_object.splits)\n  done\n\nend\n\nlemmas load_update_defs =\n  loadObject_pde updateObject_pde\n  loadObject_pte updateObject_pte\n  loadObject_asidpool updateObject_asidpool\n\ndeclare load_update_defs[simp del]\n\nend_qualify\n\ndeclare (in Arch) load_update_defs[simp]\n\nend", "property": "ASID Pool Initialization and Management: The ASID pool is initialized with a function array where each element is set to `Nothing`, and the loading and updating of the ASID pool object are handled using default methods. This ensures that the ASID pool is consistently managed and updated in the kernel.", "title": "./spec/design/skel/ARM_HYP/ArchObjInsts_H.thy", "chapter": "", "section": "", "comment": " This is hard coded since using funArray in haskell for 2^32 bound is risky "}
{"spec": "(* Architecture-specific data types shared by spec and abstract. *)\n\nchapter \"Common, Architecture-Specific Data Types\"\n\ntheory Arch_Structs_B\nimports Main Setup_Locale\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Model/StateData/ARM.lhs CONTEXT ARM_HYP_H ONLY ArmVSpaceRegionUse\n\nend\nend", "property": "Define and Share Architecture-Specific Data Types: Establish common, architecture-specific data types that are utilized across both the specification and the abstract model, ensuring consistency and reusability in the system's formalization.", "title": "./spec/design/skel/ARM_HYP/Arch_Structs_B.thy", "chapter": "Common, Architecture-Specific Data Types", "section": "", "comment": ""}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchVSpace_H\nimports\n  CNode_H\n  KI_Decls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/VSpace/ARM.lhs CONTEXT ARM_HYP_H bodies_only ArchInv=ArchRetypeDecls_H.ARM_HYP ArchLabels=ArchInvocationLabels_H.ARM_HYP NOT checkPDAt checkPTAt checkPDASIDMapMembership checkValidMappingSize vptrFromPPtr\n\ndefs checkValidMappingSize_def:\n  \"checkValidMappingSize sz \\<equiv> stateAssert\n    (\\<lambda>s. 2 ^ pageBitsForSize sz <= gsMaxObjectSize s) []\"\n\nend\nend", "property": "VSpace Lookup and Validation: Ensures that the size of a mapping is valid by checking that it does not exceed the maximum object size allowed in the system.", "title": "./spec/design/skel/ARM_HYP/ArchVSpace_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchTCB_H\nimports TCBDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/TCB/ARM.lhs RegisterSet= CONTEXT ARM_HYP_H\n\n#INCLUDE_HASKELL SEL4/Object/TCB.lhs Arch= ONLY archThreadGet archThreadSet\n\n\nend\nend", "property": "Architectural TCB Operations: Define and implement architecture-specific operations for managing thread control blocks, including getting and setting thread state, ensuring that the TCB is correctly managed according to the architectural requirements.", "title": "./spec/design/skel/ARM_HYP/ArchTCB_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "consts'\npageBase :: \"('a :: len word) \\<Rightarrow> vmpage_size \\<Rightarrow> 'a word\"\n\nend\nend", "property": "Page Base Calculation: Compute the base address of a page given a word and a virtual memory page size, ensuring that the calculation adheres to more constrained specifications.", "title": "./spec/design/skel/ARM_HYP/ArchVSpaceDecls_H.thy", "chapter": "", "section": "", "comment": " no \"wordlike\" class with a direct translation available, use more constrained spec "}
{"spec": "definition\n  canonicalAddressAssert :: \"machine_word => bool\" where\n  canonicalAddressAssert_def[simp]:\n  \"canonicalAddressAssert p = True\"\n\nend", "property": "Canonical Address Assertion: Ensures that a given machine word is considered a valid canonical address, with the assertion always evaluating to true.", "title": "./spec/design/skel/ARM_HYP/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "definition\n  canonicalAddressAssert :: \"machine_word => bool\" where\n  canonicalAddressAssert_def[simp]:\n  \"canonicalAddressAssert p = True\"\n\nend", "property": "Canonical Address Assertion: The canonical address assertion is always true, indicating that the address is considered valid or canonical on all architectures.", "title": "./spec/design/skel/ARM_HYP/ArchRetypeDecls_H.thy", "chapter": "", "section": "", "comment": " Defined differently and/or delayed on different architectures "}
{"spec": "#INCLUDE_HASKELL SEL4/API/InvocationLabels/ARM.lhs CONTEXT ARM_HYP_H ONLY ArchInvocationLabel\n\nend", "property": "Arch-Specific System Call Labels: Define a set of labels for architecture-specific system calls, providing a standardized way to identify and handle different types of system calls in the ARM architecture.", "title": "./spec/design/skel/ARM_HYP/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": "\n  An enumeration of arch-specific system call labels.\n"}
{"spec": "arch_requalify_types (H)\n  arch_invocation_label\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/API/InvocationLabels/ARM.lhs CONTEXT ARM_HYP_H instanceproofs ONLY ArchInvocationLabel\n\nend\nend", "property": "Arch-Specific Invocation Label Requalification: Ensures that the invocation labels are requalified within the architecture-specific context, maintaining consistency and correctness for architecture-dependent operations.", "title": "./spec/design/skel/ARM_HYP/ArchInvocationLabels_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, since enum instance proofs must\n   be done outside of Arch locale "}
{"spec": "chapter \"Register Set\"\n\ntheory RegisterSet_H\nimports\n  \"Lib.HaskellLib_H\"\n  MachineOps\nbegin\ncontext Arch begin arch_global_naming (H)\n\ndefinition\n  newContext :: \"user_context\"\nwhere\n \"newContext \\<equiv> UserContext ((K 0) aLU initContext)\"\n\nend\nend", "property": "Register Set Initialization: Defines a new user context with all registers initialized to zero.", "title": "./spec/design/skel/ARM_HYP/RegisterSet_H.thy", "chapter": "Register Set", "section": "", "comment": ""}
{"spec": "chapter \"Fault Handlers\"\n\ntheory ArchFaultHandler_H\nimports TCB_H Structures_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL_PREPARSE SEL4/API/Failures/ARM.lhs\n\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs decls_only\n#INCLUDE_HASKELL SEL4/API/Faults/ARM.lhs bodies_only\n\nend\n\n\nend", "property": "Fault Handling: Defines the structure and behavior of fault handlers for the ARM architecture, including the declaration and implementation of fault-related functions and data structures. This ensures that the system can effectively manage and respond to various types of faults, maintaining system stability and reliability.", "title": "./spec/design/skel/ARM_HYP/ArchFaultHandler_H.thy", "chapter": "Fault Handlers", "section": "", "comment": ""}
{"spec": "theory ArchStructures_H\nimports\n  \"Lib.Lib\"\n  Types_H\n  Hardware_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_SETTINGS keep_constructor=asidpool\n#INCLUDE_SETTINGS keep_constructor=arch_tcb\n\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP_H decls_only NOT VPPIEventIRQ VirtTimer\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP_H instanceproofs NOT VPPIEventIRQ VirtTimer\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP_H bodies_only NOT makeVCPUObject", "property": "Architectural Structures: Define and instantiate the architectural-specific structures and objects for the ARM hypervisor, including ASID pools and TCBs, to support the execution and management of virtualized environments.", "title": "./spec/design/skel/ARM_HYP/ArchStructures_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "defs makeVCPUObject_def:\n\"makeVCPUObject \\<equiv>\n    VCPUObj_ \\<lparr>\n          vcpuTCBPtr= Nothing\n        , vcpuVGIC= VGICInterface_ \\<lparr>\n                          vgicHCR= vgicHCREN\n                        , vgicVMCR= 0\n                        , vgicAPR= 0\n                        , vgicLR= (\\<lambda>_. 0)\n                        \\<rparr>\n        , vcpuRegs= funArray (const 0)  aLU  [(VCPURegSCTLR, sctlrDefault)\n                                             ,(VCPURegACTLR, actlrDefault)]\n        , vcpuVPPIMasked= (\\<lambda>_. False)\n        , vcpuVTimer= VirtTimer 0\n        \\<rparr>\"\n\ndatatype arch_kernel_object_type =\n    PDET\n  | PTET\n  | VCPUT\n  | ASIDPoolT\n\nprimrec\n  archTypeOf :: \"arch_kernel_object \\<Rightarrow> arch_kernel_object_type\"\nwhere\n  \"archTypeOf (KOPDE e) = PDET\"\n| \"archTypeOf (KOPTE e) = PTET\"\n| \"archTypeOf (KOVCPU e) = VCPUT\"\n| \"archTypeOf (KOASIDPool e) = ASIDPoolT\"\n\nend", "property": "Create VCPU Object: Defines the creation of a VCPU object with default values for its components, including an uninitialized TCB pointer, a VGIC interface with specific register values, a set of initial CPU registers, a function indicating that no VPPIMasked bits are set, and a virtual timer initialized to zero.", "title": "./spec/design/skel/ARM_HYP/ArchStructures_H.thy", "chapter": "", "section": "", "comment": " we define makeVCPUObject_def manually because we want a total function vgicLR "}
{"spec": "arch_requalify_types (H)\n  vcpu\n\nend", "property": "Requalification of vCPU: The system requalifies the vCPU type, ensuring that it meets the necessary architectural requirements. This process is specific to certain architectures and cannot be generalized due to variations in vCPU implementations across different architectures.", "title": "./spec/design/skel/ARM_HYP/ArchStructures_H.thy", "chapter": "", "section": "", "comment": " not possible to move this requalification to generic, as some arches don't have vcpu "}
{"spec": "arch_requalify_consts (H)\n  wordBits\n\n#INCLUDE_HASKELL Data/WordLib.lhs all_bits NOT wordBits\n\ncontext Arch begin arch_global_naming (H)\n\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet.lhs Arch=ARM_HYP CONTEXT ARM_HYP_H all_bits NOT UserContext UserMonad getRegister setRegister newContext mask Word PPtr\n\ndefinition\n  PPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  PPtr_def[simp]:\n \"PPtr \\<equiv> id\"\n\ndefinition\n  fromPPtr :: \"machine_word \\<Rightarrow> machine_word\"\nwhere\n  fromPPtr_def[simp]:\n \"fromPPtr \\<equiv> id\"\n\ndefinition\n  nullPointer :: machine_word\nwhere\n \"nullPointer \\<equiv> 0\"\n\nend\nend", "property": "Architectural Constants and Type Definitions: Defines architectural constants, type conversions, and a null pointer for machine words, ensuring consistency and proper handling of memory addresses and pointers in the system.", "title": "./spec/design/skel/ARM_HYP/State_H.thy", "chapter": "", "section": "", "comment": " Note: while this requalify and arch-generic Haskell import of WordLib.lhs could be moved to\n   a generic theory, no good candidate theory exists at the moment. "}
{"spec": "theory ArchInterrupt_H\nimports\n  RetypeDecls_H\n  CNode_H\n  InterruptDecls_H\n  ArchInterruptDecls_H\n  ArchHypervisor_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs Arch= CONTEXT ARM_HYP_H bodies_only ArchInv= NOT initInterruptController\n\ndefinition initInterruptController :: \"unit kernel\"\n  where \"initInterruptController \\<equiv> (do\n    setIRQState IRQReserved $ irqVGICMaintenance;\n    return ()\nod)\"\n\nend\nend", "property": "Initialize Interrupt Controller: Set the IRQ state to reserved for the maintenance of the virtual generic interrupt controller (VGIC).", "title": "./spec/design/skel/ARM_HYP/ArchInterrupt_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "chapter \"Retyping Objects\"\n\ntheory ArchRetype_H\nimports\n  ArchRetypeDecls_H\n  ArchVSpaceDecls_H\n  Hardware_H\n  VCPU_H\n  KI_Decls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/ObjectType/ARM.lhs CONTEXT ARM_HYP_H Arch.Types= ArchInv= bodies_only\n#INCLUDE_HASKELL SEL4/API/Invocation/ARM.lhs bodies_only CONTEXT ARM_HYP_H NOT isPDFlushLabel isPageFlushLabel\n\nend\nend", "property": "Retyping Objects: Allows the transformation of an object's type, enabling the modification of its structure and capabilities to fit different roles or requirements within the system.", "title": "./spec/design/skel/ARM_HYP/ArchRetype_H.thy", "chapter": "Retyping Objects", "section": "", "comment": ""}
{"spec": "chapter \"Intermediate\"\n\ntheory ArchIntermediate_H\nimports Intermediate_H\nbegin\n\ncontext Arch begin\ncontext begin\n\nprivate abbreviation (input)\n  \"createNewPageCaps regionBase numObjects dev gSize pSize \\<equiv>\n    let Data = (if dev then KOUserDataDevice else KOUserData) in\n    (do addrs \\<leftarrow> createObjects regionBase numObjects Data gSize;\n        modify (\\<lambda>ks. ks \\<lparr> gsUserPages := (\\<lambda> addr.\n          if addr `~elem~` map fromPPtr addrs then Just pSize\n          else gsUserPages ks addr)\\<rparr>);\n        when (\\<not>dev) $\n          mapM_x (\\<lambda>addr. doMachineOp $\n                            cleanCacheRange_RAM addr\n                                                (addr + mask (pageBitsForSize pSize))\n                                                (addrFromPPtr addr)) addrs;\n        return $ map (\\<lambda>n. PageCap dev (PPtr (fromPPtr n)) VMReadWrite pSize Nothing) addrs\n     od)\"\n\nprivate abbreviation (input)\n  \"createNewTableCaps regionBase numObjects tableBits objectProto cap initialiseMappings \\<equiv> (do\n      tableSize \\<leftarrow> return (tableBits - objBits objectProto);\n      addrs \\<leftarrow> createObjects regionBase numObjects (injectKO objectProto) tableSize;\n      pts \\<leftarrow> return (map (PPtr \\<circ> fromPPtr) addrs);\n      initialiseMappings pts;\n      mapM_x (\\<lambda>addr. doMachineOp $\n                       cleanCacheRange_PoU addr (addr + mask tableBits) (addrFromPPtr addr)) addrs;\n      return $ map (\\<lambda>pt. cap pt Nothing) pts\n    od)\"\n\ndefs Arch_createNewCaps_def:\n\"Arch_createNewCaps t regionBase numObjects userSize dev \\<equiv>\n    let pointerCast = PPtr \\<circ> fromPPtr\n    in (case t of\n          APIObjectType apiObject \\<Rightarrow> haskell_fail []\n        | SmallPageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 0 ARMSmallPage\n        | LargePageObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 4 ARMLargePage\n        | SectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 9 ARMSection\n        | SuperSectionObject \\<Rightarrow>\n            createNewPageCaps regionBase numObjects dev 13 ARMSuperSection\n        | PageTableObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects ptBits (makeObject::pte) PageTableCap\n              (\\<lambda>pts. return ())\n        | PageDirectoryObject \\<Rightarrow>\n            createNewTableCaps regionBase numObjects pdBits (makeObject::pde) PageDirectoryCap\n              (\\<lambda>pds. do objSize \\<leftarrow> return (((1::nat) `~shiftL~` pdBits));\n                        mapM_x copyGlobalMappings pds\n                     od)\n        | VCPUObject \\<Rightarrow> (do\n            addrs \\<leftarrow> createObjects regionBase numObjects (injectKO (makeObject :: vcpu)) 0;\n            return $ map (\\<lambda>addr. VCPUCap addr) addrs\n            od)\n        )\"\n\nend\nend\n\nend", "property": "Create New Capabilities: Generate new capabilities for different types of objects such as pages, tables, directories, and VCPUs. The process involves creating the objects, updating the kernel state to reflect the new objects, cleaning the cache, and initializing mappings if necessary. This ensures that the system can manage and utilize these new capabilities effectively.", "title": "./spec/design/skel/ARM_HYP/ArchIntermediate_H.thy", "chapter": "Intermediate", "section": "", "comment": ""}
{"spec": "chapter \"Threads\"\n\ntheory ArchThread_H\nimports\n  ArchThreadDecls_H\n  TCBDecls_H\n  ArchVSpaceDecls_H\n  ArchHypervisor_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Kernel/Thread/ARM.lhs CONTEXT ARM_HYP_H ARMHardware=ARM_HYP bodies_only\n\nend\nend", "property": "Thread Management: Defines the architecture-specific thread management for ARM, including thread creation, scheduling, and state transitions, ensuring that threads are managed efficiently and in compliance with the ARM architecture.", "title": "./spec/design/skel/ARM_HYP/ArchThread_H.thy", "chapter": "Threads", "section": "", "comment": ""}
{"spec": "#INCLUDE_HASKELL SEL4/API/Invocation/ARM.lhs CONTEXT ARM_HYP_H ONLY isPDFlushLabel isPageFlushLabel\n\nend\nend", "property": "Arch-Specific Invocation Labels: Define and identify specific invocation labels for architecture-specific operations, such as page directory flush and page flush, to ensure proper handling and execution of these operations within the ARM architecture.", "title": "./spec/design/skel/ARM_HYP/ArchLabelFuns_H.thy", "chapter": "", "section": "", "comment": "\n  Arch-specific functions on invocation labels\n"}
{"spec": "(*\n  VSpace lookup code.\n*)\n\ntheory ArchHypervisor_H\nimports\n  CNode_H\n  FaultHandlerDecls_H\n  InterruptDecls_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/VCPU/ARM.lhs CONTEXT ARM_HYP_H decls_only ONLY countTrailingZeros irqVPPIEventIndex\n#INCLUDE_HASKELL SEL4/Object/VCPU/ARM.lhs CONTEXT ARM_HYP_H bodies_only ONLY countTrailingZeros irqVPPIEventIndex\n\n#INCLUDE_HASKELL SEL4/Object/VCPU/ARM.lhs CONTEXT ARM_HYP_H ArchInv=Arch ONLY vcpuUpdate vgicUpdate vgicUpdateLR vcpuSaveReg vcpuRestoreReg vcpuSaveRegRange vcpuRestoreRegRange vcpuWriteReg vcpuReadReg saveVirtTimer restoreVirtTimer vcpuDisable vcpuEnable vcpuRestore armvVCPUSave vcpuSave vcpuSwitch vcpuInvalidateActive vcpuCleanInvalidateActive virqSetEOIIRQEN vgicMaintenance vppiEvent\n\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_HYP_H decls_only\n#INCLUDE_HASKELL SEL4/Kernel/Hypervisor/ARM.lhs Arch= CONTEXT ARM_HYP_H bodies_only\n\nend\nend", "property": "VSpace and VCPU Management: Provides functions for managing virtual CPUs, including updating, saving, restoring, enabling, and disabling VCPU states, as well as handling virtual interrupts and timer operations. These functions ensure that the VCPU state is correctly maintained and managed, supporting efficient and reliable virtualization.", "title": "./spec/design/skel/ARM_HYP/ArchHypervisor_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory ArchInterruptDecls_H\nimports RetypeDecls_H CNode_H\nbegin\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Object/Interrupt/ARM.lhs CONTEXT Arch decls_only ArchInv=\n\nend\n\nend", "property": "Architectural Interrupt Declarations: Define and import architectural-specific interrupt handling declarations for the ARM architecture, ensuring that the system can manage and respond to interrupts according to the ARM architecture's requirements.", "title": "./spec/design/skel/ARM_HYP/ArchInterruptDecls_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Hardware_H\nimports\n  MachineOps\n  State_H\nbegin\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs Platform=Platform.ARM_HYP CONTEXT ARM_HYP_H NOT getMemoryRegions getDeviceRegions getKernelDevices loadWord storeWord storeWordVM getActiveIRQ ackInterrupt maskInterrupt configureTimer resetTimer debugPrint getRestartPC setNextPC clearMemory clearMemoryVM initMemory freeMemory writeTTBR0 setGlobalPD  setTTBCR setHardwareASID invalidateLocalTLB invalidateLocalTLB_ASID invalidateLocalTLB_VAASID cleanByVA cleanByVA_PoU invalidateByVA invalidateByVA_I invalidate_I_PoU cleanInvalByVA branchFlush clean_D_PoU cleanInvalidate_D_PoC cleanInvalidate_D_PoU cleanInvalidateL2Range invalidateL2Range cleanL2Range isb dsb dmb getIFSR getDFSR getFAR HardwareASID wordFromPDE wordFromPTE VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize toPAddr paddrBase pptrBase pptrTop paddrTop kernelELFPAddrBase kernelELFBase kernelELFBaseOffset pptrBaseOffset cacheLineBits cacheLine lineStart cacheRangeOp cleanCacheRange_PoC cleanInvalidateCacheRange_RAM cleanCacheRange_RAM cleanCacheRange_PoU invalidateCacheRange_RAM invalidateCacheRange_I branchFlushRange cleanCaches_PoU cleanInvalidateL1Caches addrFromPPtr ptrFromPAddr addrFromKPPtr initIRQController MachineData hapFromVMRights wordsFromPDE wordsFromPTE writeContextIDAndPD hcrVCPU hcrNative vgicHCREN sctlrDefault actlrDefault gicVCPUMaxNumLR getHSR setHCR getHDFAR addressTranslateS1 getSCTLR setSCTLR getACTLR setACTLR get_gic_vcpu_ctrl_hcr set_gic_vcpu_ctrl_hcr get_gic_vcpu_ctrl_vmcr set_gic_vcpu_ctrl_vmcr get_gic_vcpu_ctrl_apr set_gic_vcpu_ctrl_apr get_gic_vcpu_ctrl_vtr get_gic_vcpu_ctrl_eisr0 get_gic_vcpu_ctrl_eisr1 get_gic_vcpu_ctrl_misr get_gic_vcpu_ctrl_lr set_gic_vcpu_ctrl_lr setCurrentPDPL2 readVCPUHardwareReg setIRQTrigger writeVCPUHardwareReg getTPIDRURO setTPIDRURO get_cntv_cval_64 set_cntv_cval_64 set_cntv_off_64 get_cntv_off_64 read_cntpct\n\nend\n\narch_requalify_types (H)\n  vmrights\n\ncontext Arch begin arch_global_naming (H)\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP_H instanceproofs NOT HardwareASID VMFaultType HypFaultType VMPageSize\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP_H ONLY hapFromVMRights wordsFromPDE wordsFromPTE", "property": "Hardware Abstraction: Provides a comprehensive set of hardware-specific operations and configurations for ARM architecture, including memory management, interrupt handling, timer configuration, cache operations, and virtualization support. These operations ensure efficient and secure interaction with the underlying hardware, facilitating tasks such as memory manipulation, interrupt control, and virtual machine management.", "title": "./spec/design/skel/ARM_HYP/Hardware_H.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation (input) maxIRQ :: irq where\n  \"maxIRQ \\<equiv> Kernel_Config.maxIRQ\"", "property": "Max IRQ Value: Defines the maximum value for an interrupt request (IRQ) in the system, which is specified by the Kernel_Config.", "title": "./spec/design/skel/ARM_HYP/Hardware_H.thy", "chapter": "", "section": "", "comment": " Kernel_Config provides a generic numeral, Haskell expects type irq "}
{"spec": "abbreviation (input) initIRQController where\n  \"initIRQController \\<equiv> ARM_HYP.initIRQController\"\n\nend\nend", "property": "Initialization of IRQ Controller: The system initializes the IRQ controller using the ARM/ARM_HYP machine operation, ensuring proper setup and configuration for interrupt handling.", "title": "./spec/design/skel/ARM_HYP/Hardware_H.thy", "chapter": "", "section": "", "comment": " provide ARM/ARM_HYP machine op in _H global_prefix for arch-split "}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM decls_only NOT UserContext UserMonad Word getRegister setRegister newContext", "property": "Machine State Management: Defines the structure and operations for managing the ARM machine state, including the ability to get and set register values, and create new context states.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM instanceproofs", "property": "Machine State: Defines the architecture-specific state, including register sets for the ARM architecture, ensuring that the system maintains and manages the necessary hardware state information.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM bodies_only NOT getRegister setRegister newContext", "property": "Machine State Representation: Defines the structure and contents of the ARM machine state, including the register set, to provide a formal model for the state of the ARM architecture within the system.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest", "property": "Machine State Abstraction: The machine state is left underspecified, with only the existence and some interface functions declared, without detailing the transformations or effects on the machine.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym exclusive_monitors = \"(word32 \\<Rightarrow> bool) list \\<times> (word32 \\<times> nat \\<Rightarrow> bool)\"", "property": "Exclusive Monitors State: The state of exclusive monitors is represented as a combination of a list of boolean values indexed by 32-bit words and a function that maps a pair of a 32-bit word and a natural number to a boolean value, making it observable in user mode.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The exclusive monitors state is observable in user mode.\n  The type for this is the type used in the Cambridge HOL4 ARM model.\n"}
{"spec": "end\n\nqualify ARM (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"ARM.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"word32 \\<Rightarrow> word8\"\n  device_state :: \"word32 \\<Rightarrow> word8 option\"\n  exclusive_state :: ARM.exclusive_monitors\n  machine_state_rest :: ARM.machine_state_rest\n\naxiomatization\n  irq_oracle :: \"nat \\<Rightarrow> ARM.irq\"\nwhere\n  irq_oracle_max_irq: \"\\<forall> n. irq_oracle n <= Kernel_Config.maxIRQ\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State: The machine state includes observable and underspecified components. Observable parts consist of the interrupt controller's IRQ masking status, the machine's memory, and the device state. The memory is further divided into kernel memory, which is maintained in a more abstract datatype, and user memory, which is reflected in the underlying machine memory. Additionally, the state includes exclusive monitors and other unspecified aspects encapsulated in the machine state rest.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The full machine state is the state observable by the kernel plus\n  the underspecified rest above. The observable parts are the\n  interrupt controller (which IRQs are masked) and the memory of the\n  machine. The latter is shadow state: kernel memory is kept in a\n  separate, more abstract datatype; user memory is reflected down\n  to the underlying memory of the machine.\n"}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c ARM.machine_monad\" <= (type) \"(ARM.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine Monad: Defines a monad for operations on the machine state, enabling nondeterministic actions and transformations within the context of the ARM architecture.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masking: After kernel initialization, all IRQs are masked to prevent interruptions.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"word32 \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized with all contents set to 0.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "consts' default_exclusive_state :: exclusive_monitors", "property": "Initial Exclusive State: The initial state of the exclusive monitors is set to a constant value, which is the same as the default value used by clearExMonitor.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  The initial exclusive state is the same constant\n  that clearExMonitor defaults it to.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         exclusive_state = default_exclusive_state,\n                         machine_state_rest = undefined \\<rparr>\"", "property": "Initial Machine State: Defines the initial state of the machine, including interrupt masks, interrupt state, underlying memory, device state, and exclusive state, while leaving the unspecified parts of the machine state undefined.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM ONLY HardwareASID VMFaultType VMPageSize HypFaultType pageBits pageBitsForSize\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM instanceproofs ONLY HardwareASID VMFaultType VMPageSize HypFaultType\n\nend\nend", "property": "Machine State Definitions: Define and requalify types for hardware ASID, virtual machine fault types, virtual machine page sizes, and hypervisor fault types. These definitions ensure that the system can accurately represent and manage hardware-specific attributes and fault conditions in the ARM architecture.", "title": "./spec/design/m-skel/ARM/MachineTypes.thy", "chapter": "ARM Machine Types", "section": "Machine State", "comment": " Machine/Hardware/ARM.lhs - hardware_asid, vmfault_type and vmpage_size "}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/X64.lhs CONTEXT X64 decls_only NOT UserContext UserMonad Word getRegister setRegister newContext", "property": "Machine State Management: Defines the structure and manipulation of the x86-64 machine state, including the ability to get and set register values, and create new context states. This ensures that the system can effectively manage and interact with the hardware registers and contexts, maintaining the integrity and performance of the machine operations.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register gdtslot\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/X64.lhs CONTEXT X64 instanceproofs", "property": "Machine State: Defines the architecture-specific machine state, including registers and GDT slots, for the x86-64 platform. This ensures that the system maintains the correct state and context for executing and managing processes on x86-64 hardware.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/X64.lhs CONTEXT X64 bodies_only NOT getRegister setRegister newContext", "property": "Machine State Definition: Defines the structure and management of the x86-64 machine state, including the register set and context, to ensure proper handling and manipulation of the CPU state.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest\n\nend\n\nqualify X64 (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"X64.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"word64 \\<Rightarrow> word8\"\n  device_state :: \"word64 \\<Rightarrow> word8 option\"\n  machine_state_rest :: X64.machine_state_rest\n\nconsts irq_oracle :: \"nat \\<Rightarrow> word8\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State Definition: Defines the machine state with components including IRQ masks, IRQ state, underlying memory, and device state, along with an underspecified rest of the machine state. This structure allows for the declaration of interface functions without detailing the transformations or effects on the machine.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c X64.machine_monad\" <= (type) \"(X64.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine Monad Operations: Define operations on the machine state using a monad that allows for non-deterministic computations, enabling flexible and robust handling of system-level operations.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masking: After kernel initialization, all IRQs are masked to prevent interruptions during the initial setup phase.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"word64 \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized to 0, ensuring a known and consistent starting state for the system.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         machine_state_rest = undefined \\<rparr>\"\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs CONTEXT X64 ONLY VMFaultType HypFaultType VMPageSize VMMapType pageBits ptTranslationBits pageBitsForSize\n\nend\n\narch_requalify_types vmpage_size vmmap_type\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/X64.lhs CONTEXT X64 instanceproofs ONLY VMFaultType HypFaultType VMPageSize VMMapType\n\nend\nend", "property": "Initialization of Machine State: The machine state is initialized with specific values for interrupt masks, interrupt state, underlying memory, and an empty device state. The remaining part of the machine state is left undefined, allowing for flexibility in specifying additional details as needed.", "title": "./spec/design/m-skel/X64/MachineTypes.thy", "chapter": "x86-64bit Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/RISCV64.hs CONTEXT RISCV64 decls_only NOT UserContext UserMonad Word getRegister setRegister newContext", "property": "Machine State Management: Defines the structure and manipulation of the RISCV64 machine state, including the ability to get and set register values, and create new contexts. This ensures that the machine state is correctly maintained and updated, supporting the execution and management of threads in the system.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/RISCV64.hs CONTEXT RISCV64 instanceproofs", "property": "RISCV 64-bit Machine State: Defines the architecture-specific machine state, including the register set, for the RISCV64 architecture, ensuring that the system can correctly manage and manipulate the processor's state.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/RISCV64.hs CONTEXT RISCV64 bodies_only NOT getRegister setRegister newContext", "property": "Machine State Definition: Defines the structure and management of the RISCV64 machine state, including the register set and context, to ensure proper handling and manipulation of processor state.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest\n\nend\n\nqualify RISCV64 (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"RISCV64.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"machine_word \\<Rightarrow> word8\"\n  device_state :: \"machine_word \\<Rightarrow> word8 option\"\n  machine_state_rest :: RISCV64.machine_state_rest\n\naxiomatization\n  irq_oracle :: \"nat \\<Rightarrow> RISCV64.irq\"\nwhere\n  irq_oracle_max_irq: \"\\<forall>n. irq_oracle n <= RISCV64.maxIRQ\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State Definition: The machine state includes IRQ masks, IRQ state, underlying memory, and device state, along with additional unspecified machine state. The IRQ masks indicate which interrupts are enabled or disabled, the IRQ state holds the current interrupt state, the underlying memory maps addresses to byte values, and the device state maps addresses to optional byte values. The `irq_oracle` function provides a mapping from natural numbers to IRQ identifiers, ensuring that the generated IRQ does not exceed the maximum IRQ value.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c RISCV64.machine_monad\" <= (type) \"(RISCV64.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine Monad: Defines a monad for performing operations on the machine state, enabling nondeterministic computations and state transformations within the RISCV64 architecture.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Masking: After kernel initialization, all interrupts (IRQs) are masked to prevent them from being processed until the system is fully set up.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"machine_word \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized to 0 for all addresses.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         machine_state_rest = undefined \\<rparr>\"\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64 ONLY VMFaultType HypFaultType vmFaultTypeFSR VMPageSize pageBits ptTranslationBits pageBitsForSize\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/RISCV64.hs CONTEXT RISCV64 instanceproofs ONLY VMFaultType HypFaultType VMPageSize\n\nend\nend", "property": "Initial Machine State: Defines the initial state of the machine, including IRQ masks, IRQ state, underlying memory, and an empty device state. The remaining parts of the machine state are left unspecified.", "title": "./spec/design/m-skel/RISCV64/MachineTypes.thy", "chapter": "RISCV 64bit Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/AARCH64.hs CONTEXT AARCH64 decls_only NOT UserContext UserMonad Word getRegister setRegister newContext FPUState newFPUState\n\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64 ONLY VPPIEventIRQ VirtTimer", "property": "Machine State Management: Defines the structure and operations for managing the AARCH64 machine state, including handling virtual performance monitoring interrupts (VPPI) and virtual timers. This ensures that the system can effectively manage and interact with hardware-specific features, maintaining the integrity and performance of the system.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register vcpureg vppievent_irq virt_timer\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/AARCH64.hs CONTEXT AARCH64 instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/AARCH64.hs CONTEXT AARCH64 instanceproofs ONLY VPPIEventIRQ VirtTimer", "property": "Machine State Definitions: Define and requalify types for AARCH64 architecture, including registers, virtual CPU registers, virtual PPI event IRQs, and virtual timers. This ensures that the machine state is accurately represented and manipulated within the AARCH64 context.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/AARCH64.hs CONTEXT AARCH64 bodies_only NOT getRegister setRegister newContext newFPUState", "property": "Machine State Management: Defines the structure and operations for managing the AARCH64 machine state, including the register set and FPU state, ensuring that the system can correctly handle and manipulate the state of the processor.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest\n\nend\n\nqualify AARCH64 (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"AARCH64.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"machine_word \\<Rightarrow> word8\"\n  device_state :: \"machine_word \\<Rightarrow> word8 option\"\n  machine_state_rest :: AARCH64.machine_state_rest\n\naxiomatization\n  irq_oracle :: \"nat \\<Rightarrow> AARCH64.irq\"\nwhere\n  irq_oracle_max_irq: \"\\<forall>n. irq_oracle n <= Kernel_Config.maxIRQ\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State Definition: Defines the machine state with components including IRQ masks, IRQ state, underlying memory, device state, and an underspecified rest of the machine state. The IRQ oracle function maps natural numbers to IRQ identifiers, ensuring that the mapped IRQs do not exceed the maximum IRQ value.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c AARCH64.machine_monad\" <= (type) \"(AARCH64.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine Monad: Represents operations on the machine state, encapsulating non-deterministic behaviors and effects on the system's hardware state.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "Initialization of IRQ Masks: After kernel initialization, all IRQs are masked to prevent any interruptions until the system is fully set up.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"machine_word \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized with all contents set to 0.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         machine_state_rest = undefined \\<rparr>\"\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64 ONLY \\\n  PT_Type \\\n  VMFaultType HypFaultType vmFaultTypeFSR VMPageSize pageBits ptTranslationBits \\\n  pageBitsForSize \\\n  hcrCommon hcrTWE hcrTWI \\\n  hcrVCPU hcrNative vgicHCREN sctlrDefault sctlrEL1VM actlrDefault gicVCPUMaxNumLR \\\n  vcpuBits\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/AARCH64.hs CONTEXT AARCH64 instanceproofs ONLY VMFaultType HypFaultType VMPageSize\n\nend\nend", "property": "Initialization of Machine State: The machine state is initialized with specific values for IRQ masks, IRQ state, underlying memory, and an empty device state, while the remaining part of the machine state is left undefined.", "title": "./spec/design/m-skel/AARCH64/MachineTypes.thy", "chapter": "AARCH64 Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM_HYP decls_only NOT UserContext UserMonad Word getRegister setRegister newContext\n\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP ONLY VPPIEventIRQ VirtTimer", "property": "Machine State Management: Defines and manages the machine state for ARM_HYP, including handling virtual timer and VPP event IRQs, as well as providing operations to get and set registers in the context of the ARM_HYP architecture.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": ""}
{"spec": "end\n\narch_requalify_types register vcpureg vppievent_irq virt_timer\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM_HYP instanceproofs\n#INCLUDE_HASKELL SEL4/Object/Structures/ARM.lhs CONTEXT ARM_HYP instanceproofs ONLY VPPIEventIRQ VirtTimer", "property": "Machine State Definitions: Define and requalify types for machine state components such as registers, virtual CPU registers, virtual PPI event IRQs, and virtual timers, ensuring proper handling and management of these components in the ARM_HYP architecture.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "<"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/RegisterSet/ARM.lhs CONTEXT ARM_HYP bodies_only NOT getRegister setRegister newContext", "property": "Machine State Management: Define and manage the machine state for ARM_HYP, including the register set, to ensure proper handling and manipulation of the processor's state.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": ">"}
{"spec": "text \\<open>\n  Most of the machine state is left underspecified at this level.\n  We know it exists, we will declare some interface functions, but\n  at this level we do not have access to how this state is transformed\n  or what effect it has on the machine.\n\\<close>\ntypedecl machine_state_rest", "property": "Machine State Underspecification: The machine state is largely underspecified, with only the existence of certain interface functions declared, without detailing the state transformations or their effects on the machine.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": ""}
{"spec": "type_synonym exclusive_monitors = \"(word32 \\<Rightarrow> bool) list \\<times> (word32 \\<times> nat \\<Rightarrow> bool)\"", "property": "Exclusive Monitors State: The state of exclusive monitors is represented as a combination of a list of functions that map word32 to boolean values and a function that maps a pair of word32 and natural number to a boolean value. This state is observable in user mode, allowing for the tracking and management of exclusive monitor operations.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The exclusive monitors state is observable in user mode.\n  The type for this is the type used in the Cambridge HOL4 ARM model.\n"}
{"spec": "end\n\nqualify ARM_HYP (in Arch)\n\nrecord\n  machine_state =\n  irq_masks :: \"ARM_HYP.irq \\<Rightarrow> bool\"\n  irq_state :: nat\n  underlying_memory :: \"word32 \\<Rightarrow> word8\"\n  device_state :: \"word32 \\<Rightarrow> word8 option\"\n  exclusive_state :: ARM_HYP.exclusive_monitors\n  machine_state_rest :: ARM_HYP.machine_state_rest\n\naxiomatization\n  irq_oracle :: \"nat \\<Rightarrow> ARM_HYP.irq\"\nwhere\n  irq_oracle_max_irq: \"\\<forall> n. irq_oracle n <= Kernel_Config.maxIRQ\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming", "property": "Machine State Composition: The machine state consists of observable and underspecified components. Observable parts include the interrupt controller's IRQ masking, the machine's memory, and device state, while the underspecified part encompasses the remaining state. The memory is further divided into kernel memory, which is maintained in a more abstract datatype, and user memory, which is reflected in the underlying machine memory.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The full machine state is the state observable by the kernel plus\n  the underspecified rest above. The observable parts are the\n  interrupt controller (which IRQs are masked) and the memory of the\n  machine. The latter is shadow state: kernel memory is kept in a\n  separate, more abstract datatype; user memory is reflected down\n  to the underlying memory of the machine.\n"}
{"spec": "type_synonym 'a machine_monad = \"(machine_state, 'a) nondet_monad\"\n\nend\n\ntranslations\n  (type) \"'c ARM_HYP.machine_monad\" <= (type) \"(ARM_HYP.machine_state, 'c) nondet_monad\"\n\ncontext Arch begin arch_global_naming", "property": "Machine Monad Operations: Define a monad for performing operations on the machine state, allowing for nondeterministic computations and state transformations.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The machine monad is used for operations on the state defined above.\n"}
{"spec": "definition\n  \"init_irq_masks \\<equiv> \\<lambda>_. True\"", "property": "IRQ Mask Initialization: After kernel initialization, all IRQs are masked to prevent interruptions.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  After kernel initialisation all IRQs are masked.\n"}
{"spec": "definition\n  init_underlying_memory :: \"word32 \\<Rightarrow> word8\"\n  where\n  \"init_underlying_memory \\<equiv> \\<lambda>_. 0\"", "property": "Initial Memory State: The user-visible memory is initialized to 0, ensuring a known and consistent starting state for the system.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The initial contents of the user-visible memory is 0.\n"}
{"spec": "consts' default_exclusive_state :: exclusive_monitors", "property": "Initial Exclusive State: The initial state of the exclusive monitors is set to a constant value, which is the same value used by the clearExMonitor function.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  The initial exclusive state is the same constant\n  that clearExMonitor defaults it to.\n"}
{"spec": "definition\n  init_machine_state :: machine_state where\n \"init_machine_state \\<equiv> \\<lparr> irq_masks = init_irq_masks,\n                         irq_state = 0,\n                         underlying_memory = init_underlying_memory,\n                         device_state = Map.empty,\n                         exclusive_state = default_exclusive_state,\n                         machine_state_rest = undefined \\<rparr>\"", "property": "Initialization of Machine State: The machine state is initialized with predefined values for interrupt masks, interrupt state, underlying memory, and device state, while leaving the remaining unspecified parts of the machine state undefined.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": "\n  We leave open the underspecified rest of the machine state in\n  the initial state.\n"}
{"spec": "#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP ONLY HardwareASID VMFaultType HypFaultType VMPageSize pageBits pageBitsForSize hcrCommon hcrTWE hcrTWI hcrVCPU hcrNative vgicHCREN sctlrDefault actlrDefault gicVCPUMaxNumLR\n\nend\n\narch_requalify_types vmpage_size\n\ncontext Arch begin arch_global_naming\n\n#INCLUDE_HASKELL SEL4/Machine/Hardware/ARM.lhs CONTEXT ARM_HYP instanceproofs ONLY HardwareASID VMFaultType HypFaultType VMPageSize\n\nend\nend", "property": "Machine State Definitions: Define and requalify types related to hardware ASIDs, VM fault types, hypervisor fault types, VM page sizes, and other hardware-specific configurations. These definitions ensure that the system can accurately represent and manage the state of ARM_HYP machine hardware.", "title": "./spec/design/m-skel/ARM_HYP/MachineTypes.thy", "chapter": "ARM\\_HYP Machine Types", "section": "Machine State", "comment": " Machine/Hardware/ARM.lhs - hardware_asid, vmfault_type and vmpage_size "}
{"spec": "theory Decode_D\nimports\n  Asid_D\n  CNode_D\n  Interrupt_D\n  PageTable_D\n  Tcb_D\n  Untyped_D\nbegin\n\ndefinition\n  get_cnode_intent :: \"cdl_intent \\<Rightarrow> cdl_cnode_intent option\"\nwhere\n  \"get_cnode_intent intent \\<equiv>\n    case intent of\n        CNodeIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_tcb_intent :: \"cdl_intent \\<Rightarrow> cdl_tcb_intent option\"\nwhere\n  \"get_tcb_intent intent \\<equiv>\n    case intent of\n        TcbIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_irq_control_intent :: \"cdl_intent \\<Rightarrow> cdl_irq_control_intent option\"\nwhere\n  \"get_irq_control_intent intent \\<equiv>\n    case intent of\n        IrqControlIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_irq_handler_intent :: \"cdl_intent \\<Rightarrow> cdl_irq_handler_intent option\"\nwhere\n  \"get_irq_handler_intent intent \\<equiv>\n    case intent of\n        IrqHandlerIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_asid_pool_intent :: \"cdl_intent \\<Rightarrow> cdl_asid_pool_intent option\"\nwhere\n  \"get_asid_pool_intent intent \\<equiv>\n    case intent of\n        AsidPoolIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\n\ndefinition\n  get_asid_control_intent :: \"cdl_intent \\<Rightarrow> cdl_asid_control_intent option\"\nwhere\n  \"get_asid_control_intent intent \\<equiv>\n    case intent of\n        AsidControlIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_page_intent :: \"cdl_intent \\<Rightarrow> cdl_page_intent option\"\nwhere\n  \"get_page_intent intent \\<equiv>\n    case intent of\n        PageIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_page_table_intent :: \"cdl_intent \\<Rightarrow> cdl_page_table_intent option\"\nwhere\n  \"get_page_table_intent intent \\<equiv>\n    case intent of\n        PageTableIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_page_directory_intent :: \"cdl_intent \\<Rightarrow> cdl_page_directory_intent option\"\nwhere\n  \"get_page_directory_intent intent \\<equiv>\n    case intent of\n        PageDirectoryIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_untyped_intent :: \"cdl_intent \\<Rightarrow> cdl_untyped_intent option\"\nwhere\n  \"get_untyped_intent intent \\<equiv>\n    case intent of\n        UntypedIntent x \\<Rightarrow> Some x\n      | _ \\<Rightarrow> None\"\n\ndefinition\n  get_domain_intent :: \"cdl_intent \\<Rightarrow> cdl_domain_intent option\"\nwhere\n  \"get_domain_intent intent \\<equiv>\n     case intent of\n         DomainIntent x \\<Rightarrow> Some x\n       | _ \\<Rightarrow> None\"", "property": "Intent Extraction: Extract specific types of intents from a generic intent, such as CNode, TCB, IRQ control, IRQ handler, ASID pool, ASID control, page, page table, page directory, untyped, and domain intents. This allows for the precise handling and processing of different intent types in the system.", "title": "./spec/capDL/Decode_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  decode_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow> cdl_intent \\<Rightarrow> cdl_invocation except_monad\"\nwhere\n  \"decode_invocation invoked_cap invoked_cap_ref caps intent \\<equiv>\n    case invoked_cap of\n       \\<comment> \\<open>For endpoint-like caps, we always perform an operation,\n          regardless of the user's actual intent.\\<close>\n         EndpointCap o_id badge rights \\<Rightarrow>\n           (if Write \\<in> rights then\n             returnOk $ InvokeEndpoint (SyncMessage badge (Grant \\<in> rights) (GrantReply \\<in> rights) o_id)\n           else\n             throw)\n       | NotificationCap o_id badge rights \\<Rightarrow>\n           (if Write \\<in> rights then\n             returnOk $ InvokeNotification (Signal badge o_id)\n           else\n             throw)\n       | ReplyCap o_id rights \\<Rightarrow>\n           returnOk $ InvokeReply (ReplyMessage o_id invoked_cap_ref (Grant \\<in> rights))\n\n       \\<comment> \\<open>\n         For other operations, we only perform the user's intent\n         if it matches up with the cap.\n        \n         Note that this does not currently match the current\n         implementation: instead, the user's message will be\n         decoded into a new (undefined) intent for what the\n         cap happened to be. I propose modifying labels used to\n         avoid overlaps between different items so that we can\n         recognise when the user is invoking the wrong item.\n       \\<close>\n       | CNodeCap _ _ _ _ \\<Rightarrow>\n           doE\n             cnode_intent \\<leftarrow> throw_opt undefined $ get_cnode_intent intent;\n             liftME InvokeCNode $ decode_cnode_invocation invoked_cap invoked_cap_ref caps cnode_intent\n           odE\n       | TcbCap _ \\<Rightarrow>\n           doE\n             tcb_intent \\<leftarrow> throw_opt undefined $ get_tcb_intent intent;\n             liftME InvokeTcb $ decode_tcb_invocation invoked_cap invoked_cap_ref caps tcb_intent\n           odE\n       | IrqControlCap \\<Rightarrow>\n           doE\n             irq_control_intent \\<leftarrow> throw_opt undefined $ get_irq_control_intent intent;\n             liftME InvokeIrqControl $ decode_irq_control_invocation\n                 invoked_cap invoked_cap_ref caps irq_control_intent\n           odE\n       | IrqHandlerCap _ \\<Rightarrow>\n           doE\n             irq_handler_intent \\<leftarrow> throw_opt undefined $ get_irq_handler_intent intent;\n             liftME InvokeIrqHandler $ decode_irq_handler_invocation\n                 invoked_cap invoked_cap_ref caps irq_handler_intent\n           odE\n       | AsidPoolCap _ _\\<Rightarrow>\n           doE\n             asid_pool_intent \\<leftarrow> throw_opt undefined $ get_asid_pool_intent intent;\n             liftME InvokeAsidPool $ decode_asid_pool_invocation\n                 invoked_cap invoked_cap_ref caps asid_pool_intent\n           odE\n       | AsidControlCap \\<Rightarrow>\n           doE\n             asid_control_intent \\<leftarrow> throw_opt undefined $ get_asid_control_intent intent;\n             liftME InvokeAsidControl $ decode_asid_control_invocation\n                 invoked_cap invoked_cap_ref caps asid_control_intent\n           odE\n       | UntypedCap _ _ _ \\<Rightarrow>\n           doE\n             untyped_intent \\<leftarrow> throw_opt undefined $ get_untyped_intent intent;\n             liftME InvokeUntyped $ decode_untyped_invocation\n                 invoked_cap invoked_cap_ref caps untyped_intent\n           odE\n       | FrameCap _ _ _ _ _ _ \\<Rightarrow>\n           doE\n             page_intent \\<leftarrow> throw_opt undefined $ get_page_intent intent;\n             liftME InvokePage $ decode_page_invocation\n                 invoked_cap invoked_cap_ref caps page_intent\n           odE\n       | PageTableCap _ _ _ \\<Rightarrow>\n           doE\n             page_table_intent \\<leftarrow> throw_opt undefined $ get_page_table_intent intent;\n             liftME InvokePageTable $ decode_page_table_invocation\n                 invoked_cap invoked_cap_ref caps page_table_intent\n           odE\n       | PageDirectoryCap _ _ _ \\<Rightarrow>\n          doE\n             page_directory_intent \\<leftarrow> throw_opt undefined $ get_page_directory_intent intent;\n             liftME InvokePageDirectory $ decode_page_directory_invocation\n                 invoked_cap invoked_cap_ref caps page_directory_intent\n           odE\n       | DomainCap \\<Rightarrow>\n          doE\n            domain_intent \\<leftarrow> throw_opt undefined $ get_domain_intent intent;\n            liftME InvokeDomain $ decode_domain_invocation caps domain_intent\n          odE\n\n       \\<comment> \\<open>Don't support operations on other types of caps.\\<close>\n       | _ \\<Rightarrow> throw\"\n\nend", "property": "Decode and Validate Intent: Decode the given intent into an appropriate invocation based on the type of capability. For endpoint-like capabilities, perform a specific operation regardless of the user's intent. For other capabilities, validate that the user's intent matches the capability type before proceeding with the corresponding invocation. If the intent does not match or the capability type is unsupported, the operation is aborted.", "title": "./spec/capDL/Decode_D.thy", "chapter": "", "section": "", "comment": "\n * Decode and validate the given intent, turning it into an\n * invocation.\n "}
{"spec": "(*\n * Operations on page table objects and frames.\n *)\n\ntheory Asid_D\nimports\n  Invocations_D\n  CSpace_D\n  Untyped_D\nbegin\n\ndefinition\n  decode_asid_control_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_asid_control_intent \\<Rightarrow> cdl_asid_control_invocation except_monad\"\nwhere\n  \"decode_asid_control_invocation target target_ref caps intent \\<equiv> case intent of\n     AsidControlMakePoolIntent index depth \\<Rightarrow>\n       doE\n         base \\<leftarrow> liftE $ select {x. x < 2 ^ asid_high_bits};\n\n         \\<comment> \\<open>Fetch the untyped item, and ensure it is valid.\\<close>\n         (untyped_cap, untyped_cap_ref) \\<leftarrow> throw_on_none $ get_index caps 0;\n         (case untyped_cap of\n             UntypedCap _ s _ \\<Rightarrow> returnOk ()\n           | _ \\<Rightarrow> throw);\n         ensure_no_children untyped_cap_ref;\n\n         \\<comment> \\<open>Fetch the slot we plan to put the generated cap into.\\<close>\n         (cspace_cap, _) \\<leftarrow> throw_on_none $ get_index caps 1;\n         target_slot \\<leftarrow> lookup_slot_for_cnode_op cspace_cap index (unat depth);\n         ensure_empty target_slot;\n\n         returnOk $ MakePool (set_available_range untyped_cap {}) untyped_cap_ref\n           (cap_objects untyped_cap) target_slot base\n       odE \\<sqinter> throw\"\n\ndefinition\n  decode_asid_pool_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_asid_pool_intent \\<Rightarrow> cdl_asid_pool_invocation except_monad\"\nwhere\n  \"decode_asid_pool_invocation target target_ref caps intent \\<equiv> case intent of\n     AsidPoolAssignIntent \\<Rightarrow>\n       doE\n         (pd_cap, pd_cap_ref) \\<leftarrow> throw_on_none $ get_index caps 0;\n         (case pd_cap of\n             PageDirectoryCap _ _ _ \\<Rightarrow> returnOk ()\n           | _ \\<Rightarrow> throw);\n\n         base \\<leftarrow> (case target of\n             AsidPoolCap p base \\<Rightarrow> returnOk $ base\n           | _ \\<Rightarrow> throw);\n         offset \\<leftarrow> liftE $ select {x. x < 2 ^ asid_low_bits};\n         returnOk $ Assign (base, offset) pd_cap_ref (cap_object target, offset)\n       odE \\<sqinter> throw\"\n\ndefinition\n  invoke_asid_control :: \"cdl_asid_control_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_asid_control params \\<equiv>\n    case params of\n        MakePool untyped_cap untyped_cap_ref untyped_covers target_slot base \\<Rightarrow>\n          do\n            \\<comment> \\<open>Untype the region. A choice may be made about whether to detype\n               objects with Untyped addresses.\\<close>\n            modify (detype untyped_covers);\n            set_cap untyped_cap_ref untyped_cap;\n            targets \\<leftarrow> generate_object_ids 1 AsidPoolType untyped_covers;\n\n            \\<comment> \\<open>Retype the region.\\<close>\n            retype_region 0 AsidPoolType targets;\n            assert (targets \\<noteq> []);\n\n            \\<comment> \\<open>Insert the cap.\\<close>\n            frame \\<leftarrow> return $ pick (hd targets);\n            insert_cap_child (AsidPoolCap frame base) untyped_cap_ref target_slot;\n\n            \\<comment> \\<open>Update the asid table.\\<close>\n            asid_table \\<leftarrow> gets cdl_asid_table;\n            asid_table' \\<leftarrow> return $ asid_table (base \\<mapsto> AsidPoolCap frame 0);\n            modify (\\<lambda>s. s \\<lparr>cdl_asid_table := asid_table'\\<rparr>)\n\n          od\"\n\ndefinition\n  invoke_asid_pool :: \"cdl_asid_pool_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_asid_pool params \\<equiv>\n     case params of\n       Assign asid pd_cap_ref ap_target_slot \\<Rightarrow> do\n         pd_cap \\<leftarrow> get_cap pd_cap_ref;\n         case pd_cap of\n           PageDirectoryCap pd_id _ _ \\<Rightarrow> do\n             set_cap pd_cap_ref (PageDirectoryCap pd_id Real (Some asid));\n             set_cap ap_target_slot (PageDirectoryCap pd_id Fake None)\n           od\n         | _ \\<Rightarrow> fail\n       od\"\n\nend", "property": "ASID Control and Pool Management: Manage ASID pools and their assignments, including creating new ASID pools from untyped memory regions and assigning page directories to ASID pools. Ensures that the ASID table is updated and the appropriate capabilities are inserted and modified, maintaining the integrity of the address space and memory management.", "title": "./spec/capDL/Asid_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n * Operations on untyped memory objects.\n *)\n\ntheory Untyped_D\nimports Invocations_D CSpace_D\nbegin\n\ndefinition\n  decode_untyped_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_untyped_intent \\<Rightarrow> cdl_untyped_invocation except_monad\"\nwhere\n  \"decode_untyped_invocation untyped_cap untyped_ref caps intent \\<equiv> case intent of\n     UntypedRetypeIntent type size_bits node_index node_depth node_offset node_window \\<Rightarrow>\n       doE\n         (root_cap, root_slot) \\<leftarrow> throw_on_none $ get_index caps 0;\n\n         \\<comment> \\<open>Lookup the destination slots.\\<close>\n         target_node \\<leftarrow> if node_depth = 0 then\n             returnOk root_cap\n           else\n             doE\n               target_slot \\<leftarrow> lookup_slot_for_cnode_op root_cap node_index (unat node_depth);\n               liftE $ get_cap target_slot\n             odE;\n\n         \\<comment> \\<open>Ensure it is a CNode cap.\\<close>\n         unlessE (is_cnode_cap target_node) throw;\n\n         \\<comment> \\<open>Find our target slots.\\<close>\n         slots \\<leftarrow> returnOk $ map (\\<lambda>n. (cap_object target_node, n))\n               [unat node_offset ..< unat node_offset + unat node_window];\n         mapME_x ensure_empty slots;\n\n         \\<comment> \\<open>Work out what names are available. If we haven't haven't already been typed into something we can reuse our names.\\<close>\n         s \\<leftarrow> liftE $ get;\n         has_kids \\<leftarrow> returnOk $ has_children untyped_ref s;\n\n         returnOk $ Retype untyped_ref type (unat size_bits) slots has_kids (unat node_window)\n       odE \\<sqinter> throw\"", "property": "Untyped Memory Object Operations: Decode untyped memory object invocations to retype the untyped memory into a specified type and size, ensuring that the target slots are available and empty. The operation checks if the target is a CNode cap and determines the available names based on whether the untyped memory has children.", "title": "./spec/capDL/Untyped_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  detype :: \"cdl_object_id set \\<Rightarrow> cdl_state \\<Rightarrow> cdl_state\"\nwhere\n  \"detype detype_set s \\<equiv>\n     (s\\<lparr> cdl_objects :=\n         (\\<lambda>x. if x \\<in> detype_set then\n           Some Untyped\n         else cdl_objects s x)\\<rparr>)\"", "property": "Zero Out Addresses: Set a specified set of addresses to an untyped state, effectively zeroing out the corresponding objects in the system.", "title": "./spec/capDL/Untyped_D.thy", "chapter": "", "section": "", "comment": " Zero out a set of addresses. "}
{"spec": "definition\n  generate_object_ids :: \"nat \\<Rightarrow> cdl_object_type \\<Rightarrow> cdl_object_id set \\<Rightarrow>  ((cdl_object_id set) list) k_monad\"\n  where \"generate_object_ids num_objects type object_range\n  \\<equiv> do\n    s \\<leftarrow> get;\n    available_names \\<leftarrow> return $ (cdl_objects s) -` {Some Untyped};\n    setlist \\<leftarrow> select {x. distinct  x \\<and> (\\<forall>a\\<in> set x. \\<forall>b \\<in> set x. a \\<noteq> b \\<longrightarrow> a \\<inter> b = {})\n           \\<and> (\\<forall>y \\<in> set x. y \\<noteq> {} \\<and> y \\<subseteq> object_range \\<inter> available_names)\n           \\<and> (num_objects = (size x)) };\n    if (type \\<noteq> UntypedType) then (return $ map (\\<lambda>x. {pick x}) setlist)\n    else return setlist\n    od\"\n\ndefinition create_objects :: \"(cdl_object_id set) list \\<Rightarrow> cdl_object option \\<Rightarrow> unit k_monad\"\nwhere\n  \"create_objects target_object_ids object \\<equiv>\n    (modify (\\<lambda>s. s\\<lparr>cdl_objects := (\\<lambda>x.\n     if {x} \\<in> set target_object_ids then\n      object\n     else\n      cdl_objects s x)\\<rparr>))\"", "property": "Generate and Create Objects: Generate a list of unique object IDs within a specified range, ensuring that the IDs are distinct and do not overlap. If the target object type is not Untyped, each set in the list is converted to a single object ID. The generated IDs are then used to create new objects of the specified type, updating the system state with the new objects.", "title": "./spec/capDL/Untyped_D.thy", "chapter": "", "section": "", "comment": "\n * Retype the given untyped object into a new object type,\n * and return a list of pointers to the newly constructed items.\n "}
{"spec": "definition\n  create_cap :: \"cdl_object_type \\<Rightarrow> nat \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool \\<Rightarrow> (cdl_cap_ref \\<times> cdl_object_id set) \\<Rightarrow> unit k_monad\"\nwhere\n  \"create_cap new_type sz parent_slot dev \\<equiv> \\<lambda>(dest_slot, obj_refs).\n  do\n    old_cap \\<leftarrow> get_cap dest_slot;\n    assert (old_cap = NullCap);\n    set_cap dest_slot (default_cap new_type obj_refs sz dev);\n    set_parent dest_slot parent_slot\n  od\"\n\n\ndefinition\n  update_available_range :: \"(cdl_object_id set) => (cdl_object_id list) \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> unit k_monad\"\nwhere \"update_available_range orange newids cap_ref cap \\<equiv>\n  do\n     new_range  \\<leftarrow> select {x. x \\<subseteq> orange - set newids};\n     set_cap cap_ref $ set_available_range cap new_range\n  od\"\n\n\ndefinition\n  retype_region :: \"nat \\<Rightarrow> cdl_object_type \\<Rightarrow> (cdl_object_id set list)\n  \\<Rightarrow> ((cdl_object_id set) list) k_monad\"\nwhere\n  \"retype_region target_bits target_type target_object_ids \\<equiv>\n    do\n      \\<comment> \\<open>Get a list of target locations. We are happy with any unused name\n         within the target range.\\<close>\n\n      if (target_type \\<noteq> UntypedType) then\n       do\n         current_domain \\<leftarrow> gets cdl_current_domain;\n         create_objects target_object_ids (default_object target_type target_bits current_domain)\n       od\n      else return ();\n\n      \\<comment> \\<open>Get a list of target locations. We are happy with any unused name\n         within the target range.\\<close>\n      return target_object_ids\n    od\"\n\nprimrec (nonexhaustive)\n  untyped_is_device :: \"cdl_cap \\<Rightarrow> bool\"\nwhere\n    \"untyped_is_device (UntypedCap d _ _) = d\"\n\ndefinition\n  reset_untyped_cap :: \"cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"reset_untyped_cap cref \\<equiv> doE\n    cap \\<leftarrow> liftE $ get_cap cref;\n    whenE (available_range cap \\<noteq> cap_objects cap) $ doE\n      liftE $ modify (detype (cap_objects cap));\n      new_rans \\<leftarrow> liftE $ select {xs. (\\<forall>S \\<in> set xs.\n              S \\<subseteq> cap_objects cap \\<and> available_range cap \\<subset> S)\n          \\<and> xs \\<noteq> [] \\<and> List.last xs = cap_objects cap};\n      mapME_x (\\<lambda>r. doE\n        liftE $ set_cap cref $ set_available_range cap r;\n        returnOk () \\<sqinter> throw\n      odE) new_rans\n    odE\n  odE\"\n\ndefinition\n  invoke_untyped :: \"cdl_untyped_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"invoke_untyped params \\<equiv> case params of\n     Retype untyped_ref new_type type_size target_slots has_kids num_objects \\<Rightarrow>\n   doE\n     unlessE has_kids $ reset_untyped_cap untyped_ref;\n       liftE $ do\n         untyped_cap \\<leftarrow> get_cap untyped_ref;\n\n         new_range \\<leftarrow> return $ available_range untyped_cap;\n         new_obj_refs \\<leftarrow> generate_object_ids num_objects new_type new_range;\n\n         update_available_range new_range (map (\\<lambda>s. pick s) new_obj_refs) untyped_ref untyped_cap;\n\n         \\<comment> \\<open>Construct new objects within the covered range.\\<close>\n         retype_region type_size new_type new_obj_refs;\n\n         \\<comment> \\<open>Construct caps for the new objects.\\<close>\n         mapM_x (create_cap new_type type_size untyped_ref (untyped_is_device untyped_cap)) (zip target_slots new_obj_refs);\n\n         \\<comment> \\<open>Ideally, we should return back to the user how many\n            objects were created.\\<close>\n\n         return ()\n       od\n    odE\"\n\nend", "property": "Create and Update Capabilities: Create new capabilities for objects, set their default properties, and update the available range for untyped capabilities. This ensures that new objects are properly initialized and integrated into the system, while maintaining the integrity of the available object ranges.", "title": "./spec/capDL/Untyped_D.thy", "chapter": "", "section": "", "comment": " Insert a cap for a new object in the given location. "}
{"spec": "(*\n * This file contains user \"intents\".\n *\n * Such intents attempt to capture the semantics of an operation the\n * user is attempting to perform, without having to worry about how the\n * operation is actually encoded within their message registers.\n *\n * There is a one-to-one mapping between the following intents and the\n * invocations made available to userspace. There is not quite\n * a one-to-one mapping between these intents and the invocations listed\n * in Invocations_D, as some of these intents are multiplexed onto\n * a single invocation when being validated.\n *\n * Caps required by the intents are not stored in the intent themselves,\n * but passed seperately in when required. In some sense, the Intent\n * is the \"data\" part of an invocation, but not the \"caps\" part of it.\n *)\n\ntheory Intents_D\nimports\n  \"ASpec.CapRights_A\"\n  ExecSpec.Platform\nbegin\n\ncontext begin interpretation Arch .\nrequalify_types irq\nend", "property": "User Intents: Define the semantics of operations that users aim to perform, abstracting away the specific encoding in message registers. These intents correspond one-to-one with user-space invocations and are used to separate the data part of an invocation from the capabilities required for the operation.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym cdl_right = rights", "property": "Entities have specific rights to kernel objects, which determine the permissible interactions and operations they can perform on those objects.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": "\n * Entities in seL4 have particular rights to kernel objects, which\n * affects how entities can interact with those particular objects.\n "}
{"spec": "type_synonym cdl_cptr = word32\n\nabbreviation (input) Read ::rights\n  where \"Read \\<equiv> AllowRead\"\n\nabbreviation (input) Write::rights\n  where \"Write \\<equiv> AllowWrite\"\n\nabbreviation (input) Grant::rights\n  where \"Grant \\<equiv> AllowGrant\"\n\nabbreviation (input) GrantReply::rights\n  where \"GrantReply \\<equiv> AllowGrantReply\"", "property": "User Capability Pointer: Defines a 32-bit word as a user capability pointer (cdl_cptr) and establishes abbreviations for different rights, including Read, Write, Grant, and GrantReply, to simplify the specification of access permissions.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " A user cap pointer. "}
{"spec": "type_synonym cdl_raw_capdata = word32", "property": "Capability Data Representation: Represents capability data, such as guard information, using a 32-bit word.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Capability data, such as guard information. "}
{"spec": "type_synonym cdl_raw_vmattrs = word32", "property": "VM Attributes Definition: Defines VM attributes, such as page cache attributes, using a 32-bit word.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " VM Attributes, such as page cache attributes. "}
{"spec": "type_synonym cdl_raw_usercontext = \"word32 list\"", "property": "Thread Register Operations: Allow writing to a thread's registers using a list of 32-bit words, enabling the modification of the thread's execution context.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " TCB context, for operations such as write to a thread's registers. "}
{"spec": "datatype cdl_object_type =\n    EndpointType\n  | NotificationType\n  | TcbType\n  | CNodeType\n  | IRQNodeType\n  | UntypedType\n  | AsidPoolType\n  | PageTableType\n  | PageDirectoryType\n  | FrameType nat (* size in bits of desired page *)\n\ndatatype cdl_cnode_intent =", "property": "Kernel Object Types: Defines a set of distinct object types within the kernel, including endpoints, notifications, threads (TCBs), capability nodes, interrupt request nodes, untyped memory, address space identifier pools, page tables, page directories, and frames with specified sizes.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Kernel objects types. "}
{"spec": "CNodeCopyIntent word32 word32 word32 word32 \"cdl_right set\"", "property": "Copy CNode Capabilities: Copy capabilities from a source CNode to a destination CNode, specifying the target, destination index, destination depth, source root, source index, and source depth, along with the rights to be applied to the copied capabilities.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Copy: (target), dest_index, dest_depth, (src_root), src_index, src_depth, rights "}
{"spec": "|  CNodeMintIntent word32 word32 word32 word32 \"cdl_right set\" cdl_raw_capdata", "property": "CNode Mint Intent: Specifies the intent to mint a new capability in a CNode, including details such as the target CNode, destination index and depth, source root, source index and depth, rights, and badge. This ensures that the new capability is correctly created and placed within the specified CNode, with the appropriate permissions and metadata.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Mint: (target), dest_index, dest_depth, (src_root), src_index, src_depth, rights, badge "}
{"spec": "|  CNodeMoveIntent word32 word32 word32 word32", "property": "CNode Move Intent: Specifies the movement of a capability within or between CNodes, defined by the target CNode, destination index and depth, source root CNode, and source index and depth.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Move: (target), dest_index, dest_depth, (src_root), src_index, src_depth "}
{"spec": "|  CNodeMutateIntent word32 word32 word32 word32 cdl_raw_capdata", "property": "CNode Mutation: Allows modification of a capability within a CNode by specifying the target, destination index, and depth, as well as the source root, source index, and depth, along with a badge. This ensures that capabilities can be updated or moved within the CNode structure, maintaining the integrity and flexibility of the capability system.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Mutate: (target), dest_index, dest_depth, (src_root), src_index, src_depth, badge "}
{"spec": "|  CNodeRevokeIntent word32 word32", "property": "Revoke Capability: Revokes a capability at a specified index and depth within a CNode, ensuring that the targeted capability is removed and no longer accessible.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Revoke: (target), index, depth "}
{"spec": "|  CNodeDeleteIntent word32 word32", "property": "CNode Deletion: Allows the deletion of a capability at a specified index and depth within a CNode, ensuring that the targeted capability is removed from the system.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Delete: (target), index, depth "}
{"spec": "|  CNodeSaveCallerIntent word32 word32", "property": "Save Caller Intent: Store the caller's intent in a CNode, specified by the target, index, and depth. This ensures that the caller's context is preserved for later retrieval or use.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SaveCaller: (target), index, depth "}
{"spec": "|  CNodeCancelBadgedSendsIntent word32 word32", "property": "Cancel Badged Sends: Allows the cancellation of sends to a specific CNode based on a badge, index, and depth. This ensures that any pending badged sends to the specified CNode are invalidated, maintaining the integrity and security of the communication channels.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " CancelBadgedSends: (target), index, depth "}
{"spec": "|  CNodeRotateIntent word32 word32 word32 word32 cdl_raw_capdata word32 word32 cdl_raw_capdata\n\ndatatype cdl_tcb_intent =", "property": "CNode Rotation: Allows the rotation of capabilities within a CNode, specifying the target, destination index and depth, pivot root with its index and depth, and source root with its index and depth. This operation facilitates the reorganization of capabilities within the CNode structure, ensuring that the system can dynamically adjust to changing requirements while maintaining the integrity of the capability hierarchy.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Rotate: (target), dest_index, dest_depth, (pivot_root), pivot_index, pivot_depth, pivot_badge, (src_root), src_index, src_depth, src_badge "}
{"spec": "TcbReadRegistersIntent bool word8 word32", "property": "Read Thread Registers: Retrieve a specified number of register values from the target thread, optionally suspending the source thread before reading. The operation respects architectural flags and ensures the integrity of the register data.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " ReadRegisters: (target), suspend_source, arch_flags, count "}
{"spec": "|  TcbWriteRegistersIntent bool word8 word32 cdl_raw_usercontext", "property": "WriteRegisters: Allows writing a specified number of register values to the target thread's context, with an option to resume the target thread after the operation. The operation ensures that the register values are correctly set and sanitized, and it triggers a reschedule if the target thread is the current thread.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " WriteRegisters: (target), resume_target, arch_flags, count, regs "}
{"spec": "|  TcbCopyRegistersIntent bool bool bool bool word8", "property": "CopyRegisters Intent: Defines the intent for copying registers between threads, including options to suspend the source thread, resume the target thread, and specify which sets of registers (frame or integer) to transfer.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " CopyRegisters: (target), (source), suspend_source, resume_target, transfer_frame, transfer_integer, arch_flags "}
{"spec": "|  TcbSuspendIntent", "property": "Thread Suspension: Allows a thread to request the suspension of another specified target thread.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Suspend: (target) "}
{"spec": "|  TcbResumeIntent", "property": "Resume Intent: Allows a thread to express the intention to resume another specified thread, enabling the resumption of the target thread's execution.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Resume: (target) "}
{"spec": "|  TcbConfigureIntent cdl_cptr cdl_raw_capdata cdl_raw_capdata word32", "property": "Thread Configuration: Allows the configuration of a target thread by updating its fault endpoint, CSpace root, VSpace root, and IPC buffer. The configuration ensures that the thread's capabilities and memory spaces are properly set up, enhancing the thread's operational integrity and security.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Configure: (target), fault_ep, (cspace_root), cspace_root_data, (vspace_root), vspace_root_data, buffer, (bufferFrame) "}
{"spec": "|  TcbSetMCPriorityIntent word8", "property": "Set Thread Maximum Priority: Allows setting the maximum priority of a thread. This ensures that the thread's scheduling priority is appropriately managed, maintaining system stability and performance.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetMCPriority: (target), mcp "}
{"spec": "|  TcbSetPriorityIntent word8", "property": "Set Thread Priority: Adjust the priority of a specified thread. This action updates the thread's scheduling priority, ensuring that the thread's execution is managed according to the new priority level.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetPriority: (target), priority "}
{"spec": "|  TcbSetSchedParamsIntent word8 word8", "property": "Set Scheduling Parameters: Allows setting the scheduling parameters, including maximum priority and current priority, for a target thread. This ensures that the thread's scheduling behavior is updated according to the specified parameters, maintaining the integrity and efficiency of the system's scheduling.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetSchedParams: (target), mcp, priority "}
{"spec": "|  TcbSetIPCBufferIntent word32", "property": "SetIPCBuffer: Allows setting the IPC buffer for a thread, optionally including a buffer frame. This ensures that the thread can correctly handle IPC messages with associated data and capabilities.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetIPCBuffer: (target), buffer, (bufferFrame) "}
{"spec": "|  TcbSetSpaceIntent word32 cdl_raw_capdata cdl_raw_capdata", "property": "Set Space Configuration: Allows the configuration of a thread's control space (CSpace) and virtual space (VSpace) roots, along with a fault endpoint. This ensures that the thread's memory and capability management structures are properly set up, enabling effective resource handling and error management.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetSpace: (target), fault_ep, (cspace_root), cspace_root_data, (vspace_root), vspace_root_data "}
{"spec": "|  TcbBindNTFNIntent", "property": "Bind Notification: Associates a thread with a notification, allowing the thread to receive notifications.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " BindNTFN: (target), (ntfn) "}
{"spec": "|  TcbUnbindNTFNIntent", "property": "Unbind Notification: Unbinds a notification from the target thread, removing the association between the thread and the notification.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " UnbindNTFN: (target) "}
{"spec": "|  TcbSetTLSBaseIntent\n\ndatatype cdl_untyped_intent =", "property": "Set TLS Base: Allows setting the Thread Local Storage (TLS) base for a specified thread, ensuring that the thread's TLS base register is updated. If the thread being updated is the current thread, a reschedule is required to apply the changes.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetTLSBase: (target) "}
{"spec": "UntypedRetypeIntent cdl_object_type word32 word32 word32 word32 word32\n\ndatatype cdl_irq_handler_intent =", "property": "Retype Intent: Specifies the intent to retype an untyped object, including the target object, reset action, type of the new object, size in bits, root CNode, node index, node depth, node offset, node window, and whether it has children.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Retype: (target), (do_reset), type, size_bits, (root), node_index, node_depth, node_offset, node_window, has_children "}
{"spec": "IrqHandlerAckIntent", "property": "Acknowledge Interrupt Handler: The system acknowledges the handling of an interrupt, indicating that the specified interrupt handler has completed its execution.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Ack: (target) "}
{"spec": "|  IrqHandlerSetEndpointIntent", "property": "Set Endpoint: Assigns a specified endpoint to a target, establishing the target's association with the endpoint for interrupt handling.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " SetEndpoint: (target), (endpoint) "}
{"spec": "|  IrqHandlerClearIntent\n\ndatatype cdl_arch_irq_control_intent =", "property": "Clear Interrupt Handler Intent: Clears the intent associated with an interrupt handler, ensuring that any pending or specified actions are removed or reset.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Clear: (target) "}
{"spec": "ARMIrqControlIssueIrqHandlerIntent irq word32 word32\n\ndatatype cdl_irq_control_intent =", "property": "ArchIssueIrqHandler: Configures an interrupt handler for a specified target, IRQ, and root, with the given index and depth, allowing for precise control over interrupt handling.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " ArchIssueIrqHandler: (target), irq, (root), index, depth "}
{"spec": "IrqControlIssueIrqHandlerIntent irq word32 word32", "property": "Issue IRQ Handler: Configures an interrupt request (IRQ) handler for a specified target, setting the root, index, and depth parameters to manage the IRQ handling process.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " IssueIrqHandler: (target), irq, (root), index, depth "}
{"spec": "|  ArchIrqControlIssueIrqHandlerIntent cdl_arch_irq_control_intent\n\ndatatype cdl_page_table_intent =", "property": "Interrupt Control: Manage the issuance of interrupt handler intents, allowing for the configuration and control of interrupt handling mechanisms within the system.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " InterruptControl "}
{"spec": "PageTableMapIntent word32 cdl_raw_vmattrs\n |  PageTableUnmapIntent\n\ndatatype cdl_page_intent =", "property": "Page Table Intent: Represents the intention to map or unmap a page in the page table, specifying the target, page directory, virtual address, and attributes for mapping, or the intent to unmap a page.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Map: (target), (pd), vaddr, attr "}
{"spec": "PageMapIntent word32 \"cdl_right set\" cdl_raw_vmattrs", "property": "Map Page Intent: Defines the intent to map a page with specified rights and attributes at a given virtual address, using the provided target and page directory.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Map: (target), (pd), vaddr, rights, attr "}
{"spec": "|  PageUnmapIntent", "property": "Unmap Page: Remove a page from the specified target's address space, ensuring that the memory is no longer accessible and freeing up the associated resources.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Unmap: (target) "}
{"spec": "|  PageFlushCachesIntent", "property": "FlushCaches: Initiates a cache flush operation for the specified target, ensuring that the data in the cache is synchronized with the main memory.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " FlushCaches: (target) "}
{"spec": "| PageGetAddressIntent\n\n\ndatatype cdl_page_directory_intent =\n   PageDirectoryFlushIntent\n | PageDirectoryNothingIntent\n\ndatatype cdl_asid_control_intent =", "property": "GetAddress: Retrieves the address associated with a specific page or page directory, based on the intent provided.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " GetAddress "}
{"spec": "AsidControlMakePoolIntent word32 word32\n\ndatatype cdl_asid_pool_intent =", "property": "Create ASID Pool: Generate an ASID pool with specified parameters, including target, untyped memory, root, index, and depth, to manage address space identifiers effectively.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " MakePool: (target), (untyped), (root), index, depth "}
{"spec": "AsidPoolAssignIntent\n\ndatatype cdl_notification_intent =\n    SendSignalIntent word32", "property": "Assign ASID Pool and VRoot: Allows the assignment of an ASID pool and a virtual root to a target, enabling the management and configuration of memory and virtual address spaces for the target.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Assign: (target), (vroot) "}
{"spec": "datatype cdl_endpoint_intent =\n    SendMessageIntent \"cdl_cptr list\"\n\ndatatype cdl_domain_intent = DomainSetIntent word8\n\ndatatype cdl_intent =\n    CNodeIntent cdl_cnode_intent\n  | TcbIntent cdl_tcb_intent\n  | UntypedIntent cdl_untyped_intent\n  | IrqHandlerIntent cdl_irq_handler_intent\n  | IrqControlIntent cdl_irq_control_intent\n  | PageTableIntent cdl_page_table_intent\n  | PageIntent cdl_page_intent\n  | PageDirectoryIntent cdl_page_directory_intent\n  | AsidControlIntent cdl_asid_control_intent\n  | AsidPoolIntent cdl_asid_pool_intent\n  | NotificationIntent cdl_notification_intent\n  | EndpointIntent cdl_endpoint_intent\n  | DomainIntent cdl_domain_intent\n\nrecord cdl_full_intent =\n  cdl_intent_op        :: \"cdl_intent option\"\n  cdl_intent_error     :: bool\n  cdl_intent_cap       :: cdl_cptr\n  cdl_intent_extras    :: \"cdl_cptr list\"\n  cdl_intent_recv_slot :: \"(cdl_cptr \\<times> word32 \\<times> nat) option\"\n\nend", "property": "Intent Representation: Defines a structured representation for various types of system intents, including operations on CNodes, TCBS, untyped objects, IRQ handlers and controls, page tables, pages, page directories, ASID controls, ASID pools, notifications, endpoints, and domains. Each intent can optionally include an error flag, a capability pointer, extra capability pointers, and a receive slot. This structure allows for the encapsulation of complex operations and their associated data, facilitating the management and execution of system-level actions.", "title": "./spec/capDL/Intents_D.thy", "chapter": "", "section": "", "comment": " Also used with reply caps "}
{"spec": "(*\n * Operations on thread control blocks.\n *)\n\ntheory Tcb_D\nimports Invocations_D CSpace_D\nbegin\n\ndefinition cdl_update_cnode_cap_data :: \"cdl_cap \\<Rightarrow> word32 \\<Rightarrow> cdl_cap\"\nwhere \"cdl_update_cnode_cap_data cap data  \\<equiv>\n  case cap of cdl_cap.CNodeCap oid _ _ sz \\<Rightarrow> if data\\<noteq>0 then\n    (let reserved_bits = 3; guard_bits = 18; guard_size_bits = 5; new_guard_size = unat ((data >> reserved_bits) && mask guard_size_bits);\n        new_guard =\n          (data >> reserved_bits + guard_size_bits) && mask (min (unat ((data >> reserved_bits) && mask guard_size_bits)) guard_bits)\n    in CNodeCap oid new_guard new_guard_size sz)\n    else cap\n  | _ \\<Rightarrow> cap\"\n\ndefinition cdl_same_arch_obj_as :: \"cdl_cap \\<Rightarrow> cdl_cap \\<Rightarrow> bool\"\nwhere \"cdl_same_arch_obj_as capa capb \\<equiv>\n  case capa of AsidPoolCap x _ \\<Rightarrow> (\n        case capb of AsidPoolCap y _ \\<Rightarrow>  y = x\n        | _ \\<Rightarrow> False)\n  | AsidControlCap \\<Rightarrow> (\n       case capb of AsidControlCap \\<Rightarrow> True\n        | _ \\<Rightarrow> False)\n  | FrameCap dev ra _ sa _ _ \\<Rightarrow> (\n       case capb of FrameCap dev' rb _ sb _ _ \\<Rightarrow> rb = ra \\<and> sb = sa \\<and> dev = dev'\n        | _ \\<Rightarrow> False)\n  | cdl_cap.PageTableCap a _ _ \\<Rightarrow> (\n       case capb of cdl_cap.PageTableCap b _ _ \\<Rightarrow> b = a\n        | _ \\<Rightarrow> False)\n  | cdl_cap.PageDirectoryCap a _ _ \\<Rightarrow> (\n       case capb of cdl_cap.PageDirectoryCap b _ _ \\<Rightarrow> b = a\n        | _ \\<Rightarrow> False)\n  | _ \\<Rightarrow> False\"\n\ndefinition\n  decode_tcb_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_tcb_intent \\<Rightarrow> cdl_tcb_invocation except_monad\"\nwhere\n  \"decode_tcb_invocation target slot caps intent \\<equiv> case intent of\n       \\<comment> \\<open>Read another thread's registers.\\<close>\n       TcbReadRegistersIntent suspend flags count \\<Rightarrow>\n         returnOk (ReadRegisters (cap_object target) suspend 0 0) \\<sqinter> throw\n\n       \\<comment> \\<open>Write another thread's registers.\\<close>\n     | TcbWriteRegistersIntent resume flags count regs \\<Rightarrow>\n         returnOk (WriteRegisters (cap_object target) resume [0] 0) \\<sqinter> throw\n\n       \\<comment> \\<open>Copy registers from one thread to another.\\<close>\n     | TcbCopyRegistersIntent suspend_source resume_target f1 f2 f3 \\<Rightarrow>\n         doE\n           (source_cap, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           source_tcb \\<leftarrow> (\n              case source_cap of\n                  TcbCap x \\<Rightarrow> returnOk x\n                | _ \\<Rightarrow> throw);\n           target_tcb \\<leftarrow> returnOk $ cap_object target;\n           returnOk (CopyRegisters target_tcb source_tcb suspend_source resume_target f1 f2 0)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Suspend the target thread.\\<close>\n     | TcbSuspendIntent \\<Rightarrow>\n         returnOk (Suspend (cap_object target)) \\<sqinter> throw\n\n       \\<comment> \\<open>Resume the target thread.\\<close>\n     | TcbResumeIntent \\<Rightarrow>\n         returnOk (Resume (cap_object target)) \\<sqinter> throw\n\n       \\<comment> \\<open>Configure: target, fault_ep, mcp, priority, cspace_root_data, vspace_root_data, buffer\\<close>\n     | TcbConfigureIntent fault_ep cspace_root_data vspace_root_data buffer \\<Rightarrow>\n         doE\n           cspace_root \\<leftarrow> throw_on_none $ get_index caps 0;\n           vspace_root \\<leftarrow> throw_on_none $ get_index caps 1;\n           buffer_frame \\<leftarrow> throw_on_none $ get_index caps 2;\n           cspace_root_cap_ref \\<leftarrow> returnOk $ (cdl_update_cnode_cap_data (fst cspace_root) cspace_root_data,snd cspace_root);\n           vspace_root_cap_ref \\<leftarrow> returnOk $ vspace_root;\n           buffer_frame_opt \\<leftarrow> returnOk $ (if (buffer \\<noteq> 0) then Some (reset_mem_mapping (fst buffer_frame), snd buffer_frame) else None);\n           returnOk (ThreadControl (cap_object target) slot (Some fault_ep)\n               (Some cspace_root_cap_ref) (Some vspace_root_cap_ref) (buffer_frame_opt))\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Modify a thread's maximum control priority.\\<close>\n     | TcbSetMCPriorityIntent mcp \\<Rightarrow>\n         doE\n           auth_cap \\<leftarrow> throw_on_none $ get_index caps 0;\n           returnOk (ThreadControl (cap_object target) slot None None None None)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Modify a thread's priority.\\<close>\n     | TcbSetPriorityIntent priority \\<Rightarrow>\n         doE\n           auth_cap \\<leftarrow> throw_on_none $ get_index caps 0;\n           returnOk (ThreadControl (cap_object target) slot None None None None)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Modify a thread's mcp and priority at the same time.\\<close>\n     | TcbSetSchedParamsIntent mcp priority \\<Rightarrow>\n         doE\n           auth_cap \\<leftarrow> throw_on_none $ get_index caps 0;\n           returnOk (ThreadControl (cap_object target) slot None None None None)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Modify a thread's IPC buffer.\\<close>\n     | TcbSetIPCBufferIntent buffer \\<Rightarrow>\n         doE\n           buffer_frame \\<leftarrow> throw_on_none $ get_index caps 0;\n           buffer_frame_opt \\<leftarrow> returnOk $ (if (buffer \\<noteq> 0) then Some (reset_mem_mapping (fst buffer_frame), snd buffer_frame) else None);\n           returnOk (ThreadControl (cap_object target) slot None None None buffer_frame_opt)\n         odE \\<sqinter> throw\n\n       \\<comment> \\<open>Update the various spaces (CSpace/VSpace) of a thread.\\<close>\n     | TcbSetSpaceIntent fault_ep cspace_root_data vspace_root_data \\<Rightarrow>\n         doE\n           cspace_root \\<leftarrow> throw_on_none $ get_index caps 0;\n           vspace_root \\<leftarrow> throw_on_none $ get_index caps 1;\n           cspace_root_cap_ref \\<leftarrow> returnOk $ (cdl_update_cnode_cap_data (fst cspace_root) cspace_root_data,snd cspace_root);\n           vspace_root_cap_ref \\<leftarrow> returnOk $ vspace_root;\n           returnOk (ThreadControl (cap_object target) slot (Some fault_ep)\n               (Some cspace_root_cap_ref) (Some vspace_root_cap_ref) None)\n        odE \\<sqinter> throw\n     | TcbBindNTFNIntent \\<Rightarrow> doE\n           (ntfn_cap, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           returnOk (NotificationControl (cap_object target) (Some (cap_object ntfn_cap)))\n         odE \\<sqinter> throw\n     | TcbUnbindNTFNIntent \\<Rightarrow> returnOk (NotificationControl (cap_object target) None) \\<sqinter> throw\n     | TCBSetTLSBaseIntent \\<Rightarrow> returnOk (SetTLSBase (cap_object target)) \\<sqinter> throw\n  \"", "property": "Thread Control Block Invocations: Allows for various operations on thread control blocks, including reading and writing registers, suspending and resuming threads, copying registers between threads, configuring thread settings (fault endpoints, cspace and vspace roots, IPC buffers), modifying thread priorities, and managing notifications and TLS base. These operations ensure that threads can be effectively managed and controlled, maintaining the system's integrity and performance.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  tcb_empty_thread_slot :: \"cdl_object_id \\<Rightarrow> cdl_cnode_index \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_empty_thread_slot target_tcb target_slot \\<equiv> doE\n    cap \\<leftarrow> liftE $ get_cap (target_tcb,target_slot);\n    whenE (cap \\<noteq> NullCap) $\n      delete_cap  (target_tcb, target_slot)\n  odE\"", "property": "Empty TCB Slot: Deletes the specified slot of a TCB if it is not a null capability, ensuring that the slot is cleared and the associated resources are freed.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Delete the given slot of a TCB. "}
{"spec": "definition\n  tcb_update_thread_slot :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cnode_index \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_thread_slot target_tcb tcb_cap_slot target_slot pcap \\<equiv>\n         liftE (do\n           thread_cap \\<leftarrow> get_cap tcb_cap_slot;\n           when (thread_cap = TcbCap target_tcb)\n           (insert_cap_child (fst pcap) (snd pcap) (target_tcb, target_slot)\n            \\<sqinter> insert_cap_sibling (fst pcap) (snd pcap) (target_tcb,target_slot))\n         od)\"", "property": "Update TCB Slot: Update a specified slot of a TCB with a new capability, and delete the previous capability in that slot. This ensures that the TCB's capabilities are correctly managed and updated.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update the given slot of a TCB with a new cap, delete the previous\n * capability that was in the slot. "}
{"spec": "definition\n  tcb_update_cspace_root :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap \\<times> cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_cspace_root target_tcb tcb_cap_ref croot \\<equiv>\n  doE\n     tcb_empty_thread_slot target_tcb tcb_cspace_slot;\n     src_cap \\<leftarrow> liftE $ get_cap (snd croot);\n     whenE (is_cnode_cap src_cap \\<and> (cap_object src_cap = cap_object (fst croot)))\n       $ tcb_update_thread_slot target_tcb tcb_cap_ref tcb_cspace_slot croot\n  odE\"", "property": "Update CSpace Root: Update a thread's CSpace root by emptying the existing CSpace slot and, if the new capability is a valid CNode, inserting the new CSpace root into the thread's CSpace slot.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update a thread's CSpace root. "}
{"spec": "definition\n  tcb_update_vspace_root :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_vspace_root target_tcb tcb_cap_ref vroot \\<equiv>\n  doE\n     tcb_empty_thread_slot target_tcb tcb_vspace_slot;\n     src_cap \\<leftarrow> liftE $ get_cap (snd vroot);\n     whenE (cdl_same_arch_obj_as (fst vroot) src_cap)\n       $ tcb_update_thread_slot target_tcb tcb_cap_ref tcb_vspace_slot vroot\n  odE\"", "property": "Update VSpace Root: Updates the virtual space root of a target thread by first emptying the existing VSpace slot, then retrieving and validating the new VSpace capability, and finally updating the thread's VSpace slot with the new capability.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update a thread's VSpace root. "}
{"spec": "definition\n  mark_tcb_intent_error :: \"cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"mark_tcb_intent_error target_tcb has_error \\<equiv>\n      update_thread target_tcb (\\<lambda>t. (t\\<lparr>cdl_tcb_intent := (cdl_tcb_intent t)\\<lparr>cdl_intent_error := has_error\\<rparr>\\<rparr>))\"", "property": "Modify TCB Intent Error: Update the TCB's intent to indicate whether an error occurred during decode. This ensures that the TCB's state accurately reflects the outcome of the decoding process.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Modify the TCB's intent to indicate an error during decode. "}
{"spec": "definition\n  tcb_update_ipc_buffer :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"tcb_update_ipc_buffer target_tcb tcb_cap_ref ipc_buffer \\<equiv>\n     doE\n       tcb_empty_thread_slot target_tcb tcb_ipcbuffer_slot;\n       liftE $ corrupt_tcb_intent target_tcb;\n       src_cap \\<leftarrow> liftE $ get_cap (snd ipc_buffer);\n       whenE (cdl_same_arch_obj_as (fst ipc_buffer) src_cap)\n         $ tcb_update_thread_slot target_tcb tcb_cap_ref tcb_ipcbuffer_slot ipc_buffer\n     odE\n\"", "property": "Update IPC Buffer: Updates a thread's IPC buffer by first emptying the existing slot, corrupting the TCB intent, and then updating the thread slot with the new IPC buffer if the source capability is from the same architectural object.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Update a thread's IPC buffer. "}
{"spec": "definition\n  restart :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"restart target_tcb \\<equiv>\n  do\n     cap \\<leftarrow> KHeap_D.get_cap (target_tcb,tcb_pending_op_slot);\n     when (cap \\<noteq> RestartCap \\<and> cap\\<noteq> RunningCap)\n     (do\n       CSpace_D.cancel_ipc target_tcb;\n       KHeap_D.set_cap (target_tcb,tcb_replycap_slot) (cdl_cap.MasterReplyCap target_tcb);\n       KHeap_D.set_cap (target_tcb,tcb_pending_op_slot) (cdl_cap.RestartCap)\n      od)\n  od\"", "property": "Thread Restart: Resumes a thread, aborts any pending operations, and revokes any incoming reply capabilities. If the thread is not already in a restart or running state, it cancels the current IPC operation, sets the reply capability to a master reply capability, and updates the pending operation to a restart state.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Resume a thread, aborting any pending operation, and revoking\n * any incoming reply caps. "}
{"spec": "definition\n  suspend :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"suspend target_tcb \\<equiv> CSpace_D.cancel_ipc target_tcb >>= K (KHeap_D.set_cap (target_tcb,tcb_pending_op_slot) cdl_cap.NullCap)\"\n\ndefinition\n  bind_notification :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"bind_notification tcb_id ntfn_id \\<equiv> set_cap (tcb_id, tcb_boundntfn_slot) (BoundNotificationCap ntfn_id)\"\n\ndefinition\n  invoke_tcb :: \"cdl_tcb_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"invoke_tcb params \\<equiv> case params of\n    \\<comment> \\<open>Modify a thread's registers.\\<close>\n      WriteRegisters target_tcb resume _ _ \\<Rightarrow>\n        liftE $\n        do\n          corrupt_tcb_intent target_tcb;\n          when resume $ restart target_tcb\n        od\n\n    \\<comment> \\<open>Read a thread's registers.\\<close>\n    | ReadRegisters src_tcb _ _ _ \\<Rightarrow>\n        liftE $ suspend src_tcb \\<sqinter> return ()\n\n    \\<comment> \\<open>Copy registers from one thread to another\\<close>\n    | CopyRegisters target_tcb source_tcb _ _ _ _ _ \\<Rightarrow>\n        liftE $\n        do\n          suspend source_tcb \\<sqinter> return ();\n          restart target_tcb \\<sqinter> return ();\n          corrupt_tcb_intent target_tcb\n       od\n\n    \\<comment> \\<open>Suspend this thread.\\<close>\n    | Suspend target_tcb \\<Rightarrow>\n        liftE $ suspend target_tcb \\<sqinter> return ()\n\n    \\<comment> \\<open>Resume this thread.\\<close>\n    | Resume target_tcb \\<Rightarrow>\n        liftE $ restart target_tcb\n\n    \\<comment> \\<open>Update a thread's options.\\<close>\n    | ThreadControl target_tcb tcb_cap_slot faultep croot vroot ipc_buffer \\<Rightarrow>\n        doE\n          case faultep of\n              Some x \\<Rightarrow> liftE $ update_thread target_tcb (\\<lambda>tcb. tcb\\<lparr>cdl_tcb_fault_endpoint := x\\<rparr>)\n            | None \\<Rightarrow> returnOk ();\n\n          \\<comment> \\<open>Possibly update CSpace\\<close>\n          case croot of\n              Some x \\<Rightarrow> tcb_update_cspace_root target_tcb tcb_cap_slot x\n            | None \\<Rightarrow> returnOk ();\n\n          \\<comment> \\<open>Possibly update VSpace\\<close>\n          case vroot of\n              Some x \\<Rightarrow> tcb_update_vspace_root target_tcb tcb_cap_slot x\n            | None \\<Rightarrow> returnOk ();\n\n          \\<comment> \\<open>Possibly update Ipc Buffer\\<close>\n          case ipc_buffer of\n              Some x \\<Rightarrow> tcb_update_ipc_buffer target_tcb tcb_cap_slot x\n            | None \\<Rightarrow> (returnOk () \\<sqinter> (doE tcb_empty_thread_slot target_tcb tcb_ipcbuffer_slot;\n                 liftE $ corrupt_tcb_intent target_tcb odE))\n        odE\n    | NotificationControl tcb ntfn \\<Rightarrow>\n          liftE $ (case ntfn of\n             Some ntfn_id \\<Rightarrow> bind_notification tcb ntfn_id\n           | None \\<Rightarrow> unbind_notification tcb)\n    | SetTLSBase tcb \\<Rightarrow> liftE $ corrupt_tcb_intent tcb\"\n\n\ndefinition\n  decode_domain_invocation :: \"(cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow> cdl_domain_intent \\<Rightarrow> cdl_domain_invocation except_monad\"\nwhere\n  \"decode_domain_invocation caps intent \\<equiv> case intent of\n     DomainSetIntent d \\<Rightarrow> returnOk (SetDomain (cap_object (fst (hd caps))) d) \\<sqinter> throw\"\n\ndefinition\n  set_domain :: \"cdl_object_id \\<Rightarrow> word8 \\<Rightarrow> unit k_monad\"\nwhere\n  \"set_domain tcb d \\<equiv> update_thread tcb (\\<lambda>t. (t\\<lparr>cdl_tcb_domain := d \\<rparr>))\"\n\ndefinition\n  invoke_domain :: \"cdl_domain_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"invoke_domain params \\<equiv> case params of\n     SetDomain tcb d \\<Rightarrow> liftE $ set_domain tcb d\"\n\n\nend", "property": "Thread and Domain Management: Allows threads to be suspended, resumed, and have their state and capabilities modified. Suspend operations abort any pending operations and revoke incoming reply capabilities, while resume operations restart the thread. Thread control operations can update fault endpoints, CSpace, VSpace, and IPC buffers. Additionally, domain management allows setting the domain of a thread, updating its scheduling and execution context.", "title": "./spec/capDL/Tcb_D.thy", "chapter": "", "section": "", "comment": " Suspend a thread, aborting any pending operation, and revoking\n * any incoming reply caps. "}
{"spec": "(*\n * Operations on endpoints.\n *)\n\ntheory Endpoint_D\nimports Invocations_D CSpace_D Tcb_D\nbegin", "property": "Endpoint Operations: Manage and manipulate endpoints, enabling communication and synchronization between threads.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  inject_reply_cap :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"inject_reply_cap src_tcb_id dst_tcb_id can_grant \\<equiv> do\n     set_cap (src_tcb_id, tcb_pending_op_slot) $\n         cdl_cap.PendingSyncRecvCap src_tcb_id True False;\n     insert_cap_child (ReplyCap src_tcb_id (if can_grant then {Grant, Write} else {Write}))\n                      (src_tcb_id, tcb_replycap_slot)\n                      (dst_tcb_id, tcb_caller_slot);\n     return ()\n  od\"", "property": "Inject Reply Capability: Inject a reply capability into the target TCB, setting the pending operation and inserting the reply capability with specified permissions.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " Inject the reply cap into the target TCB "}
{"spec": "definition\n  get_receive_slot :: \"cdl_object_id \\<Rightarrow> cdl_cap_ref option k_monad\"\nwhere\n  \"get_receive_slot thread \\<equiv>\n    do\n      tcb \\<leftarrow> get_thread thread;\n      recv_slot \\<leftarrow> (case (cdl_tcb_caps tcb tcb_ipcbuffer_slot) of (Some (FrameCap _ _ rights _ _ _)) \\<Rightarrow>\n        if (Read \\<in> rights \\<and> Write \\<in> rights)\n          then return (cdl_intent_recv_slot (cdl_tcb_intent tcb))\n        else\n          return None\n      | _ \\<Rightarrow> return None);\n      case ( recv_slot ) of\n          None \\<Rightarrow>\n            return None\n        | Some (croot, index, depth) \\<Rightarrow>\n            doE\n              \\<comment> \\<open>Lookup the slot.\\<close>\n              cspace_root \\<leftarrow> unify_failure $ lookup_cap thread croot;\n              result \\<leftarrow> unify_failure $ lookup_slot_for_cnode_op cspace_root index depth;\n\n              \\<comment> \\<open>Ensure nothing is already in it.\\<close>\n              cap \\<leftarrow> liftE $ get_cap result;\n              whenE (cap \\<noteq> NullCap) throw;\n\n              returnOk $ Some result\n            odE <catch> (\\<lambda>_. return None)\n    od\n  \"", "property": "Determine Receive Slot: Identify and validate the slot for an incoming capability for a specific thread. If the thread's IPC buffer has the necessary read and write permissions, the function locates the appropriate slot in the cspace, ensuring it is empty before returning it.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Get the slot where we should place an incoming cap for a\n * particular thread.\n "}
{"spec": "definition\n  get_send_slots :: \"cdl_object_id \\<Rightarrow> cdl_cptr list k_monad\"\nwhere\n  \"get_send_slots thread \\<equiv>\n    do\n      tcb \\<leftarrow> get_thread thread;\n      return $ cdl_intent_extras (cdl_tcb_intent tcb)\n    od\n  \"\n\ndefinition\n  get_ipc_buffer :: \"cdl_object_id \\<Rightarrow> bool \\<Rightarrow> cdl_object_id option k_monad\"\nwhere\n  \"get_ipc_buffer oid in_receive \\<equiv> do\n    frame_cap \\<leftarrow> get_cap (oid,tcb_ipcbuffer_slot);\n    (case frame_cap of\n        Types_D.FrameCap _ a rights _ _ _ \\<Rightarrow> if (Write \\<in> rights \\<and> Read \\<in> rights) \\<or> (Read\\<in> rights \\<and> \\<not> in_receive)\n          then return (Some a)\n          else return None\n        | _ \\<Rightarrow> return None)\n   od\"\n\ndefinition\n  corrupt_ipc_buffer :: \"cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\n  where\n  \"corrupt_ipc_buffer oid in_receive \\<equiv> do\n    buffer \\<leftarrow> get_ipc_buffer oid in_receive;\n    (case buffer of\n        Some a \\<Rightarrow> corrupt_frame a\n      | None \\<Rightarrow> corrupt_tcb_intent oid)\n  od\"", "property": "Retrieve and Validate IPC Buffer: Obtain the IPC buffer for a given thread, ensuring it has the necessary read and write permissions based on the operation context. If the buffer is valid, return its address; otherwise, return none.\n\nCorrupt IPC Buffer or TCB Intent: Depending on the validity and permissions of the IPC buffer, either corrupt the frame associated with the buffer or the TCB intent of the thread. This ensures that the integrity of the IPC mechanism is maintained by invalidating the data in case of an error.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " Get the cptr's that the given thread wishes to transfer. "}
{"spec": "fun\n  transfer_caps_loop :: \"cdl_object_id option \\<Rightarrow> cdl_object_id \\<Rightarrow>\n                         (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow> cdl_cap_ref option\n                         \\<Rightarrow> unit k_monad\"\nwhere\n  \"transfer_caps_loop ep receiver [] dest = return ()\"\n| \"transfer_caps_loop ep receiver ((cap,slot)#caps) dest =\n      \\<comment> \\<open>Transfer badge, transfer cap, or abort early if more than\n         one cap to transfer\\<close>\n      (if is_ep_cap cap \\<and> ep = Some (cap_object cap)\n      then do\n        \\<comment> \\<open>transfer badge\\<close>\n        corrupt_ipc_buffer receiver True;\n        \\<comment> \\<open>transfer rest of badges or cap\\<close>\n        transfer_caps_loop ep receiver caps dest\n      od\n      else if dest \\<noteq> None then doE\n        new_cap \\<leftarrow> returnOk (update_cap_rights (cap_rights cap - {Write}) cap) \\<sqinter>\n                  returnOk cap;\n\n        \\<comment> \\<open>Target cap is derived. This may abort transfer early.\\<close>\n        target_cap \\<leftarrow> derive_cap slot new_cap;\n        whenE (target_cap = NullCap) throw;\n\n        \\<comment> \\<open>Copy the cap across as either a child or sibling.\\<close>\n        liftE (insert_cap_child target_cap slot (the dest)\n               \\<sqinter> insert_cap_sibling target_cap slot (the dest));\n\n        \\<comment> \\<open>Transfer rest of badges\\<close>\n        liftE $ transfer_caps_loop ep receiver caps None\n      odE <catch> (\\<lambda>_. return ())\n      else\n        return ())\"", "property": "Transfer Cap and Badges: Transfers at most one capability and a number of endpoint badges. If the capability to be transferred is to the endpoint used in the transfer, it transfers the badge; otherwise, it transfers the capability while updating its rights and inserting it into the destination slot.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Transfers at most one cap in addition to a number of endpoint badges.\n *\n * Endpoint badges are transferred if the cap to be transferred is to\n * the endpoint used in the transfer.\n "}
{"spec": "definition\n  transfer_caps :: \"cdl_object_id option \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n                    cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"transfer_caps ep caps sender receiver \\<equiv>\n    do\n      dest_slot \\<leftarrow> get_receive_slot receiver \\<sqinter> return None;\n      transfer_caps_loop ep receiver caps dest_slot\n    od\"", "property": "Capability Transfer: Transfer capabilities from the source to the destination thread, with the actual behavior depending on the specific implementation details. The transfer process may involve nondeterministic outcomes, such as caps not being sent but still consuming the receive slot, or the transfer stopping midway due to faults. Only one destination cap slot is supported, and the new cap may be a sibling or child of the source cap.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Transfer caps from src to dest.\n *\n * In theory, the source thread specifies a list of caps to send, and\n * the destination thread specifies a list of cap slots to put them in.\n *\n * In the true spirit of L4 Pistachio, what _actually_ occurs during the\n * IPC transfer is hard to determine without knowing intricate details\n * of the kernel's implementation. In particular:\n *\n *   - Caps often just won't send, but still 'burn' the receive slot\n *     (ZombieCaps, ReplyCaps, IrqControlCap);\n *\n *   - Caps may not send, but still allow later caps to\n *     use the receive slot (Unwrapped endpoints);\n *\n *   - Cap sending may stop half way (cap lookup faults);\n *\n *   - The new cap may either be a sibling or child of source cap,\n *     depending on where in the CDT the source cap is.\n *\n *   - In reality, no more than one cap will ever be sent, because only\n *     one destination cap slot is supported elsewhere in the code.\n *\n * We remove some of the details, replacing them with nondeterminism.\n "}
{"spec": "definition\n  get_waiting_ntfn_recv_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_waiting_ntfn_recv_threads target state \\<equiv>\n     {x. \\<exists>a. (cdl_objects state) x = Some (Tcb a) \\<and>\n         (((cdl_tcb_caps a) tcb_pending_op_slot) = Some (PendingNtfnRecvCap target)) }\"", "property": "Notification Reception Waiters: Retrieve the set of threads that are waiting to receive a notification on the specified target. These threads have a pending operation slot indicating they are awaiting a notification from the given target.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Get the set of threads waiting to receive on the given notification.\n "}
{"spec": "definition\n  get_waiting_sync_recv_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_waiting_sync_recv_threads target state \\<equiv>\n     {x. \\<exists>a. (cdl_objects state) x = Some (Tcb a) \\<and>\n         (\\<exists>can_grant. (cdl_tcb_caps a) tcb_pending_op_slot = Some (PendingSyncRecvCap target False can_grant)) }\"", "property": "Retrieve Waiting Sync Receive Threads: Identify the set of threads that are waiting to receive on a specified synchronization endpoint. This involves checking the state of each thread and determining if it has a pending synchronous receive operation on the given endpoint.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " Get the set of threads waiting to receive on the given sync endpoint. "}
{"spec": "definition\n  get_waiting_sync_send_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_waiting_sync_send_threads target state \\<equiv>\n     {t. \\<exists>fault a b. (cdl_objects state) t = Some (Tcb a) \\<and>\n         (\\<exists>call can_grant can_grant_reply. (cdl_tcb_caps a) tcb_pending_op_slot =\n                    Some (PendingSyncSendCap target b call can_grant can_grant_reply fault)) }\"", "property": "Retrieve Waiting Sync Send Threads: Identify the set of threads that are waiting to send to a specified synchronization endpoint. These threads have a pending synchronous send operation associated with the target endpoint.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Get the set of threads waiting to send to the given sync endpoint.\n "}
{"spec": "definition\n  get_waiting_sync_bound_ntfn_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_waiting_sync_bound_ntfn_threads ntfn_id state \\<equiv>\n     {x. \\<exists>a ep_id. (cdl_objects state) x = Some (Tcb a) \\<and>\n         (\\<exists>can_grant. (cdl_tcb_caps a) tcb_pending_op_slot = Some (PendingSyncRecvCap ep_id False can_grant)) \\<and>\n         ((cdl_tcb_caps a) tcb_boundntfn_slot = Some (BoundNotificationCap ntfn_id))}\"", "property": "Identify Synchronous Bound Notification Threads: Retrieve the set of threads that are both bound to a specific notification and waiting for synchronous IPC. This ensures that only relevant threads, which are in the correct state and associated with the given notification, are selected.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Get the set of threads which are bound to the given ntfn, but are\n * also waiting on sync IPC\n "}
{"spec": "definition\n  block_thread_on_ipc :: \"cdl_object_id \\<Rightarrow> cdl_cap \\<Rightarrow> unit k_monad\"\nwhere\n  \"block_thread_on_ipc tcb cap \\<equiv> set_cap (tcb, tcb_pending_op_slot) cap\" (* Might need to do some check here *)\n\ndefinition\n  lookup_extra_caps :: \"cdl_object_id \\<Rightarrow> cdl_cptr list \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list fault_monad\"\nwhere\n  \"lookup_extra_caps thread cptrs \\<equiv>\n     mapME (\\<lambda>cptr. lookup_cap_and_slot thread cptr) cptrs\"", "property": "Thread IPC Blocking: When a thread blocks on an IPC, it is assigned a new \"send once\" or \"receive once\" capability. This ensures that the IPC transfer can proceed even if the original capability used to initiate the send or receive operation is revoked.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Mark a thread blocked on IPC.\n *\n * Theads get a new implicit \"send once\" or \"receive once\" capability\n * when they block on an IPC. This is because if the capability they\n * used to start the send/receive is revoked, the transfer will still be\n * allowed to proceed (even if it is at a much later point in time).\n "}
{"spec": "definition\n  do_ipc_transfer :: \"cdl_object_id option \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"do_ipc_transfer ep_id sender_id receiver_id can_grant \\<equiv> do\n      \\<comment> \\<open>look up cap transfer\\<close>\n      src_slots \\<leftarrow> get_send_slots sender_id;\n      do \\<comment> \\<open>do normal transfer\\<close>\n        caps \\<leftarrow> if can_grant then\n                lookup_extra_caps sender_id src_slots <catch> (\\<lambda>_. return [])\n              else\n                return [];\n        \\<comment> \\<open>copy registers, transfer message or fault\\<close>\n        corrupt_ipc_buffer receiver_id True;\n        \\<comment> \\<open>transfer caps if no fault occured\\<close>\n        transfer_caps ep_id caps sender_id receiver_id\n      od  \\<sqinter>  \\<comment> \\<open>fault transfer\\<close>\n      corrupt_ipc_buffer receiver_id True;\n      \\<comment> \\<open>set message info\\<close>\n      corrupt_tcb_intent receiver_id\n  od\"", "property": "IPC Transfer: Transfers a message from the sender to the receiver, optionally copying capabilities. If the receiver has a pending fault, the fault is sent instead of the message. The transfer process includes looking up and transferring capabilities, corrupting the IPC buffer, and setting the message information.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Transfer a message from \"sender\" to \"receiver\", possibly copying caps\n * over in the process. If a fault is pending in receiver, send fault instead.\n "}
{"spec": "definition\n  do_reply_transfer :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"do_reply_transfer sender_id receiver_id reply_cap_slot can_grant \\<equiv>\n    do\n      has_fault \\<leftarrow> get_thread_fault receiver_id;\n      when (\\<not> has_fault) $ do_ipc_transfer None sender_id receiver_id can_grant;\n      \\<comment> \\<open>Clear out any pending operation caps.\\<close>\n      delete_cap_simple reply_cap_slot;\n      when (has_fault) $ (do corrupt_tcb_intent receiver_id;\n        update_thread_fault receiver_id (\\<lambda>_. False) od );\n      if ( \\<not> has_fault) then set_cap (receiver_id, tcb_pending_op_slot) RunningCap\n      else\n         (set_cap (receiver_id,tcb_pending_op_slot) NullCap\n        \\<sqinter> set_cap (receiver_id,tcb_pending_op_slot) RestartCap)\n    od\"", "property": "Message Reply Transfer: Transfers a message from the sender to the receiver using a reply capability, with the option for the sender to grant capabilities over the channel. If the receiver has a pending fault, the fault is transferred and the receiver's intent is corrupted. The reply capability is deleted after the transfer, and the receiver's pending operation slot is updated based on the presence of a fault.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Transfer a message from \"sender\" to \"receiver\" using a reply capability.\n *\n * The sender may have the right to grant caps over the channel.\n *\n * If a fault is pending in the receiver, the fault is transferred.\n "}
{"spec": "definition\n  do_notification_transfer :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"do_notification_transfer receiver_id \\<equiv> do\n      set_cap (receiver_id,tcb_pending_op_slot) RunningCap;\n      corrupt_tcb_intent receiver_id\n   od\"", "property": "Wake-up Thread on Notification: Wake up a thread that is waiting on a notification by setting the capability of the receiver's pending operation slot to RunningCap and corrupting the TCB intent.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " Wake-up a thread waiting on an notification. "}
{"spec": "definition\n  send_signal_bound :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"send_signal_bound ntfn_id \\<equiv> do\n      bound_tcbs \\<leftarrow> gets $ get_waiting_sync_bound_ntfn_threads ntfn_id;\n      if (bound_tcbs \\<noteq> {}) then do\n          t \\<leftarrow> select bound_tcbs;\n          set_cap (t, tcb_pending_op_slot) NullCap;\n          do_notification_transfer t\n        od\n      else return ()\n    od\"\n\ndefinition\n  send_signal :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"send_signal ep_id \\<equiv>\n    (do waiters \\<leftarrow> gets $ get_waiting_ntfn_recv_threads ep_id;\n          t \\<leftarrow> option_select waiters;\n          case t of\n              None \\<Rightarrow> return ()\n            | Some receiver \\<Rightarrow> do_notification_transfer receiver\n     od)\n            \\<sqinter> send_signal_bound ep_id\"", "property": "Signal Notification: Sends a signal to a notification, waking up a thread if one is blocked on the notification. If no threads are waiting, the operation has no effect.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Signal on a notification.\n *\n * If someone is blocked on the notifications, we wake them up. Otherwise,\n * this is a no-(.)\n "}
{"spec": "definition\n  recv_signal :: \"cdl_object_id \\<Rightarrow> cdl_cap \\<Rightarrow> unit k_monad\"\nwhere\n  \"recv_signal tcb_id_receiver ep_cap  \\<equiv> do\n     ep_id \\<leftarrow> return $ cap_object ep_cap;\n     block_thread_on_ipc tcb_id_receiver (PendingNtfnRecvCap ep_id) \\<sqinter> corrupt_tcb_intent tcb_id_receiver\n   od\"", "property": "Receive Signal: A thread can receive a signal from a notification, either by receiving the data or blocking until the data is available. This ensures that the thread's state is updated to reflect the pending reception and any associated intent is corrupted.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Receive a signal (receive from a notification).\n *\n * We will either receive data or block waiting.\n "}
{"spec": "definition\n  send_ipc :: \"bool \\<Rightarrow> bool \\<Rightarrow> cdl_badge \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"send_ipc block call badge can_grant can_grant_reply tcb_id_sender ep_id \\<equiv>\n    do\n      waiters \\<leftarrow> gets $ get_waiting_sync_recv_threads ep_id;\n      t \\<leftarrow> option_select waiters;\n      case t of\n          None \\<Rightarrow>\n            if block then\n              block_thread_on_ipc tcb_id_sender\n                  (PendingSyncSendCap ep_id badge call can_grant can_grant_reply False)\n            else\n              return ()\n        | Some tcb_id_receiver \\<Rightarrow> do\n             \\<comment> \\<open>liftM instead of bind+return avoids early unfolding in send_ipc_corres\\<close>\n             recv_state \\<leftarrow> liftM (\\<lambda>tcb. the (cdl_tcb_caps tcb tcb_pending_op_slot)) $\n                              get_thread tcb_id_receiver;\n             reply_can_grant \\<leftarrow>\n               (case recv_state of\n                    PendingSyncRecvCap target False receiver_grant \\<Rightarrow> do\n                      do_ipc_transfer (Some ep_id) tcb_id_sender tcb_id_receiver can_grant;\n                      return receiver_grant od\n                  | _ \\<Rightarrow> fail);\n             set_cap (tcb_id_receiver,tcb_pending_op_slot) RunningCap;\n             (when (can_grant \\<or> can_grant_reply) $\n                  (inject_reply_cap tcb_id_sender tcb_id_receiver reply_can_grant))\n               \\<sqinter> set_cap (tcb_id_sender,tcb_pending_op_slot) NullCap \\<sqinter> return ()\n          od\n    od\"", "property": "IPC Synchronization: Sends an IPC to a specified endpoint. If there is a waiting receiver, it wakes up the receiver and performs the IPC transfer, including capability grants if allowed. If no receiver is waiting and blocking is enabled, the sender is put to sleep; otherwise, the operation returns immediately.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Send an IPC to the given endpoint. If someone is waiting, we wake\n * them up. Otherwise, we put the sender to sleep.\n "}
{"spec": "definition\n  receive_sync :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"receive_sync thread ep_id receiver_can_grant \\<equiv> do\n    waiters \\<leftarrow> gets $ get_waiting_sync_send_threads ep_id;\n      waiter \\<leftarrow> option_select waiters;\n      (case waiter of\n          None \\<Rightarrow>\n            block_thread_on_ipc thread (PendingSyncRecvCap ep_id False receiver_can_grant)\n             \\<sqinter> corrupt_tcb_intent thread\n        | Some tcb_id_sender \\<Rightarrow> (do\n            tcb \\<leftarrow> get_thread tcb_id_sender;\n            case ((cdl_tcb_caps tcb) tcb_pending_op_slot) of\n              Some (PendingSyncSendCap target _ call can_grant can_grant_reply fault) \\<Rightarrow> (do\n                 do_ipc_transfer (Some ep_id) tcb_id_sender thread can_grant;\n                 (when (can_grant \\<or> can_grant_reply) $\n                    (inject_reply_cap tcb_id_sender thread receiver_can_grant)) \\<sqinter>\n                 set_cap (tcb_id_sender, tcb_pending_op_slot) RunningCap \\<sqinter>\n                 set_cap (tcb_id_sender, tcb_pending_op_slot) NullCap\n              od)\n        od)\n      )\n    od\"", "property": "Receive Synchronous IPC: Handle synchronous IPC reception from a specified endpoint. If there are waiting senders, wake one up and perform the IPC transfer, including capability grants if allowed. If no senders are waiting, block the receiver on the endpoint and mark its intent as corrupted.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Receive an IPC from the given endpoint. If someone is waiting, we\n * wake them up. Otherwise, we put the receiver to sleep.\n "}
{"spec": "definition\n  receive_ipc :: \"cdl_object_id \\<Rightarrow> cdl_object_id \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"receive_ipc thread ep_id can_grant \\<equiv> corrupt_tcb_intent thread \\<sqinter> receive_sync thread ep_id can_grant\"\n\ndefinition\n  invoke_endpoint :: \"bool \\<Rightarrow> bool \\<Rightarrow> cdl_endpoint_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_endpoint is_call can_block params \\<equiv> case params of\n    SyncMessage badge can_grant can_grant_reply ep_id \\<Rightarrow> do\n      thread \\<leftarrow> gets_the cdl_current_thread;\n      send_ipc can_block is_call badge can_grant can_grant_reply thread ep_id\n    od\"\n\ndefinition\n  invoke_notification :: \"cdl_notification_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_notification params \\<equiv> case params of\n    Signal badge ep_id \\<Rightarrow>\n      send_signal ep_id\"\n\ndefinition\n  invoke_reply :: \"cdl_reply_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_reply params \\<equiv> case params of\n    ReplyMessage recv reply_cap_ref rights \\<Rightarrow> do\n      send \\<leftarrow> gets_the cdl_current_thread;\n      do_reply_transfer send recv reply_cap_ref rights\n    od\"", "property": "IPC and Notification Handling: Enables threads to send and receive IPC messages, signals, and reply messages. The system supports synchronous message passing, signal sending, and reply message transfers, allowing for inter-thread communication and coordination.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": " This is more nonderministic than is really required, but\n   it makes the refinement proofs much easier "}
{"spec": "definition\n  send_fault_ipc :: \"cdl_object_id \\<Rightarrow> unit fault_monad\"\n  where\n  \"send_fault_ipc tcb_id \\<equiv>\n    doE\n      \\<comment> \\<open>Lookup where we should send the fault IPC to.\\<close>\n      tcb \\<leftarrow> liftE $ get_thread tcb_id;\n      target_ep_cptr \\<leftarrow> returnOk $ cdl_tcb_fault_endpoint tcb;\n      handler_cap \\<leftarrow> lookup_cap tcb_id target_ep_cptr;\n      (case handler_cap of\n          EndpointCap ref badge rights \\<Rightarrow>\n            if Write \\<in> rights \\<and> (Grant \\<in> rights \\<or> GrantReply \\<in> rights) then\n              liftE $ do\n                update_thread_fault tcb_id (\\<lambda>_. True);\n                send_ipc True True badge (Grant \\<in> rights) True tcb_id ref\n              od\n            else\n               throw\n        | _ \\<Rightarrow> throw)\n    odE\"", "property": "Send Fault IPC: Send a fault IPC to the specified thread's fault handler, provided the handler has the necessary rights (Write and either Grant or GrantReply). If the handler does not have the required rights, the operation fails.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Send a fault IPC to the given thread's fault handler.\n "}
{"spec": "definition\n  handle_fault :: \"unit k_monad\"\nwhere\n  \"handle_fault \\<equiv> do\n    tcb_id \\<leftarrow> gets_the cdl_current_thread;\n    (send_fault_ipc tcb_id\n      <catch> (\\<lambda>_. KHeap_D.set_cap (tcb_id,tcb_pending_op_slot) cdl_cap.NullCap))\n  od\"\n\nend", "property": "Handle Fault: Manage a fault caused by the current thread. If sending a fault IPC fails, set the capability in the current thread's pending operation slot to null.", "title": "./spec/capDL/Endpoint_D.thy", "chapter": "", "section": "", "comment": "\n * Handle a fault caused by the current thread.\n *\n * The abstract spec adds two additional parameters:\n *\n *    1. The fault type (which we abstract away);\n *\n *    2. The thread causing the fault (which always turns out\n *       to be the current thread).\n "}
{"spec": "(*\n * Operations on CNodes.\n *)\n\ntheory CNode_D\nimports Invocations_D CSpace_D\nbegin\n\ndefinition\n  has_cancel_send_rights :: \"cdl_cap \\<Rightarrow> bool\" where\n  \"has_cancel_send_rights cap \\<equiv> case cap of\n   EndpointCap _ _ R \\<Rightarrow> R = UNIV\n   | _ \\<Rightarrow> False\"\n\ndefinition\n  decode_cnode_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_cnode_intent \\<Rightarrow> cdl_cnode_invocation except_monad\"\nwhere\n  \"decode_cnode_invocation target target_ref caps intent \\<equiv> case intent of\n       \\<comment> \\<open>Copy a cap to anther capslot, without modifying the cap.\\<close>\n       CNodeCopyIntent dest_index dest_depth src_index src_depth rights \\<Rightarrow>\n         doE\n           (src_root, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op target dest_index (unat dest_depth);\n           ensure_empty dest_slot;\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n           new_cap \\<leftarrow> returnOk $ update_cap_rights (cap_rights src_cap \\<inter> rights) src_cap;\n           cap \\<leftarrow> derive_cap src_slot new_cap;\n           whenE (cap = cdl_cap.NullCap) throw;\n\n           returnOk $ InsertCall cap src_slot dest_slot\n         odE\n\n     \\<comment> \\<open>Copy a cap to another capslot, possibly modifying the cap.\\<close>\n     | CNodeMintIntent dest_index dest_depth src_index src_depth rights badge \\<Rightarrow>\n         doE\n           (src_root, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op target dest_index (unat dest_depth);\n           ensure_empty dest_slot;\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n\n           \\<comment> \\<open>Munge the caps rights/data.\\<close>\n           new_cap \\<leftarrow> returnOk $ update_cap_rights (cap_rights src_cap \\<inter> rights) src_cap;\n           new_cap' \\<leftarrow> liftE $ update_cap_data False badge new_cap;\n\n           cap \\<leftarrow> derive_cap src_slot new_cap';\n           whenE (cap = cdl_cap.NullCap) throw;\n\n           returnOk $ InsertCall cap src_slot dest_slot\n         odE\n\n     \\<comment> \\<open>Move a cap to another capslot, without modifying the cap.\\<close>\n     | CNodeMoveIntent dest_index dest_depth src_index src_depth \\<Rightarrow>\n         doE\n           (src_root, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op target dest_index (unat dest_depth);\n           ensure_empty dest_slot;\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n           whenE (src_cap = NullCap) throw;\n           returnOk $ MoveCall src_cap src_slot dest_slot\n         odE\n\n     \\<comment> \\<open>Move a cap to another capslot, possibly modifying the cap.\\<close>\n     | CNodeMutateIntent dest_index dest_depth src_index src_depth badge \\<Rightarrow>\n         doE\n           (src_root, _) \\<leftarrow> throw_on_none $ get_index caps 0;\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op target dest_index (unat dest_depth);\n           ensure_empty dest_slot;\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n\n           \\<comment> \\<open>Munge the caps rights/data.\\<close>\n           cap \\<leftarrow> liftE $ update_cap_data True badge src_cap;\n           whenE (cap = NullCap) throw;\n\n           returnOk $ MoveCall cap src_slot dest_slot\n         odE\n\n     \\<comment> \\<open>Revoke all CDT children of the given cap.\\<close>\n     | CNodeRevokeIntent index depth \\<Rightarrow>\n         doE\n           target_slot \\<leftarrow> lookup_slot_for_cnode_op target index (unat depth);\n           returnOk $ RevokeCall target_slot\n         odE\n\n     \\<comment> \\<open>Delete the given cap, but not its children.\\<close>\n     | CNodeDeleteIntent index depth \\<Rightarrow>\n         doE\n           target_slot \\<leftarrow> lookup_slot_for_cnode_op target index (unat depth);\n           returnOk $ DeleteCall target_slot\n         odE\n\n     \\<comment> \\<open>Save the current thread's reply cap into the target slot.\\<close>\n     | CNodeSaveCallerIntent index depth \\<Rightarrow>\n         doE\n           target_slot \\<leftarrow> lookup_slot_for_cnode_op target index (unat depth);\n           ensure_empty target_slot;\n           returnOk $ SaveCall target_slot\n         odE\n\n     \\<comment> \\<open>Recycle the target cap.\\<close>\n     | CNodeCancelBadgedSendsIntent index depth \\<Rightarrow>\n         doE\n           target_slot \\<leftarrow> lookup_slot_for_cnode_op target index (unat depth);\n           cap \\<leftarrow> liftE $ get_cap target_slot;\n           unlessE (has_cancel_send_rights cap) throw;\n           returnOk $ CancelBadgedSendsCall cap\n         odE\n\n     \\<comment> \\<open>Atomically move several caps.\\<close>\n     | CNodeRotateIntent dest_index dest_depth pivot_index pivot_depth pivot_badge src_index src_depth src_badge \\<Rightarrow>\n         doE\n           pivot_root \\<leftarrow> throw_on_none $ get_index caps 0;\n           src_root \\<leftarrow> throw_on_none $ get_index caps 1;\n\n           dest_root \\<leftarrow> returnOk $ target;\n           pivot_root \\<leftarrow> returnOk $ fst pivot_root;\n           src_root \\<leftarrow> returnOk $ fst src_root;\n\n           dest_slot \\<leftarrow> lookup_slot_for_cnode_op dest_root dest_index (unat dest_depth);\n           src_slot \\<leftarrow> lookup_slot_for_cnode_op src_root src_index (unat src_depth);\n           pivot_slot \\<leftarrow> lookup_slot_for_cnode_op pivot_root pivot_index (unat pivot_depth);\n\n           whenE (pivot_slot = src_slot \\<or> pivot_slot = dest_slot) throw;\n\n           unlessE (src_slot = dest_slot) $ ensure_empty dest_slot;\n\n           src_cap \\<leftarrow> liftE $ get_cap src_slot;\n           whenE (src_cap = NullCap) throw;\n\n           pivot_cap \\<leftarrow> liftE $ get_cap pivot_slot;\n           whenE (pivot_cap = NullCap) throw;\n\n           \\<comment> \\<open>Munge caps.\\<close>\n           new_src \\<leftarrow> liftE $ update_cap_data True src_badge src_cap;\n           new_pivot \\<leftarrow> liftE $ update_cap_data True pivot_badge pivot_cap;\n\n           whenE (new_src = NullCap) throw;\n           whenE (new_pivot = NullCap) throw;\n\n           returnOk $ RotateCall new_src new_pivot src_slot pivot_slot dest_slot\n         odE\n   \"\n\ndefinition\n  invoke_cnode :: \"cdl_cnode_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"invoke_cnode params \\<equiv> case params of\n    \\<comment> \\<open>Insert a new cap.\\<close>\n      InsertCall cap src_slot dest_slot \\<Rightarrow>\n        liftE $\n          insert_cap_sibling cap src_slot dest_slot\n          \\<sqinter>\n          insert_cap_child cap src_slot dest_slot\n\n    \\<comment> \\<open>Move a cap, possibly modifying it in the process.\\<close>\n    | MoveCall cap src_slot dest_slot \\<Rightarrow>\n        liftE $ move_cap cap src_slot dest_slot\n\n    \\<comment> \\<open>Revoke a cap.\\<close>\n    | RevokeCall src_slot \\<Rightarrow>\n        revoke_cap src_slot\n\n    \\<comment> \\<open>Delete a cap.\\<close>\n    | DeleteCall src_slot \\<Rightarrow>\n        delete_cap src_slot\n\n    \\<comment> \\<open>Atomically move two capabilities.\\<close>\n    | RotateCall cap1 cap2 slot1 slot2 slot3 \\<Rightarrow>\n        liftE $ if slot1 = slot3 then\n          swap_cap cap1 slot1 cap2 slot2\n        else\n          do\n            move_cap cap2 slot2 slot3;\n            move_cap cap1 slot1 slot2\n          od\n\n    \\<comment> \\<open>Save a reply cap from the caller's TCB into this CNode.\\<close>\n    | SaveCall dest_slot \\<Rightarrow>\n        liftE $ do\n          current \\<leftarrow> gets_the cdl_current_thread;\n          replycap \\<leftarrow> get_cap (current, tcb_caller_slot);\n          when (replycap \\<noteq> NullCap)\n            $ move_cap replycap (current, tcb_caller_slot) dest_slot\n        od\n\n    \\<comment> \\<open>Reset an object into its original state.\\<close>\n    | CancelBadgedSendsCall (EndpointCap ep b _) \\<Rightarrow> liftE $ when (b \\<noteq> 0) $ cancel_badged_sends ep b\n    | CancelBadgedSendsCall _ \\<Rightarrow> fail\n  \"\n\nend", "property": "CNode Operations: Perform various operations on capabilities within CNodes, including copying, moving, revoking, deleting, and rotating capabilities. These operations ensure the integrity and management of capabilities, allowing for the modification of rights and data, and the atomic movement of capabilities between slots.", "title": "./spec/capDL/CNode_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(*\n * Operations on page table objects and frames.\n *)\n\ntheory PageTable_D\nimports Invocations_D CSpace_D\nbegin", "property": "Page Table and Frame Operations: Manage and manipulate page table objects and frames, ensuring proper memory allocation, deallocation, and configuration within the system.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  free_pd_slots :: \"cdl_object \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\"\nwhere\n  \"free_pd_slots pd pd_id state \\<equiv> {(pd_id, y). (object_slots pd) y = Some NullCap}\"", "property": "Free PD Slots: Identify and return the set of free slots in the given page directory, where each slot contains a NullCap.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Return the set of free PD slots in the given PD. "}
{"spec": "definition\n  all_pd_pt_slots :: \"cdl_object \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\"\nwhere\n  \"all_pd_pt_slots pd pd_id state \\<equiv> {(pd_id, y). y \\<in> dom (object_slots pd)}\n     \\<union> {(x, y). \\<exists> a b c. (object_slots pd) a = Some (PageTableCap x b c) \\<and> x \\<in> dom (cdl_objects state)}\"\n\ndefinition\n  \"cdl_get_pt_mapped_addr cap \\<equiv>\n    case cap of PageTableCap pid ctype maddr \\<Rightarrow>  maddr\n    | _ \\<Rightarrow> None\"", "property": "Retrieve All PD/PT Slots: Collect all the slots in the given page directory (PD) and its associated page tables (PTs). The set includes both the slots within the PD and the slots of the PTs referenced by the PD, ensuring a comprehensive mapping of the memory structure.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Return the set of all PD/PT slots in the given PD. "}
{"spec": "definition\n  decode_page_table_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_page_table_intent \\<Rightarrow> cdl_page_table_invocation except_monad\"\nwhere\n  \"decode_page_table_invocation target target_ref caps intent \\<equiv> case intent of\n    \\<comment> \\<open>\n      Map the given PageTable into the given PageDirectory at the given\n      virtual address.\n\n      The concrete implementation only allows a PageTable to be mapped\n      once at any point in time, but we don't enforce that here.\n     \\<close>\n    PageTableMapIntent vaddr attr \\<Rightarrow>\n      doE\n        case cdl_get_pt_mapped_addr target of Some a \\<Rightarrow> throw\n        | None \\<Rightarrow> returnOk ();\n        \\<comment> \\<open>Ensure that a PD was passed in.\\<close>\n        pd \\<leftarrow> throw_on_none $ get_index caps 0;\n        (pd_object_id, asid) \\<leftarrow>\n          case (fst pd) of\n              PageDirectoryCap x _ (Some asid) \\<Rightarrow> returnOk (x, asid)\n            | _ \\<Rightarrow> throw;\n\n        target_slot \\<leftarrow> returnOk $ cdl_lookup_pd_slot pd_object_id vaddr;\n\n        returnOk $ PageTableMap (PageTableCap (cap_object target) Real (Some (asid,vaddr && ~~ mask 20)))\n          (PageTableCap (cap_object target) Fake None) target_ref target_slot\n      odE \\<sqinter> throw\n    \\<comment> \\<open>Unmap this PageTable.\\<close>\n    | PageTableUnmapIntent \\<Rightarrow> (\n        case target of PageTableCap pid ctype maddr \\<Rightarrow>\n        (returnOk $ PageTableUnmap maddr pid target_ref)\n        | _ \\<Rightarrow> throw\n      ) \\<sqinter> throw\n  \"", "property": "Page Table Invocation Decoding: Decode a page table intent into a specific invocation, supporting mapping and unmapping operations. For mapping, it ensures the page table is not already mapped, retrieves the page directory and ASID, and sets up the necessary mappings. For unmapping, it validates the target as a page table and performs the unmap operation.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Decode a page table intent into an invocation. "}
{"spec": "definition\n  decode_page_directory_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_page_directory_intent \\<Rightarrow> cdl_page_directory_invocation except_monad\"\nwhere\n  \"decode_page_directory_invocation target target_ref caps intent \\<equiv>\n      (returnOk $ PageDirectoryNothing) \\<sqinter>\n      (returnOk $ PageDirectoryFlush Unify)  \\<sqinter>  (returnOk $ PageDirectoryFlush Clean)  \\<sqinter>\n      (returnOk $ PageDirectoryFlush CleanInvalidate )  \\<sqinter> (returnOk $ PageDirectoryFlush Invalidate)\n      \\<sqinter> throw \"", "property": "Decode Page Directory Intent: Interpret a page directory intent into a corresponding page directory invocation, which can include various flush operations (Unify, Clean, CleanInvalidate, Invalidate) or no operation.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Decode a page table intent into an invocation. "}
{"spec": "definition\n  decode_page_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_page_intent \\<Rightarrow> cdl_page_invocation except_monad\"\nwhere\n  \"decode_page_invocation target target_ref caps intent \\<equiv> case intent of\n      \\<comment> \\<open>\n        Map the given Page into the given PageDirectory or PageTable at\n        the given virtual address.\n\n        The concrete implementation only allows a Page to be mapped\n        once at any point in time, but we don't enforce that here.\n       \\<close>\n      PageMapIntent vaddr rights attr \\<Rightarrow>\n        doE\n          \\<comment> \\<open>Ensure that a PD was passed in.\\<close>\n          pd \\<leftarrow> throw_on_none $ get_index caps 0;\n          (pd_object_id, asid) \\<leftarrow>\n            case (fst pd) of\n                PageDirectoryCap x _ (Some asid) \\<Rightarrow> returnOk (x, asid)\n              | _ \\<Rightarrow> throw;\n\n          \\<comment> \\<open>Collect mapping from target cap.\\<close>\n          (frame,sz,dev) \\<leftarrow> returnOk $ (case target of FrameCap dev p R sz m mp \\<Rightarrow> (p,sz,dev));\n\n          target_slots \\<leftarrow> cdl_page_mapping_entries vaddr sz pd_object_id;\n\n          \\<comment> \\<open>Calculate rights.\\<close>\n          new_rights \\<leftarrow> returnOk $ validate_vm_rights $ cap_rights target \\<inter> rights;\n\n          \\<comment> \\<open>Return the map intent.\\<close>\n          returnOk $ PageMap (FrameCap dev frame (cap_rights target) sz Real (Some (asid,vaddr)))\n            (FrameCap False frame new_rights sz Fake None) target_ref target_slots\n        odE \\<sqinter> throw\n\n    \\<comment> \\<open>Unmap this PageTable.\\<close>\n    | PageUnmapIntent \\<Rightarrow> doE\n        (frame, asid, sz) \\<leftarrow> (case target of\n           FrameCap _ p R sz m mp \\<Rightarrow> returnOk (p, mp , sz)\n        | _ \\<Rightarrow> throw);\n      (returnOk $ PageUnmap asid frame target_ref sz) \\<sqinter> throw\n      odE\n\n    \\<comment> \\<open>Flush the caches associated with this page.\\<close>\n    | PageFlushCachesIntent \\<Rightarrow>\n       (returnOk $ PageFlushCaches Unify)  \\<sqinter>  (returnOk $ PageFlushCaches Clean)  \\<sqinter>\n      (returnOk $ PageFlushCaches CleanInvalidate )  \\<sqinter> (returnOk $ PageFlushCaches Invalidate)\n      \\<sqinter> throw\n\n    | PageGetAddressIntent \\<Rightarrow> returnOk PageGetAddress\n\n  \"", "property": "Page Invocation Decoding: Decode a page intent into a specific page invocation, supporting actions such as mapping a page into a page directory or table, unmapping a page, flushing caches, and retrieving the page address. Each action ensures that the appropriate capabilities and parameters are validated and used to construct the corresponding page invocation.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Decode a page intent into an invocation. "}
{"spec": "definition\n  invoke_page_directory :: \"cdl_page_directory_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_page_directory params \\<equiv> case params of\n      PageDirectoryFlush flush  => return ()\n    | PageDirectoryNothing => return ()\n  \"\n\ndefinition \"option_exec f \\<equiv> \\<lambda>x. case x of Some a \\<Rightarrow> f a | None \\<Rightarrow> return ()\"", "property": "Page Directory Invocation: Handles page directory operations, including flushing the page directory or performing no action. This ensures that the page directory can be updated or left unchanged as required.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Invoke a page table. "}
{"spec": "definition\n  invoke_page_table :: \"cdl_page_table_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_page_table params \\<equiv> case params of\n      PageTableMap real_pt_cap pt_cap pt_cap_ref pd_target_slot \\<Rightarrow>\n        do set_cap pt_cap_ref real_pt_cap;\n           \\<comment> \\<open>\n             We install the Page Table into the Page Directory.  The\n             concrete kernel uses hardware-defined PDEs (Page Directory\n             Entries). Our abstract spec just uses caps.\n            \\<close>\n           insert_cap_orphan pt_cap pd_target_slot\n        od\n    | PageTableUnmap mapped_addr pt_id pt_cap_ref \\<Rightarrow> do\n        (case mapped_addr of Some maddr \\<Rightarrow> do\n                 unmap_page_table maddr pt_id;\n                 clear_object_caps pt_id \\<sqinter> return ()\n               od\n          | _ \\<Rightarrow> return ());\n        cap \\<leftarrow> get_cap pt_cap_ref;\n        set_cap pt_cap_ref (reset_mem_mapping cap)\n        od\n\n  \"", "property": "Page Table Invocation: Manages the mapping and unmapping of page tables. It sets or updates the capability for a page table, installs the page table into a page directory, and unmaps the page table from a specified address, clearing its capabilities if necessary.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Invoke a page table. "}
{"spec": "definition\n  invoke_page :: \"cdl_page_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_page params \\<equiv> case params of\n      PageMap frame_cap pseudo_frame_cap frame_cap_ref target_slots \\<Rightarrow>\n          \\<comment> \\<open>Clear out the target slots.\\<close>\n        do\n          set_cap frame_cap_ref frame_cap;\n          mapM_x (swp set_cap pseudo_frame_cap) target_slots\n        od\n\n    | PageUnmap mapped_addr frame_id frame_cap_ref pgsz \\<Rightarrow> do\n        (case mapped_addr of\n          Some maddr \\<Rightarrow> unmap_page maddr frame_id pgsz\n        | _ \\<Rightarrow> return ());\n        cap \\<leftarrow> get_cap frame_cap_ref;\n        set_cap frame_cap_ref (reset_mem_mapping cap)\n      od\n\n    | PageFlushCaches flush \\<Rightarrow> return ()\n\n    | PageGetAddress \\<Rightarrow> return ()\n\n  \"\n\nend", "property": "Page Invocation: Manages page operations including mapping, unmapping, flushing caches, and retrieving the address of a page. It ensures that frame capabilities are correctly set or reset, target slots are updated, and cache operations are performed as specified.", "title": "./spec/capDL/PageTable_D.thy", "chapter": "", "section": "", "comment": " Invoke a page. "}
{"spec": "(*\n * System calls\n *)\n\ntheory Syscall_D\nimports\n  Schedule_D\n  Decode_D\n  \"ExecSpec.Event_H\"\nbegin", "property": "System Call Interface: Defines the interface for system calls, enabling user-level applications to request services from the kernel. This ensures that the kernel can securely and efficiently handle requests, providing necessary functionalities while maintaining system integrity and stability.", "title": "./spec/capDL/Syscall_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\nsyscall :: \"\n  ('a fault_monad) \\<Rightarrow> (unit k_monad) \\<Rightarrow>\n  ('a \\<Rightarrow> 'b except_monad) \\<Rightarrow> (unit k_monad) \\<Rightarrow>\n  ('b \\<Rightarrow> unit preempt_monad) \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"syscall\n      cap_decoder_fn decode_error_handler_fn\n      arg_decode_fn arg_error_handler_fn\n      perform_syscall_fn \\<equiv>\n    cap_decoder_fn\n    <handle>\n      (\\<lambda> _. liftE $ decode_error_handler_fn)\n    <else>\n      (\\<lambda> a. ((arg_decode_fn a)\n        <handle>\n          (\\<lambda> _. liftE $ arg_error_handler_fn)\n        <else>\n          perform_syscall_fn))\n  \"\n\nfun\n  perform_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> cdl_invocation \\<Rightarrow> unit preempt_monad\"\nwhere\n    \"perform_invocation is_call can_block (InvokeUntyped untyped_params) = (invoke_untyped untyped_params)\"\n  | \"perform_invocation is_call can_block (InvokeEndpoint endpoint_params) = liftE (invoke_endpoint is_call can_block endpoint_params)\"\n  | \"perform_invocation is_call can_block (InvokeNotification ntfn_params) = liftE (invoke_notification ntfn_params)\"\n  | \"perform_invocation is_call can_block (InvokeReply reply_params) = liftE (invoke_reply reply_params)\"\n  | \"perform_invocation is_call can_block (InvokeTcb tcb_params) = (invoke_tcb tcb_params)\"\n  | \"perform_invocation is_call can_block (InvokeDomain domain_params) = (invoke_domain domain_params)\"\n  | \"perform_invocation is_call can_block (InvokeCNode cnode_params) = invoke_cnode cnode_params\"\n  | \"perform_invocation is_call can_block (InvokeIrqControl irq_params) = liftE (invoke_irq_control irq_params)\"\n  | \"perform_invocation is_call can_block (InvokeIrqHandler handler_params) = liftE (invoke_irq_handler handler_params)\"\n  | \"perform_invocation is_call can_block (InvokePageTable page_table_params) = liftE (invoke_page_table page_table_params)\"\n  | \"perform_invocation is_call can_block (InvokePage page_params) = liftE (invoke_page page_params)\"\n  | \"perform_invocation is_call can_block (InvokeAsidControl asid_control_params) = liftE (invoke_asid_control asid_control_params)\"\n  | \"perform_invocation is_call can_block (InvokeAsidPool asid_pool_params) = liftE (invoke_asid_pool asid_pool_params)\"\n  | \"perform_invocation is_call can_block (InvokePageDirectory page_dir_params) = liftE (invoke_page_directory page_dir_params) \"\n\ndefinition ep_related_cap :: \"cdl_cap \\<Rightarrow> bool\"\nwhere \"ep_related_cap cap \\<equiv> case cap of\n cdl_cap.EndpointCap o_id badge rights \\<Rightarrow> True\n| cdl_cap.NotificationCap o_id badge rights \\<Rightarrow> True\n| cdl_cap.ReplyCap o_id rights \\<Rightarrow> True\n| _ \\<Rightarrow> False\"\n\ndefinition \"has_restart_cap \\<equiv> \\<lambda>tcb_id. do\n  t \\<leftarrow> get_thread tcb_id;\n  return ((cdl_tcb_caps t) tcb_pending_op_slot = Some cdl_cap.RestartCap)\n  od\"\n\ndefinition\n  handle_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"handle_invocation is_call can_block \\<equiv>\n    doE\n      thread_ptr \\<leftarrow> liftE $ gets_the cdl_current_thread;\n      thread \\<leftarrow> liftE $ get_thread thread_ptr;\n      full_intent \\<leftarrow> returnOk $ cdl_tcb_intent thread;\n\n      intent \\<leftarrow> returnOk $ cdl_intent_op full_intent;\n      invoked_cptr \\<leftarrow> returnOk $ cdl_intent_cap full_intent;\n      extra_cap_cptrs \\<leftarrow> returnOk $ cdl_intent_extras full_intent;\n\n      syscall\n        \\<comment> \\<open>Lookup all caps presented.\\<close>\n        (doE\n          (cap, cap_ref) \\<leftarrow> lookup_cap_and_slot thread_ptr invoked_cptr;\n          extra_caps \\<leftarrow> lookup_extra_caps thread_ptr extra_cap_cptrs;\n          returnOk (cap, cap_ref, extra_caps)\n        odE)\n        \\<comment> \\<open>If that failed, send off a fault IPC (if we did a blocking operation).\\<close>\n        (when can_block $ handle_fault)\n\n        \\<comment> \\<open>Decode the user's intent.\\<close>\n        (\\<lambda> (cap, cap_ref, extra_caps).\n          case intent of\n              None \\<Rightarrow> (if ep_related_cap cap then\n                decode_invocation cap cap_ref extra_caps undefined\n                else throw)\n            | Some intent' \\<Rightarrow>\n                decode_invocation cap cap_ref extra_caps intent')\n\n        \\<comment> \\<open>If that stuffed up, we do nothing more than corrupt the frames.\\<close>\n        (do corrupt_ipc_buffer thread_ptr True;\n            when is_call (mark_tcb_intent_error thread_ptr True)\n         od)\n\n        \\<comment> \\<open>Invoke the system call.\\<close>\n        (\\<lambda> inv. doE\n            liftE $ set_cap (thread_ptr,tcb_pending_op_slot) RestartCap;\n            perform_invocation is_call can_block inv;\n            restart \\<leftarrow> liftE $ has_restart_cap thread_ptr;\n            whenE restart $ liftE (do\n                       corrupt_ipc_buffer thread_ptr True;\n                       when (is_call) (mark_tcb_intent_error thread_ptr False);\n                       set_cap (thread_ptr,tcb_pending_op_slot) RunningCap\n            od)\n            odE)\n  odE\n  \"\n\ndefinition\n  handle_recv :: \"unit k_monad\"\nwhere\n  \"handle_recv \\<equiv>\n    do\n      \\<comment> \\<open>Get the current thread.\\<close>\n      tcb_id \\<leftarrow> gets_the cdl_current_thread;\n      tcb \\<leftarrow> get_thread tcb_id;\n      \\<comment> \\<open>Get the endpoint it is trying to receive from.\\<close>\n      (doE\n        ep_cptr \\<leftarrow> returnOk $ cdl_intent_cap (cdl_tcb_intent tcb);\n        ep_cap \\<leftarrow> lookup_cap tcb_id ep_cptr;\n        (case ep_cap of\n          EndpointCap o_id badge rights \\<Rightarrow>\n            if Read \\<in> rights then\n              (liftE $ do\n                   delete_cap_simple (tcb_id, tcb_caller_slot);\n                   receive_ipc tcb_id (cap_object ep_cap) (Grant \\<in> rights)\n                od) \\<sqinter> throw\n            else\n              throw\n        | NotificationCap o_id badge rights \\<Rightarrow>\n            if Read \\<in> rights then\n              (liftE $ recv_signal tcb_id ep_cap) \\<sqinter> throw\n            else\n              throw\n        | _ \\<Rightarrow>\n            throw)\n      odE)\n      <catch>\n        (\\<lambda> _. handle_fault)\n    od\n  \"\n\ndefinition\n  handle_reply :: \"unit k_monad\"\nwhere\n  \"handle_reply \\<equiv>\n    do\n      tcb_id \\<leftarrow> gets_the cdl_current_thread;\n      caller_cap \\<leftarrow> get_cap (tcb_id, tcb_caller_slot);\n\n      case caller_cap of\n          ReplyCap target rights \\<Rightarrow> do_reply_transfer tcb_id target (tcb_id, tcb_caller_slot) (Grant \\<in> rights)\n        | NullCap \\<Rightarrow> return ()\n        | _ \\<Rightarrow> fail\n    od\n  \"\n\ndefinition handle_hypervisor_fault :: \"unit k_monad\"\nwhere \"handle_hypervisor_fault \\<equiv> return ()\"\n\ndefinition\n  handle_syscall :: \"syscall \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"handle_syscall sys \\<equiv>\n    case sys of\n      SysSend  \\<Rightarrow> handle_invocation False True\n    | SysNBSend \\<Rightarrow> handle_invocation False False\n    | SysCall \\<Rightarrow> handle_invocation True True\n    | SysRecv \\<Rightarrow> liftE $ handle_recv\n    | SysYield \\<Rightarrow> returnOk ()\n    | SysReply \\<Rightarrow> liftE $ handle_reply\n    | SysReplyRecv \\<Rightarrow> liftE $ do\n        handle_reply;\n        handle_recv\n      od\n    | SysNBRecv \\<Rightarrow> liftE $ handle_recv\"\n\ndefinition\n  handle_event :: \"event \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"handle_event ev \\<equiv> case ev of\n      SyscallEvent sys \\<Rightarrow> handle_syscall sys\n    | UnknownSyscall n \\<Rightarrow> liftE $ handle_fault\n    | UserLevelFault a b \\<Rightarrow> liftE $ handle_fault\n    | VMFaultEvent c \\<Rightarrow> liftE $ handle_fault\n    | Interrupt \\<Rightarrow> liftE $ handle_pending_interrupts\n    | HypervisorEvent w \\<Rightarrow> liftE $ handle_hypervisor_fault\n    \"\n\ndefinition\n  call_kernel :: \"event \\<Rightarrow> unit k_monad\"\nwhere\n  \"call_kernel ev \\<equiv>\n    do\n      \\<comment> \\<open>Deal with the event.\\<close>\n      handle_event ev\n        <handle> (\\<lambda> _. liftE handle_pending_interrupts);\n      schedule;\n      t \\<leftarrow> gets cdl_current_thread;\n      case t of Some thread \\<Rightarrow> do\n       restart \\<leftarrow> has_restart_cap thread;\n       when restart $ set_cap (thread, tcb_pending_op_slot) RunningCap\n      od | None \\<Rightarrow> return ()\n    od\"\n\nend", "property": "System Call Handling: System calls are processed in three stages—capability validation, argument validation, and execution. The system call function takes five user-provided functions for these stages, including error handlers, and executes the system call, handling any potential preemption by interrupts. \n\n- **Capability Validation**: Ensures that all capabilities passed into the system call are valid.\n- **Argument Validation**: Ensures that the requested operation is valid and permitted.\n- **Execution**: Carries out the actual operation, with the ability to handle preemption by interrupts.", "title": "./spec/capDL/Syscall_D.thy", "chapter": "", "section": "", "comment": "\n * Perform system calls.\n *\n * Each system call is broken into three stages:\n *\n *   (1) Cap validation, where we ensure that all caps passed\n *       into the system call are valid;\n *\n *   (2) Argument validation, where we ensure that the requested\n *       operation is valid and permitted; and\n *\n *   (3) Syscall execution, where we carry out the actual\n *       operation.\n *\n * For this function, the user passes us in 5 functions:\n *\n *   (1, 2) A cap validation function, and an error handler;\n *   (3, 4) A argument validation function, and an error handler;\n *   (5)    A syscall execution function.\n *\n * This function returns an item of type \"'c\", and may also\n * return an exception if operation (3) above was preempted\n * by an interrupt.\n "}
{"spec": "(*\n * Unmapping pages and page tables and what is needed for it:\n * short cut delete, revoke and finale of caps, ipc cancelling.\n *)\n\ntheory PageTableUnmap_D\nimports\n  Invocations_D\n  KHeap_D\nbegin\n\n\\<comment> \\<open>Return all slots in the system containing a cap with the given property.\\<close>\ndefinition\n  slots_with :: \"(cdl_cap \\<Rightarrow> bool) \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\"\nwhere\n  \"slots_with P s \\<equiv> {(obj, slot). \\<exists>x c. cdl_objects s obj = Some x \\<and>\n                                        has_slots x \\<and>\n                                        object_slots x slot = Some c \\<and> P c}\"\n\n\n\\<comment> \\<open>Remove a pending operation from the given TCB.\\<close>\ndefinition\n  remove_pending_operation :: \"cdl_tcb \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_tcb\"\nwhere\n  \"remove_pending_operation t cap \\<equiv> t\\<lparr>cdl_tcb_caps := (cdl_tcb_caps t)(tcb_pending_op_slot \\<mapsto> cap)\\<rparr>\"\n\n\n\\<comment> \\<open>Is the given thread pending on the given endpoint?\\<close>\ndefinition\n  is_thread_blocked_on_endpoint :: \"cdl_tcb \\<Rightarrow> cdl_object_id \\<Rightarrow> bool\"\nwhere\n  \"is_thread_blocked_on_endpoint t ep \\<equiv>\n    case (cdl_tcb_caps t tcb_pending_op_slot) of\n        Some (PendingSyncSendCap p _ _ _ _ _) \\<Rightarrow> p = ep\n      | Some (PendingSyncRecvCap p is_reply _) \\<Rightarrow> p = ep \\<and> \\<not> is_reply\n      | Some (PendingNtfnRecvCap p) \\<Rightarrow> p = ep\n      | _ \\<Rightarrow> False\"\n\n\n\\<comment> \\<open>Cancel all pending IPCs currently blocked on this endpoint.\\<close>\ndefinition\n  cancel_all_ipc :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"cancel_all_ipc ep \\<equiv>\n    modify (\\<lambda>s. s\\<lparr>cdl_objects :=  map_option\n        (\\<lambda>obj. case obj of\n            Tcb t \\<Rightarrow>\n              if (is_thread_blocked_on_endpoint t ep) then\n                Tcb (remove_pending_operation t RestartCap)\n              else\n                Tcb t\n           | _ \\<Rightarrow> obj)\n          \\<circ> (cdl_objects s)\\<rparr>)\"\n\n\\<comment> \\<open>Is the given thread bound to the given ntfn?\\<close>\ndefinition\n  is_thread_bound_to_ntfn :: \"cdl_tcb \\<Rightarrow> cdl_object_id \\<Rightarrow> bool\"\nwhere\n  \"is_thread_bound_to_ntfn t ntfn \\<equiv>\n    case (cdl_tcb_caps t tcb_boundntfn_slot) of\n        Some (BoundNotificationCap a) \\<Rightarrow> a = ntfn\n      | _ \\<Rightarrow> False\"\n\n\\<comment> \\<open>find all tcbs that are bound to a given ntfn\\<close>\ndefinition\n  get_bound_notification_threads :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"get_bound_notification_threads ntfn_id state \\<equiv>\n     {x. \\<exists>a. (cdl_objects state) x = Some (Tcb a) \\<and>\n         (((cdl_tcb_caps a) tcb_boundntfn_slot) = Some (BoundNotificationCap ntfn_id))}\"\n\ndefinition\n  modify_bound_ntfn :: \"cdl_tcb \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_tcb\"\nwhere\n  \"modify_bound_ntfn t cap \\<equiv> t \\<lparr> cdl_tcb_caps := (cdl_tcb_caps t)(tcb_boundntfn_slot \\<mapsto> cap)\\<rparr>\"\n\n\nabbreviation\n  do_unbind_notification :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"do_unbind_notification tcb \\<equiv> set_cap (tcb, tcb_boundntfn_slot) NullCap\"\n\ndefinition\n  unbind_notification :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"unbind_notification tcb \\<equiv> do\n     cap \\<leftarrow> KHeap_D.get_cap (tcb, tcb_boundntfn_slot);\n     (case cap of\n      BoundNotificationCap _ \\<Rightarrow> do_unbind_notification tcb\n    | _ \\<Rightarrow> return ())\n   od\"\n\ndefinition\n  unbind_maybe_notification :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"unbind_maybe_notification ntfn_id \\<equiv> do\n     bound_tcbs \\<leftarrow> gets $ get_bound_notification_threads ntfn_id;\n     t \\<leftarrow> option_select bound_tcbs;\n     (case t of\n       None \\<Rightarrow> return ()\n     | Some tcb \\<Rightarrow> do_unbind_notification tcb)\n  od\"\n\ndefinition\n  can_fast_finalise :: \"cdl_cap \\<Rightarrow> bool\" where\n \"can_fast_finalise cap \\<equiv> case cap of ReplyCap r R \\<Rightarrow> True\n                       | MasterReplyCap r \\<Rightarrow> True\n                       | EndpointCap r b R \\<Rightarrow> True\n                       | NotificationCap r b R \\<Rightarrow> True\n                       | NullCap \\<Rightarrow> True\n                       | RestartCap \\<Rightarrow> True\n                       | RunningCap \\<Rightarrow> True\n                       | PendingSyncSendCap r _ _ _ _ _ \\<Rightarrow> True\n                       | PendingSyncRecvCap r _ _ \\<Rightarrow> True\n                       | PendingNtfnRecvCap r \\<Rightarrow> True\n                       | DomainCap \\<Rightarrow> True\n                       | PageDirectoryCap _ x _ \\<Rightarrow> \\<not>(x = Real)\n                       | PageTableCap _ x _ \\<Rightarrow> \\<not>(x = Real)\n                       | FrameCap _ _ _ _ x _ \\<Rightarrow> \\<not>(x = Real)\n                       | _ \\<Rightarrow> False\"\n\ncontext\nnotes [[function_internals =true]]\nbegin\n\nfun\n  fast_finalise :: \"cdl_cap \\<Rightarrow> bool \\<Rightarrow> unit k_monad\"\nwhere\n  \"fast_finalise NullCap                  final = return ()\"\n| \"fast_finalise (RestartCap)             final = return ()\"\n| \"fast_finalise (RunningCap)             final = return ()\"\n| \"fast_finalise (ReplyCap r R)           final = return ()\"\n| \"fast_finalise (MasterReplyCap r)       final = return ()\"\n| \"fast_finalise (EndpointCap r b R)      final =\n      (when final $ cancel_all_ipc r)\"\n| \"fast_finalise (NotificationCap r b R) final =\n      (when final $ do\n            unbind_maybe_notification r;\n            cancel_all_ipc r\n          od)\"\n| \"fast_finalise (PendingSyncSendCap r _ _ _ _ _) final = return()\"\n| \"fast_finalise (PendingSyncRecvCap r _ _) final = return()\"\n| \"fast_finalise  (PendingNtfnRecvCap r) final = return()\"\n| \"fast_finalise DomainCap final = return ()\"\n| \"fast_finalise (PageDirectoryCap _ x _) _ = (if x = Real then fail else return())\"\n| \"fast_finalise (PageTableCap _ x _) _ = (if x = Real then fail else return())\"\n| \"fast_finalise (FrameCap _ _ _ _ x _) _ = (if x = Real then fail else return())\"\n| \"fast_finalise _ _ = fail\"\n\nend\n\n\\<comment> \\<open>These caps don't count when determining if an entity should be deleted or not\\<close>\ndefinition\n  cap_counts :: \"cdl_cap \\<Rightarrow> bool\" where\n \"cap_counts cap \\<equiv> (case cap of\n    cdl_cap.NullCap \\<Rightarrow> False\n  | UntypedCap _ _ _ \\<Rightarrow> False\n  | ReplyCap _ _ \\<Rightarrow> False\n  | MasterReplyCap _ \\<Rightarrow> False\n  | RestartCap \\<Rightarrow> False\n  | RunningCap \\<Rightarrow> False\n  | PendingSyncSendCap _ _ _ _ _ _ \\<Rightarrow> False\n  | PendingSyncRecvCap _ _ _ \\<Rightarrow> False\n  | PendingNtfnRecvCap _ \\<Rightarrow> False\n  | DomainCap \\<Rightarrow> False\n  | BoundNotificationCap _ \\<Rightarrow> False\n  | IrqControlCap  \\<Rightarrow> False\n  | AsidControlCap \\<Rightarrow> False\n  | IOSpaceMasterCap \\<Rightarrow> False\n  | FrameCap _ _ _ _ c _ \\<Rightarrow> c = Real\n  | PageTableCap _ c _ \\<Rightarrow> c = Real\n  | PageDirectoryCap _ c _ \\<Rightarrow> c = Real\n  | _ \\<Rightarrow> True)\"\n\ndefinition\n  cdl_cap_irq :: \"cdl_cap \\<Rightarrow> cdl_irq option\" where\n \"cdl_cap_irq cap \\<equiv> (case cap of IrqHandlerCap irq \\<Rightarrow> Some irq | _ \\<Rightarrow> None)\"\n\n\\<comment> \\<open>Some caps don't count when determining if an entity should be deleted or not\\<close>\ndefinition\n  is_final_cap' :: \"cdl_cap \\<Rightarrow> cdl_state \\<Rightarrow> bool\" where\n \"is_final_cap' cap s \\<equiv> ((cap_counts cap) \\<and>\n  (\\<exists>cref. {cref. \\<exists>cap'. opt_cap cref s = Some cap'\n                       \\<and> (cap_object cap = cap_object cap'\n                             \\<and> cdl_cap_irq cap = cdl_cap_irq cap')\n                       \\<and> cap_counts cap'}\n         = {cref}))\"\n\n\ndefinition\n  is_final_cap :: \"cdl_cap \\<Rightarrow> bool k_monad\" where\n  \"is_final_cap cap \\<equiv> gets (is_final_cap' cap)\"\n\n\ndefinition\n  always_empty_slot :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n \"always_empty_slot slot = do\n    remove_parent slot;\n    set_cap slot NullCap\n  od\"\n\ndefinition\n  empty_slot :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n \"empty_slot slot = do\n  cap \\<leftarrow> get_cap slot;\n  if cap = NullCap then\n    return ()\n  else do\n    remove_parent slot;\n    set_cap slot NullCap\n    od\n  od\"", "property": "Page and Cap Management: Enables the management of page tables, including unmapping pages, revoking and finalizing capabilities, and canceling IPC operations. It supports operations to unbind notifications, check if a thread is blocked on an endpoint, and determine if a capability can be fast-finalized. Additionally, it provides mechanisms to clear and manage capability slots, ensuring that entities are correctly deleted or retained based on their cap counts and finality.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  delete_cap_simple :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"delete_cap_simple cap_ref \\<equiv> do\n    cap \\<leftarrow> get_cap cap_ref;\n    unless (cap = NullCap) $ do\n      final \\<leftarrow> is_final_cap cap;\n      fast_finalise cap final;\n      always_empty_slot cap_ref\n    od\n  od\"", "property": "Non-Preemptable Cap Deletion: Ensures the deletion of a capability without causing preemption, suitable for capabilities that exist at the CapDL level but not at lower levels. The operation checks if the capability is not null, determines if it is a final capability, and then finalizes and empties the slot.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": "\n Non-premptable delete.\n\n Should only be used on deletes guaranteed not to preempt\n (and you are happy to prove this). In particular, it is\n useful for deleting caps that exist at the CapDL level\n but not at lower levels.\n"}
{"spec": "function\n  revoke_cap_simple :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"revoke_cap_simple victim s = (do\n    descendants \\<leftarrow> gets $ KHeap_D.descendants_of victim;\n    assert (finite descendants);\n    non_null \\<leftarrow> gets (\\<lambda>s. {slot. opt_cap slot s \\<noteq> Some NullCap \\<and> opt_cap slot s \\<noteq> None});\n    non_null_descendants \\<leftarrow> return (descendants \\<inter> non_null);\n    if (non_null_descendants \\<noteq> {}) then do\n      a \\<leftarrow> select non_null_descendants;\n      delete_cap_simple a;\n      revoke_cap_simple victim\n    od else return ()\n  od) s\"\n  by auto\n\n\ndefinition cdl_get_pde :: \"(word32 \\<times> nat)\\<Rightarrow> cdl_cap k_monad\"\nwhere \"cdl_get_pde ptr \\<equiv>\n  KHeap_D.get_cap ptr\"\n\ndefinition cdl_lookup_pd_slot :: \"word32 \\<Rightarrow> word32 \\<Rightarrow> word32 \\<times> nat \"\n  where \"cdl_lookup_pd_slot pd vptr \\<equiv> (pd, unat (vptr >> 20))\"\n\ndefinition cdl_lookup_pt_slot :: \"word32 \\<Rightarrow> word32 \\<Rightarrow> (word32 \\<times> nat) except_monad\"\n  where \"cdl_lookup_pt_slot pd vptr \\<equiv>\n    doE pd_slot \\<leftarrow> returnOk (cdl_lookup_pd_slot pd vptr);\n        pdcap \\<leftarrow> liftE $ cdl_get_pde pd_slot;\n        (case pdcap of cdl_cap.PageTableCap ref Fake None\n         \\<Rightarrow> ( doE pt \\<leftarrow> returnOk ref;\n              pt_index \\<leftarrow> returnOk ((vptr >> 12) && 0xFF);\n              returnOk (pt,unat pt_index)\n         odE)\n        | _ \\<Rightarrow> Monads_D.throw)\n    odE\"\n\ndefinition\n  cdl_find_pd_for_asid :: \"cdl_mapped_addr \\<Rightarrow> cdl_object_id except_monad\"\nwhere\n  \"cdl_find_pd_for_asid maddr \\<equiv> doE\n     asid_table \\<leftarrow> liftE $ gets cdl_asid_table;\n     asid_pool \\<leftarrow> returnOk $ asid_table (fst (fst maddr));\n     pd_cap_ref \\<leftarrow> (case asid_pool of Some (AsidPoolCap ptr _) \\<Rightarrow> returnOk (ptr, (snd \\<circ> fst) maddr)\n              | _ \\<Rightarrow> throw );\n     pd_cap \\<leftarrow> liftE $ get_cap pd_cap_ref;\n     case pd_cap of (PageDirectoryCap pd _ _) \\<Rightarrow> returnOk pd\n     | _ \\<Rightarrow> throw\n   odE \"\n\ndefinition cdl_page_mapping_entries :: \"32 word \\<Rightarrow> nat \\<Rightarrow> 32 word\n                                       \\<Rightarrow> ((32 word \\<times> nat) list) except_monad\"\n  where \"cdl_page_mapping_entries vptr pgsz pd \\<equiv>\n  if pgsz = 12 then doE\n    p \\<leftarrow> cdl_lookup_pt_slot pd vptr;\n         returnOk [p]\n    odE\n\n  else if pgsz = 16 then doE\n    p \\<leftarrow> cdl_lookup_pt_slot pd vptr;\n         returnOk [p]\n    odE\n  else if pgsz = 20 then doE\n    p \\<leftarrow> returnOk $ (cdl_lookup_pd_slot pd vptr);\n         returnOk [p]\n    odE\n  else if pgsz = 24 then doE\n    p \\<leftarrow> returnOk $ (cdl_lookup_pd_slot pd vptr);\n         returnOk [p]\n    odE\n  else throw\"\n\ndefinition\n  cdl_page_table_mapped :: \"cdl_mapped_addr \\<Rightarrow> cdl_object_id \\<Rightarrow> (cdl_cap_ref option) k_monad\"\nwhere\n  \"cdl_page_table_mapped maddr pt_id \\<equiv> doE\n     pd \\<leftarrow> cdl_find_pd_for_asid maddr;\n     pd_slot \\<leftarrow> returnOk (cdl_lookup_pd_slot pd (snd maddr));\n     pdcap \\<leftarrow> liftE $ cdl_get_pde pd_slot;\n     (case pdcap of\n       cdl_cap.PageTableCap ref Fake None \\<Rightarrow>\n         (returnOk $ if ref = pt_id then Some pd_slot else None)\n     | _ \\<Rightarrow> returnOk None )\n   odE <catch> (K (return None))\"", "property": "Non-Preemptable Revocation: Ensures that a capability and its non-null descendants are revoked in a non-preemptable manner, suitable for bounded revokes. The process involves recursively deleting non-null descendant capabilities until all relevant capabilities are removed.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": "\n  Non-preemptable revoke.\n\n  Should only be used on bounded revokes.\n   * PageTableUnmap pt_cap_ref\n   * PageUnmap frame_cap_ref \\<Rightarrow>\n   * revoke_cap_simple (target_tcb, tcb_replycap_slot)\n"}
{"spec": "definition\n \"might_throw \\<equiv> (returnOk ()) \\<sqinter> throw\"\n\ndefinition\n  unmap_page :: \"cdl_mapped_addr  \\<Rightarrow> cdl_object_id \\<Rightarrow> nat \\<Rightarrow> unit k_monad\"\nwhere\n  \"unmap_page maddr frame_id pgsz \\<equiv>\n    doE\n      pd \\<leftarrow> cdl_find_pd_for_asid maddr;\n      pslots \\<leftarrow> cdl_page_mapping_entries (snd maddr) pgsz pd;\n      might_throw;\n      liftE $ mapM_x delete_cap_simple pslots;\n      returnOk ()\n    odE <catch> (K $ return ())\"", "property": "Unmap Frame: Unmaps a specified frame from the given address, removing its associated page table entries. The operation involves finding the appropriate page directory, identifying the relevant page table slots, and deleting the capabilities in those slots.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": "\n  Unmap a frame.\n"}
{"spec": "definition\n  unmap_page_table  :: \"cdl_mapped_addr \\<Rightarrow> cdl_object_id  \\<Rightarrow> unit k_monad\"\nwhere\n  \"unmap_page_table maddr pt_id\\<equiv>\n    do\n      pt_slot \\<leftarrow> cdl_page_table_mapped maddr pt_id;\n      case pt_slot of (Some slot) \\<Rightarrow> delete_cap_simple slot\n      | None \\<Rightarrow> return ()\n    od\"\n\n\nend", "property": "Unmap Page Table: Unmaps a specified page table from a given memory address. If the page table is found, it is removed; otherwise, no action is taken.", "title": "./spec/capDL/PageTableUnmap_D.thy", "chapter": "", "section": "", "comment": "\n  Unmap a page table.\n\n  This hits the same problems as 'unmap_page', so we also\n  non-deterministically choose a bunch of page-tables to unmap.\n"}
{"spec": "(*\n * CapDL Types\n *\n * This file introduces many of the high-level types used in this\n * specification.\n *)\n\ntheory Types_D\nimports\n  \"ASpec.VMRights_A\"\n  Intents_D\n  \"Lib.Lib\"\n  \"Lib.SplitRule\"\n  \"HOL-Combinatorics.Transposition\" (* for Fun.swap *)\nbegin", "property": "High-Level Type Definitions: Introduces the fundamental types and structures used in the CapDL specification, providing a foundation for defining and manipulating system components and their interactions.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym cdl_irq = irq", "property": "Hardware IRQ Number: Represents a hardware interrupt request number, used to identify specific hardware interrupts in the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A hardware IRQ number. "}
{"spec": "type_synonym cdl_object_id = word32\n\ntype_synonym cdl_object_set = \"(cdl_object_id set)\"", "property": "Object Naming: Objects within the kernel are named using 32-bit words, which may correspond to the memory addresses of the objects.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * How objects are named within the kernel.\n *\n * Objects are named by 32 bit words.\n * This name may correspond to the memory address of the object.\n "}
{"spec": "type_synonym cdl_badge = word32", "property": "Endpoint Badge: Represents a 32-bit value used to identify or tag an endpoint, enabling unique identification and management within the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The badge of an endpoint "}
{"spec": "type_synonym cdl_cap_guard = word32\ntype_synonym cdl_cap_guard_size = nat", "property": "CNode Cap Guard: Defines a guard for a CNode capability, represented as a 32-bit word, and specifies the number of bits used by the guard.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The guard of a CNode cap, and the number of bits the guard uses. "}
{"spec": "type_synonym cdl_size_bits = nat", "property": "Object Size Representation: Represents the size of objects using natural numbers.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The type we use to represent object sizes. "}
{"spec": "type_synonym cdl_io_port = nat", "property": "IA32 IO Port: Represents a single IO port in the IA32 architecture, identified by a natural number.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A single IA32 IO port. "}
{"spec": "type_synonym cdl_io_pagetable_level = nat", "property": "Pagetable Depth: Defines the depth of an IA32 pagetable, representing the number of levels in the pagetable structure.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The depth of a particular IA32 pagetable. "}
{"spec": "type_synonym cdl_cnode_index = nat", "property": "Index for Kernel Object Capabilities: A natural number used as an index to reference capabilities within a CNode, TCB, or other kernel objects.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " An index into a CNode, TCB, or other kernel object that contains caps. "}
{"spec": "type_synonym cdl_cap_ref = \"cdl_object_id \\<times> cdl_cnode_index\"", "property": "Capability Slot Reference: Represents a reference to a specific capability slot, identified by an object ID and a CNode index.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A reference to a capability slot. "}
{"spec": "type_synonym cdl_asid = \"cdl_cnode_index \\<times> cdl_cnode_index\"", "property": "Virtual ASID Representation: A virtual ASID is represented as a pair of CDL cnode indices, allowing for the identification and management of address spaces within the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A virtual ASID. "}
{"spec": "type_synonym cdl_mapped_addr = \"(cdl_asid \\<times> word32)\"", "property": "Mapped Address: Represents a mapped address in the system, consisting of an ASID (Address Space Identifier) and a 32-bit word. This allows for the identification and management of memory mappings within the context of a specific address space.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " mapped address  "}
{"spec": "definition\n  badge_bits :: nat\nwhere\n  \"badge_bits \\<equiv> 28\"", "property": "Badge Bit Count: Defines the number of bits available for a badge, which is 28 bits.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Number of bits of a badge we can use. "}
{"spec": "datatype cdl_frame_cap_type = Real | Fake", "property": "Frame and Page Table Capabilities: Frame, page table, and page directory capabilities can be either real or fake. Real capabilities are installed in CNodes, while fake capabilities represent a page table mapping.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " FrameCaps, PageTableCaps and PageDirectoryCaps can either be\n * \"real\" cap or \"fake\" cap. Real caps are installed in CNodes,\n * and fake caps represent a page table mapping.\n "}
{"spec": "datatype cdl_cap =\n    NullCap", "property": "Kernel Capabilities: Define the structure of capabilities, which include attributes such as the object they point to, the rights they confer to the holder, and the allowed interactions with the target object.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * Kernel capabilities.\n *\n * Such capabilities (or \"caps\") give the holder particular rights to\n * a kernel object or system hardware.\n *\n * Caps have attributes such as the object they point to, the rights\n * they give the holder, or how the holder is allowed to interact with\n * the target object.\n "}
{"spec": "| UntypedCap bool cdl_object_set cdl_object_set\n  | EndpointCap cdl_object_id cdl_badge \"cdl_right set\"\n  | NotificationCap cdl_object_id cdl_badge \"cdl_right set\"\n  | ReplyCap cdl_object_id \"cdl_right set\" (* The id of the tcb of the target thread *)\n  | MasterReplyCap cdl_object_id\n  | CNodeCap cdl_object_id cdl_cap_guard cdl_cap_guard_size cdl_size_bits\n  | TcbCap cdl_object_id\n  | DomainCap", "property": "Kernel Object Capabilities: Define various types of capabilities that grant permissions and access rights to different kernel objects, including untyped memory, endpoints, notifications, reply slots, CNodes, TCBs, and domains. These capabilities ensure controlled and secure access to the underlying resources.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Kernel object capabilities "}
{"spec": "| PendingSyncSendCap cdl_object_id cdl_badge bool bool bool bool", "property": "Pending Synchronous Send Capability: Represents a pending synchronous send operation with associated properties including the object ID, badge, and flags indicating whether it is a call, can grant, can grant reply, and if it is a fault IPC.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " thread, badge, is call, can grant, can grant reply, is fault ipc "}
{"spec": "| PendingSyncRecvCap cdl_object_id bool bool\n  | PendingNtfnRecvCap cdl_object_id", "property": "Pending Synchronization and Notification Capabilities: A thread can be in a state where it is waiting for a reply, during which it can grant synchronization or notification capabilities.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " thread, is waiting for reply, can grant "}
{"spec": "| RestartCap\n  | RunningCap", "property": "Thread State Indication: The thread is marked as ready for rescheduling, indicating that it is either in a state to restart or is currently running.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Indicate that the thread is ready for Reschedule "}
{"spec": "| IrqControlCap\n  | IrqHandlerCap cdl_irq", "property": "Interrupt Capabilities: Define two types of interrupt capabilities, `IrqControlCap` for controlling interrupts and `IrqHandlerCap` for handling specific interrupts identified by `cdl_irq`.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Interrupt capabilities "}
{"spec": "| FrameCap bool cdl_object_id \"cdl_right set\" nat cdl_frame_cap_type \"cdl_mapped_addr option\"\n  | PageTableCap cdl_object_id cdl_frame_cap_type \"cdl_mapped_addr option\"\n  | PageDirectoryCap cdl_object_id cdl_frame_cap_type \"cdl_asid option\"\n  | AsidControlCap\n  | AsidPoolCap cdl_object_id \"cdl_cnode_index\"", "property": "Virtual Memory Capabilities: Define various types of capabilities for managing virtual memory, including frame, page table, and page directory capabilities, each with specific attributes such as object IDs, rights, and mapped addresses. Additionally, include control capabilities for ASID and ASID pools, which manage address space identifiers and their associated cnode indices.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Virtual memory capabilties "}
{"spec": "| IOPortsCap cdl_object_id \"cdl_io_port set\"\n  | IOSpaceMasterCap\n  | IOSpaceCap cdl_object_id\n  | IOPageTableCap cdl_object_id", "property": "X86-Specific Capabilities: Define capabilities specific to the x86 architecture, including I/O port sets, I/O space master, I/O space, and I/O page table. These capabilities enable fine-grained control over I/O operations and memory management in the x86 environment.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " x86-specific capabilities "}
{"spec": "| ZombieCap cdl_object_id", "property": "Zombie Capabilities: Represent objects that are in the process of being deleted, maintaining a reference to the object ID to ensure proper cleanup and resource management.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Zombie caps (representing objects mid-deletion) "}
{"spec": "| BoundNotificationCap cdl_object_id", "property": "Bound Notification Capability: Represents a capability that signifies a TCB is bound to a notification, allowing the TCB to receive and handle notifications.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Bound NTFN caps signifying when a tcb is bound to an NTFN "}
{"spec": "type_synonym cdl_cap_map = \"cdl_cnode_index \\<Rightarrow> cdl_cap option\"", "property": "Capability Mapping: Provides a mapping from capability identifiers to their corresponding capabilities, allowing for efficient lookup and management of capabilities within the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " A mapping from capability identifiers to capabilities. "}
{"spec": "type_synonym cdl_cdt = \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref option\"\n\ntranslations\n  (type) \"cdl_cap_map\" <=(type) \"nat \\<Rightarrow> cdl_cap option\"\n  (type) \"cdl_cap_ref\" <=(type) \"cdl_object_id \\<times> nat\"\n  (type) \"cdl_cap_ref\" <=(type) \"word32 \\<times> nat\"\n  (type) \"cdl_cdt\"     <=(type) \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref option\"", "property": "Cap Derivation Tree (CDT): Records the derivation relationships between capabilities, where each capability may have a parent capability. This structure is crucial for managing capability revocation, as revoking a parent capability automatically revokes all its derived (child) capabilities.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * The cap derivation tree (CDT).\n *\n * This tree records how certain caps are derived from others. This\n * information is important because it affects how caps are revoked; if an\n * entity revokes a particular cap, all of the cap's children (as\n * recorded in the CDT) are also revoked.\n *\n * At this point in time, we leave the definition of the CDT quite\n * abstract. This may be made more concrete in the future allowing us to\n * reason about revocation.\n "}
{"spec": "record cdl_tcb =\n  cdl_tcb_caps           :: cdl_cap_map\n  cdl_tcb_fault_endpoint :: cdl_cptr\n  cdl_tcb_intent         :: cdl_full_intent\n  cdl_tcb_has_fault      :: bool\n  cdl_tcb_domain         :: word8\n\nrecord cdl_cnode =\n  cdl_cnode_caps :: cdl_cap_map\n  cdl_cnode_size_bits :: cdl_size_bits\n\nrecord cdl_asid_pool =\n  cdl_asid_pool_caps :: cdl_cap_map\n\nrecord cdl_page_table =\n  cdl_page_table_caps :: cdl_cap_map\n\nrecord cdl_page_directory =\n  cdl_page_directory_caps :: cdl_cap_map\n\nrecord cdl_frame =\n  cdl_frame_size_bits :: cdl_size_bits\n\nrecord cdl_irq_node =\n  cdl_irq_node_caps :: cdl_cap_map", "property": "Kernel Object Structures: Define the structure of various kernel objects, each containing a capability map and additional specific attributes. These structures include TCBs with fault handling and domain information, CNodes with size bits, ASID pools, page tables, page directories, frames with size bits, and IRQ nodes.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Kernel objects "}
{"spec": "datatype cdl_object =\n    Endpoint\n  | Notification\n  | Tcb cdl_tcb\n  | CNode cdl_cnode\n  | AsidPool cdl_asid_pool\n  | PageTable cdl_page_table\n  | PageDirectory cdl_page_directory\n  | Frame cdl_frame\n  | Untyped\n  | IRQNode cdl_irq_node", "property": "Kernel Objects: Define a set of in-memory objects that can be created or deleted by users, including endpoints, notifications, threads (TCBs), capability nodes (CNodes), ASID pools, page tables, page directories, frames, untyped memory, and IRQ nodes.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * Kernel objects.\n *\n * These are in-memory objects that may, over the course of the system\n * execution, be created or deleted by users.\n "}
{"spec": "datatype cdl_arch = IA32 | ARM11", "property": "Architecture Definition: Specifies the supported architectures, including IA32 and ARM11, for the system model.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The architecture that we are modelling. "}
{"spec": "type_synonym cdl_heap = \"cdl_object_id \\<Rightarrow> cdl_object option\"\n\ntranslations\n  (type) \"cdl_heap\" <=(type) \"32 word \\<Rightarrow> cdl_object option\"", "property": "System Object Mapping: Represents a mapping of object identifiers to their corresponding objects within the system, allowing for the tracking and management of all objects present in the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " The map of objects that are in the system. "}
{"spec": "record cdl_state =\n  cdl_arch           :: cdl_arch\n  cdl_objects        :: cdl_heap\n  cdl_cdt            :: cdl_cdt\n  cdl_current_thread :: \"cdl_object_id option\"\n  cdl_irq_node       :: \"cdl_irq \\<Rightarrow> cdl_object_id\"\n  cdl_asid_table     :: cdl_cap_map\n  cdl_current_domain :: word8", "property": "System State Representation: The system state is represented by a record that includes the architecture, existing objects, capability derivation tree, current thread, IRQ to notification mappings, ASID table, and current domain. This comprehensive state record ensures that all essential information about the system's configuration and runtime status is accessible and manageable.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * The current state of the system.\n *\n * The state record contains the following primary pieces of information:\n *\n * arch:\n *   The architecture of the system. This affects what capabilities and\n *   kernel objects could possibly be present. In the current kernel\n *   arch will not change at runtime.\n *\n * objects:\n *   The objects that currently exist in the system.\n *\n * cdt:\n *   The cap derivation tree of the system.\n *\n * current_thread:\n *   The currently running thread. Operations will always be performed\n *   on behalf of this thread.\n *\n * irq_node:\n *   Which IRQs are mapped to which notifications.\n *\n * asid_table:\n *   The first level of the asid table, containing capabilities to all\n *   of the ASIDPools.\n *\n * current_domain:\n *   The currently running domain.\n "}
{"spec": "definition\n  object_type :: \"cdl_object \\<Rightarrow> cdl_object_type\"\nwhere\n  \"object_type x \\<equiv>\n    case x of\n        Untyped \\<Rightarrow> UntypedType\n      | Endpoint \\<Rightarrow> EndpointType\n      | Notification \\<Rightarrow> NotificationType\n      | Tcb _ \\<Rightarrow> TcbType\n      | CNode _ \\<Rightarrow> CNodeType\n      | IRQNode _ \\<Rightarrow> IRQNodeType\n      | AsidPool _ \\<Rightarrow> AsidPoolType\n      | PageTable _ \\<Rightarrow> PageTableType\n      | PageDirectory _ \\<Rightarrow> PageDirectoryType\n      | Frame f \\<Rightarrow> FrameType (cdl_frame_size_bits f)\"\n\nlemmas object_type_simps = object_type_def[split_simps cdl_object.split]\n\ndefinition\n  asid_high_bits :: nat where\n  \"asid_high_bits \\<equiv> 7\"\ndefinition\n  asid_low_bits :: nat where\n  \"asid_low_bits \\<equiv> 10 :: nat\"\ndefinition\n  asid_bits :: nat where\n  \"asid_bits \\<equiv> 17 :: nat\"", "property": "Determine Object Type: Identify the type of a given object, such as Untyped, Endpoint, Notification, TCB, CNode, IRQNode, AsidPool, PageTable, PageDirectory, or Frame, based on its definition.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Return the type of an object. "}
{"spec": "definition \"tcb_cspace_slot     = (0 :: cdl_cnode_index)\"\ndefinition \"tcb_vspace_slot     = (1 :: cdl_cnode_index)\"\ndefinition \"tcb_replycap_slot   = (2 :: cdl_cnode_index)\"\ndefinition \"tcb_caller_slot     = (3 :: cdl_cnode_index)\"\ndefinition \"tcb_ipcbuffer_slot  = (4 :: cdl_cnode_index)\"\ndefinition \"tcb_pending_op_slot = (5 :: cdl_cnode_index)\"\ndefinition \"tcb_boundntfn_slot  = (8 :: cdl_cnode_index)\"\n\ndefinition \"tcb_slots_list \\<equiv> [0..<tcb_pending_op_slot + 1] @ [tcb_boundntfn_slot]\"\nabbreviation \"tcb_slots \\<equiv> set tcb_slots_list\"\nlemmas tcb_slots_def = tcb_slots_list_def\n\nlemmas tcb_slot_defs =\n  tcb_cspace_slot_def\n  tcb_vspace_slot_def\n  tcb_replycap_slot_def\n  tcb_caller_slot_def\n  tcb_ipcbuffer_slot_def\n  tcb_pending_op_slot_def\n  tcb_boundntfn_slot_def\n  tcb_slots_list_def", "property": "TCB Cap Slot Definitions: Each TCB contains a set of cap slots, each with a specific purpose, such as cspace, vspace, reply cap, caller cap, IPC buffer, pending operation, and bound notification. These slots are defined by constants and organized in a list to ensure consistent and predictable behavior in the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "\n * Each TCB contains a number of cap slots, each with a specific\n * purpose. These constants define the purpose of each slot.\n *\n * The specific list of slots is chosen to be consistent with the output\n * of the CapDL-tool.\n "}
{"spec": "primrec (nonexhaustive)\n  cap_objects :: \"cdl_cap \\<Rightarrow> cdl_object_id set\"\nwhere\n    \"cap_objects (IOPageTableCap x) = {x}\"\n  | \"cap_objects (IOSpaceCap x) = {x}\"\n  | \"cap_objects (IOPortsCap x _) = {x}\"\n  | \"cap_objects (AsidPoolCap x _) = {x}\"\n  | \"cap_objects (PageDirectoryCap x _ _) = {x}\"\n  | \"cap_objects (PageTableCap x _ _) = {x}\"\n  | \"cap_objects (FrameCap _ x _ _ _ _) = {x}\"\n  | \"cap_objects (TcbCap x) = {x}\"\n  | \"cap_objects (CNodeCap x _ _ _) = {x}\"\n  | \"cap_objects (MasterReplyCap x) = {x}\"\n  | \"cap_objects (ReplyCap x _) = {x}\"\n  | \"cap_objects (NotificationCap x _ _) = {x}\"\n  | \"cap_objects (EndpointCap x _ _) = {x}\"\n  | \"cap_objects (UntypedCap _ x a) = x\"\n  | \"cap_objects (ZombieCap x) = {x}\"\n  | \"cap_objects (PendingSyncSendCap x _ _ _ _ _) = {x}\"\n  | \"cap_objects (PendingSyncRecvCap x _ _) = {x}\"\n  | \"cap_objects (PendingNtfnRecvCap x) = {x}\"\n  | \"cap_objects (BoundNotificationCap x) = {x}\"\n\ndefinition\n  cap_has_object :: \"cdl_cap \\<Rightarrow> bool\"\nwhere\n  \"cap_has_object cap \\<equiv> case cap of\n     NullCap          \\<Rightarrow> False\n  | IrqControlCap    \\<Rightarrow> False\n  | IrqHandlerCap _  \\<Rightarrow> False\n  | AsidControlCap   \\<Rightarrow> False\n  | IOSpaceMasterCap \\<Rightarrow> False\n  | RestartCap       \\<Rightarrow> False\n  | RunningCap       \\<Rightarrow> False\n  | DomainCap        \\<Rightarrow> False\n  | _                \\<Rightarrow> True\"\n\ndefinition\n  cap_object :: \"cdl_cap \\<Rightarrow> cdl_object_id\"\nwhere\n  \"cap_object cap \\<equiv>\n     if cap_has_object cap\n     then (THE c. c \\<in> cap_objects cap)\n     else undefined\"\n\nlemma cap_object_simps[simp]:\n  \"cap_object (IOPageTableCap x) = x\"\n  \"cap_object (IOSpaceCap x) = x\"\n  \"cap_object (IOPortsCap x a) = x\"\n  \"cap_object (AsidPoolCap x b) = x\"\n  \"cap_object (PageDirectoryCap x c d) = x\"\n  \"cap_object (PageTableCap x e f) = x\"\n  \"cap_object (FrameCap dev x g h i j) = x\"\n  \"cap_object (TcbCap x) = x\"\n  \"cap_object (CNodeCap x k l sz) = x\"\n  \"cap_object (MasterReplyCap x) = x\"\n  \"cap_object (ReplyCap x q) = x\"\n  \"cap_object (NotificationCap x m n) = x\"\n  \"cap_object (EndpointCap x p q) = x\"\n  \"cap_object (ZombieCap x) = x\"\n  \"cap_object (PendingSyncSendCap x s t u v w) = x\"\n  \"cap_object (PendingSyncRecvCap x t u) = x\"\n  \"cap_object (PendingNtfnRecvCap x) = x\"\n  \"cap_object (BoundNotificationCap x) = x\"\n  by (simp_all add:cap_object_def Nitpick.The_psimp cap_has_object_def)\n\nprimrec (nonexhaustive) cap_badge :: \"cdl_cap \\<Rightarrow> cdl_badge\"\nwhere\n    \"cap_badge (NotificationCap _ x _) = x\"\n  | \"cap_badge (EndpointCap _ x _) = x\"\n\ndefinition\n  update_cap_badge :: \"cdl_badge \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"update_cap_badge x c \\<equiv> case c of\n      NotificationCap f1 _ f3 \\<Rightarrow> NotificationCap f1 x f3\n    | EndpointCap f1 _ f3      \\<Rightarrow> EndpointCap f1 x f3\n    | _ \\<Rightarrow> c\"\n\ndefinition all_cdl_rights :: \"cdl_right set\" where\n  \"all_cdl_rights = {Read, Write, Grant, GrantReply}\"\n\ndefinition\n  cap_rights :: \"cdl_cap \\<Rightarrow> cdl_right set\"\nwhere\n  \"cap_rights c \\<equiv> case c of\n      FrameCap _ _ x _ _ _ \\<Rightarrow> x\n    | NotificationCap _ _ x \\<Rightarrow> x\n    | EndpointCap _ _ x \\<Rightarrow> x\n    | ReplyCap _ x \\<Rightarrow> x\n    | _ \\<Rightarrow> all_cdl_rights\"\n\ndefinition\n  update_cap_rights :: \"cdl_right set \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"update_cap_rights r c \\<equiv> case c of\n      FrameCap dev f1 _ f2 f3 f4 \\<Rightarrow> FrameCap dev f1 (validate_vm_rights r) f2 f3 f4\n    | NotificationCap f1 f2 _ \\<Rightarrow> NotificationCap f1 f2 (r - {Grant, GrantReply})\n    | EndpointCap f1 f2 _ \\<Rightarrow> EndpointCap f1 f2 r\n    | ReplyCap f1 _ \\<Rightarrow> ReplyCap f1 (r - {Read, GrantReply} \\<union> {Write})\n    | _ \\<Rightarrow> c\"\n\ndefinition\n  update_mapping_cap_status :: \"cdl_frame_cap_type \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n \"update_mapping_cap_status r c \\<equiv> case c of\n      FrameCap dev f1 f2 f3 _ f4 \\<Rightarrow> FrameCap dev f1 f2 f3 r f4\n    | PageTableCap pt1 _ pt2 \\<Rightarrow> PageTableCap pt1 r pt2\n    | _ \\<Rightarrow> c\"\n\nprimrec (nonexhaustive) cap_guard :: \"cdl_cap \\<Rightarrow> cdl_cap_guard\"\nwhere\n  \"cap_guard (CNodeCap _ x _ _) = x\"\n\ndefinition\n  update_cap_guard :: \"cdl_cap_guard \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"update_cap_guard x c \\<equiv> case c of\n      CNodeCap f1 _ f3 f4 \\<Rightarrow> CNodeCap f1 x f3 f4\n    | _ \\<Rightarrow> c\"\n\nprimrec (nonexhaustive) cap_guard_size :: \"cdl_cap \\<Rightarrow> cdl_cap_guard_size\"\nwhere\n  \"cap_guard_size (CNodeCap _ _ x _ ) = x\"\n\ndefinition\n  cnode_cap_size :: \"cdl_cap \\<Rightarrow> cdl_size_bits\"\nwhere\n  \"cnode_cap_size cap \\<equiv> case cap of\n      CNodeCap _ _ _ x \\<Rightarrow> x\n    | _ \\<Rightarrow> 0\"\n\ndefinition\n  update_cap_guard_size :: \"cdl_cap_guard_size \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"update_cap_guard_size x c \\<equiv> case c of\n      CNodeCap f1 f2 _ f3 \\<Rightarrow> CNodeCap f1 f2 x f3\n    | _ \\<Rightarrow> c\"", "property": "Capability Management: Defines and manipulates various attributes of capabilities, including the associated objects, badges, rights, and guards. It allows for updating these attributes, ensuring that capabilities are correctly configured and managed within the system.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Capability getters / setters "}
{"spec": "definition\n  object_slots :: \"cdl_object \\<Rightarrow> cdl_cap_map\"\nwhere\n  \"object_slots obj \\<equiv> case obj of\n    PageDirectory x \\<Rightarrow> cdl_page_directory_caps x\n  | PageTable x \\<Rightarrow> cdl_page_table_caps x\n  | AsidPool x \\<Rightarrow> cdl_asid_pool_caps x\n  | CNode x \\<Rightarrow> cdl_cnode_caps x\n  | Tcb x \\<Rightarrow> cdl_tcb_caps x\n  | IRQNode x \\<Rightarrow> cdl_irq_node_caps x\n  | _ \\<Rightarrow> Map.empty\"\n\ndefinition\n  update_slots :: \"cdl_cap_map \\<Rightarrow> cdl_object \\<Rightarrow> cdl_object\"\nwhere\n  \"update_slots new_val obj \\<equiv> case obj of\n    PageDirectory x \\<Rightarrow> PageDirectory (x\\<lparr>cdl_page_directory_caps := new_val\\<rparr>)\n  | PageTable x \\<Rightarrow> PageTable (x\\<lparr>cdl_page_table_caps := new_val\\<rparr>)\n  | AsidPool x \\<Rightarrow> AsidPool (x\\<lparr>cdl_asid_pool_caps := new_val\\<rparr>)\n  | CNode x \\<Rightarrow> CNode (x\\<lparr>cdl_cnode_caps := new_val\\<rparr>)\n  | Tcb x \\<Rightarrow> Tcb (x\\<lparr>cdl_tcb_caps := new_val\\<rparr>)\n  | IRQNode x \\<Rightarrow> IRQNode (x\\<lparr>cdl_irq_node_caps := new_val\\<rparr>)\n  | _ \\<Rightarrow> obj\"\n\ndefinition\n  has_slots :: \"cdl_object \\<Rightarrow> bool\"\nwhere\n  \"has_slots obj \\<equiv> case obj of\n    PageDirectory _ \\<Rightarrow> True\n  | PageTable _ \\<Rightarrow> True\n  | AsidPool _ \\<Rightarrow> True\n  | CNode _ \\<Rightarrow> True\n  | Tcb _ \\<Rightarrow> True\n  | IRQNode _ \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"\n\n\ndefinition\n  cap_free_ids :: \"cdl_cap \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"cap_free_ids cap \\<equiv> (case cap of\n     UntypedCap _ _ free_ids \\<Rightarrow> free_ids\n   | _ \\<Rightarrow> {})\"\n\ndefinition\n  remove_free_ids :: \"cdl_cap \\<Rightarrow> cdl_object_id set \\<Rightarrow> cdl_cap\"\nwhere\n  \"remove_free_ids cap obj_ids \\<equiv> case cap of\n     UntypedCap dev c a \\<Rightarrow> UntypedCap dev c (a - obj_ids)\n   | _ \\<Rightarrow> cap\"\n\ndefinition cap_irq :: \"cdl_cap \\<Rightarrow> cdl_irq\"\nwhere\n  \"cap_irq cap \\<equiv> case cap of\n      IrqHandlerCap x \\<Rightarrow> x\n    | _ \\<Rightarrow> undefined\"", "property": "Kernel Object Management: Provides functions to get, update, and check the capability slots of different kernel objects, as well as manage free IDs and IRQs associated with capabilities. This ensures that the kernel can effectively manage and manipulate the capabilities and resources of various objects, maintaining system integrity and resource allocation.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Kernel object getters / setters "}
{"spec": "definition cap_type :: \"cdl_cap \\<Rightarrow> cdl_object_type option\"\nwhere\n  \"cap_type x \\<equiv> case x of\n    UntypedCap _ _ _         \\<Rightarrow> Some UntypedType\n  | EndpointCap _ _ _      \\<Rightarrow> Some EndpointType\n  | NotificationCap _ _ _ \\<Rightarrow> Some NotificationType\n  | TcbCap _               \\<Rightarrow> Some TcbType\n  | CNodeCap _ _ _ _       \\<Rightarrow> Some CNodeType\n  | AsidPoolCap _ _        \\<Rightarrow> Some AsidPoolType\n  | PageTableCap _ _ _     \\<Rightarrow> Some PageTableType\n  | PageDirectoryCap _ _ _ \\<Rightarrow> Some PageDirectoryType\n  | FrameCap _ _ _ f _ _     \\<Rightarrow> Some (FrameType f)\n  | IrqHandlerCap _        \\<Rightarrow> Some IRQNodeType\n  | _                      \\<Rightarrow> None \"\n\nabbreviation \"is_untyped_cap cap    \\<equiv> (cap_type cap = Some UntypedType)\"\nabbreviation \"is_ep_cap cap         \\<equiv> (cap_type cap = Some EndpointType)\"\nabbreviation \"is_ntfn_cap cap        \\<equiv> (cap_type cap = Some NotificationType)\"\nabbreviation \"is_tcb_cap cap        \\<equiv> (cap_type cap = Some TcbType)\"\nabbreviation \"is_cnode_cap cap      \\<equiv> (cap_type cap = Some CNodeType)\"\nabbreviation \"is_asidpool_cap cap   \\<equiv> (cap_type cap = Some AsidPoolType)\"\nabbreviation \"is_pt_cap cap         \\<equiv> (cap_type cap = Some PageTableType)\"\nabbreviation \"is_pd_cap cap         \\<equiv> (cap_type cap = Some PageDirectoryType)\"\nabbreviation \"is_frame_cap cap      \\<equiv> (\\<exists>sz. cap_type cap = Some (FrameType sz))\"\nabbreviation \"is_irqhandler_cap cap \\<equiv> (cap_type cap = Some IRQNodeType)\"\ndefinition   \"is_irqcontrol_cap cap \\<equiv> (cap = IrqControlCap)\"\n\nlemma cap_type_simps [simp]:\n  \"is_untyped_cap    (UntypedCap dev a a')\"\n  \"is_ep_cap         (EndpointCap b c d)\"\n  \"is_ntfn_cap        (NotificationCap e f g)\"\n  \"is_tcb_cap        (TcbCap h)\"\n  \"is_cnode_cap      (CNodeCap j k l m)\"\n  \"is_asidpool_cap   (AsidPoolCap n p)\"\n  \"is_pd_cap         (PageDirectoryCap r s t)\"\n  \"is_pt_cap         (PageTableCap u v w)\"\n  \"is_frame_cap      (FrameCap dev a1 a2 a3 a4 a5)\"\n  \"is_irqhandler_cap (IrqHandlerCap a6)\"\n  \"cap_type (FrameCap dev obj_id rights sz rs asid) = Some (FrameType sz)\"\n  by (clarsimp simp: cap_type_def)+\n\nabbreviation \"cap_has_type cap \\<equiv> (\\<exists>type. cap_type cap = Some type)\"\n\nlemma cap_type_update_cap_badge [simp]:\n  \"cap_type (update_cap_badge x cap) = cap_type cap\"\n  by (clarsimp simp: update_cap_badge_def cap_type_def split: cdl_cap.splits)\n\nlemma cap_type_update_cap_rights [simp]:\n  \"cap_type (update_cap_rights x cap) = cap_type cap\"\n  by (clarsimp simp: update_cap_rights_def cap_type_def split: cdl_cap.splits)\n\nlemma cap_type_update_mapping_cap_status [simp]:\n  \"cap_type (update_mapping_cap_status x cap) = cap_type cap\"\n  by (clarsimp simp: update_mapping_cap_status_def cap_type_def split: cdl_cap.splits)\n\nlemma cap_type_update_cap_guard [simp]:\n  \"cap_type (update_cap_guard x cap) = cap_type cap\"\n  by (clarsimp simp: update_cap_guard_def cap_type_def split: cdl_cap.splits)\n\nlemma update_cap_guard_size [simp]:\n  \"cap_type (update_cap_guard_size x cap) = cap_type cap\"\n  by (clarsimp simp: update_cap_guard_size_def cap_type_def split: cdl_cap.splits)\n\n\n\ndefinition is_pending_cap :: \"cdl_cap \\<Rightarrow> bool\"\nwhere \"is_pending_cap c \\<equiv> case c of\n  PendingSyncRecvCap _ _ _ \\<Rightarrow> True\n  | PendingNtfnRecvCap _ \\<Rightarrow> True\n  | PendingSyncSendCap _ _ _ _ _ _ \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"", "property": "Cap Type Classification: Categorizes different types of capabilities, such as Untyped, Endpoint, Notification, TCB, CNode, ASID Pool, Page Table, Page Directory, Frame, and IRQ Node, based on their specific attributes. Each capability type is uniquely identified, and the type remains unchanged under certain updates like badge, rights, mapping status, and guard. Additionally, it identifies pending capabilities, which include PendingSyncRecv, PendingNtfnRecv, and PendingSyncSend.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": "************\n * Cap types *\n ************"}
{"spec": "definition\n  empty_cap_map :: \"nat \\<Rightarrow> cdl_cap_map\"\nwhere\n  \"empty_cap_map sz \\<equiv> (\\<lambda>a. if a < 2^sz then (Some NullCap) else None)\"", "property": "Create an Empty Capability Map: Generate a capability map of a specified size, where all entries are initialized to NullCap.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Create a capability map that contains no caps. "}
{"spec": "definition\n  empty_cnode :: \"nat \\<Rightarrow> cdl_cnode\"\nwhere\n  \"empty_cnode sz = \\<lparr> cdl_cnode_caps = empty_cap_map sz, cdl_cnode_size_bits = sz \\<rparr>\"\n\ndefinition\n  empty_irq_node :: cdl_irq_node\nwhere\n  \"empty_irq_node \\<equiv> \\<lparr> cdl_irq_node_caps = empty_cap_map 0 \\<rparr>\"", "property": "Create Empty Node: Initialize an empty CNode or IRQ node with a specified size, where the CNode contains an empty capability map and the size in bits, and the IRQ node contains an empty capability map.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Create an empty CNode. "}
{"spec": "definition\n  default_tcb :: \"word8 \\<Rightarrow> cdl_tcb\"\nwhere\n  \"default_tcb current_domain = \\<lparr>\n    cdl_tcb_caps = \\<lambda>n. if n \\<in> tcb_slots then Some NullCap else None,\n    cdl_tcb_fault_endpoint = 0,\n    cdl_tcb_intent = \\<lparr>\n      cdl_intent_op = None,\n      cdl_intent_error = False,\n      cdl_intent_cap = 0,\n      cdl_intent_extras = [],\n      cdl_intent_recv_slot = None\n      \\<rparr>,\n    cdl_tcb_has_fault = False,\n    cdl_tcb_domain = current_domain\n    \\<rparr>\"", "property": "Default TCB Initialization: Initialize a TCB with default values, including setting all capability slots to `NullCap`, fault endpoint to 0, intent fields to default values, and the domain to the specified current domain. This ensures that a newly created TCB is in a known, safe state.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Standard empty TCB object. "}
{"spec": "definition\n  default_object :: \"cdl_object_type \\<Rightarrow> nat \\<Rightarrow> word8 \\<Rightarrow> cdl_object option\"\nwhere\n  \"default_object x y current_domain \\<equiv>\n    case x of\n        UntypedType \\<Rightarrow> Some Untyped\n      | EndpointType \\<Rightarrow> Some Endpoint\n      | NotificationType \\<Rightarrow> Some Notification\n      | TcbType \\<Rightarrow> Some (Tcb (default_tcb current_domain))\n      | CNodeType \\<Rightarrow> Some (CNode (empty_cnode y))\n      | AsidPoolType \\<Rightarrow> Some (AsidPool \\<lparr> cdl_asid_pool_caps = empty_cap_map asid_low_bits \\<rparr>)\n      | PageTableType \\<Rightarrow> Some (PageTable \\<lparr> cdl_page_table_caps = empty_cap_map 8 \\<rparr>)\n      | PageDirectoryType \\<Rightarrow> Some (PageDirectory \\<lparr> cdl_page_directory_caps = empty_cap_map 12 \\<rparr>)\n      | FrameType sz \\<Rightarrow> Some (Frame \\<lparr> cdl_frame_size_bits = sz \\<rparr>)\n      | IRQNodeType \\<Rightarrow> Some (IRQNode empty_irq_node)\"\n\nabbreviation \"pick a \\<equiv> SOME x. x\\<in> a\"", "property": "Default Object Construction: Construct a new object of the specified type with default properties, including setting up empty structures or specific default values as required by the object type.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Return a newly constructed object of the given type. "}
{"spec": "definition\n  default_cap :: \"cdl_object_type \\<Rightarrow> cdl_object_id set \\<Rightarrow> cdl_size_bits \\<Rightarrow> bool \\<Rightarrow> cdl_cap\"\nwhere\n  \"default_cap t id_set sz dev \\<equiv>\n    case t of\n        EndpointType \\<Rightarrow> EndpointCap (pick id_set) 0 UNIV\n      | NotificationType \\<Rightarrow> NotificationCap (THE i. i \\<in> id_set) 0 {Read,Write}\n      | TcbType \\<Rightarrow> TcbCap (pick id_set)\n      | CNodeType \\<Rightarrow> CNodeCap (pick id_set) 0 0 sz\n      | IRQNodeType \\<Rightarrow> IrqHandlerCap undefined\n      | UntypedType \\<Rightarrow> UntypedCap dev id_set id_set\n      | AsidPoolType \\<Rightarrow> AsidPoolCap (pick id_set) 0\n      | PageTableType \\<Rightarrow> PageTableCap (pick id_set) Real None\n      | PageDirectoryType \\<Rightarrow> PageDirectoryCap (pick id_set) Real None\n      | FrameType frame_size \\<Rightarrow> FrameCap dev (pick id_set) {Read, Write} frame_size Real None\"\n\nend", "property": "Default Capability Construction: Generate a default capability for a new object based on its type, a set of available object IDs, size in bits, and a device flag. The generated capability is tailored to the specific object type, ensuring it is correctly configured with the appropriate permissions and attributes.", "title": "./spec/capDL/Types_D.thy", "chapter": "", "section": "", "comment": " Construct a cap for a new object. "}
{"spec": "definition\n  all_active_tcbs :: \"cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"all_active_tcbs state \\<equiv> {x \\<in> dom (cdl_objects state).\n      \\<exists> a. (cdl_objects state) x = Some (Tcb a)\n          \\<and> ( ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RunningCap) \\<or> ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RestartCap))}\"\n\ndefinition\n  active_tcbs_in_domain :: \"word8 \\<Rightarrow> cdl_state \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"active_tcbs_in_domain domain state  = {x \\<in> dom (cdl_objects state).\n      \\<exists> a. (cdl_objects state) x = Some (Tcb a)\n          \\<and> ( ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RunningCap) \\<or> ((cdl_tcb_caps a) tcb_pending_op_slot) = (Some RestartCap))\n          \\<and> cdl_tcb_domain a = domain }\"", "property": "Collect Runnable Threads: Identify and collect the set of all active threads in the system that are either running or ready to restart. Additionally, filter these threads based on their scheduling domain.", "title": "./spec/capDL/Schedule_D.thy", "chapter": "", "section": "", "comment": "\n * Collect the set of runnable threads in the system.\n "}
{"spec": "definition\n  switch_to_thread :: \"cdl_object_id option \\<Rightarrow> unit k_monad\"\nwhere\n  \"switch_to_thread target \\<equiv>\n     modify (\\<lambda> t. t\\<lparr> cdl_current_thread := target \\<rparr>)\"\n\ndefinition\n  change_current_domain :: \"unit k_monad\"\nwhere\n  \"change_current_domain = do\n     next_domain \\<leftarrow> select UNIV;\n     modify      (\\<lambda>s. s\\<lparr> cdl_current_domain := next_domain \\<rparr>)\n   od\"", "property": "Thread Switching: Switch the current thread to a specified target, updating the system state to reflect the new current thread.\n\nDomain Change: Randomly select a new domain and update the system state to set this as the current domain.", "title": "./spec/capDL/Schedule_D.thy", "chapter": "", "section": "", "comment": "\n * Switch to a new thread.\n "}
{"spec": "definition\n  schedule :: \"unit k_monad\"\nwhere\n  \"schedule \\<equiv> do\n     change_current_domain;\n     next_domain \\<leftarrow> gets cdl_current_domain;\n     threads     \\<leftarrow> gets (active_tcbs_in_domain next_domain);\n     next_thread \\<leftarrow> select threads;\n     switch_to_thread (Some next_thread)\n   od \\<sqinter> do\n     change_current_domain;\n     switch_to_thread None\n   od\"\n\n\nend", "property": "Scheduling Nondeterminism: The scheduling process is fully nondeterministic, allowing for the selection of any active thread within the current domain or switching to an idle state.", "title": "./spec/capDL/Schedule_D.thy", "chapter": "", "section": "", "comment": "\n * Scheduling is fully nondeterministic at this level.\n "}
{"spec": "(*\n * Operations on CSpace\n *)\n\ntheory CSpace_D\nimports\n  PageTableUnmap_D\nbegin", "property": "CSpace Operations: Define and manage the operations related to the capability space, ensuring the proper allocation, manipulation, and deallocation of capabilities within the system.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  has_children :: \"cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> bool\"\nwhere\n  \"has_children parent s = (\\<exists>child. is_cdt_parent s parent child)\"", "property": "Cap Has Children: Determines whether a given capability has any children by checking if there exists a child capability in the capability derivation table (CDT) that is associated with the parent.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Does the given cap have any children? "}
{"spec": "definition\n  ensure_no_children :: \"cdl_cap_ref \\<Rightarrow> unit except_monad\"\nwhere\n  \"ensure_no_children x \\<equiv> doE\n     c \\<leftarrow> liftE $ gets (has_children x);\n     whenE c $ throw\n   odE\"", "property": "Ensure No Children: Verify that the given capability does not have any children in the CDT. If it does, an exception is thrown.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Ensure that the given cap does not contain any children\n * in the CDT.\n "}
{"spec": "definition\n  ensure_empty :: \"cdl_cap_ref \\<Rightarrow> unit except_monad\"\nwhere\n  \"ensure_empty cap_ref \\<equiv> doE\n     cap \\<leftarrow> liftE $ get_cap cap_ref;\n     unlessE (cap = NullCap) $ throw\n  odE\"", "property": "Ensure Slot Emptiness: Verify that the specified capability slot is empty, and if not, throw an exception.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Ensure that the given cap slot is empty. "}
{"spec": "definition\n  insert_cap_orphan :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"insert_cap_orphan new_cap dest_slot \\<equiv> do\n     old_cap \\<leftarrow> get_cap dest_slot;\n     assert (old_cap = NullCap);\n     set_cap dest_slot new_cap\n   od\"\n\n\n\nprimrec (nonexhaustive)\n  available_range :: \"cdl_cap \\<Rightarrow> cdl_object_id set\"\nwhere\n  \"available_range (UntypedCap _ r available) = available\"\n\ndefinition\n  set_available_range :: \"cdl_cap \\<Rightarrow> cdl_object_id set \\<Rightarrow> cdl_cap\"\nwhere\n  \"set_available_range cap nrange \\<equiv>\n    case cap of UntypedCap d r available \\<Rightarrow> UntypedCap d r nrange | _ \\<Rightarrow> cap\"\n\nlemmas set_avaiable_range_simps[simp] = set_available_range_def[split_simps cdl_cap.split]\n\ndefinition\n  set_untyped_cap_as_full :: \"cdl_cap \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"set_untyped_cap_as_full src_cap new_cap src_slot \\<equiv>\n  if (is_untyped_cap src_cap \\<and> is_untyped_cap new_cap\n     \\<and> cap_objects src_cap = cap_objects new_cap) then\n     (set_cap src_slot (set_available_range src_cap {}))\n     else return ()\"", "property": "Insert Orphan Capability: Insert a new capability into a specified slot, ensuring that the destination slot is empty (contains a NullCap) before the insertion. This guarantees that the new capability is added without a parent and does not overwrite an existing capability.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Insert a new cap into an object. The cap will have no parent. "}
{"spec": "definition\n  insert_cap_sibling :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"insert_cap_sibling new_cap src_slot dest_slot \\<equiv> do\n    src_cap \\<leftarrow> get_cap src_slot;\n    old_cap \\<leftarrow> get_cap dest_slot;\n    assert (old_cap = NullCap);\n    set_untyped_cap_as_full src_cap new_cap src_slot;\n    set_cap dest_slot new_cap;\n    p \\<leftarrow> gets $ opt_parent src_slot;\n    case p of\n      None \\<Rightarrow> return ()\n    | Some parent \\<Rightarrow> set_parent dest_slot parent\n  od\"", "property": "Insert Cap Sibling: Insert a new capability as a sibling to an existing slot. The operation ensures that the destination slot is initially empty, updates the source and destination slots with the new capability, and sets the parent of the destination slot if it exists.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Insert a new cap into an object. The cap will be a sibling. "}
{"spec": "definition\n  insert_cap_child :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"insert_cap_child new_cap src_slot dest_slot \\<equiv> do\n    src_cap \\<leftarrow> get_cap src_slot;\n    old_cap \\<leftarrow> get_cap dest_slot;\n    assert (old_cap = NullCap);\n    set_untyped_cap_as_full src_cap new_cap src_slot;\n    set_cap dest_slot new_cap;\n    set_parent dest_slot src_slot\n  od\"", "property": "Insert New Capability as Child: Insert a new capability into an object as a child, ensuring the destination slot is initially empty. The source capability is updated to reflect the new capability, and the parent-child relationship is established between the source and destination slots.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Insert a new cap into an object. The cap will be a child. "}
{"spec": "definition\n  delete_asid_pool :: \"cdl_cnode_index \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"delete_asid_pool base ptr \\<equiv> do\n    asid_table \\<leftarrow> gets cdl_asid_table;\n    asid_table' \\<leftarrow> return $ asid_table (base \\<mapsto> NullCap);\n    modify (\\<lambda>s. s \\<lparr>cdl_asid_table := asid_table'\\<rparr>)\n  od \\<sqinter> return ()\"", "property": "Delete ASID Pool: Remove the specified ASID pool from the ASID table, setting its entry to NullCap. This ensures that the ASID pool is no longer referenced and can be safely deallocated.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Delete an ASID pool.\n "}
{"spec": "definition\n  delete_asid :: \"cdl_asid \\<Rightarrow> cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"delete_asid asid pd \\<equiv> do\n    asid_table \\<leftarrow> gets cdl_asid_table;\n    case asid_table (fst asid) of\n       Some NullCap \\<Rightarrow> return ()\n     | Some (AsidPoolCap p _) \\<Rightarrow> set_cap (p, (snd asid)) NullCap\n     | _ \\<Rightarrow> fail\n  od \\<sqinter> return ()\"\n\ndefinition\n  get_irq_slot :: \"cdl_irq \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref\"\nwhere\n  \"get_irq_slot irq s \\<equiv> (cdl_irq_node s irq, 0)\"", "property": "Delete ASID: Remove a specified ASID from the ASID table, deactivating the associated page directory in the process. If the ASID is found, it is replaced with a null capability; otherwise, the operation fails.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Delete a particular ASID, decactivating the PD using it\n * in the process.\n "}
{"spec": "definition\n  deleting_irq_handler :: \"cdl_irq \\<Rightarrow> unit k_monad\"\nwhere\n \"deleting_irq_handler irq \\<equiv>\n    gets (get_irq_slot irq) >>= delete_cap_simple\"\n\ndefinition\n  cancel_ipc ::\"cdl_object_id \\<Rightarrow> unit k_monad\"\n  where \"cancel_ipc ptr \\<equiv>\n  do cap \\<leftarrow> KHeap_D.get_cap (ptr,tcb_pending_op_slot);\n   (case cap of\n    PendingSyncRecvCap _ is_reply _ \\<Rightarrow> ( do\n     when is_reply $ update_thread_fault ptr (\\<lambda>x. False);\n     revoke_cap_simple (ptr,tcb_replycap_slot);\n     when (\\<not> is_reply) $ set_cap (ptr,tcb_pending_op_slot) NullCap\n     od )\n   | PendingSyncSendCap _ _ _ _ _ _ \\<Rightarrow> (do\n     revoke_cap_simple (ptr,tcb_replycap_slot);\n     set_cap (ptr,tcb_pending_op_slot) NullCap\n     od)\n   | PendingNtfnRecvCap _ \\<Rightarrow> (do\n     revoke_cap_simple (ptr,tcb_replycap_slot);\n     set_cap (ptr, tcb_pending_op_slot) NullCap\n     od)\n   | _ \\<Rightarrow> return ())\n  od\"\n\ndefinition\n  prepare_thread_delete ::\"cdl_object_id \\<Rightarrow> unit k_monad\"\n  where \"prepare_thread_delete ptr \\<equiv> return ()\" (* for ARM it does nothing *)", "property": "IRQ Handler Deletion: Upon deleting an IRQ handler capability, the corresponding slot is cleared. Additionally, for a thread, any pending IPC operations are canceled by revoking related capabilities and setting the pending operation slot to `NullCap`. This ensures that the system maintains a consistent state after the deletion of an IRQ handler.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "Actions to be taken after deleting an IRQ Handler capability."}
{"spec": "fun\n  finalise_cap :: \"cdl_cap \\<Rightarrow> bool \\<Rightarrow> (cdl_cap \\<times> cdl_cap) k_monad\"\nwhere\n  \"finalise_cap NullCap                  final = return (NullCap, NullCap)\"\n| \"finalise_cap RestartCap               final = return (NullCap, NullCap)\"\n| \"finalise_cap (UntypedCap dev r a)           final = return (NullCap, NullCap)\"\n| \"finalise_cap (EndpointCap r b R)      final =\n      (liftM (K (NullCap, NullCap)) $ when  final $ cancel_all_ipc r)\"\n| \"finalise_cap (NotificationCap r b R) final =\n      (liftM (K (NullCap, NullCap)) $ when  final $\n       do\n         unbind_maybe_notification r;\n         cancel_all_ipc r\n       od)\"\n| \"finalise_cap (ReplyCap r R)           final = return (NullCap, NullCap)\"\n| \"finalise_cap (MasterReplyCap r)       final = return (NullCap, NullCap)\"\n| \"finalise_cap (CNodeCap r bits g sz)   final =\n      (return (if final then ZombieCap r else NullCap, NullCap))\"\n| \"finalise_cap (TcbCap r)               final =\n      (do\n         when final $ (do unbind_notification r;\n         cancel_ipc r;\n         KHeap_D.set_cap (r, tcb_pending_op_slot) cdl_cap.NullCap;\n         prepare_thread_delete r od);\n         return (if final then (ZombieCap r) else NullCap, NullCap)\n       od)\"\n| \"finalise_cap (PendingSyncSendCap r _ _ _ _ _) final = return (NullCap, NullCap)\"\n| \"finalise_cap (PendingSyncRecvCap r _ _) final = return (NullCap, NullCap)\"\n| \"finalise_cap (PendingNtfnRecvCap r)  final = return (NullCap, NullCap)\"\n| \"finalise_cap IrqControlCap            final = return (NullCap, NullCap)\"\n| \"finalise_cap (IrqHandlerCap irq)      final = (\n       if final then do\n         deleting_irq_handler irq;\n         return (NullCap, (IrqHandlerCap irq))\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (ZombieCap r)            final =\n      (do assert final; return (ZombieCap r, NullCap) od)\"\n| \"finalise_cap (AsidPoolCap ptr asid)        final = (\n       if final then do\n         delete_asid_pool asid ptr;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap AsidControlCap           final = return (NullCap,NullCap)\"\n| \"finalise_cap (PageDirectoryCap ptr x (Some asid))   final = (\n       if final \\<and> x = Real then do\n         delete_asid asid ptr;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (PageTableCap ptr x (Some asid))     final = (\n       if (final \\<and> x = Real) then do\n         unmap_page_table asid ptr;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (FrameCap dev ptr _ s x (Some asid))       final = (\n       if x = Real then do\n         unmap_page asid ptr s;\n         return (NullCap, NullCap)\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap _ final = return (NullCap, NullCap)\"", "property": "Capability Finalization: Perform necessary actions when a capability is deleted, such as canceling IPC, unbinding notifications, and clearing IRQs. If the deletion requires a long-running operation, return a Zombie capability.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "Actions that must be taken when a capability is deleted. Returns a\nZombie capability if deletion requires a long-running operation and also a\npossible IRQ to be cleared."}
{"spec": "lemma fast_finalise_def2:\n  \"fast_finalise cap final = do\n     assert (can_fast_finalise cap);\n     result \\<leftarrow> finalise_cap cap final;\n     assert (result = (NullCap, NullCap))\n   od\"\n  unfolding can_fast_finalise_def\n  by (rule finalise_cap.cases[of \"(cap,final)\"]; simp add: assert_def liftM_def)", "property": "Fast Finalize Operation: Ensures that a capability is deleted when it is known that a long-running operation is impossible, by asserting the capability can be fast finalized and verifying the result of the finalization is a null capability.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "The fast_finalise operation is used to delete a capability when it is\nknown that a long-running operation is impossible. It is equivalent to calling\nthe regular finalise operation. It cannot be defined in that way as doing so\nwould create a circular definition."}
{"spec": "definition\n  swap_cap :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"swap_cap cap1 slot1 cap2 slot2 \\<equiv> do\n     set_cap slot1 cap2;\n     set_cap slot2 cap1;\n     swap_parents slot1 slot2\n  od\"", "property": "Atomic Cap Swap: Atomically swap the contents of two capability slots, ensuring that the operation is performed in a single, indivisible step to maintain system integrity.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Atomically swap the two given caps.\n "}
{"spec": "definition\n  move_cap :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n  \"move_cap cap src_slot dest_slot \\<equiv> do\n     insert_cap_orphan cap dest_slot;\n     set_cap src_slot NullCap;\n     swap_parents src_slot dest_slot\n  od\"\n\ndefinition\n  monadic_rel_optionation_form :: \"('a \\<Rightarrow> ('s, 'b) nondet_monad)\n      \\<Rightarrow> (('a \\<times> 's) option \\<times> ('b \\<times> 's) option) set\"\nwhere\n \"monadic_rel_optionation_form f =\n    {(x, y). (x \\<noteq> None \\<and> y \\<noteq> None \\<and> the y \\<in> fst (case_prod f (the x)))\n           \\<or> (x \\<noteq> None \\<and> y = None \\<and> snd (case_prod f (the x)))\n           \\<or> (x = None \\<and> y = None)}\"\n\ndefinition\n  monadic_option_dest :: \"('a \\<times> 's) option set \\<Rightarrow> (('a \\<times> 's) set \\<times> bool)\"\nwhere\n \"monadic_option_dest S = (Some -` S, None \\<in> S)\"\n\nlemma use_option_form:\n  \"f x = (\\<lambda>s. monadic_option_dest  (monadic_rel_optionation_form f `` {Some (x, s)}))\"\n  by (simp add: monadic_rel_optionation_form_def monadic_option_dest_def)\n\nlemma ex_option: \" (\\<exists>x. P x) = ((\\<exists>y. P (Some y)) \\<or> P None)\"\n  apply safe\n  apply (case_tac x, auto)\n  done\n\nlemma use_option_form_bind:\n  \"f x >>= g = (\\<lambda>s. monadic_option_dest\n       ((monadic_rel_optionation_form f O monadic_rel_optionation_form g) `` {Some (x, s)}))\"\n  apply (rule ext)\n  apply (simp add: monadic_rel_optionation_form_def monadic_option_dest_def\n                   bind_def split_def)\n  apply (simp add: relcomp_unfold ex_option image_def prod_eq_iff Bex_def)\n  apply fastforce\n  done\n\ndefinition\n  monadic_trancl :: \"('a \\<Rightarrow> ('s, 'a) nondet_monad)\n       \\<Rightarrow> 'a \\<Rightarrow> ('s, 'a) nondet_monad\"\nwhere\n \"monadic_trancl f x = (\\<lambda>s. monadic_option_dest ((monadic_rel_optionation_form f)\\<^sup>* `` {Some (x, s)}))\"\n\ndefinition\n  monadic_trancl_preemptible ::\n     \"('a \\<Rightarrow> ('s, 'e + 'a) nondet_monad)\n         \\<Rightarrow> ('a \\<Rightarrow> ('s, 'e + 'a) nondet_monad)\"\nwhere\n \"monadic_trancl_preemptible f x\n    = monadic_trancl (lift f) (Inr x)\"\n\ndefinition\n  cap_removeable :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> bool\"\nwhere\n \"cap_removeable cap slot s =\n   (cap = NullCap\n      \\<or> (\\<exists>p. cap = ZombieCap p \\<and> swp opt_cap s ` (({p} \\<times> UNIV) - {slot})\n              \\<subseteq> {Some NullCap, None}))\"\n\ndefinition\n  finalise_slot_inner1 :: \"cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> bool) k_monad\"\nwhere\n \"finalise_slot_inner1 victim = do\n    cap \\<leftarrow> get_cap victim;\n    final \\<leftarrow> is_final_cap cap;\n    (cap', irqopt) \\<leftarrow> finalise_cap cap final;\n    removeable \\<leftarrow> gets $ cap_removeable cap' victim;\n    when (\\<not> removeable) (set_cap victim cap')\n        \\<sqinter> set_cap victim cap';\n    return (cap', removeable)\n  od\"\n\ndefinition\n  get_zombie_range :: \"cdl_cap \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\"\nwhere\n \"get_zombie_range cap =\n    (\\<lambda>s. case cap of ZombieCap p \\<Rightarrow> dom (swp opt_cap s) \\<inter> ({p} \\<times> UNIV)\n               | _ \\<Rightarrow> {})\"\n\ndefinition\n  swap_for_delete :: \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\"\nwhere\n \"swap_for_delete ptr1 ptr2 = do\n    cap1 \\<leftarrow> get_cap ptr1;\n    cap2 \\<leftarrow> get_cap ptr2;\n    swap_cap cap1 ptr1 cap2 ptr2\n  od\"\n\ndefinition\n \"finalise_slot_inner2 =\n      (\\<lambda>(region, finalised).\n        liftE (do (victim', remove) \\<leftarrow> select region;\n          (cap', removeable) \\<leftarrow> finalise_slot_inner1 victim';\n          region' \\<leftarrow> gets $ get_zombie_range cap';\n          return (region \\<union> (region' \\<times> {True}), if removeable then {(victim', remove)} else {})\n        od) \\<sqinter>\n        liftE (do (slot, slot') \\<leftarrow> select {(x, y). (x, True) \\<in> region \\<and> (y, True) \\<in> region \\<and> x \\<noteq> y};\n          swap_for_delete slot slot';\n          return (region, {})\n        od) \\<sqinter>\n        liftE (do victim' \\<leftarrow> select {x. (x, True) \\<in> finalised};\n          empty_slot victim';\n          return (region, {})\n        od) \\<sqinter>\n        throw\n      )\"\n\ndefinition\n  finalise_slot :: \"cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n \"finalise_slot victim = doE\n    (region, finalised) \\<leftarrow>\n      monadic_trancl_preemptible finalise_slot_inner2\n        ({(victim, False)}, {});\n    whenE (victim \\<notin> fst ` finalised) throw\n  odE\"\n\ndefinition\n  delete_cap :: \"cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n \"delete_cap victim = doE\n    finalise_slot victim;\n    liftE $ empty_slot victim\n  odE\"", "property": "Cap Movement and Finalization: Enables the movement of a capability from one location to another, potentially modifying it in the process. It also supports the finalization and deletion of capabilities, ensuring that they are properly removed and their resources are freed, while handling zombie capabilities and maintaining system integrity.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Move the given cap from one location to another,\n * possibly modifying it along the way.\n "}
{"spec": "definition\n  revoke_cap :: \"cdl_cap_ref \\<Rightarrow> unit preempt_monad\"\nwhere\n  \"revoke_cap victim = doE\n     fin \\<leftarrow> monadic_trancl_preemptible (K (doE\n          S \\<leftarrow> liftE $ gets $ descendants_of victim;\n          if S = {} then returnOk True\n          else doE\n            child \\<leftarrow> liftE $ select S;\n            cap \\<leftarrow> liftE $ get_cap child;\n            assertE (cap \\<noteq> NullCap);\n            delete_cap child;\n            Monads_D.throw \\<sqinter> returnOk False\n          odE\n       odE)) False;\n     unlessE fin throw\n   odE\"", "property": "Revoke Cap and Descendants: Recursively revokes the given capability and all its descendants. If the capability being revoked is encountered during the process, an exception is thrown. This ensures that the capability and its entire lineage are removed from the system, maintaining the integrity of the capability hierarchy.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Revoke all the descendants of the given cap.\n *\n * If the CDT is being modelled, this will delete all the\n * descendants of the given cap. Wonderful things happen\n * if we happen to, in this process, delete something\n * that contains the cap we are trying to revoke.\n "}
{"spec": "definition\n  get_tcb_ep_badge :: \"cdl_tcb \\<Rightarrow> cdl_badge option\"\nwhere\n  \"get_tcb_ep_badge t \\<equiv>\n    case (cdl_tcb_caps t tcb_pending_op_slot) of\n      Some (PendingSyncSendCap _ badge _ _ _ _) \\<Rightarrow> Some badge\n    | _ \\<Rightarrow> None\"", "property": "Retrieve Badge for IPC Send Operation: Obtain the badge used by a thread for its pending IPC send operation, if such an operation exists.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Get the badge the given thread object is using to\n * perform its IPC send operation.\n "}
{"spec": "definition\n  cancel_badged_sends :: \"cdl_object_id \\<Rightarrow> cdl_badge \\<Rightarrow> unit k_monad\"\nwhere\n  \"cancel_badged_sends ep badge \\<equiv>\n    modify (\\<lambda>s. s\\<lparr>cdl_objects := map_option\n        (\\<lambda>obj. case obj of\n            Tcb t \\<Rightarrow>\n              if (is_thread_blocked_on_endpoint t ep\n                  \\<and> get_tcb_ep_badge t = Some badge) then\n                    Tcb (remove_pending_operation t cdl_cap.RestartCap)\n              else\n                Tcb t\n          | _ \\<Rightarrow> obj) \\<circ> (cdl_objects s)\\<rparr>)\"", "property": "Cancel Badged Sends: Cancels all pending send operations to a specified endpoint that are using a specific badge. This ensures that any blocked threads associated with the given endpoint and badge are unblocked and their pending operations are removed.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Cancel all pending send operations to the given endpoint\n * that are using the given badge.\n "}
{"spec": "definition\n  clear_object_caps :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n \"clear_object_caps ptr = do\n    ptrs \\<leftarrow> gets (\\<lambda>s. {cptr. fst cptr = ptr \\<and> opt_cap cptr s \\<noteq> None});\n    ptrlist \\<leftarrow> select {xs. set xs = ptrs \\<and> distinct xs};\n    mapM_x empty_slot ptrlist\n  od\"\n\ndefinition cdl_default_tcb :: \"cdl_object\"\nwhere \"cdl_default_tcb \\<equiv>  Tcb \\<lparr>cdl_tcb_caps =\n           [tcb_cspace_slot \\<mapsto> cdl_cap.NullCap, tcb_vspace_slot \\<mapsto> cdl_cap.NullCap, tcb_replycap_slot \\<mapsto>\n            cdl_cap.NullCap, tcb_caller_slot \\<mapsto> cdl_cap.NullCap, tcb_ipcbuffer_slot \\<mapsto> cdl_cap.NullCap,\n            tcb_pending_op_slot \\<mapsto> cdl_cap.NullCap, tcb_boundntfn_slot \\<mapsto> cdl_cap.NullCap],\n           cdl_tcb_fault_endpoint = 0,\n           cdl_tcb_intent =\n             \\<lparr>cdl_intent_op = None, cdl_intent_error = False,cdl_intent_cap = 0, cdl_intent_extras = [],\n                cdl_intent_recv_slot = None\\<rparr>, cdl_tcb_has_fault = False, cdl_tcb_domain = minBound\\<rparr>\"\n\ndefinition obj_tcb :: \"cdl_object \\<Rightarrow> cdl_tcb\"\nwhere \"obj_tcb obj \\<equiv> case obj of Tcb tcb \\<Rightarrow> tcb\"\n\ndefinition tcb_caps_merge :: \"cdl_tcb \\<Rightarrow> cdl_tcb \\<Rightarrow> cdl_tcb\"\n  where \"tcb_caps_merge regtcb captcb \\<equiv> regtcb\\<lparr>cdl_tcb_caps\n  := (cdl_tcb_caps captcb)(tcb_pending_op_slot \\<mapsto> the (cdl_tcb_caps regtcb tcb_pending_op_slot), tcb_boundntfn_slot \\<mapsto> the (cdl_tcb_caps regtcb tcb_boundntfn_slot))\\<rparr>\"\n\ndefinition merge_with_dft_tcb :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere \"merge_with_dft_tcb o_id \\<equiv>\n do\n  new_intent \\<leftarrow> select UNIV;\n  KHeap_D.update_thread o_id (cdl_tcb_intent_update (\\<lambda>x. new_intent) \\<circ> (tcb_caps_merge (obj_tcb cdl_default_tcb)))\n od\"\n\nfun\n  reset_mem_mapping :: \"cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"reset_mem_mapping (FrameCap dev p rts sz b mp) = FrameCap dev p rts sz b None\"\n| \"reset_mem_mapping (PageTableCap ptr b mp) = PageTableCap ptr b None\"\n| \"reset_mem_mapping (PageDirectoryCap ptr b ma) = PageDirectoryCap ptr b None\"\n| \"reset_mem_mapping cap = cap\"", "property": "Object Recycle and Reset: The target object is reset to its initial state, with any children capabilities first being revoked. The process involves clearing the object's capabilities, resetting memory mappings, and merging the object with a default template to restore its initial configuration.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Regenerate the target object.\n *\n * Any children of the cap are first revoked. The object\n * is then reset into its original (as-if just created)\n * state. But maybe not. It's complex.\n *\n * In the C implementation, attempting to recycle a\n * non-master cap may do something that is not\n * a recycle. (Should be perhaps return an error?)\n "}
{"spec": "function\n  resolve_address_bits ::\n  \"cdl_cap \\<Rightarrow> cdl_cptr \\<Rightarrow> nat \\<Rightarrow> (cdl_cap_ref \\<times> nat) fault_monad\"\nwhere\n  \"resolve_address_bits cnode_cap cap_ptr remaining_size = doE\n    unlessE (is_cnode_cap cnode_cap) $ throw;\n\n    \\<comment> \\<open>Fetch the next level CNode.\\<close>\n    cnode \\<leftarrow> liftE $ get_cnode $ cap_object cnode_cap;\n    radix_size \\<leftarrow> returnOk $ cdl_cnode_size_bits cnode;\n    guard_size \\<leftarrow> returnOk $ cap_guard_size cnode_cap;\n    cap_guard  \\<leftarrow> returnOk $ cap_guard cnode_cap;\n    level_size \\<leftarrow> returnOk (radix_size + guard_size);\n    assertE (level_size \\<noteq> 0);\n\n    \\<comment> \\<open>Ensure the guard matches up.\\<close>\n    guard \\<leftarrow> returnOk $ (cap_ptr >> (remaining_size-guard_size)) && (mask guard_size);\n    unlessE (guard_size \\<le> remaining_size \\<and> guard = cap_guard) $ throw;\n\n    \\<comment> \\<open>Ensure we still enough unresolved bits left in our CPTR.\\<close>\n    whenE (level_size > remaining_size) $ throw;\n\n    \\<comment> \\<open>Find the next slot.\\<close>\n    offset \\<leftarrow> returnOk $ (cap_ptr >> (remaining_size-level_size)) && (mask radix_size);\n    slot \\<leftarrow> returnOk (cap_object cnode_cap, unat offset);\n    size_left \\<leftarrow> returnOk (remaining_size - level_size);\n    if (size_left = 0) then\n      returnOk (slot, 0)\n    else\n      doE\n        next_cap \\<leftarrow> liftE $ get_cap (slot);\n        if is_cnode_cap next_cap then\n          resolve_address_bits next_cap cap_ptr size_left\n        else\n          returnOk (slot, size_left)\n      odE\n  odE\"\n  by fastforce+\n\ntermination resolve_address_bits\n  apply (relation \"measure (\\<lambda>(a,b,c). c)\")\n  apply (auto simp: in_monad)\n  done\n\ndefinition\n  lookup_slot :: \"cdl_object_id \\<Rightarrow> cdl_cptr \\<Rightarrow> cdl_cap_ref fault_monad\"\nwhere\n  \"lookup_slot thread cptr \\<equiv>\n    doE\n      cspace_root \\<leftarrow> liftE $ get_cap (thread, tcb_cspace_slot);\n      (slot, _) \\<leftarrow> resolve_address_bits cspace_root cptr word_bits;\n      returnOk slot\n    odE\"\n\ndefinition\n  lookup_cap :: \"cdl_object_id \\<Rightarrow> cdl_cptr \\<Rightarrow> cdl_cap fault_monad\"\nwhere\n  \"lookup_cap thread cptr \\<equiv>\n    doE\n      slot \\<leftarrow> lookup_slot thread cptr;\n      liftE $ get_cap slot\n    odE\"\n\ndefinition\n  lookup_cap_and_slot :: \"cdl_object_id \\<Rightarrow> cdl_cptr \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) fault_monad\"\nwhere\n  \"lookup_cap_and_slot thread cptr \\<equiv>\n    doE\n      slot \\<leftarrow> lookup_slot thread cptr;\n      cap \\<leftarrow> liftE $ get_cap slot;\n      returnOk (cap, slot)\n    odE\"\n\ndefinition\n  lookup_slot_for_cnode_op :: \"cdl_cap \\<Rightarrow> cdl_cptr \\<Rightarrow> nat \\<Rightarrow> cdl_cap_ref except_monad\"\nwhere\n  \"lookup_slot_for_cnode_op croot cptr depth \\<equiv>\n    doE\n      whenE (depth < 1 \\<or> depth > word_bits) throw;\n      (slot, rem) \\<leftarrow> fault_to_except $ resolve_address_bits croot cptr depth;\n      if rem = 0 then returnOk slot else throw\n    odE\"", "property": "Capability Address Resolution: Resolve a user's capability pointer (CPTR) into a corresponding capability slot by walking through the CSpace, ensuring that the guard and remaining bits are correctly matched at each level. This process validates the CPTR and retrieves the final cap slot, ensuring the integrity and correctness of the capability lookup.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Walk a user's CSpace to convert a user's CPTR into a cap slot.\n "}
{"spec": "definition\n  badge_update :: \"word32 \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap\"\nwhere\n  \"badge_update data cap \\<equiv> update_cap_badge (data && mask badge_bits) cap\"", "property": "Update Cap Badge: Modify the badge of a capability by applying a mask to the provided data, ensuring that only the bits that can be stored by the lower specifications are updated.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Update the badge of a cap, masking off bits the lower specs are unable\n * to store for implementation reasons.\n "}
{"spec": "definition\n  update_cap_data :: \"bool \\<Rightarrow> word32 \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap k_monad\"\nwhere\n  \"update_cap_data preserve data cap \\<equiv>\n    return $ case cap of\n        EndpointCap _ b _ \\<Rightarrow>\n          if b = 0 \\<and> \\<not> preserve then\n            badge_update data cap\n          else\n            NullCap\n      | NotificationCap _ b _ \\<Rightarrow>\n          if b = 0 \\<and> \\<not> preserve then\n            badge_update data cap\n          else\n            NullCap\n      | CNodeCap object guard guard_size sz \\<Rightarrow>\n          let\n            reserved_bits = 3;\n            guard_bits = 18;\n            guard_size_bits = 5;\n\n            new_guard_size = unat ((data >> reserved_bits) && mask guard_size_bits);\n            new_guard = (data >> (reserved_bits + guard_size_bits)) && mask (min (unat ((data >> reserved_bits) && mask guard_size_bits)) guard_bits)\n          in\n            if new_guard_size + sz > word_bits then NullCap else\n            (CNodeCap object new_guard new_guard_size sz)\n      | _ \\<Rightarrow> cap\"", "property": "Update Capability Data: Transform a capability based on user request, interpreting the \"data\" word differently for various cap types. For Endpoint and Notification caps, update the badge if the current badge is 0 and preservation is not required. For CNode caps, update the guard and guard size based on the data, ensuring the new guard size does not exceed the word bits. Other cap types remain unchanged.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Transform a capability based on a request from the user.\n *\n * The \"data\" word is interpreted differently for different cap types.\n *\n * We return a set of possible caps to allow for non-deterministic\n * implementations, to avoid messy implementation details of the CDT\n * in lower-level models.\n "}
{"spec": "definition\n  derive_cap :: \"cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> cdl_cap except_monad\"\nwhere\n  \"derive_cap slot cap \\<equiv> case cap of\n     UntypedCap _ _ _ \\<Rightarrow> doE ensure_no_children slot; returnOk cap odE\n   | ReplyCap _ _ \\<Rightarrow> returnOk NullCap\n   | MasterReplyCap oref \\<Rightarrow> returnOk NullCap\n   | IrqControlCap \\<Rightarrow> returnOk NullCap\n   | ZombieCap _ \\<Rightarrow> returnOk NullCap\n   | FrameCap dev p r sz b x \\<Rightarrow> returnOk (FrameCap dev p r sz b None)\n   | PageTableCap _ _ _ \\<Rightarrow> throw \\<sqinter> returnOk cap\n   | PageDirectoryCap _ _ _ \\<Rightarrow> throw \\<sqinter> returnOk cap\n   | _ \\<Rightarrow> returnOk cap\"", "property": "Derive Capabilities: Derives a new capability from an existing one, potentially returning a modified version or `NullCap` for certain types. For `FrameCap`, it clears the badge. For `PageTableCap` and `PageDirectoryCap`, it may throw an exception or return the original capability, reflecting the nondeterminism in their handling. Other capabilities are returned unchanged.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": "\n * Some caps may not be copied/minted. In this case the following function\n * returns NullCap or throws.\n *\n * PageTable and PageDirectory caps may not be copied if already mapped. This is\n * left out here and modelled by nondeterminism.\n "}
{"spec": "definition\n  corrupt_tcb_intent :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\nwhere\n  \"corrupt_tcb_intent target_tcb \\<equiv>\n    do\n      new_intent \\<leftarrow> select UNIV;\n      update_thread target_tcb (\\<lambda>t. t\\<lparr>cdl_tcb_intent := new_intent\\<rparr>)\n    od\"\n\nend", "property": "Arbitrary TCB Corruption: Allows the modification of a TCB's IPC buffer or registers to an arbitrary new state, ensuring that the TCB's intent can be altered as needed.", "title": "./spec/capDL/CSpace_D.thy", "chapter": "", "section": "", "comment": " Modify the TCB's IpcBuffer or Registers in an arbitrary fashion. "}
{"spec": "(*\n * The basic monads used in capDL\n *)\n\ntheory Monads_D\nimports\n  Types_D\n  Monads.Nondet_In_Monad\n  Monads.Nondet_VCG\nbegin", "property": "Basic Monads for capDL: Defines the fundamental monadic structures used in the capDL system, providing a foundation for handling non-determinism and verification conditions within the system.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "type_synonym 'a k_monad = \"(cdl_state, 'a) nondet_monad\"\n\ndatatype cdl_except_error = ExceptError\ndatatype cdl_preempt_error = PreemptError\ndatatype cdl_fault_error = FaultError", "property": "Kernel State Monad: Represents a monadic computation in the kernel state, which can handle non-deterministic operations and specific error types including exceptions, preemptions, and faults.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Kernel state monad "}
{"spec": "type_synonym 'a except_monad = \"(cdl_state, cdl_except_error + 'a) nondet_monad\"", "property": "Exception Handling: Manages operations that may result in exceptions, providing a mechanism to handle errors without additional exception information.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Exception monad, no further exception information "}
{"spec": "type_synonym 'a preempt_monad = \"(cdl_state, cdl_preempt_error + 'a) nondet_monad\"", "property": "Exception Handling in Preemption: The preemption monad encapsulates operations that may result in a preemption error, providing a structured way to handle exceptions without additional error information.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Exception monad, no further exception information "}
{"spec": "type_synonym 'a fault_monad =  \"(cdl_state, cdl_fault_error + 'a) nondet_monad\"\n\nabbreviation\n  throw :: \"(cdl_state, 'a + 'b) nondet_monad\" where\n  \"throw == throwError undefined\"", "property": "Exception Handling: The fault monad allows for the throwing of exceptions, where `throw` is used to signal an error by returning an undefined value. This mechanism ensures that errors can be propagated and handled within the system.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Exception monad, no further exception information "}
{"spec": "definition\n  preemption_point :: \"unit preempt_monad\" where\n \"preemption_point \\<equiv> throw \\<sqinter> returnOk ()\"", "property": "Preemption Point: Allow the system to preempt the current thread at a specified point, enabling the scheduler to potentially switch to a different thread.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": "Allow preemption at this point."}
{"spec": "definition\n  unify_failure :: \"('f + 'a) k_monad \\<Rightarrow> (unit + 'a) k_monad\" where\n \"unify_failure m \\<equiv> handleE' m (\\<lambda>x. throwError ())\"", "property": "Unify Failure: Convert an exception monad with an arbitrary type into a new exception monad with a unit type, handling any failure by throwing a unit error.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": "\n * Convert an exception monad with aribtrary type into a\n * new exception monad with unit type.\n "}
{"spec": "definition\n  fault_to_except :: \"'a fault_monad \\<Rightarrow> 'a except_monad\"\nwhere\n  \"fault_to_except m \\<equiv> handleE' m (\\<lambda>x. throw)\"", "property": "Convert Fault Monad to Exception Monad: Transforms a fault monad into an exception monad by handling faults and throwing exceptions.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": "\n  Convert a fault monad into an exception monad.\n"}
{"spec": "definition\n  option_select :: \"'a set \\<Rightarrow> ('s, 'a option) nondet_monad\"\nwhere\n  \"option_select S \\<equiv>\n    if S = {} then\n      return None\n    else\n      select S >>= (\\<lambda>a. return (Some a))\"", "property": "Non-deterministic Selection: Select an item from a given set non-deterministically. If the set is empty, return `None`.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": "\n * Non-deterministically select an item from the given set.\n * If the set if empty, return 'None'.\n "}
{"spec": "definition\n  throw_on_none :: \"'a option \\<Rightarrow> ('e + 'a) k_monad\"\nwhere\n  \"throw_on_none x \\<equiv>\n    case x of\n        None \\<Rightarrow> throw\n      | Some y \\<Rightarrow> returnOk y\"\n\n\nend", "property": "Error Handling for Optional Values: Ensures that if the given object is 'None', an error is thrown; otherwise, the object is returned successfully.", "title": "./spec/capDL/Monads_D.thy", "chapter": "", "section": "", "comment": " Return the given object, throwing an error if it is 'None'. "}
{"spec": "theory Invocations_D\nimports Types_D\nbegin\n\ndatatype cdl_cnode_invocation =\n    InsertCall cdl_cap cdl_cap_ref cdl_cap_ref\n  | MoveCall cdl_cap cdl_cap_ref cdl_cap_ref\n  | RevokeCall cdl_cap_ref\n  | DeleteCall cdl_cap_ref\n  | RotateCall cdl_cap cdl_cap cdl_cap_ref cdl_cap_ref cdl_cap_ref\n  | SaveCall cdl_cap_ref\n  | CancelBadgedSendsCall cdl_cap\n\ndatatype cdl_untyped_invocation =\n    Retype cdl_cap_ref\n        cdl_object_type cdl_size_bits \"cdl_cap_ref list\" bool nat\n\ndatatype cdl_tcb_invocation =\n    WriteRegisters cdl_object_id bool \"word32 list\" nat\n  | ReadRegisters cdl_object_id bool word32 nat\n  | CopyRegisters cdl_object_id cdl_object_id bool bool bool bool nat\n  | ThreadControl cdl_object_id cdl_cap_ref\n        \"cdl_cptr option\"\n        \"(cdl_cap \\<times> cdl_cap_ref) option\"\n        \"(cdl_cap \\<times> cdl_cap_ref) option\"\n        \"(cdl_cap \\<times> cdl_cap_ref) option\"\n  | Suspend cdl_object_id\n  | Resume cdl_object_id\n  | NotificationControl cdl_object_id \"cdl_object_id option\"\n  | SetTLSBase cdl_object_id\n\ndatatype arch_cdl_irq_control_invocation =\n    ARMIssueIrqHandler cdl_irq cdl_cap_ref cdl_cap_ref bool\n\ndatatype cdl_irq_control_invocation =\n    IssueIrqHandler cdl_irq cdl_cap_ref cdl_cap_ref\n  | ArchIssueIrqHandler arch_cdl_irq_control_invocation\n\ndatatype cdl_irq_handler_invocation =\n    AckIrq cdl_irq\n  | SetIrqHandler cdl_irq cdl_cap cdl_cap_ref\n  | ClearIrqHandler cdl_irq\n\ndatatype cdl_endpoint_invocation =", "property": "CNode Invocation: Supports operations on capabilities within a CNode, including inserting, moving, revoking, deleting, rotating, saving, and canceling badged sends. These operations allow for the dynamic management of capabilities, ensuring flexibility and security in capability-based systems.\n\nUntyped Invocation: Enables re-typing of untyped memory regions into typed objects, specifying the type, size, and target locations. This allows for the creation and allocation of various object types from untyped memory, providing a flexible memory management system.\n\nTCB Invocation: Allows threads to perform actions such as suspending and resuming other threads, controlling thread settings, copying and reading/writing registers, and managing notifications. These actions ensure that threads can manage their state and capabilities effectively, maintaining the integrity and performance of the system.\n\nIRQ Control Invocation: Manages IRQ handlers by issuing, setting, and clearing them, with support for architecture-specific IRQ handling. This ensures that interrupt requests are handled efficiently and securely, allowing for proper system response to hardware events.\n\nIRQ Handler Invocation: Provides mechanisms to acknowledge, set, and clear IRQ handlers, ensuring that interrupts are managed correctly and the system can respond to hardware events in a timely and controlled manner.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "SyncMessage cdl_badge bool bool cdl_object_id\n\ndatatype cdl_notification_invocation =", "property": "Notification Invocation: Allows the management of notifications, including setting a badge, granting, and replying to notifications. This ensures that threads can communicate and coordinate effectively through notification mechanisms.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": " badge, grant, grant reply, ep "}
{"spec": "Signal cdl_badge cdl_object_id\n\ndatatype cdl_reply_invocation =\n    ReplyMessage cdl_object_id cdl_cap_ref bool (* can grant *)\n\ndatatype cdl_page_table_invocation =", "property": "Signal Notification: A signal is associated with a badge (notification word) and a notification object, allowing for the delivery of notifications to specific objects with designated badges.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": " badge (notification word) and notification object "}
{"spec": "PageTableMap cdl_cap cdl_cap cdl_cap_ref cdl_cap_ref", "property": "PageTable Mapping: Establishes a mapping between a real page table capability and a target page directory slot, ensuring that the page table is correctly referenced and accessible within the memory hierarchy.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": " PageTableMap <real_pt_cap> <pt_cap> <pt_cap_ref> <pd_target_slot> "}
{"spec": "| PageTableUnmap \"cdl_mapped_addr option\"  cdl_object_id cdl_cap_ref\n\ndatatype cdl_asid_control_invocation =\n    MakePool cdl_cap cdl_cap_ref \"cdl_object_id set\" cdl_cap_ref nat\n\ndatatype cdl_asid_pool_invocation =\n    Assign cdl_asid cdl_cap_ref cdl_cap_ref\n\ndatatype flush =\n   Clean | Invalidate | CleanInvalidate | Unify\n\ndatatype cdl_page_invocation =\n    PageMap cdl_cap cdl_cap cdl_cap_ref \"cdl_cap_ref list\"\n  | PageUnmap \"cdl_mapped_addr option\" cdl_object_id \"cdl_cap_ref\" nat\n  | PageFlushCaches flush\n  | PageGetAddress\n\n\ndatatype cdl_page_directory_invocation =\n   PageDirectoryFlush  flush\n | PageDirectoryNothing\n\n\ndatatype cdl_domain_invocation =\n  SetDomain cdl_object_id word8\n\ndatatype cdl_invocation =\n    InvokeUntyped cdl_untyped_invocation\n  | InvokeEndpoint cdl_endpoint_invocation\n  | InvokeNotification cdl_notification_invocation\n  | InvokeReply cdl_reply_invocation\n  | InvokeTcb cdl_tcb_invocation\n  | InvokeDomain cdl_domain_invocation\n  | InvokeCNode cdl_cnode_invocation\n  | InvokeIrqControl cdl_irq_control_invocation\n  | InvokeIrqHandler cdl_irq_handler_invocation\n  | InvokePageTable cdl_page_table_invocation\n  | InvokePage cdl_page_invocation\n  | InvokePageDirectory cdl_page_directory_invocation\n  | InvokeAsidControl cdl_asid_control_invocation\n  | InvokeAsidPool cdl_asid_pool_invocation\n\nend", "property": "Page Unmap Operation: Unmaps a page from the specified address in the page table, identified by the provided object ID and capability reference. This operation ensures that the page is no longer accessible through the given address, maintaining the integrity of the memory mapping.", "title": "./spec/capDL/Invocations_D.thy", "chapter": "", "section": "", "comment": " PageTableUnmap <mapped_addr option> <pt_obj_id> <pt_cap_ref> "}
{"spec": "(*\n * Accessor functions for objects and caps.\n *)\n\ntheory KHeap_D\nimports Monads_D\nbegin", "property": "Accessor Functions for Objects and Caps: Provide methods to access and manipulate objects and capabilities within the kernel heap, ensuring that the system can effectively manage and interact with these entities.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation\n  get_object :: \"cdl_object_id \\<Rightarrow> cdl_object k_monad\"\nwhere\n  \"get_object p \\<equiv> gets_the (\\<lambda>s. cdl_objects s p)\"", "property": "Retrieve Object: Fetch an object from the heap based on its ID. The operation fails if the specified object does not exist.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Return an item from the heap. Fail if no such object exists. "}
{"spec": "definition\n  set_object :: \"cdl_object_id \\<Rightarrow> cdl_object \\<Rightarrow> unit k_monad\"\nwhere\n  \"set_object p obj \\<equiv>\n    modify (\\<lambda>s. s \\<lparr> cdl_objects := (cdl_objects s) (p \\<mapsto> obj) \\<rparr> )\"", "property": "Heap Object Update: Set the value of a specified object in the heap to a given new object, updating the heap's state to reflect this change.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Set an item on the heap to the given object. "}
{"spec": "definition\n  get_thread :: \"cdl_object_id \\<Rightarrow> cdl_tcb k_monad\"\nwhere\n  \"get_thread p \\<equiv>\n    do\n      t \\<leftarrow> get_object p;\n      case t of\n          Tcb tcb \\<Rightarrow> return tcb\n        | _ \\<Rightarrow> fail\n    od\"", "property": "Retrieve Thread: Obtain the thread control block (TCB) from a given object pointer, ensuring that the object is indeed a TCB.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Get a thread from the given pointer. "}
{"spec": "definition\n  get_thread_fault :: \"cdl_object_id \\<Rightarrow> bool k_monad\"\nwhere\n  \"get_thread_fault p \\<equiv>\n    do\n      t \\<leftarrow> get_object p;\n      case t of\n          Tcb tcb \\<Rightarrow> return (cdl_tcb_has_fault tcb)\n        | _ \\<Rightarrow> fail\n    od\"", "property": "Retrieve Thread Fault Status: Obtain the fault status of a thread from the given pointer, returning whether the thread has a fault.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Get a thread from the given pointer. "}
{"spec": "definition\n  update_thread :: \"cdl_object_id \\<Rightarrow> (cdl_tcb \\<Rightarrow> cdl_tcb) \\<Rightarrow> unit k_monad\"\nwhere\n  \"update_thread p f \\<equiv>\n     do\n       t \\<leftarrow> get_object p;\n       case t of\n          Tcb tcb \\<Rightarrow> set_object p (Tcb (f tcb))\n       | _ \\<Rightarrow> fail\n     od\"", "property": "Thread Update: Modify a thread's state on the heap by applying a function to its current state. This ensures that the thread's properties can be updated dynamically while maintaining the integrity of the system.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Update a thread on the heap. "}
{"spec": "definition\n  update_thread_fault :: \"cdl_object_id \\<Rightarrow> (bool\\<Rightarrow>bool) \\<Rightarrow> unit k_monad\"\nwhere\n  \"update_thread_fault p f \\<equiv>\n     do\n       t \\<leftarrow> get_object p;\n       case t of\n          Tcb tcb \\<Rightarrow> set_object p (Tcb (tcb\\<lparr>cdl_tcb_has_fault := f (cdl_tcb_has_fault tcb)\\<rparr>))\n       | _ \\<Rightarrow> fail\n     od\"", "property": "Update Thread Fault: Modify the fault status of a thread by updating the `cdl_tcb_has_fault` field in the thread control block. This ensures that the thread's fault status is accurately reflected in the system.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Update a thread on the heap. "}
{"spec": "definition\n  get_cnode :: \"cdl_object_id \\<Rightarrow> cdl_cnode k_monad\"\nwhere\n  \"get_cnode p \\<equiv>\n    do\n      t \\<leftarrow> get_object p;\n      case t of\n          CNode cnode \\<Rightarrow> return cnode\n        | _ \\<Rightarrow> fail\n    od\"", "property": "Retrieve CNode: Obtain a CNode from the given object pointer. If the object is not a CNode, the operation fails.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Get a CNode from the given pointer. "}
{"spec": "definition\n  get_index :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a option\"\nwhere\n  \"get_index a b \\<equiv>\n     if b < length a then\n       Some (a ! b)\n     else\n       None\"", "property": "Retrieve Element by Index: Obtain an element from a list at a specified index, returning `None` if the index is out of bounds.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": "\n * Get the index out of the given list, returning None if it\n * doesn't exist.\n "}
{"spec": "definition\n  slots_of :: \"cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_map\"\nwhere\n  \"slots_of obj_id \\<equiv> \\<lambda>s.\n  case cdl_objects s obj_id of\n    None \\<Rightarrow> Map.empty\n  | Some obj \\<Rightarrow> object_slots obj\"", "property": "Retrieve Object Slots: Returns the slots of an object as a capability map. If the object does not exist or does not have any capabilities, it returns an empty map.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " The slots of an object, returns an empty map for non-existing objects\n   or objects that do not have caps "}
{"spec": "definition\n  opt_cap :: \"cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap option\"\nwhere\n  \"opt_cap \\<equiv> \\<lambda>(obj_id, slot) s. slots_of obj_id s slot\"", "property": "Retrieve Cap Option: Obtain the capability at the specified reference, returning `None` if the object or capability does not exist.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " The cap at the given cap_ref. None if object or cap does not exist "}
{"spec": "abbreviation\n  get_cap :: \"cdl_cap_ref \\<Rightarrow> cdl_cap k_monad\" where\n  \"get_cap p \\<equiv> gets_the (opt_cap p)\"", "property": "Retrieve the Capability: Obtain the capability associated with a given capability reference.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " monad version of opt_cap "}
{"spec": "definition\n  set_cap :: \"cdl_cap_ref \\<Rightarrow> cdl_cap \\<Rightarrow> unit k_monad\"\nwhere\n  \"set_cap \\<equiv> \\<lambda>(obj_id, slot) cap. do\n    obj \\<leftarrow> get_object obj_id;\n    assert (has_slots obj);\n    slots \\<leftarrow> return $ object_slots obj;\n    obj' \\<leftarrow> return $ update_slots (slots (slot \\<mapsto> cap)) obj;\n    obj'' \\<leftarrow> case obj' of\n              Tcb t \\<Rightarrow> if slot = tcb_ipcbuffer_slot \\<and> slots slot \\<noteq> Some cap then do\n                   intent' \\<leftarrow> select UNIV;\n                   return $ Tcb (t \\<lparr> cdl_tcb_intent := intent' \\<rparr>)\n                 od\n                 else return obj'\n             | _ \\<Rightarrow> return obj';\n    set_object obj_id obj''\n  od\"", "property": "Set Capability: Assign a capability to a specific slot in an object. The object must exist and have the necessary slots. If the object is a TCB and the slot being updated is the IPC buffer, the TCB's intent is reset if the capability changes.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Setting a cap at specific cap_ref. Object must exist and have cap slots. "}
{"spec": "definition\n  opt_parent :: \"cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref option\" where\n  \"opt_parent p \\<equiv> \\<lambda>s. cdl_cdt s p\"\n\nabbreviation\n  get_parent :: \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref k_monad\" where\n  \"get_parent p \\<equiv> gets_the (opt_parent p)\"", "property": "Parent Lookup: Retrieve the parent of a given capability reference from the capability descriptor table (CDT).", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " looking up the parent of a cap in the cdt "}
{"spec": "definition\n  set_parent :: \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\" where\n  \"set_parent child parent \\<equiv> do\n    cdt \\<leftarrow> gets cdl_cdt;\n    assert (cdt child = None);\n    modify (\\<lambda>s. s \\<lparr> cdl_cdt := (cdl_cdt s) (child \\<mapsto> parent) \\<rparr> )\n   od\"", "property": "Set Cap Derivation: Establish a parent-child relationship for a capability reference, ensuring that the child does not already have a parent and updating the capability derivation table to reflect the new relationship.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " setting a cap derivation of a specific cap_ref  "}
{"spec": "definition\n  remove_parent :: \"cdl_cap_ref \\<Rightarrow> unit k_monad\" where\n  \"remove_parent parent \\<equiv>\n   modify (\\<lambda>s. s \\<lparr>cdl_cdt := (\\<lambda> x. if x = parent\n                                 then None\n                                 else (if cdl_cdt s x = Some parent\n                                     then cdl_cdt s parent\n                                     else cdl_cdt s x )) \\<rparr>)\"", "property": "Remove Parent Slot: Removes a specified cap slot from the capability descriptor table (CDT) and updates all its children to point to their grandparent, ensuring the integrity of the CDT structure.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Removes a cap slot from the cdt, and points all its children to their grandparent "}
{"spec": "definition\n  swap_parents :: \"cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> unit k_monad\" where\n  \"swap_parents p p' = modify (cdl_cdt_update\n     (\\<lambda>cd. Fun.swap p p'\n          (\\<lambda>x. if cd x = Some p then Some p' else\n              if cd x = Some p' then Some p else cd x)))\"\n\ndefinition\n  is_cdt_parent :: \"cdl_state \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool\" where\n  \"is_cdt_parent s p c \\<equiv> cdl_cdt s c = Some p\"\n\ndefinition\n  cdt_parent_rel :: \"cdl_state \\<Rightarrow> (cdl_cap_ref \\<times> cdl_cap_ref) set\" where\n  \"cdt_parent_rel \\<equiv> \\<lambda>s. {(p,c). is_cdt_parent s p c}\"\n\nabbreviation\n  parent_of :: \"cdl_state \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> p cdt_parent_of c \\<equiv> (p,c) \\<in> cdt_parent_rel s\"\n\nabbreviation\n  parent_of_trancl :: \"cdl_state \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of\\<^sup>+ _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x cdt_parent_of\\<^sup>+ y \\<equiv> (x, y) \\<in> (cdt_parent_rel s)\\<^sup>+\"\n\nabbreviation\n  parent_of_rtrancl :: \"cdl_state \\<Rightarrow> cdl_cap_ref \\<Rightarrow> cdl_cap_ref \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of\\<^sup>* _\" [60,0,60] 61)\nwhere\n  \"s \\<turnstile> x cdt_parent_of\\<^sup>* y \\<equiv> (x, y) \\<in> (cdt_parent_rel s)\\<^sup>*\"\n\n\\<comment> \\<open>descendants of a slot\\<close>\ndefinition\n  descendants_of :: \"cdl_cap_ref \\<Rightarrow> cdl_state \\<Rightarrow> cdl_cap_ref set\" where\n  \"descendants_of p s \\<equiv> {q. (p,q) \\<in> (cdt_parent_rel s)\\<^sup>+}\"\n\n\n\ndefinition\n  tcb_ipcframe_id :: \"cdl_tcb \\<Rightarrow> cdl_object_id option\"\nwhere\n  \"tcb_ipcframe_id tcb \\<equiv> case (cdl_tcb_caps tcb tcb_ipcbuffer_slot) of\n                              Some (FrameCap _ oid _ _ _ _) \\<Rightarrow> Some oid\n                              | _                       \\<Rightarrow> None\"", "property": "Parent Swapping: Exchanges the parent-child relationships between two capability references, ensuring that the children of each reference are reassigned to the other parent. This operation maintains the integrity of the capability tree by updating the parent-child relationships accordingly.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " Swaps the parents of two cap_refs "}
{"spec": "definition\n  corrupt_intents ::\"(word32 \\<Rightarrow> cdl_full_intent) \\<Rightarrow> cdl_object_id \\<Rightarrow> cdl_state \\<Rightarrow> cdl_state\"\nwhere\n  \"corrupt_intents f bufp s \\<equiv>\n  let changed = (\\<lambda>ptr. case cdl_objects s ptr of\n    Some (Tcb tcb)\n      \\<Rightarrow> if tcb_ipcframe_id tcb = Some bufp then Some (Tcb (tcb\\<lparr> cdl_tcb_intent := f ptr \\<rparr> ) ) else None\n  | _ \\<Rightarrow> None)\n  in\n  s\\<lparr>cdl_objects := cdl_objects s ++ changed\\<rparr>\"", "property": "Corrupt Intents: Modify the intent of a TCB based on a given function if the TCB's IPC frame ID matches a specified buffer. This ensures that the intents in the TCB are updated to reflect potential changes in the message registers or other relevant locations, affecting how intents are interpreted.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": "\n * Dealing with writes to message registers or other locations that\n * may have an effect on how intents are interpreted.\n "}
{"spec": "definition\n  corrupt_frame :: \"cdl_object_id \\<Rightarrow> unit k_monad\"\n  where\n  \"corrupt_frame bufp \\<equiv> do\n      f \\<leftarrow> select UNIV;\n      modify (corrupt_intents f bufp)\n    od\"\n\nend", "property": "Memory Frame Corruption: When a memory frame is identified as corrupted, the intents of all TCBs whose IPC buffers are located within that frame are modified to reflect the corruption.", "title": "./spec/capDL/KHeap_D.thy", "chapter": "", "section": "", "comment": " When a memory frame has been corrupted,\n * we need to change all the intents of tcbs\n * whose ipc_buffer is located within that frame\n "}
{"spec": "(*\n * Operations on interrupt objects.\n *)\n\ntheory Interrupt_D\nimports Endpoint_D \"ExecSpec.Platform\"\nbegin\n\ncontext begin interpretation Arch .\nrequalify_types\n  irq\nend", "property": "Operations on Interrupt Objects: Define and manage operations related to interrupt objects, ensuring proper handling and processing of interrupts within the system.", "title": "./spec/capDL/Interrupt_D.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  get_active_irq :: \"(cdl_irq option) k_monad\"\nwhere\n  \"get_active_irq \\<equiv>\n    do\n      irq \\<leftarrow> select UNIV;\n      return $ Some irq\n    od \\<sqinter> (return None)\n  \"\n\ndefinition\n  arch_decode_irq_control_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_arch_irq_control_intent \\<Rightarrow> cdl_irq_control_invocation except_monad\"\nwhere\n  \"arch_decode_irq_control_invocation target target_ref caps intent \\<equiv> case intent of\n      ARMIrqControlIssueIrqHandlerIntent irq index depth \\<Rightarrow>\n        doE\n          root \\<leftarrow> throw_on_none $ get_index caps 0;\n          cnode_cap \\<leftarrow> returnOk $ fst root;\n          dest_slot_cap_ref \\<leftarrow> lookup_slot_for_cnode_op cnode_cap index (unat depth);\n          returnOk $ IssueIrqHandler irq target_ref dest_slot_cap_ref\n        odE \\<sqinter> throw\"\n\ndefinition\n  decode_irq_control_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_irq_control_intent \\<Rightarrow> cdl_irq_control_invocation except_monad\"\nwhere\n  \"decode_irq_control_invocation target target_ref caps intent \\<equiv> case intent of\n      \\<comment> \\<open>Create an IRQ handler cap for the given IRQ, placing it\n         in the specified CNode slot.\\<close>\n      IrqControlIssueIrqHandlerIntent irq index depth \\<Rightarrow>\n        doE\n          root \\<leftarrow> throw_on_none $ get_index caps 0;\n          cnode_cap \\<leftarrow> returnOk $ fst root;\n          dest_slot_cap_ref \\<leftarrow> lookup_slot_for_cnode_op cnode_cap index (unat depth);\n          returnOk $ IssueIrqHandler irq target_ref dest_slot_cap_ref\n        odE \\<sqinter> throw\n    | ArchIrqControlIssueIrqHandlerIntent arch_intent \\<Rightarrow> arch_decode_irq_control_invocation target target_ref caps arch_intent\"\n\ndefinition\n  decode_irq_handler_invocation :: \"cdl_cap \\<Rightarrow> cdl_cap_ref \\<Rightarrow> (cdl_cap \\<times> cdl_cap_ref) list \\<Rightarrow>\n      cdl_irq_handler_intent \\<Rightarrow> cdl_irq_handler_invocation except_monad\"\nwhere\n  \"decode_irq_handler_invocation target target_ref caps intent \\<equiv> case intent of\n    \\<comment> \\<open>Acknowledge an IRQ.\\<close>\n    IrqHandlerAckIntent \\<Rightarrow>\n      doE\n        irq \\<leftarrow> liftE $ assert_opt $ cdl_cap_irq target;\n        returnOk $ AckIrq irq\n      odE \\<sqinter> throw\n\n    \\<comment> \\<open>Modify the IRQ so that it no longer sends to an endpoint.\\<close>\n    | IrqHandlerClearIntent \\<Rightarrow>\n      doE\n        irq \\<leftarrow> liftE $ assert_opt $ cdl_cap_irq target;\n        returnOk $ ClearIrqHandler irq\n      odE \\<sqinter> throw\n\n    \\<comment> \\<open>Setup an IRQ to cause an endpoint to be sent to.\\<close>\n    | IrqHandlerSetEndpointIntent \\<Rightarrow>\n      doE\n        endpoint \\<leftarrow> throw_on_none $ get_index caps 0;\n        endpoint_cap \\<leftarrow> returnOk $ fst endpoint;\n        endpoint_cap_ref \\<leftarrow> returnOk $ snd endpoint;\n        irq \\<leftarrow> liftE $ assert_opt $ cdl_cap_irq target;\n        case endpoint_cap of\n              NotificationCap x _ _ \\<Rightarrow> returnOk ()\n              | _                    \\<Rightarrow> throw;\n        returnOk $ SetIrqHandler irq endpoint_cap endpoint_cap_ref\n      odE \\<sqinter> throw\n  \"\n\ndefinition\n  arch_invoke_irq_control :: \"arch_cdl_irq_control_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"arch_invoke_irq_control params \\<equiv> case params of\n      \\<comment> \\<open>Create a new IRQ handler cap.\\<close>\n      ARMIssueIrqHandler irq control_slot dest_slot trigger \\<Rightarrow>\n        insert_cap_child (IrqHandlerCap irq) control_slot dest_slot\n  \"\n\ndefinition\n  invoke_irq_control :: \"cdl_irq_control_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_irq_control params \\<equiv> case params of\n      \\<comment> \\<open>Create a new IRQ handler cap.\\<close>\n      IssueIrqHandler irq control_slot dest_slot \\<Rightarrow>\n        insert_cap_child (IrqHandlerCap irq) control_slot dest_slot\n    | ArchIssueIrqHandler arch_inv \\<Rightarrow>\n        arch_invoke_irq_control arch_inv\"\n\ndefinition\n  invoke_irq_handler :: \"cdl_irq_handler_invocation \\<Rightarrow> unit k_monad\"\nwhere\n  \"invoke_irq_handler params \\<equiv> case params of\n      \\<comment> \\<open>Acknowledge and unmask an IRQ.\\<close>\n      AckIrq irq \\<Rightarrow> return ()\n\n      \\<comment> \\<open>Attach an IRQ handler to write to an endpoint.\\<close>\n    | SetIrqHandler irq cap slot \\<Rightarrow>\n        do\n          irqslot \\<leftarrow> gets (get_irq_slot irq);\n          delete_cap_simple irqslot;\n          insert_cap_child cap slot irqslot \\<sqinter> insert_cap_sibling cap slot irqslot\n        od\n\n      \\<comment> \\<open>Deassociate this handler with all endpoints.\\<close>\n    | ClearIrqHandler irq \\<Rightarrow>\n        do\n          irqslot \\<leftarrow> gets (get_irq_slot irq);\n          delete_cap_simple irqslot\n        od\n  \"", "property": "IRQ Management: Enables the creation, acknowledgment, and modification of IRQ handlers. It supports creating new IRQ handler capabilities, acknowledging and unmasking IRQs, setting endpoints for IRQs, and clearing IRQ handlers. These operations ensure that IRQs are managed effectively, allowing for proper handling and dispatching of interrupts in the system.", "title": "./spec/capDL/Interrupt_D.thy", "chapter": "", "section": "", "comment": " Return the currently pending IRQ. "}
{"spec": "definition\n  handle_interrupt :: \"cdl_irq \\<Rightarrow> unit k_monad\"\nwhere\n  \"handle_interrupt irq \\<equiv> if irq > maxIRQ then return () else\n    do\n      irq_slot \\<leftarrow> gets $ get_irq_slot irq;\n      c \\<leftarrow> gets $ opt_cap irq_slot;\n      case c of\n          None \\<Rightarrow> return ()\n        | Some cap \\<Rightarrow> (\n            case cap of\n              (NotificationCap obj _ rights) \\<Rightarrow>\n                  if (Write \\<in> rights) then send_signal obj else return ()\n              | _ \\<Rightarrow> return ()\n          )\n    od\n  \"\n\ndefinition\n  handle_pending_interrupts :: \"unit k_monad\"\nwhere\n  \"handle_pending_interrupts \\<equiv>\n    do\n      active \\<leftarrow> get_active_irq;\n      case active of\n          Some irq \\<Rightarrow> handle_interrupt irq\n        | None \\<Rightarrow> return ()\n    od\"\n\nend", "property": "Interrupt Handling: Process interrupts by checking the corresponding IRQ slot and, if a notification capability with write rights is found, send a signal to the associated object. If no valid capability or no active interrupt is present, the handling process returns without action.", "title": "./spec/capDL/Interrupt_D.thy", "chapter": "", "section": "", "comment": " Handle an interrupt. "}
{"spec": "translations\n  (type) \"cslot_ptr\" <= (type) \"word32 \\<times> bool list\"\n\ntype_synonym slot_ptr = \"cslot_ptr\"\ntype_synonym slot_region_t = \"nat \\<times> nat\"\ntype_synonym bi_dev_reg_t = \"paddr \\<times> word32 \\<times> slot_region_t\"", "property": "Type Definitions for System Components: Define types for component pointers and regions, including a capability slot pointer, a slot region, and a device register. These types facilitate the representation and manipulation of system components in the kernel.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Parameters passed in from linker script", "comment": ""}
{"spec": "definition\n  \"throw_select S ex \\<equiv> doE\n     whenE (S = {}) (throwError ex);\n     liftE (select S)\n   odE\"", "property": "Select from State: Select an element from a non-empty state set S, and throw an exception if the set is empty.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Parameters passed in from linker script", "comment": "Select from state S, throw ex if S is empty."}
{"spec": "consts\n  ki_boot_end :: paddr\n  arm_vector_table :: obj_ref\n  arm_kernel_stack :: obj_ref\n  idle_thread_start :: vspace_ref (* &idle_thread *)", "property": "Kernel Initialization State: Defines the initial state of the kernel, including the boot end address, ARM vector table, ARM kernel stack, and the start of the idle thread. These constants ensure that the kernel has a well-defined starting point for its execution and resource management.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel Init State", "comment": ""}
{"spec": "text \\<open>Ghost state representing the contents of the boot info frame\\<close>\nrecord bi_frame_data =\n  bi_f_node_id :: word32\n  bi_f_num_nodes :: word32\n  bi_f_num_iopt_levels :: word32\n  bi_f_ipcbuf_vptr :: vspace_ref\n  bi_f_null_caps :: slot_region_t\n  bi_f_sh_frame_caps :: slot_region_t\n  bi_f_ui_frame_caps :: slot_region_t\n  bi_f_ui_pt_caps :: slot_region_t\n  bi_f_ut_obj_caps :: slot_region_t\n  bi_f_ut_obj_paddr_list :: \"paddr list\"\n  bi_f_ut_obj_size_bits_list :: \"word8 list\"\n  bi_f_it_cnode_size_bits :: word8\n  bi_f_num_dev_regs :: word32\n  bi_f_dev_reg_list :: \"bi_dev_reg_t list\"\n\ntype_synonym (* XXX: natural numbers represent components of kernel objects, for those\n              objects that can be subdivided *)\n  component = \"bool list\"", "property": "Kernel Boot Information: The boot information frame contains essential data for initializing the kernel, including node identifiers, the number of nodes, I/O port levels, virtual space references, and various capability and object lists. This data is crucial for setting up the initial state and configuration of the kernel.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel Init State", "comment": ""}
{"spec": "record ('z) ki_state =\n  ki_kernel_state    :: \"'z state\"\n  ki_free_mem        :: \"obj_ref set\" (* ndks_boot.freemem representative? *)\n  ki_available_mem   :: \"obj_ref set\" (* ghost state *)\n  ki_bootinfo        :: bi_frame_data (* ghost state *)\n  ki_components      :: \"paddr \\<Rightarrow> component set\"\n  ndks_boot_slot_pos_cur :: nat\n  ndks_boot_slot_pos_max :: nat\n  ndks_boot_bi_frame :: paddr", "property": "Kernel Initialization State: Manages the initial state of the kernel, including the basic kernel state, free memory, available memory, boot information, and a components map. The free memory and available memory sets track unallocated and allocated but not yet retyped memory, respectively. The components map specifies which parts of objects in the heap can be accessed, enabling fine-grained permission management.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel Init State", "comment": "\n  For kernel initialisation, we need the basic kernel state plus some extra\n  information to keep track of, such as free memory.\n  At the concrete level, this is managed by region lists.\n\n  The ``available memory'' indicates memory that has been allocated (and thus\n  no longer free) but that has no objects in it, as it has not been retyped.\n  This is so we can state heap-consuming separation logic predicates which\n  assert that ``there's nothing here'', e.g. so-called untyped objects.\n\n  The components map should have the same domain as the abstract heap in the\n  kernel state, but indicate which components of the object we have permission\n  to access. The purpose is separation logic statements about heaps in which\n  objects can be split up, e.g. only one cap in a CNode.\n"}
{"spec": "text \\<open>\n  The kernel init monad can fail. The actual value of the failure is largely\n  irrelevant, just so long as we don't have assertion failures for no reason.\n\\<close>\n\ndatatype ki_failure = InitFailure\ntype_synonym ('a,'z) ki_monad = \"('z ki_state, ki_failure + 'a) nondet_monad\"\ntranslations\n  (type) \"'a ki_monad\" <=\n    (type) \"((ki_failure + 'a) \\<times> ki_state \\<Rightarrow> bool) \\<times> bool\"", "property": "Kernel Initialization Monad: The kernel initialization monad can fail, with the failure value being largely irrelevant. It is designed to prevent assertion failures without a valid reason.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init monad", "comment": ""}
{"spec": "definition\n  do_kernel_op :: \"('a,'z::state_ext) s_monad \\<Rightarrow> ('a,'z) ki_monad\" where\n \"do_kernel_op kop \\<equiv> liftE $ do\n    ms \\<leftarrow> gets ki_kernel_state;\n    (r, ms') \\<leftarrow> select_f (kop ms);\n    modify (\\<lambda>ks. ks \\<lparr> ki_kernel_state := ms' \\<rparr>);\n    return r\n  od\"", "property": "Lift Kernel State Monad Operations: Elevate operations from the kernel state monad to the kernel init monad, ensuring that the kernel state is properly updated and the result is returned.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init monad", "comment": "Lift kernel state monad ops to the kernel init monad."}
{"spec": "definition \"MIN_NUM_4K_UNTYPED_OBJ \\<equiv> 12 :: nat\"\ndefinition \"MAX_NUM_FREEMEM_REG \\<equiv> 2 :: nat\"", "property": "Minimum Untyped Object Size: The minimum number of 4K untyped objects is defined as 12.  \nMaximum Free Memory Regions: The maximum number of free memory regions is defined as 2.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel constants", "comment": ""}
{"spec": "definition \"BI_CAP_NULL         \\<equiv>  0 :: nat\"\ndefinition \"BI_CAP_IT_TCB       \\<equiv>  1 :: nat\"\ndefinition \"BI_CAP_IT_CNODE     \\<equiv>  2 :: nat\"\ndefinition \"BI_CAP_IT_PD        \\<equiv>  3 :: nat\"\ndefinition \"BI_CAP_IRQ_CTRL     \\<equiv>  4 :: nat\"\ndefinition \"BI_CAP_ASID_CTRL    \\<equiv>  5 :: nat\"\ndefinition \"BI_CAP_IT_ASID_POOL \\<equiv>  6 :: nat\"\ndefinition \"BI_CAP_IO_PORT      \\<equiv>  7 :: nat\"\ndefinition \"BI_CAP_IO_SPACE     \\<equiv>  8 :: nat\"\ndefinition \"BI_CAP_BI_FRAME     \\<equiv>  9 :: nat\"\ndefinition \"BI_CAP_IT_IPCBUF    \\<equiv> 10 :: nat\"\ndefinition \"BI_CAP_DYN_START    \\<equiv> 11 :: nat\"\n\ndefinition \"BI_FRAME_SIZE_BITS \\<equiv> pageBits\"\ndefinition \"ROOT_CNODE_SIZE_BITS \\<equiv> 12 :: nat\"", "property": "Fixed Cap Positions in Root CNode: Define specific, fixed positions for various capabilities in the root CNode, including TCB, CNode, PD, IRQ controller, ASID controller, ASID pool, I/O port, I/O space, bootinfo frame, IPC buffer, and dynamic start. These fixed positions ensure consistent and predictable access to critical system resources.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel constants", "comment": "Fixed cap positions in root CNode (bootinfo.h)"}
{"spec": "definition \"PPTR_VECTOR_TABLE \\<equiv> 0xffff0000 :: word32\"\ndefinition \"PPTR_GLOBALS_PAGE \\<equiv> 0xffffc000 :: word32\"\ndefinition \"PPTR_KERNEL_STACK \\<equiv> 0xfffff000 :: word32\"\n\ndefinition \"IT_ASID     \\<equiv> 1 :: asid\" (* initial thread ASID *)\n\ndefinition \"WORD_SIZE_BITS \\<equiv> 2 :: nat\"\ndefinition \"ASID_POOL_BITS \\<equiv> asid_low_bits :: nat\"\ndefinition \"ASID_POOL_SIZE_BITS \\<equiv> ASID_POOL_BITS + WORD_SIZE_BITS\"\n\ndefinition \"CTE_SIZE_BITS \\<equiv> 4 :: nat\" (* from ARM structures.h *)", "property": "Memory and ASID Constants: Define specific memory addresses for the vector table, globals page, and kernel stack, as well as constants for ASID and bit sizes for word, ASID pool, and CTE. These constants ensure consistent and predictable memory and ASID management in the system.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "ARM constants", "comment": ""}
{"spec": "definition \"PD_BITS \\<equiv> 12 :: nat\"\ndefinition \"PT_BITS \\<equiv> 8 :: nat\"\n\ndefinition \"PDE_SIZE_BITS \\<equiv> 2 :: nat\"\ndefinition \"PTE_SIZE_BITS \\<equiv> 2 :: nat\"", "property": "Page Table and Page Directory Bit Sizes: Define the bit sizes for page directories (PD_BITS), page tables (PT_BITS), page directory entries (PDE_SIZE_BITS), and page table entries (PTE_SIZE_BITS).", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "ARM constants", "comment": "in abstract, these do not have a direct equivalent"}
{"spec": "definition \"PD_SIZE_BITS \\<equiv> PD_BITS + PDE_SIZE_BITS\"\ndefinition \"PT_SIZE_BITS \\<equiv> PT_BITS + PTE_SIZE_BITS\"", "property": "Page Table and Page Directory Size Bits: Define the size bits for page directories and page tables by summing the base bits with the corresponding entry size bits.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "ARM constants", "comment": "in abstract, these are pd_bits and pt_bits respectively"}
{"spec": "definition \"irqInvalid       \\<equiv> 255 :: irq\"\ndefinition \"INTERRUPT_PMU    \\<equiv> 23 :: irq\"\ndefinition \"INTERRUPT_EPIT1  \\<equiv> 28 :: irq\"\ndefinition \"KERNEL_TIMER_IRQ \\<equiv> INTERRUPT_EPIT1\"", "property": "Platform Interrupt Constants: Define specific interrupt values for the iMX31 platform, including an invalid IRQ value and specific interrupts for PMU and EPIT1, with the kernel timer interrupt mapped to EPIT1.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Platform constants (iMX31)", "comment": ""}
{"spec": "definition \"EPIT_PADDR \\<equiv> 0x53f94000 :: word32\"\ndefinition \"EPIT_PPTR  \\<equiv> 0xfff00000 :: word32\"\ndefinition \"AVIC_PADDR \\<equiv> 0x68000000 :: word32\"\ndefinition \"AVIC_PPTR  \\<equiv> 0xfff01000 :: word32\"\ndefinition \"L2CC_PADDR \\<equiv> 0x30000000 :: word32\"\ndefinition \"L2CC_PPTR  \\<equiv> 0xfff02000 :: word32\"\ndefinition \"UART_PADDR \\<equiv> 0x43f90000 :: word32\"\ndefinition \"UART_PPTR  \\<equiv> 0xfff03000 :: word32\"\n\ndefinition \"BASE_OFFSET = pptrBaseOffset\"", "property": "Platform Constants: Define physical and pseudo-physical addresses for various kernel devices, including EPIT, AVIC, L2CC, and UART, to facilitate memory-mapped I/O operations.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Platform constants (iMX31)", "comment": "Kernel devices for imx31"}
{"spec": "text \\<open>\n  These shadow the normal functions, but do not force a well-formedness\n  check for the cnodes, as wellformed\\_cnode\\_sz is non-local with respect\n  to individual caps, and so get\\_cap and set\\_cap are also.\\<close>\n\ndefinition\n  get_cap_local :: \"cslot_ptr \\<Rightarrow> (cap,'z::state_ext) s_monad\"\nwhere\n  \"get_cap_local \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     caps \\<leftarrow> case obj of\n             CNode sz cnode \\<Rightarrow> return cnode\n           | TCB tcb     \\<Rightarrow> return (tcb_cnode_map tcb)\n           | _ \\<Rightarrow> fail;\n     assert_opt (caps cref)\n   od\"\n\ndefinition\n  set_cap_local :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_cap_local cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     obj' \\<leftarrow> case obj of\n               CNode sz cn \\<Rightarrow> if cref \\<in> dom cn\n                                then return $ CNode sz $ cn (cref \\<mapsto> cap)\n                                else fail\n             | TCB tcb \\<Rightarrow>\n                   if cref = tcb_cnode_index 0 then\n                       return $ TCB $ tcb \\<lparr> tcb_ctable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 1 then\n                       return $ TCB $ tcb \\<lparr> tcb_vtable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 2 then\n                       return $ TCB $ tcb \\<lparr> tcb_reply := cap \\<rparr>\n                   else if cref = tcb_cnode_index 3 then\n                       return $ TCB $ tcb \\<lparr> tcb_caller := cap \\<rparr>\n                   else if cref = tcb_cnode_index 4 then\n                       return $ TCB $ tcb \\<lparr> tcb_ipcframe := cap \\<rparr>\n                   else\n                       fail\n             | _ \\<Rightarrow> fail;\n     set_object oref obj'\n  od\"\n\ndefinition\n  set_untyped_cap_as_full_local :: \"cap \\<Rightarrow> cap \\<Rightarrow> word32 \\<times> bool list\\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_untyped_cap_as_full_local src_cap new_cap src_slot \\<equiv>\n   if (is_untyped_cap src_cap \\<and> is_untyped_cap new_cap\n       \\<and> obj_ref_of src_cap = obj_ref_of new_cap \\<and> cap_bits_untyped src_cap = cap_bits_untyped new_cap)\n       then set_cap_local (max_free_index_update src_cap) src_slot else return ()\"\n\ndefinition\n  cap_insert_local :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"cap_insert_local new_cap src_slot dest_slot \\<equiv> do\n    src_cap \\<leftarrow> get_cap_local src_slot;\n\n    dest_original \\<leftarrow> return (if is_ep_cap new_cap then\n                                cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n                             else if is_ntfn_cap new_cap then\n                                cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n                             else if \\<exists>irq. new_cap = IRQHandlerCap irq then\n                                src_cap = IRQControlCap\n                             else is_untyped_cap new_cap);\n    old_cap \\<leftarrow> get_cap_local dest_slot;\n    assert (old_cap = NullCap);\n    set_untyped_cap_as_full_local src_cap new_cap src_slot;\n    set_cap_local new_cap dest_slot;\n\n    is_original \\<leftarrow> gets is_original_cap;\n    src_parent \\<leftarrow> return $\n       should_be_parent_of src_cap (is_original src_slot) new_cap dest_original;\n    src_p \\<leftarrow> gets (\\<lambda>s. cdt s src_slot);\n    dest_p \\<leftarrow> gets (\\<lambda>s. cdt s dest_slot);\n    update_cdt (\\<lambda>cdt. cdt (dest_slot := if src_parent\n                                        then Some src_slot\n                                        else cdt src_slot));\n    do_extended_op (cap_insert_ext src_parent src_slot dest_slot src_p dest_p);\n    set_original dest_slot dest_original\n  od\"\n\ndefinition\n  \"setup_reply_master_local thread \\<equiv> do\n     old_cap <- get_cap_local (thread, tcb_cnode_index 2);\n     when (old_cap = NullCap) $ do\n         set_original (thread, tcb_cnode_index 2) True;\n         set_cap_local (ReplyCap thread True) (thread, tcb_cnode_index 2)\n     od\n  od\"", "property": "Local Capability Management: Manage capabilities within CNodes and TCBs without enforcing well-formedness checks. Capabilities can be retrieved, set, and inserted, with specific rules for updating and transferring capabilities between slots, ensuring that the integrity of the capability system is maintained.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Functions cloned and modified for separation logic to work", "comment": ""}
{"spec": "consts \n  sync_bootinfo_frame :: \"paddr \\<Rightarrow> (unit,'z::state_ext) ki_monad\"\n\ndefinition \n      returnOk pptr\n   odE\"\n\ndefinition\n  create_idle_thread :: \"(unit,'z::state_ext) ki_monad\" where\n  \"create_idle_thread \\<equiv> doE\n     pptr \\<leftarrow> create_objects (obj_bits $ TCB undefined)\n                           (obj_bits $ TCB undefined) TCBObject;\n     do_kernel_op $ do\n       modify (\\<lambda>s. s \\<lparr> idle_thread := pptr \\<rparr>);\n       configure_idle_thread pptr\n     od\n   odE\"\n\ndefinition\n  create_root_cnode :: \"(cap,'z::state_ext) ki_monad\" where\n  \"create_root_cnode \\<equiv>\n   let sz = (ROOT_CNODE_SIZE_BITS + CTE_SIZE_BITS) in\n   doE\n     liftE $ modify\n               (\\<lambda>s. s \\<lparr> ndks_boot_slot_pos_max := 2 ^ ROOT_CNODE_SIZE_BITS \\<rparr>);\n\n     pptr \\<leftarrow> create_objects sz sz CapTableObject;\n\n     let cap = CNodeCap pptr ROOT_CNODE_SIZE_BITS\n                             (replicate (32 - ROOT_CNODE_SIZE_BITS) False)\n     in (doE\n           do_kernel_op $ write_slot (cap_slot_pptr cap BI_CAP_IT_CNODE) cap;\n           returnOk cap\n         odE)\n   odE\"\n\ndefinition\n  create_irq_cnode :: \"(unit,'z::state_ext) ki_monad\" where\n  \"create_irq_cnode \\<equiv> doE", "property": "Kernel Initialization: Initializes the kernel by creating essential components, including an idle thread and root capability node. The idle thread is created and configured, while the root capability node is set up with a specified size and its slot position is updated. This ensures that the kernel has the necessary structures in place for proper operation.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": ""}
{"spec": "pptr \\<leftarrow> create_objects pageBits CTE_SIZE_BITS CapTableObject;", "property": "Create CNode Page: Initialize a page with a specified number of CTEs, each occupying the space defined by CTE_SIZE_BITS, to form a CapTableObject.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " Make a page full of cnodes with one CTE each. At the C level\n        this is of course just an array of CTEs taking up the whole page. "}
{"spec": "do_kernel_op $ modify\n               (\\<lambda>s. s \\<lparr> interrupt_irq_node :=\n                        (\\<lambda>irq. pptr + ucast irq * of_nat CTE_SIZE_BITS) \\<rparr>)\n   odE\"\n\ndefinition\n  create_it_frame_cap :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> asid option \\<Rightarrow> bool \\<Rightarrow> (cap,'z::state_ext) ki_monad\"\n  where\n  \"create_it_frame_cap pptr vptr asid use_large \\<equiv>\n   let sz = if use_large then ARMLargePage else ARMSmallPage in\n     returnOk $ ArchObjectCap $ PageCap pptr {AllowRead,AllowWrite}\n                                        sz (map_option (\\<lambda>a. (a, vptr)) asid)\"\n\ndefinition\n  create_ipcbuf_frame :: \"cap \\<Rightarrow> (vspace_ref \\<times> vspace_ref)\n                          \\<Rightarrow> (cap \\<times> vspace_ref,'z::state_ext) ki_monad\" where\n  \"create_ipcbuf_frame root_cnode_cap ui_v_reg \\<equiv>\n   let vptr = snd ui_v_reg (* ui_v_reg.end *)\n   in\n   doE\n     pptr \\<leftarrow> alloc_region pageBits;\n     do_kernel_op $ do_machine_op $ clearMemory pptr pageBits;\n\n     cap \\<leftarrow> create_it_frame_cap pptr vptr (Some IT_ASID) False;\n\n     do_kernel_op $\n       write_slot (cap_slot_pptr root_cnode_cap BI_CAP_IT_IPCBUF) cap;\n\n     returnOk (cap, vptr)\n   odE\"\n\ndefinition\n  create_bi_frame :: \"cap \\<Rightarrow> (vspace_ref \\<times> vspace_ref) \\<Rightarrow> vspace_ref \\<Rightarrow> word32\n                      \\<Rightarrow> word32 \\<Rightarrow> (vspace_ref,'z::state_ext) ki_monad\" where\n  \"create_bi_frame root_cnode_cap ui_v_reg ipcbuf_vptr node_id num_nodes \\<equiv>\n   let vptr = ipcbuf_vptr + of_nat (2 ^ pageBits)\n   in\n   doE\n     pptr \\<leftarrow> alloc_region BI_FRAME_SIZE_BITS;", "property": "Kernel Initialization: Initialize kernel structures by associating each cnode with an IRQ, creating and configuring frame capabilities for IPC buffers, and allocating and setting up memory regions for various kernel objects. This ensures that the kernel is properly configured with the necessary resources and mappings to support inter-process communication and other critical functionalities.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " Now associate each cnode with an irq "}
{"spec": "liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_node_id := node_id,\n       bi_f_num_nodes := num_nodes,\n       bi_f_num_iopt_levels := 0,\n       bi_f_ipcbuf_vptr := ipcbuf_vptr,\n       bi_f_it_cnode_size_bits := of_nat ROOT_CNODE_SIZE_BITS \\<rparr>\\<rparr>);", "property": "Update Boot Info: Modify the abstract representation of the boot information frame, updating fields such as node ID, number of nodes, IPC buffer virtual pointer, and root CNode size bits.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " update in abstract representation of boot info frame "}
{"spec": "sync_bootinfo_frame pptr;\n\n     liftE $ modify (\\<lambda>s. s \\<lparr> ndks_boot_bi_frame := pptr,\n                             ndks_boot_slot_pos_cur := BI_CAP_DYN_START \\<rparr> );\n\n     cap \\<leftarrow> create_it_frame_cap pptr vptr (Some IT_ASID) False;\n     do_kernel_op $\n       write_slot (cap_slot_pptr root_cnode_cap BI_CAP_BI_FRAME) cap;\n\n     returnOk vptr\n   odE\"\n\ndefinition\n  create_it_asid_pool :: \"cap \\<Rightarrow> (cap,'z::state_ext) ki_monad\" where\n  \"create_it_asid_pool root_cnode_cap \\<equiv> doE", "property": "Kernel Initialization: Synchronize the abstract boot information with the boot information frame, update the kernel state to reflect the new boot information frame pointer and the current slot position, create an initial translation frame capability, and write this capability to the specified slot in the root CNode. This ensures that the kernel's initial memory setup is correctly configured for subsequent operations.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " synchronise abstract bootinfo with boot info frame "}
{"spec": "ap_pptr \\<leftarrow> create_objects ASID_POOL_SIZE_BITS\n                              ASID_POOL_SIZE_BITS (ArchObject ASIDPoolObj);\n\n     ap_cap \\<leftarrow> returnOk $ ArchObjectCap $\n                 ASIDPoolCap ap_pptr (IT_ASID >> asid_low_bits);\n\n     do_kernel_op $ write_slot (cap_slot_pptr root_cnode_cap\n                                BI_CAP_IT_ASID_POOL) ap_cap;", "property": "ASID Pool Initialization: Create an ASID pool and initialize it with a specified size, then generate a capability for the ASID pool and write this capability into the root CNode.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create ASID pool "}
{"spec": "do_kernel_op $ write_slot (cap_slot_pptr root_cnode_cap BI_CAP_ASID_CTRL)\n                               (ArchObjectCap ASIDControlCap);\n\n     returnOk ap_cap\n   odE\"\n\ndefinition\n  create_frames_of_region :: \"cap \\<Rightarrow> (paddr \\<times> paddr) \\<Rightarrow> bool \\<Rightarrow> word32\n                              \\<Rightarrow> (nat \\<times> nat,'z::state_ext) ki_monad\" where\n  \"create_frames_of_region root_cnode_cap reg do_map pv_offset \\<equiv> doE\n\n     slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n     (swp mapME)\n       [(fst reg),(fst reg + of_nat (2 ^ pageBits)) .e. (snd reg - 1)]\n       (\\<lambda>f. doE\n              frame_cap \\<leftarrow> (if do_map\n                           then create_it_frame_cap f\n                                  (f - BASE_OFFSET - pv_offset) (Some IT_ASID) False\n                           else create_it_frame_cap f 0 None False);\n              provide_cap root_cnode_cap frame_cap\n            odE);\n\n     slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n     returnOk (slot_pos_before, slot_pos_after)\n   odE\"\n\ndefinition\n  write_it_asid_pool :: \"cap \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"write_it_asid_pool it_ap_cap it_pd_cap \\<equiv>\n   let ap_ptr = obj_ref_of it_ap_cap;\n       pd_ptr = obj_ref_of it_pd_cap;\n       asid_idx = ucast (IT_ASID >> asid_low_bits)\n   in\n   do\n     ap \\<leftarrow> get_asid_pool ap_ptr;\n     ap' \\<leftarrow> return (ap (ucast IT_ASID \\<mapsto> pd_ptr));\n     set_asid_pool ap_ptr ap';\n\n     asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n     asid_table' \\<leftarrow> return (asid_table(asid_idx \\<mapsto> ap_ptr));\n     modify (\\<lambda>s. s \\<lparr> arch_state :=\n                      arch_state s \\<lparr> arm_asid_table := asid_table' \\<rparr>\\<rparr>)\n\n   od\"\n\ndefinition\n  map_it_pt_cap :: \"cap \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"map_it_pt_cap pd_cap pt_cap \\<equiv> do\n\n     pd \\<leftarrow> return $ obj_ref_of pd_cap; (* C uses specific PD version *)\n\n     (pt,vptr) \\<leftarrow> return $ case the_arch_cap pt_cap\n                            of PageTableCap ref (Some (_, vref)) \\<Rightarrow> (ref,vref);\n\n     slot \\<leftarrow> return $ vptr >> pageBitsForSize ARMSection;", "property": "Kernel Initialization Functions: Initialize and configure kernel resources, including creating ASID control capabilities, generating frame capabilities for a specified region, writing ASID pool mappings, and mapping page table capabilities. These functions ensure that the kernel's memory management and address space isolation are properly set up, facilitating secure and efficient operation.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create ASID control cap "}
{"spec": "pde \\<leftarrow> return $ PageTablePDE (addrFromPPtr pt) {ParityEnabled} 0;\n\n     pd_obj \\<leftarrow> get_object pd;\n     pd_obj' \\<leftarrow> return (case pd_obj\n                         of ArchObj (PageDirectory table)\n                            \\<Rightarrow> ArchObj (PageDirectory $ table(ucast slot := pde)\n                       ));\n     set_object pd pd_obj'\n   od\"\n\ndefinition\n  map_it_frame_cap :: \"cap \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"map_it_frame_cap pd_cap frame_cap \\<equiv> do\n\n     pd \\<leftarrow> return $ obj_ref_of pd_cap;\n\n     (frame, vptr) \\<leftarrow> return $ case the_arch_cap frame_cap\n                       of PageCap ref _ _ (Some (_, vptr)) \\<Rightarrow> (ref, vptr);\n\n     pd_obj \\<leftarrow> get_object pd;\n     pde \\<leftarrow> return $ case pd_obj\n                      of ArchObj (PageDirectory table)\n                         \\<Rightarrow> table (ucast (vptr >> pageBitsForSize ARMSection));\n\n     pt \\<leftarrow> return (case pde of PageTablePDE ref _ _ \\<Rightarrow> ptrFromPAddr ref);\n\n     slot \\<leftarrow> return $ (vptr && mask (pageBitsForSize ARMSection))\n                              >> pageBitsForSize ARMSmallPage;\n\n     pte \\<leftarrow> return $ SmallPagePTE (addrFromPPtr frame) {PageCacheable}\n                                 vm_read_write;\n     pt_obj \\<leftarrow> get_object pt;\n     pt_obj' \\<leftarrow> return (case pt_obj\n                         of ArchObj (PageTable table)\n                            \\<Rightarrow> ArchObj (PageTable $ table(ucast slot := pte)));\n     set_object pt pt_obj'\n   od\"\n\ndefinition\n  write_it_pd_pts :: \"cap \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"write_it_pd_pts root_cnode_cap it_pd_cap \\<equiv> doE\n\n     do_kernel_op $ copy_global_mappings $ obj_ref_of it_pd_cap;", "property": "Kernel Initialization and Memory Mapping: Initialize the kernel by setting up page directories and page tables, including enabling parity for error correction. Map frame capabilities to specific virtual addresses in the page table, ensuring that memory is correctly configured and accessible.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " C code sets ParityEnable bit, which is apparently to enable ECC "}
{"spec": "(start, end) \\<leftarrow> liftE $ gets (bi_f_ui_pt_caps \\<circ> ki_bootinfo);\n\n     do_kernel_op $\n       (swp mapM)\n          [start..<end]\n          (\\<lambda>pos. do\n                   cap \\<leftarrow> get_cap_local $ cap_slot_pptr root_cnode_cap pos;\n                   map_it_pt_cap it_pd_cap cap\n                 od);", "property": "Map Page Table Capabilities: Map the page table capabilities into the page directory. This involves iterating over a range of positions, retrieving the capability at each position, and mapping it into the page directory to establish the necessary memory mappings.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map PTs into PD "}
{"spec": "(start, end) \\<leftarrow> liftE $ gets (bi_f_ui_frame_caps \\<circ> ki_bootinfo);\n\n     do_kernel_op (do\n       (swp mapM)\n          [start..<end]\n          (\\<lambda>pos. do\n                   cap \\<leftarrow> get_cap_local $ cap_slot_pptr root_cnode_cap pos;\n                   map_it_frame_cap it_pd_cap cap\n                 od);\n\n       cap \\<leftarrow> get_cap_local $ cap_slot_pptr root_cnode_cap BI_CAP_IT_IPCBUF;\n       map_it_frame_cap it_pd_cap cap;\n       cap \\<leftarrow> get_cap_local $ cap_slot_pptr root_cnode_cap BI_CAP_BI_FRAME;\n       map_it_frame_cap it_pd_cap cap\n     od)\n   odE\"\n\ndefinition\n  bi_finalise :: \"(unit,'z::state_ext) ki_monad\" where\n  \"bi_finalise \\<equiv> doE\n     slot_pos_start \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n     slot_pos_end \\<leftarrow> liftE $ gets ndks_boot_slot_pos_max;\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_null_caps := (of_nat slot_pos_start, of_nat slot_pos_end) \\<rparr>\\<rparr>);\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame\n   odE\"\n\ndefinition\n  create_it_pd_pts :: \"cap \\<Rightarrow> (vspace_ref \\<times> vspace_ref) \\<Rightarrow> vspace_ref\n                       \\<Rightarrow> vspace_ref \\<Rightarrow> (cap,'z::state_ext) ki_monad\" where\n  \"create_it_pd_pts root_cnode_cap ui_v_reg ipcbuf_vptr bi_frame_vptr \\<equiv> doE", "property": "Map Frames into Page Tables: Maps frames into page tables by iterating over a range of frame capabilities, retrieving each capability, and mapping it. Additionally, specific capabilities for the IPC buffer and bootinfo frame are also mapped to ensure proper initialization and accessibility of these critical resources.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map frames into PTs "}
{"spec": "pd_pptr \\<leftarrow> create_objects PD_SIZE_BITS PD_SIZE_BITS\n                              (ArchObject PageDirectoryObj);\n     pd_cap \\<leftarrow> returnOk $ ArchObjectCap $\n                           PageDirectoryCap pd_pptr (Some IT_ASID);\n     do_kernel_op $ write_slot (cap_slot_pptr root_cnode_cap BI_CAP_IT_PD)\n                               pd_cap;", "property": "Create and Initialize Page Directory: Create a page directory object and its corresponding capability, then write the capability to the specified slot in the root CNode. This ensures that the page directory is properly set up and accessible for memory management operations.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create PD obj and cap "}
{"spec": "(ui_v_reg_start, ui_v_reg_end) \\<leftarrow>\n         returnOk (fst ui_v_reg, bi_frame_vptr + 2 ^ BI_FRAME_SIZE_BITS);", "property": "Initialize Userland Image: Include the IPC buffer and bootinfo frames in the userland image, setting the virtual register start and end addresses accordingly.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " include IPC buffer and bootinfo frames in the userland image "}
{"spec": "slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n     start \\<leftarrow> returnOk $ round_down ui_v_reg_start (PD_BITS + pageBits);\n     next \\<leftarrow> returnOk $ start + (2 ^ (PT_BITS + pageBits));\n\n     (swp mapME) [start,next .e. ui_v_reg_end] (\\<lambda>pt_vptr. doE\n\n       pt_pptr \\<leftarrow> alloc_region PT_SIZE_BITS;\n       do_kernel_op $ retype_region pt_pptr 1 PT_SIZE_BITS\n                                            (ArchObject PageTableObj);\n\n       provide_cap root_cnode_cap $\n         ArchObjectCap $ PageTableCap pt_pptr (Some (IT_ASID, pt_vptr))\n     odE);\n\n     slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_ui_pt_caps := (of_nat slot_pos_before, of_nat slot_pos_after) \\<rparr>\\<rparr>);\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame;\n\n     returnOk pd_cap\n   odE\"\n\ndefinition\n  create_initial_thread :: \"cap \\<Rightarrow> cap \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref\n                            \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"create_initial_thread root_cnode_cap it_pd_cap ui_v_entry bi_frame_vptr\n                         ipcbuf_vptr ipcbuf_cap \\<equiv>\n   let tcb_bits = obj_bits $ TCB undefined\n   in\n   doE", "property": "Create Initial Thread and Page Tables: Initialize the kernel by creating all necessary page table objects and capabilities to cover the userland image. This includes allocating and typing page tables, providing corresponding capabilities, and updating the boot information with the positions of the created capabilities.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create all PT objs and caps necessary to cover userland image "}
{"spec": "tcb_pptr \\<leftarrow> create_objects tcb_bits tcb_bits TCBObject;", "property": "Allocate TCB: Creates and initializes a new TCB object with the specified number of bits, ensuring that the TCB is properly set up for thread management.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " allocate TCB "}
{"spec": "do_kernel_op $ (do\n     cap_insert_local root_cnode_cap (cap_slot_pptr root_cnode_cap BI_CAP_IT_CNODE)\n                               (tcb_pptr, tcb_cnode_index 0); (* tcbCTable *)\n     cap_insert_local root_cnode_cap (cap_slot_pptr root_cnode_cap BI_CAP_IT_PD)\n                               (tcb_pptr, tcb_cnode_index 1); (* tcbVTable *)\n     cap_insert_local root_cnode_cap (cap_slot_pptr root_cnode_cap BI_CAP_IT_IPCBUF)\n                               (tcb_pptr, tcb_cnode_index 4); (* tcbBuffer *)\n\n     tcb_obj \\<leftarrow> get_object tcb_pptr;\n     tcb_obj' \\<leftarrow> return $\n                case tcb_obj\n                  of TCB tcb \\<Rightarrow> TCB (tcb\\<lparr>tcb_ipc_buffer := ipcbuf_vptr\\<rparr>);\n     set_object tcb_pptr tcb_obj';\n\n     as_user tcb_pptr $ set_register CPSR 0x1f;\n     as_user tcb_pptr $ setNextPC ui_v_entry;", "property": "Kernel Initialization: Initialize the kernel by inserting capabilities for the TCB's CNode, VTable, and IPC buffer into the root CNode. Update the TCB object to set the IPC buffer, and configure the user context by setting the CPSR register and the next program counter.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " Arch_initContext should be implicit in retype_region "}
{"spec": "setup_reply_master_local tcb_pptr;\n     set_thread_state tcb_pptr Running;", "property": "Kernel Initialization: Sets up the reply master for a thread and transitions its state to running, ensuring the thread is ready for execution.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " TCB priority not in abstract spec "}
{"spec": "idle_thread \\<leftarrow> gets idle_thread;\n     modify (\\<lambda>s. s\\<lparr> cur_thread := idle_thread \\<rparr>);\n\n     switch_to_thread tcb_pptr;\n\n     cap \\<leftarrow> return $ ThreadCap tcb_pptr;\n     write_slot (cap_slot_pptr root_cnode_cap BI_CAP_IT_TCB) cap\n   od)\n   odE\"\n\ndefinition\n  create_device_frames :: \"cap \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"create_device_frames root_cnode_cap \\<equiv> doE\n     dev_regs \\<leftarrow> do_kernel_op $ do_machine_op getDeviceRegions;\n\n     (swp mapME) dev_regs (\\<lambda>(start,end). doE", "property": "Kernel Initialization: Initializes the kernel by setting the current thread to the idle thread, switching to a new thread, and writing the thread capability to the specified slot in the root cnode. This ensures that the kernel is in a known state and ready for further operations.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " scheduler action not in abstract spec "}
{"spec": "frame_size \\<leftarrow>\n         returnOk $ if (is_aligned start (pageBitsForSize ARMSection)\n                        \\<and> is_aligned end (pageBitsForSize ARMSection))\n                    then ARMSection\n                    else ARMSmallPage;\n\n       slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n       (swp mapME) [start,(start + 2^(pageBitsForSize frame_size))\n                       .e. (end - 1)]\n         (\\<lambda>f. doE\n                frame_cap \\<leftarrow> create_it_frame_cap f 0 None\n                                                (frame_size = ARMSection);\n                provide_cap root_cnode_cap frame_cap\n              odE);\n\n       slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n       bi_dev_reg \\<leftarrow> returnOk (addrFromPPtr start,\n                              of_nat (pageBitsForSize frame_size),\n                              (slot_pos_before, slot_pos_after));\n\n       liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n         bi_f_dev_reg_list := (bi_f_dev_reg_list $\n                                 ki_bootinfo s) @ [bi_dev_reg]\n         \\<rparr>\\<rparr>);\n\n       bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n       sync_bootinfo_frame bi_frame\n\n     odE);\n\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_num_dev_regs := of_nat $ length (bi_f_dev_reg_list $\n                                               ki_bootinfo s)\n       \\<rparr>\\<rparr>);\n\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame\n   odE\"\n\nfun (* for (ptr,bits)-style regions which don't straddle the end of memory *)\n  no_region_overlap :: \"(paddr \\<times> nat) \\<Rightarrow> (paddr \\<times> nat) \\<Rightarrow> bool\" where\n  \"no_region_overlap (ptr1,bits1) (ptr2,bits2) =\n     ({ptr1 .. ptr1 + 2 ^ bits1 - 1} \\<inter> {ptr2 .. ptr2 + 2 ^ bits2 - 1} = {})\"\n\ndefinition\n  freemem_regions :: \"obj_ref set \\<Rightarrow> ((paddr \\<times> nat) list,'z::state_ext) s_monad\" where\n  \"freemem_regions free \\<equiv> do\n     regs \\<leftarrow> select {lst. (\\<forall>(ptr,bits) \\<in> set lst. is_aligned ptr bits \\<and>\n                                           {ptr .. ptr + 2 ^ bits - 1} \\<subseteq> free)\n                         \\<and> distinct_prop no_region_overlap lst};\n     return regs\n   od\"\n\ndefinition\n  create_untyped_obj :: \"cap \\<Rightarrow> (paddr \\<times> paddr) \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"create_untyped_obj root_cnode_cap boot_mem_reuse_reg \\<equiv> doE\n\n     slot_pos_before \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;", "property": "Kernel Initialization: Allocate memory frames, preferentially using 1M frames if the start and end addresses are aligned, otherwise using 4K frames. The function creates frame capabilities, updates the boot information with device region details, and ensures that the regions do not overlap, maintaining the integrity of the memory layout.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " use 1M frames if possible, else 4K frames "}
{"spec": "(swp mapME) [fst boot_mem_reuse_reg,(fst boot_mem_reuse_reg + 2^pageBits)\n                   .e. (snd boot_mem_reuse_reg - 1)]\n                  (\\<lambda>i. provide_untyped_cap root_cnode_cap i pageBits\n                                           slot_pos_before);", "property": "Kernel Memory Reuse: Reuse the boot code and data frames by providing untyped capabilities for the specified memory regions, ensuring efficient memory utilization during initialization.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " re-use boot code/data frames "}
{"spec": "slot_pos_cur \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n     (swp mapME) [(slot_pos_cur - slot_pos_before)..<MIN_NUM_4K_UNTYPED_OBJ]\n       (\\<lambda>i. doE\n              pptr \\<leftarrow> alloc_region pageBits;\n              provide_untyped_cap root_cnode_cap pptr pageBits slot_pos_before\n            odE);", "property": "Allocate and Provide Untyped Objects: Allocate a minimum number of 4K untyped objects as requested and provide them with the appropriate capabilities.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " allocate and provide the minimum number of 4K UT objects requested "}
{"spec": "freemem \\<leftarrow> liftE $ gets ki_free_mem;\n     freeregs \\<leftarrow> do_kernel_op $ freemem_regions freemem;\n\n     (swp mapME) (take MAX_NUM_FREEMEM_REG freeregs)\n       (\\<lambda>(start,bits). provide_untyped_cap root_cnode_cap start bits\n                                           slot_pos_before);\n\n     slot_pos_after \\<leftarrow> liftE $ gets ndks_boot_slot_pos_cur;\n\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_ut_obj_caps := (slot_pos_before, slot_pos_after) \\<rparr>\\<rparr>);\n\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame\n   odE\"\n\ndefinition\n  map_kernel_frame :: \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vm_rights \\<Rightarrow> vm_attributes\n                       \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"map_kernel_frame paddr vaddr vm_rights attributes \\<equiv> do\n\n     idx \\<leftarrow> return $ (vaddr && mask (pageBitsForSize ARMSection))\n                    >> pageBitsForSize ARMSmallPage;\n\n     global_pt \\<leftarrow> get_arm_global_pt;\n\n     pte \\<leftarrow> return $ SmallPagePTE paddr attributes vm_rights;\n\n     store_pte (global_pt + (idx << PTE_SIZE_BITS)) pte\n   od\"\n\n\ndefinition (* from plat/imx31/machine/hardware.c *)\n  map_kernel_devices :: \"(unit,'z::state_ext) s_monad\" where\n  \"map_kernel_devices \\<equiv> do\n     map_kernel_frame EPIT_PADDR EPIT_PPTR vm_kernel_only\n                      {ParityEnabled,PageCacheable};\n     map_kernel_frame AVIC_PADDR AVIC_PPTR vm_kernel_only\n                      {ParityEnabled,PageCacheable};\n     map_kernel_frame L2CC_PADDR L2CC_PPTR vm_kernel_only\n                      {ParityEnabled,PageCacheable}\n   od\"\n\ndefinition\n  map_kernel_window :: \"(unit,'z::state_ext) s_monad\" where\n  \"map_kernel_window \\<equiv> do\n\n     global_pd \\<leftarrow> gets (arm_global_pd \\<circ> arch_state);", "property": "Kernel Initialization: Initializes the kernel by allocating and mapping free memory regions, setting up untyped capabilities, updating boot information, and mapping kernel frames and devices. This ensures that the kernel is properly configured with the necessary memory and device mappings, and the boot information is synchronized.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " using non-determinism to the max "}
{"spec": "idx \\<leftarrow> return $ kernel_base >> pageBitsForSize ARMSection;", "property": "Initial Page Directory Index: The initial index into the page directory is calculated by shifting the kernel base address right by the number of bits corresponding to the ARM section size, ensuring that the index is divisible by 16.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " initial index into the PD, guaranteed to be divisible by 16 "}
{"spec": "phys \\<leftarrow> return $ physBase;", "property": "Initialize Physical Base Address: Set the initial physical address to be used for memory mapping.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " first physical address we'll map "}
{"spec": "iterations \\<leftarrow> return ((2^(PD_BITS) - idx) >> 4);\n\n     (swp mapM) [0 .e. iterations - 1] (\\<lambda>i. do\n         idx' \\<leftarrow> return $ idx + i * 16;\n         phys' \\<leftarrow> return $ phys + i * (2^(pageBitsForSize(ARMSuperSection)));\n\n         pde \\<leftarrow> return $ SuperSectionPDE phys' {ParityEnabled,PageCacheable}\n                                         vm_kernel_only;", "property": "Kernel Initialization: Map the physical base at the kernel base in 16MB segments, setting up SuperSection Page Directory Entries (PDEs) with specific attributes such as parity enabled and page cacheable, but not finalizing the supersection.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map physBase at kernel_base 16M at a time, but not final supersection "}
{"spec": "mapM (\\<lambda>offs. store_pde (idx' + offs) pde) [0 .e. 15]\n       od);", "property": "Initialize Supersection: Write 16 section entries for the supersection by storing the page directory entry (PDE) at each offset from 0 to 15.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " write 16 section entries for this supersection "}
{"spec": "idx \\<leftarrow> return $ idx + iterations * 16; (* should be 2^PD_BITS - 16 *)\n     phys \\<leftarrow> return $ phys + iterations * (2^pageBitsForSize(ARMSuperSection));", "property": "Advance Index and Physical Address: Update the index and physical address by adding the product of the number of iterations and their respective increments, ensuring they match the exit condition of the C loop.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " advance idx and phys to match exit of C loop "}
{"spec": "(swp mapM) [0 .e. 14] (\\<lambda>i. do\n         phys' \\<leftarrow> return $ phys + i * (2^(pageBitsForSize(ARMSection)));\n         pde \\<leftarrow> return $ SectionPDE phys' {ParityEnabled,PageCacheable} 0\n                                   vm_kernel_only;\n         store_pde (idx + i) pde\n       od);", "property": "Map Memory Sections: Map 15 megabytes of memory using 1-megabyte frames, starting from a specified physical address. Each frame is mapped with specific attributes (parity enabled and page cacheable) and restricted to kernel-only access.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " next 15M mapped using 1M frames "}
{"spec": "idx \\<leftarrow> return $ idx + 15; (* should be 2^PD_BITS - 1 *)\n     phys \\<leftarrow> return $ phys + 15 * (2^pageBitsForSize(ARMSection));", "property": "Advance Index and Physical Address: Increment the index and physical address to align with the exit condition of a loop, ensuring that they are updated by a fixed value corresponding to the page size and the number of entries.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " advance idx and phys to match exit of C loop "}
{"spec": "global_pt \\<leftarrow> get_arm_global_pt;\n     pde \\<leftarrow> return $ PageTablePDE (addrFromPPtr global_pt) {ParityEnabled} 0;\n     store_pde idx pde;", "property": "Map Global Page Table: Map the global page table into the last slot of the global page directory by creating and storing a Page Table PDE.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " now map global PT into last slot in global PD  "}
{"spec": "retype_region global_pt 1 PT_SIZE_BITS\n                   (ArchObject PageTableObj);", "property": "Initialize Page Table: Set up the initial page table by retyping a specified region of memory to be used as a page table, ensuring that the kernel has a properly configured memory structure for managing virtual-to-physical address translations.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " init the PT "}
{"spec": "map_kernel_frame (addrFromPPtr arm_vector_table) PPTR_VECTOR_TABLE\n                      vm_kernel_only {ParityEnabled,PageCacheable};", "property": "Map Kernel Frame: Maps the vector table from physical to virtual memory with specific attributes, including parity enabled and page cacheable, ensuring proper initialization and accessibility of the kernel's vector table.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map vector table "}
{"spec": "globals_frame \\<leftarrow> gets (arm_globals_frame \\<circ> arch_state);\n     map_kernel_frame (addrFromPPtr globals_frame) PPTR_GLOBALS_PAGE\n                      vm_read_only {ParityEnabled,PageCacheable};", "property": "Kernel Initialization: Map the global frame with read-only permissions and specific memory attributes (parity enabled and page cacheable) to ensure the integrity and performance of the kernel's global data.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map globals frame "}
{"spec": "map_kernel_frame (addrFromPPtr arm_kernel_stack) PPTR_KERNEL_STACK\n                      vm_kernel_only {ParityEnabled,PageCacheable};\n\n     map_kernel_devices\n   od\"\n\n\n\ndefinition\n  paddr_to_pptr_reg :: \"(paddr \\<times> paddr) \\<Rightarrow> (paddr \\<times> paddr)\" where\n  \"paddr_to_pptr_reg p_reg \\<equiv> (fst p_reg + pptrBaseOffset,\n                              snd p_reg + pptrBaseOffset)\"\n\ndefinition\n  init_kernel :: \"paddr \\<Rightarrow> paddr \\<Rightarrow> word32 \\<Rightarrow> vspace_ref \\<Rightarrow> (unit,'z::state_ext) ki_monad\" where\n  \"init_kernel ui_p_reg_start ui_p_reg_end pv_offset v_entry \\<equiv>\n   let ui_v_reg_start = ui_p_reg_start - pv_offset;\n       ui_v_reg_end = ui_p_reg_end - pv_offset;\n       ui_v_reg = (ui_v_reg_start, ui_v_reg_end);\n       ui_reg = paddr_to_pptr_reg (ui_p_reg_start, ui_p_reg_end)\n   in\n   doE\n     do_kernel_op $ map_kernel_window;\n     do_kernel_op $ init_cpu;\n     do_kernel_op $ init_plat;\n     init_freemem ui_reg;\n     root_cnode_cap \\<leftarrow> create_root_cnode;\n     create_irq_cnode;\n     do_kernel_op $ init_irqs root_cnode_cap;", "property": "Kernel Initialization: Initializes the kernel by setting up the virtual memory, initializing CPU and platform-specific components, creating root and IRQ cnode capabilities, and initializing interrupt handling. This ensures that the kernel is properly configured and ready for operation.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " map stack frame "}
{"spec": "ipcbuf_ret \\<leftarrow> create_ipcbuf_frame root_cnode_cap ui_v_reg;\n\n     bi_frame_vptr \\<leftarrow> create_bi_frame root_cnode_cap ui_v_reg\n                                     (snd ipcbuf_ret) 0 1;", "property": "Initialization of IPC Buffer and Boot Info Frame: Creates the initial thread's IPC buffer and boot info frame, ensuring that the necessary memory structures are set up for inter-process communication and boot information.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create initial thread's ipc buffer "}
{"spec": "ui_fr_caps \\<leftarrow> create_frames_of_region root_cnode_cap ui_reg True pv_offset;\n     liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_ui_frame_caps := ui_fr_caps \\<rparr>\\<rparr>);\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame;", "property": "Initialize Userland Image: Create and initialize frame objects for the userland image, store the information in the bootinfo frame, and synchronize the bootinfo frame to ensure the system is properly set up for boot.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create userland image frame objs, store info in bootinfo frame "}
{"spec": "it_pd_cap \\<leftarrow> create_it_pd_pts root_cnode_cap ui_v_reg (snd ipcbuf_ret)\n                                   bi_frame_vptr;\n     write_it_pd_pts root_cnode_cap it_pd_cap;", "property": "Initialize Page Directory and Page Tables: Create and initialize the page directory and page tables for the userland image, and write the initialized page directory and page tables to the root CNode.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create/init PDs and PTs for userland image "}
{"spec": "it_ap_cap \\<leftarrow> create_it_asid_pool root_cnode_cap;\n     do_kernel_op $ write_it_asid_pool it_ap_cap it_pd_cap;\n\n     create_idle_thread;", "property": "Initialize ASID Pool: Create and initialize the initial thread's ASID pool, and write the ASID pool capability to the kernel's initial ASID pool. Additionally, create the idle thread to ensure the system is ready for operation.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create/init initial thread's ASID pool "}
{"spec": "create_initial_thread root_cnode_cap it_pd_cap v_entry bi_frame_vptr\n                           (snd ipcbuf_ret) (fst ipcbuf_ret);", "property": "Create Initial Thread: Initializes the first thread in the system, setting up essential capabilities and resources such as the root CNode, initial page directory, virtual entry, and IPC buffer.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create_initial_thread "}
{"spec": "create_untyped_obj root_cnode_cap (kernel_base, ki_boot_end);", "property": "Create Untyped Object: Initialize an untyped object in the kernel's memory space, reclaiming the boot code and data area. This ensures that the memory previously used for boot code and data is made available for other uses, optimizing memory utilization.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create_untyped_obj (reclaim boot code/data) "}
{"spec": "create_device_frames root_cnode_cap;", "property": "Create Device Frames: Initialize and allocate memory frames for device usage, ensuring that the necessary resources are available for device operations.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " create_device_frames "}
{"spec": "liftE $ modify (\\<lambda>s. s \\<lparr> ki_bootinfo := (ki_bootinfo s) \\<lparr>\n       bi_f_sh_frame_caps := (0,0) \\<rparr>\\<rparr>);\n     bi_frame \\<leftarrow> liftE $ gets ndks_boot_bi_frame;\n     sync_bootinfo_frame bi_frame;\n\n     bi_finalise;\n\n     do_kernel_op $ do_machine_op cleanCache\n   odE\n  \"\n\nend", "property": "Kernel Initialization: Initialize the kernel by setting the shared frame capabilities to zero, indicating no shared frame capabilities are used. Finalize the boot information and clean the cache to ensure the system starts in a known, consistent state.", "title": "./spec/abstract/KernelInit_A.thy", "chapter": "", "section": "Kernel init functions", "comment": " no shared frame caps (ARM = no multikernel) "}
{"spec": "datatype cnode_invocation =\n    InsertCall cap cslot_ptr cslot_ptr\n  | MoveCall cap cslot_ptr cslot_ptr\n  | RevokeCall cslot_ptr\n  | DeleteCall cslot_ptr\n  | RotateCall cap cap cslot_ptr cslot_ptr cslot_ptr\n  | SaveCall cslot_ptr\n  | CancelBadgedSendsCall cap\n\ndatatype untyped_invocation =\n    Retype cslot_ptr bool obj_ref obj_ref apiobject_type nat \"cslot_ptr list\" bool\n\ndatatype tcb_invocation =\n    WriteRegisters machine_word bool \"machine_word list\" arch_copy_register_sets\n  | ReadRegisters machine_word bool machine_word arch_copy_register_sets\n  | CopyRegisters machine_word machine_word bool bool bool bool arch_copy_register_sets\n  | ThreadControl (tc_target: machine_word) (tc_slot: cslot_ptr)\n                  (tc_new_fault_ep: \"cap_ref option\")\n                  (tc_new_mcpriority: \"(word8 * obj_ref) option\")\n                  (tc_new_priority: \"(word8 * obj_ref) option\")\n                  (tc_new_croot: \"(cap * cslot_ptr) option\")\n                  (tc_new_vroot: \"(cap * cslot_ptr) option\")\n                  (tc_new_buffer: \"(vspace_ref * (cap * cslot_ptr) option) option\")\n  | Suspend \"obj_ref\"\n  | Resume \"obj_ref\"\n  | NotificationControl \"obj_ref\" \"obj_ref option\"\n  | SetTLSBase obj_ref machine_word\n\ndatatype irq_control_invocation =\n    IRQControl irq cslot_ptr cslot_ptr\n  | ArchIRQControl arch_irq_control_invocation\n\ndatatype irq_handler_invocation =\n    ACKIrq irq\n  | SetIRQHandler irq cap cslot_ptr\n  | ClearIRQHandler irq\n\ndatatype invocation =\n    InvokeUntyped untyped_invocation\n  | InvokeEndpoint obj_ref machine_word bool bool\n  | InvokeNotification obj_ref machine_word\n  | InvokeReply obj_ref cslot_ptr bool\n  | InvokeTCB tcb_invocation\n  | InvokeDomain obj_ref word8\n  | InvokeCNode cnode_invocation\n  | InvokeIRQControl irq_control_invocation\n  | InvokeIRQHandler irq_handler_invocation\n  | InvokeArchObject arch_invocation\n\nend", "property": "System Call Arguments Encoding: Defines the structure of arguments for various system calls, including operations on capabilities, untyped memory, thread control, interrupt handling, and domain management. These datatypes ensure that the system calls are provided with the necessary parameters to perform their intended actions, maintaining the integrity and functionality of the operating system.", "title": "./spec/abstract/Invocations_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the available system calls."}
{"spec": "text \\<open>\n Recall that a capability may reside in either a CNode, or inside a TCB;\nthe following definitions allow the kernel model to retrieve and update\ncapabilities in a uniform fashion.\\<close>\ndefinition\n  get_cap :: \"cslot_ptr \\<Rightarrow> (cap,'z::state_ext) s_monad\"\nwhere\n  \"get_cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     caps \\<leftarrow> case obj of\n             CNode sz cnode \\<Rightarrow> do\n                                assert (well_formed_cnode_n sz cnode);\n                                return cnode\n                              od\n           | TCB tcb     \\<Rightarrow> return (tcb_cnode_map tcb)\n           | _ \\<Rightarrow> fail;\n     assert_opt (caps cref)\n   od\"\n\ndefinition\n  set_cap :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_cap cap \\<equiv> \\<lambda>(oref, cref). do\n     obj \\<leftarrow> get_object oref;\n     obj' \\<leftarrow> case obj of\n               CNode sz cn \\<Rightarrow> if cref \\<in> dom cn \\<and> well_formed_cnode_n sz cn\n                                then return $ CNode sz $ cn (cref \\<mapsto> cap)\n                                else fail\n             | TCB tcb \\<Rightarrow>\n                   if cref = tcb_cnode_index 0 then\n                       return $ TCB $ tcb \\<lparr> tcb_ctable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 1 then\n                       return $ TCB $ tcb \\<lparr> tcb_vtable := cap \\<rparr>\n                   else if cref = tcb_cnode_index 2 then\n                       return $ TCB $ tcb \\<lparr> tcb_reply := cap \\<rparr>\n                   else if cref = tcb_cnode_index 3 then\n                       return $ TCB $ tcb \\<lparr> tcb_caller := cap \\<rparr>\n                   else if cref = tcb_cnode_index 4 then\n                       return $ TCB $ tcb \\<lparr> tcb_ipcframe := cap \\<rparr>\n                   else\n                       fail\n             | _ \\<Rightarrow> fail;\n     set_object oref obj'\n  od\"", "property": "Capability Access and Modification: Retrieve and update capabilities in a uniform manner from either a CNode or a TCB. Ensure that the capability slots are well-formed and within the valid range, and update the corresponding fields in the TCB or CNode.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": ""}
{"spec": "definition\n  ensure_empty :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"ensure_empty slot \\<equiv> doE\n    cap \\<leftarrow> liftE $ get_cap slot;\n    whenE (cap \\<noteq> NullCap) (throwError DeleteFirst)\n  odE\"", "property": "Ensure Slot Emptiness: Verify that a given capability slot is empty, and if it contains a non-null capability, an error is thrown to indicate the slot must be cleared.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "Ensure a capability slot is empty."}
{"spec": "text \\<open>Set the capability derivation tree.\\<close>\ndefinition\n  set_cdt :: \"cdt \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"set_cdt t \\<equiv> do\n    s \\<leftarrow> get;\n    put $ s\\<lparr> cdt := t \\<rparr>\n  od\"", "property": "Set Capability Derivation Tree: Updates the capability derivation tree to a new value, ensuring that the system's capability structure is correctly maintained.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": ""}
{"spec": "definition\n  update_cdt :: \"(cdt \\<Rightarrow> cdt) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"update_cdt f \\<equiv> do\n     t \\<leftarrow> gets cdt;\n     set_cdt (f t)\n  od\"", "property": "Update Capability Derivation Tree: Modify the capability derivation tree by applying a given function to the current tree, ensuring that the updated tree reflects the changes accurately.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "Update the capability derivation tree."}
{"spec": "definition\n  set_original :: \"cslot_ptr \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_original slot v \\<equiv> do\n     r \\<leftarrow> gets is_original_cap;\n     modify (\\<lambda>s. s \\<lparr> is_original_cap := r (slot := v) \\<rparr>)\n  od\"", "property": "Set Original Flag: Update the original flag for a specified capability slot, ensuring that the flag reflects whether the capability is an original or a derived one.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "Set the original flag for a given cap slot."}
{"spec": "definition\n  is_cdt_parent :: \"cdt \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\" where\n  \"is_cdt_parent t p c \\<equiv> t c = Some p\"\n\ndefinition\n  cdt_parent_rel :: \"cdt \\<Rightarrow> (cslot_ptr \\<times> cslot_ptr) set\" where\n  \"cdt_parent_rel t \\<equiv> {(p,c). is_cdt_parent t p c}\"\n\nabbreviation\n  parent_of :: \"cdt \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of _\" [60,0,60] 61)\nwhere\n  \"t \\<turnstile> p cdt_parent_of c \\<equiv> (p,c) \\<in> cdt_parent_rel t\"\n\nabbreviation\n  parent_of_trancl :: \"cdt \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of\\<^sup>+ _\" [60,0,60] 61)\nwhere\n  \"t \\<turnstile> x cdt_parent_of\\<^sup>+ y \\<equiv> (x, y) \\<in> (cdt_parent_rel t)\\<^sup>+\"\n\nabbreviation\n  parent_of_rtrancl :: \"cdt \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\"\n  (\"_ \\<turnstile> _ cdt'_parent'_of\\<^sup>* _\" [60,0,60] 61)\nwhere\n  \"t \\<turnstile> x cdt_parent_of\\<^sup>* y \\<equiv> (x, y) \\<in> (cdt_parent_rel t)\\<^sup>*\"\n\n\nnotation\n  parent_of (\"_ \\<Turnstile> _ \\<leadsto> _\" [60,0,60] 60)\nand\n  parent_of_trancl (\"_ \\<Turnstile> _ \\<rightarrow> _\" [60,0,60] 60)\nand\n  parent_of_rtrancl (\"_ \\<Turnstile> _ \\<rightarrow>* _\" [60,0,60] 60)", "property": "Capability Derivation Tree Relations: Define relationships between capability slots in the capability derivation tree, including direct parent-child relationships, transitive parent-child relationships, and reflexive-transitive parent-child relationships. These relations enable the system to track and manage the hierarchical structure of capabilities within the CSpace.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "Definitions and syntax for predicates on capability derivation."}
{"spec": "definition\n  descendants_of :: \"cslot_ptr \\<Rightarrow> cdt \\<Rightarrow> cslot_ptr set\" where\n  \"descendants_of p t \\<equiv> {q. (p,q) \\<in> (cdt_parent_rel t)\\<^sup>+}\"\n\nend", "property": "Descendants of a CSlot: Identify all the descendant slots of a given slot in the capability derivation tree, forming a set that includes all slots that are reachable from the given slot through the parent-child relationships in the tree.", "title": "./spec/abstract/CSpaceAcc_A.thy", "chapter": "Accessing CSpace", "section": "Accessing the capability derivation tree", "comment": "The set of descendants of a particular slot in the CDT."}
{"spec": "definition\n  get_message_info :: \"obj_ref \\<Rightarrow> (message_info,'z::state_ext) s_monad\"\nwhere\n  \"get_message_info thread \\<equiv> do\n     x \\<leftarrow> as_user thread $ getRegister msg_info_register;\n     return $ data_to_message_info x\n   od\"", "property": "Retrieve Message Information: Obtain the message information from the specified thread's message info register and convert it to a structured message information format.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "IPC Capability Transfers", "comment": ""}
{"spec": "definition\n  remove_rights :: \"cap_rights \\<Rightarrow> cap \\<Rightarrow> cap\"\nwhere\n \"remove_rights rights cap \\<equiv> cap_rights_update (cap_rights cap - rights) cap\"", "property": "Modify Capabilities: Adjust the rights of a capability by removing specified rights, ensuring that the capability's permissions are appropriately restricted.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": ""}
{"spec": "definition\n  buffer_cptr_index :: nat\nwhere\n \"buffer_cptr_index \\<equiv> (msg_max_length + 2)\"\n\nprimrec\n  get_extra_cptrs :: \"obj_ref option \\<Rightarrow> message_info \\<Rightarrow> (cap_ref list,'z::state_ext) s_monad\"\nwhere\n  \"get_extra_cptrs (Some buf) mi =\n    (liftM (map data_to_cptr) $ mapM (load_word_offs buf)\n        [buffer_cptr_index ..< buffer_cptr_index + (unat (mi_extra_caps mi))])\"\n| \"get_extra_cptrs None mi = return []\"\n\ndefinition\n  get_extra_cptr :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> (cap_ref,'z::state_ext) s_monad\"\nwhere\n  \"get_extra_cptr buffer n \\<equiv> liftM data_to_cptr\n      (load_word_offs buffer (n + buffer_cptr_index))\"", "property": "Retrieve Additional Capabilities: Retrieve the identities of additional capabilities from the thread's IPC buffer. Load the word offsets corresponding to the extra capabilities and convert them to capability pointers.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "In addition to the data payload a message may also contain capabilities.\nWhen a thread requests additional capabilities be transferred the identities of\nthose capabilities are retreived from the thread's IPC buffer."}
{"spec": "definition\n  lookup_extra_caps :: \"obj_ref \\<Rightarrow> data option \\<Rightarrow> message_info \\<Rightarrow> ((cap \\<times> cslot_ptr) list,'z::state_ext) f_monad\" where\n  \"lookup_extra_caps thread buffer mi \\<equiv> doE\n       cptrs \\<leftarrow> liftE $ get_extra_cptrs buffer mi;\n       mapME (\\<lambda>cptr. cap_fault_on_failure (of_bl cptr) False $ lookup_cap_and_slot thread cptr) cptrs\n  odE\"", "property": "Lookup and Retrieve Extra Capabilities: Retrieve the additional capability pointers from the thread's IPC buffer and look up the corresponding capabilities and their slot pointers in the sender's CSpace, handling any faults that may occur during the process.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "This function both looks up the addresses of the additional capabilities\nand retreives them from the sender's CSpace."}
{"spec": "definition\n  set_extra_badge :: \"obj_ref \\<Rightarrow> machine_word \\<Rightarrow> nat \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_extra_badge buffer badge n \\<equiv>\n      store_word_offs buffer (buffer_cptr_index + n) badge\"\n\ntype_synonym transfer_caps_data = \"(cap \\<times> cslot_ptr) list \\<times> cslot_ptr list\"\n\nfun\n  transfer_caps_loop :: \"obj_ref option \\<Rightarrow> obj_ref \\<Rightarrow> nat\n                          \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> cslot_ptr list\n                          \\<Rightarrow> message_info \\<Rightarrow> (message_info,'z::state_ext) s_monad\"\nwhere\n  \"transfer_caps_loop ep rcv_buffer n [] slots\n      mi = return (MI (mi_length mi) (of_nat n) (mi_caps_unwrapped mi)\n                        (mi_label mi))\"\n| \"transfer_caps_loop ep rcv_buffer n ((cap, slot) # morecaps)\n         slots mi =\n  const_on_failure (MI (mi_length mi) (of_nat n) (mi_caps_unwrapped mi)\n                       (mi_label mi)) (doE\n    transfer_rest \\<leftarrow> returnOk $ transfer_caps_loop ep\n         rcv_buffer (n + 1) morecaps;\n    if (is_ep_cap cap \\<and> ep = Some (obj_ref_of cap))\n    then doE\n       liftE $ set_extra_badge rcv_buffer (cap_ep_badge cap) n;\n       liftE $ transfer_rest slots (MI (mi_length mi) (mi_extra_caps mi)\n         (mi_caps_unwrapped mi || (1 << n)) (mi_label mi))\n    odE\n    else if slots \\<noteq> []\n    then doE\n      cap' \\<leftarrow> derive_cap slot cap;\n      whenE (cap' = NullCap) $ throwError undefined;\n      liftE $ cap_insert cap' slot (hd slots);\n      liftE $ transfer_rest (tl slots) mi\n    odE\n    else returnOk (MI (mi_length mi) (of_nat n) (mi_caps_unwrapped mi)\n                       (mi_label mi))\n  odE)\"\n\ndefinition\n  transfer_caps :: \"message_info \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n                   obj_ref option \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow>\n                   (message_info,'z::state_ext) s_monad\"\nwhere\n  \"transfer_caps info caps endpoint receiver recv_buffer \\<equiv> do\n     dest_slots \\<leftarrow> get_receive_slots receiver recv_buffer;\n     mi' \\<leftarrow> return $ MI (mi_length info) 0 0 (mi_label info);\n     case recv_buffer of\n       None \\<Rightarrow> return mi'\n     | Some receive_buffer \\<Rightarrow>\n         transfer_caps_loop endpoint receive_buffer 0 caps dest_slots mi'\n   od\"", "property": "Capability Transfer and Unwrapping: During message passing, capabilities are divided into two groups. Capabilities to the same endpoint as the message are not copied; instead, their badges are unwrapped and stored in the receiver's message buffer. Other capabilities are copied into the specified slots, ensuring that the receiver can efficiently demonstrate authority to multiple services provided by the sender.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "Capability transfers. Capabilities passed along with a message are split\ninto two groups. Capabilities to the same endpoint as the message is passed\nthrough are not copied. Their badges are unwrapped and stored in the receiver's\nmessage buffer instead. Other capabilities are copied into the given slots.\n\nCapability unwrapping allows a client to efficiently demonstrate to a server\nthat it possesses authority to two or more services that server provides.\n"}
{"spec": "text \\<open>Threads fault when they attempt to access services that are not backed\nby any resources. Such a thread is then blocked and a fault messages is sent to\nits supervisor. When a reply to that message is sent the thread is reactivated.\n\\<close>", "property": "Thread Fault Handling: When a thread attempts to access services without the necessary resources, it is blocked, and a fault message is sent to its supervisor. Upon receiving a reply to the fault message, the thread is reactivated.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": ""}
{"spec": "fun\n  make_fault_msg :: \"fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\nwhere\n  \"make_fault_msg (CapFault cptr rp lf) thread = (do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (1, pc # cptr # (if rp then 1 else 0) # msg_from_lookup_failure lf)\n   od)\"\n| \"make_fault_msg (UnknownSyscallException n) thread = (do\n     msg \\<leftarrow> as_user thread $ mapM getRegister syscallMessage;\n     return (2, msg @ [n])\n   od)\"\n| \"make_fault_msg (UserException exception code) thread = (do\n     msg \\<leftarrow> as_user thread $ mapM getRegister exceptionMessage;\n     return (3, msg @ [exception, code])\n   od)\"\n| \"make_fault_msg (ArchFault af) thread = make_arch_fault_msg af thread \" (* arch_fault *)", "property": "Fault Message Formatting: Construct a message for a given fault type, including relevant details such as the program counter, capability pointer, and other fault-specific information. The message is formatted based on the type of fault, ensuring that the necessary data is included for proper handling.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "Format a message for a given fault type."}
{"spec": "fun\n  handle_fault_reply :: \"fault \\<Rightarrow> obj_ref \\<Rightarrow>\n                         data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault_reply (CapFault cptr rp lf) thread x y = return True\"\n| \"handle_fault_reply (UnknownSyscallException n) thread label msg = do\n     t \\<leftarrow> arch_get_sanitise_register_info thread;\n     as_user thread $ zipWithM_x\n         (\\<lambda>r v. setRegister r $ sanitise_register t r v)\n         syscallMessage msg;\n     return (label = 0)\n   od\"\n| \"handle_fault_reply (UserException exception code) thread label msg = do\n     t \\<leftarrow> arch_get_sanitise_register_info thread;\n     as_user thread $ zipWithM_x\n         (\\<lambda>r v. setRegister r $ sanitise_register t r v)\n         exceptionMessage msg;\n     return (label = 0)\n   od\"\n| \" handle_fault_reply (ArchFault af) thread label msg =\n    handle_arch_fault_reply af thread label msg\" (* arch_fault *)", "property": "Fault Handling: Processes fault replies by interpreting the message based on the type of the original fault. For certain faults, it reconfigures the thread to save the recipient an additional system call. The function returns a boolean indicating whether the thread should be restarted.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "React to a fault reply. The reply message is interpreted in a manner\nthat depends on the type of the original fault. For some fault types a thread\nreconfiguration is performed. This is done entirely to save the fault message\nrecipient an additional system call. This function returns a boolean indicating\nwhether the thread should now be restarted."}
{"spec": "definition\n  do_fault_transfer :: \"data \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref\n                             \\<Rightarrow> obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"do_fault_transfer badge sender receiver buf \\<equiv> do\n    fault \\<leftarrow> thread_get tcb_fault sender;\n    f \\<leftarrow> (case fault of\n         Some f \\<Rightarrow> return f\n       | None \\<Rightarrow> fail);\n    (label, msg) \\<leftarrow> make_fault_msg f sender;\n    sent \\<leftarrow> set_mrs receiver buf msg;\n    set_message_info receiver $ MI sent 0 0 label;\n    as_user receiver $ setRegister badge_register badge\n  od\"", "property": "Fault Message Transfer: Transfers a fault message from a faulting thread to its supervisor, including setting the message information and badge register for the receiver.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Fault Handling", "comment": "Transfer a fault message from a faulting thread to its supervisor."}
{"spec": "text \\<open>Transfer a non-fault message.\\<close>\ndefinition\n  do_normal_transfer :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> obj_ref option\n                                    \\<Rightarrow> data \\<Rightarrow> bool \\<Rightarrow> obj_ref\n                                    \\<Rightarrow> obj_ref option\n                                    \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"do_normal_transfer sender sbuf endpoint badge grant\n                     receiver rbuf  \\<equiv>\n  do\n    mi \\<leftarrow> get_message_info sender;\n    caps \\<leftarrow> if grant then lookup_extra_caps sender sbuf mi <catch> K (return [])\n      else return [];\n    mrs_transferred \\<leftarrow> copy_mrs sender sbuf receiver rbuf (mi_length mi);\n    mi' \\<leftarrow> transfer_caps mi caps endpoint receiver rbuf;\n    set_message_info receiver $ MI mrs_transferred (mi_extra_caps mi')\n                                   (mi_caps_unwrapped mi') (mi_label mi);\n    as_user receiver $ setRegister badge_register badge\n  od\"", "property": "Synchronous Message Transfer: Transfers a non-fault message from the sender to the receiver, including the message data, badge, and optionally additional capabilities. The transfer updates the message information for the receiver and sets the badge register.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": ""}
{"spec": "definition\n  do_ipc_transfer :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow>\n                       badge \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"do_ipc_transfer sender ep badge grant\n     receiver \\<equiv> do\n\n     recv_buffer \\<leftarrow> lookup_ipc_buffer True receiver;\n     fault \\<leftarrow> thread_get tcb_fault sender;\n\n     case fault\n        of None \\<Rightarrow> do\n            send_buffer \\<leftarrow> lookup_ipc_buffer False sender;\n            do_normal_transfer sender send_buffer ep badge grant\n                           receiver recv_buffer\n            od\n         | Some f \\<Rightarrow> do_fault_transfer badge sender receiver recv_buffer\n   od\"", "property": "Synchronous Message Transfer: Perform a message transfer between a sender and a receiver, which may involve handling a fault. If no fault is present, a normal transfer is executed; otherwise, a fault-specific transfer is conducted.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Transfer a message either involving a fault or not."}
{"spec": "definition\n  do_reply_transfer :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"do_reply_transfer sender receiver slot grant \\<equiv> do\n    state \\<leftarrow> get_thread_state receiver;\n    assert (state = BlockedOnReply);\n    fault \\<leftarrow> thread_get tcb_fault receiver;\n    case fault of\n      None \\<Rightarrow> do\n         do_ipc_transfer sender None 0 grant receiver;\n         cap_delete_one slot;\n         set_thread_state receiver Running;\n         do_extended_op (possible_switch_to receiver)\n      od\n    | Some f \\<Rightarrow> do\n         cap_delete_one slot;\n         mi \\<leftarrow> get_message_info sender;\n         buf \\<leftarrow> lookup_ipc_buffer False sender;\n         mrs \\<leftarrow> get_mrs sender buf mi;\n         restart \\<leftarrow> handle_fault_reply f receiver (mi_label mi) mrs;\n         thread_set (\\<lambda>tcb. tcb \\<lparr> tcb_fault := None \\<rparr>) receiver;\n         set_thread_state receiver (if restart then Restart else Inactive);\n         when restart $ do_extended_op (possible_switch_to receiver);\n         return ()\n       od\n  od\"", "property": "Synchronous Reply Transfer: Transfers a reply message from the sender to the receiver, deletes the one-use Reply capability, and updates the receiver's thread state. If the receiver is blocked on a reply, it resumes the receiver in the Running state; if there is a fault, it handles the fault, updates the receiver's fault status, and sets the receiver's state based on the fault handling result.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Transfer a reply message and delete the one-use Reply capability."}
{"spec": "definition\n  reply_from_kernel :: \"obj_ref \\<Rightarrow> (data \\<times> data list) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"reply_from_kernel thread x \\<equiv> do\n    (label, msg) \\<leftarrow> return x;\n    buf \\<leftarrow> lookup_ipc_buffer True thread;\n    as_user thread $ setRegister badge_register 0;\n    len \\<leftarrow> set_mrs thread buf msg;\n    set_message_info thread $ MI len 0 0 label\n  od\"", "property": "Synchronous Message Transfer: Transfers a reply message to a thread from the kernel, setting the badge register to 0, updating the IPC buffer with the message, and setting the message information.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "This function transfers a reply message to a thread when that message\nis generated by a kernel service."}
{"spec": "definition\n  setup_caller_cap :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"setup_caller_cap sender receiver grant \\<equiv> do\n    set_thread_state sender BlockedOnReply;\n    cap_insert (ReplyCap sender False (if grant then {AllowGrant, AllowWrite} else {AllowWrite}))\n               (sender, tcb_cnode_index 2)\n      (receiver, tcb_cnode_index 3)\n  od\"", "property": "Install Reply Capability: Set up a one-use Reply capability for the sender, placing it in the receiver's CNode. The capability is configured with specific permissions, including AllowWrite and optionally AllowGrant, and the sender is placed in a BlockedOnReply state.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Install a one-use Reply capability."}
{"spec": "definition\n  send_ipc :: \"bool \\<Rightarrow> bool \\<Rightarrow> badge \\<Rightarrow> bool \\<Rightarrow> bool\n                \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"send_ipc block call badge can_grant can_grant_reply thread epptr \\<equiv> do\n     ep \\<leftarrow> get_endpoint epptr;\n     case (ep, block) of\n         (IdleEP, True) \\<Rightarrow> do\n               set_thread_state thread (BlockedOnSend epptr\n                                   \\<lparr> sender_badge = badge,\n                                     sender_can_grant = can_grant,\n                                     sender_can_grant_reply = can_grant_reply,\n                                     sender_is_call = call \\<rparr>);\n               set_endpoint epptr $ SendEP [thread]\n             od\n       | (SendEP queue, True) \\<Rightarrow> do\n               set_thread_state thread (BlockedOnSend epptr\n                                   \\<lparr> sender_badge = badge,\n                                     sender_can_grant = can_grant,\n                                     sender_can_grant_reply = can_grant_reply,\n                                     sender_is_call = call\\<rparr>);\n               set_endpoint epptr $ SendEP (queue @ [thread])\n             od\n       | (IdleEP, False) \\<Rightarrow> return ()\n       | (SendEP queue, False) \\<Rightarrow> return ()\n       | (RecvEP (dest # queue), _) \\<Rightarrow> do\n                set_endpoint epptr $ (case queue of [] \\<Rightarrow> IdleEP\n                                                     | _ \\<Rightarrow> RecvEP queue);\n                recv_state \\<leftarrow> get_thread_state dest;\n                reply_can_grant \\<leftarrow> case recv_state\n                  of (BlockedOnReceive x data) \\<Rightarrow> do\n                           do_ipc_transfer thread (Some epptr) badge can_grant dest;\n                           return (receiver_can_grant data)\n                           od\n                  | _ \\<Rightarrow> fail;\n                set_thread_state dest Running;\n                do_extended_op (possible_switch_to dest);\n                when call $\n                  if (can_grant \\<or> can_grant_reply)\n                  then setup_caller_cap thread dest reply_can_grant\n                  else set_thread_state thread Inactive\n                od\n\n       | (RecvEP [], _) \\<Rightarrow> fail\n   od\"", "property": "Synchronous Message Transfer: Handles message send operations on an endpoint by a thread, transferring the message to a waiting receiver if available. If no receiver is waiting and the thread is willing to block, it is placed in the sending queue of the endpoint. If the thread is not willing to block and there is no waiting receiver, the operation does nothing.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Handle a message send operation performed on an endpoint by a thread.\nIf a receiver is waiting then transfer the message. If no receiver is available\nand the thread is willing to block waiting to send then put it in the endpoint\nsending queue."}
{"spec": "definition\n  isActive :: \"notification \\<Rightarrow> bool\"\nwhere\n  \"isActive ntfn \\<equiv> case ntfn_obj ntfn\n     of ActiveNtfn _ \\<Rightarrow> True\n      | _ \\<Rightarrow> False\"", "property": "Message Reception on Endpoint: Handle a message receive operation on an endpoint by a thread. If a sender is waiting, the message is transferred; otherwise, the thread is placed in the endpoint's receiving queue.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Handle a message receive operation performed on an endpoint by a thread.\nIf a sender is waiting then transfer the message, otherwise put the thread in\nthe endpoint receiving queue."}
{"spec": "definition\n  complete_signal :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"complete_signal ntfnptr tcb \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     case ntfn_obj ntfn of\n       ActiveNtfn badge \\<Rightarrow> do\n           as_user tcb $ setRegister badge_register badge;\n           set_notification ntfnptr $ ntfn_set_obj ntfn IdleNtfn\n         od\n     | _ \\<Rightarrow> fail\n   od\"\n\ndefinition\n  do_nbrecv_failed_transfer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"do_nbrecv_failed_transfer thread = do as_user thread $ setRegister badge_register 0; return () od\"\n\ndefinition\n  receive_ipc :: \"obj_ref \\<Rightarrow> cap \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"receive_ipc thread cap is_blocking \\<equiv> do\n     (epptr,rights) \\<leftarrow> (case cap\n                       of EndpointCap ref badge rights \\<Rightarrow> return (ref,rights)\n                        | _ \\<Rightarrow> fail);\n     ep \\<leftarrow> get_endpoint epptr;\n     ntfnptr \\<leftarrow> get_bound_notification thread;\n     ntfn \\<leftarrow> case_option (return default_notification) get_notification ntfnptr;\n     if (ntfnptr \\<noteq> None \\<and> isActive ntfn)\n     then\n       complete_signal (the ntfnptr) thread\n     else\n       case ep\n         of IdleEP \\<Rightarrow> (case is_blocking of\n              True \\<Rightarrow> do\n                  set_thread_state thread (BlockedOnReceive epptr\n                                           \\<lparr>receiver_can_grant = (AllowGrant \\<in> rights)\\<rparr>);\n                  set_endpoint epptr (RecvEP [thread])\n                od\n              | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n            | RecvEP queue \\<Rightarrow> (case is_blocking of\n              True \\<Rightarrow> do\n                  set_thread_state thread (BlockedOnReceive epptr\n                                           \\<lparr>receiver_can_grant = (AllowGrant \\<in> rights)\\<rparr>);\n                  set_endpoint epptr (RecvEP (queue @ [thread]))\n                od\n              | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n          | SendEP q \\<Rightarrow> do\n              assert (q \\<noteq> []);\n              queue \\<leftarrow> return $ tl q;\n              sender \\<leftarrow> return $ hd q;\n              set_endpoint epptr $\n                (case queue of [] \\<Rightarrow> IdleEP | _ \\<Rightarrow> SendEP queue);\n              sender_state \\<leftarrow> get_thread_state sender;\n              data \\<leftarrow> (case sender_state\n                       of BlockedOnSend ref data \\<Rightarrow> return data\n                        | _ \\<Rightarrow> fail);\n              do_ipc_transfer sender (Some epptr)\n                        (sender_badge data) (sender_can_grant data)\n                        thread;\n              if (sender_is_call data)\n              then\n                if (sender_can_grant data \\<or> sender_can_grant_reply data)\n                then setup_caller_cap sender thread (AllowGrant \\<in> rights)\n                else set_thread_state sender Inactive\n              else do\n                set_thread_state sender Running;\n                do_extended_op (possible_switch_to sender)\n              od\n            od\n   od\"", "property": "Synchronous Message Transfers: Handle the reception of IPC messages, including processing notifications, managing thread states, and transferring data between sender and receiver. The system ensures that threads are correctly blocked or unblocked based on the message reception status, and it properly updates endpoint states to reflect the current communication status.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Synchronous Message Transfers", "comment": "Helper function for performing \\emph{signal} when receiving on a normal\nendpoint"}
{"spec": "text \\<open>Helper function to handle a signal operation in the case\nwhere a receiver is waiting.\\<close>\ndefinition\n  update_waiting_ntfn :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref option \\<Rightarrow> badge \\<Rightarrow>\n                         (unit,'z::state_ext) s_monad\"\nwhere\n  \"update_waiting_ntfn ntfnptr queue bound_tcb badge \\<equiv> do\n     assert (queue \\<noteq> []);\n     (dest,rest) \\<leftarrow> return $ (hd queue, tl queue);\n     set_notification ntfnptr $ \\<lparr>\n         ntfn_obj = (case rest of [] \\<Rightarrow> IdleNtfn | _ \\<Rightarrow> WaitingNtfn rest),\n         ntfn_bound_tcb = bound_tcb \\<rparr>;\n     set_thread_state dest Running;\n     as_user dest $ setRegister badge_register badge;\n     do_extended_op (possible_switch_to dest)\n\n   od\"", "property": "Update Waiting Notification: Updates the state of a waiting notification, setting the notification object and bound thread control block, transitioning the destination thread to the running state, and setting the badge register. If there are more threads in the queue, it updates the notification to reflect the new waiting state; otherwise, it sets the notification to idle. This ensures that the next thread in the queue is properly prepared for execution.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Asynchronous Message Transfers", "comment": ""}
{"spec": "definition\n  receive_blocked :: \"thread_state \\<Rightarrow> bool\"\nwhere\n  \"receive_blocked st \\<equiv> case st of\n       BlockedOnReceive _ _ \\<Rightarrow> True\n     | _ \\<Rightarrow> False\"\n\ndefinition\n  send_signal :: \"obj_ref \\<Rightarrow> badge \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"send_signal ntfnptr badge \\<equiv> do\n    ntfn \\<leftarrow> get_notification ntfnptr;\n    case (ntfn_obj ntfn, ntfn_bound_tcb ntfn) of\n          (IdleNtfn, Some tcb) \\<Rightarrow> do\n                  st \\<leftarrow> get_thread_state tcb;\n                  if (receive_blocked st)\n                  then do\n                      cancel_ipc tcb;\n                      set_thread_state tcb Running;\n                      as_user tcb $ setRegister badge_register badge;\n                      do_extended_op (possible_switch_to tcb)\n                    od\n                  else set_notification ntfnptr $ ntfn_set_obj ntfn (ActiveNtfn badge)\n            od\n       | (IdleNtfn, None) \\<Rightarrow> set_notification ntfnptr $ ntfn_set_obj ntfn (ActiveNtfn badge)\n       | (WaitingNtfn queue, bound_tcb) \\<Rightarrow> update_waiting_ntfn ntfnptr queue bound_tcb badge\n       | (ActiveNtfn badge', _) \\<Rightarrow>\n           set_notification ntfnptr $ ntfn_set_obj ntfn $\n             ActiveNtfn (combine_ntfn_badges badge badge')\n   od\"", "property": "Send Signal for Asynchronous Message Transfers: Sends a signal to a notification object, which may unblock a thread if it is blocked on receiving a message. If the thread is blocked, it cancels the IPC, sets the thread state to running, and updates the badge register. If the notification is in an idle or active state, it updates the notification object accordingly. If the notification is in a waiting state, it updates the waiting notification queue.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Asynchronous Message Transfers", "comment": " helper function for checking if thread is blocked "}
{"spec": "definition\n  receive_signal :: \"obj_ref \\<Rightarrow> cap \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n   \"receive_signal thread cap is_blocking \\<equiv> do\n    ntfnptr \\<leftarrow>\n      case cap\n        of NotificationCap ntfnptr badge rights \\<Rightarrow> return ntfnptr\n         | _ \\<Rightarrow> fail;\n    ntfn \\<leftarrow> get_notification ntfnptr;\n    case ntfn_obj ntfn\n      of IdleNtfn \\<Rightarrow>\n                   (case is_blocking of\n                     True \\<Rightarrow> do\n                          set_thread_state thread (BlockedOnNotification ntfnptr);\n                          set_notification ntfnptr $ ntfn_set_obj ntfn $ WaitingNtfn [thread]\n                        od\n                   | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n       | WaitingNtfn queue \\<Rightarrow>\n                   (case is_blocking of\n                     True \\<Rightarrow> do\n                          set_thread_state thread (BlockedOnNotification ntfnptr);\n                          set_notification ntfnptr $ ntfn_set_obj ntfn $ WaitingNtfn (queue @ [thread])\n                        od\n                   | False \\<Rightarrow> do_nbrecv_failed_transfer thread)\n       | ActiveNtfn badge \\<Rightarrow> do\n                     as_user thread $ setRegister badge_register badge;\n                     set_notification ntfnptr $ ntfn_set_obj ntfn IdleNtfn\n                   od\n    od\"", "property": "Notification Receive Operation: Handles the receive operation on a notification object by a thread. If a message is waiting, it transfers the badge to the thread and resets the notification object. If no message is waiting and the operation is blocking, the thread is placed in the receiving queue of the notification; if non-blocking, it performs a failed transfer action.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Asynchronous Message Transfers", "comment": "Handle a receive operation performed on a notification object by a\nthread. If a message is waiting then perform the transfer, otherwise put the\nthread in the endpoint's receiving queue."}
{"spec": "text \\<open>When a thread encounters a fault, retreive its fault handler capability\nand send a fault message.\\<close>\ndefinition\n  send_fault_ipc :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n  \"send_fault_ipc tptr fault \\<equiv> doE\n     handler_cptr \\<leftarrow> liftE $ thread_get tcb_fault_handler tptr;\n     handler_cap \\<leftarrow> cap_fault_on_failure (of_bl handler_cptr) False $\n         lookup_cap tptr handler_cptr;\n\n     let f = CapFault (of_bl handler_cptr) False (MissingCapability 0)\n     in\n     (case handler_cap\n       of EndpointCap ref badge rights \\<Rightarrow>\n           if AllowSend \\<in> rights \\<and> (AllowGrant \\<in> rights \\<or> AllowGrantReply \\<in> rights)\n           then liftE $ (do\n               thread_set (\\<lambda>tcb. tcb \\<lparr> tcb_fault := Some fault \\<rparr>) tptr;\n               send_ipc True True (cap_ep_badge handler_cap)\n                        (AllowGrant \\<in> rights) True tptr (cap_ep_ptr handler_cap)\n             od)\n           else throwError f\n        | _ \\<Rightarrow> throwError f)\n   odE\"", "property": "Send Fault IPC: When a thread encounters a fault, retrieve its fault handler capability and send a fault message to the designated endpoint. The message is sent only if the handler capability has the necessary permissions (AllowSend and either AllowGrant or AllowGrantReply). If the handler does not have the required permissions, a CapFault is thrown.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Sending Fault Messages", "comment": ""}
{"spec": "definition\n  handle_double_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_double_fault tptr ex1 ex2 \\<equiv> set_thread_state tptr Inactive\"", "property": "Handle Double Fault: Set the thread state to inactive if a fault message cannot be sent, ensuring that the thread remains in an inactive state to prevent further execution.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Sending Fault Messages", "comment": "If a fault message cannot be sent then leave the thread inactive."}
{"spec": "definition\n  handle_fault :: \"obj_ref \\<Rightarrow> fault \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_fault thread ex \\<equiv> do\n     _ \\<leftarrow> gets_the $ get_tcb thread;\n     send_fault_ipc thread ex\n          <catch> handle_double_fault thread ex;\n     return ()\n   od\"\n\nend", "property": "Handle Thread Fault: Manages a thread fault by attempting to send a fault message. If sending the fault message fails, it catches the exception and handles a double fault.", "title": "./spec/abstract/Ipc_A.thy", "chapter": "IPC", "section": "Sending Fault Messages", "comment": "Handle a thread fault by sending a fault message if possible."}
{"spec": "text \\<open>This definition decodes CNode invocations.\\<close>\n\ndefinition\n  decode_cnode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap \\<Rightarrow> cap list \\<Rightarrow> (cnode_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_cnode_invocation label args cap excaps \\<equiv> doE\n  unlessE (gen_invocation_type label \\<in> set [CNodeRevoke .e. CNodeSaveCaller]) $\n    throwError IllegalOperation;\n  whenE (length args < 2) (throwError TruncatedMessage);\n  index \\<leftarrow> returnOk $ data_to_cptr $ args ! 0;\n  bits \\<leftarrow> returnOk $ data_to_nat $ args ! 1;\n  args \\<leftarrow> returnOk $ drop 2 args;\n  dest_slot \\<leftarrow> lookup_target_slot cap index bits;\n  if length args \\<ge> 2 \\<and> length excaps > 0\n        \\<and> gen_invocation_type label \\<in> set [CNodeCopy .e. CNodeMutate] then\n  doE\n    src_index \\<leftarrow> returnOk $ data_to_cptr $ args ! 0;\n    src_depth \\<leftarrow> returnOk $ data_to_nat $ args ! 1;\n    args \\<leftarrow> returnOk $ drop 2 args;\n    src_root_cap \\<leftarrow> returnOk $ excaps ! 0;\n    ensure_empty dest_slot;\n    src_slot \\<leftarrow>\n         lookup_source_slot src_root_cap src_index src_depth;\n    src_cap \\<leftarrow> liftE $ get_cap src_slot;\n    whenE (src_cap = NullCap) $\n         throwError $ FailedLookup True $ MissingCapability src_depth;\n    (rights, cap_data, is_move) \\<leftarrow> case (gen_invocation_type label, args) of\n      (CNodeCopy, rightsWord # _) \\<Rightarrow> doE\n                    rights \\<leftarrow> returnOk $ data_to_rights $ rightsWord;\n                    returnOk $ (rights, None, False)\n                odE\n     | (CNodeMint, rightsWord # capData # _) \\<Rightarrow> doE\n                    rights \\<leftarrow> returnOk $ data_to_rights $ rightsWord;\n                    returnOk $ (rights, Some capData, False)\n                odE\n     | (CNodeMove, _) \\<Rightarrow> returnOk (all_rights, None, True)\n     | (CNodeMutate, capData # _) \\<Rightarrow> returnOk (all_rights, Some capData, True)\n     | _ \\<Rightarrow> throwError TruncatedMessage;\n    src_cap \\<leftarrow> returnOk $ mask_cap rights src_cap;\n    new_cap \\<leftarrow> (if is_move then returnOk else derive_cap src_slot) (case cap_data of\n                  Some w \\<Rightarrow> update_cap_data is_move w src_cap\n                | None \\<Rightarrow> src_cap);\n    whenE (new_cap = NullCap) $ throwError IllegalOperation;\n    returnOk $ (if is_move then MoveCall else InsertCall) new_cap src_slot dest_slot\n  odE\n  else if gen_invocation_type label = CNodeRevoke then returnOk $ RevokeCall dest_slot\n  else if gen_invocation_type label = CNodeDelete then returnOk $ DeleteCall dest_slot\n  else if gen_invocation_type label = CNodeSaveCaller then doE\n    ensure_empty dest_slot;\n    returnOk $ SaveCall dest_slot\n  odE\n  else if gen_invocation_type label = CNodeCancelBadgedSends then doE\n    cap \\<leftarrow> liftE $ get_cap dest_slot;\n    unlessE (has_cancel_send_rights cap) $ throwError IllegalOperation;\n    returnOk $ CancelBadgedSendsCall cap\n  odE\n  else if gen_invocation_type label = CNodeRotate \\<and> length args > 5\n          \\<and> length excaps > 1 then\n  doE\n    pivot_new_data \\<leftarrow> returnOk $ args ! 0;\n    pivot_index \\<leftarrow> returnOk $ data_to_cptr $ args ! 1;\n    pivot_depth \\<leftarrow> returnOk $ data_to_nat $ args ! 2;\n    src_new_data \\<leftarrow> returnOk $ args ! 3;\n    src_index \\<leftarrow> returnOk $ data_to_cptr $ args ! 4;\n    src_depth \\<leftarrow> returnOk $ data_to_nat $ args ! 5;\n    pivot_root_cap <- returnOk $ excaps ! 0;\n    src_root_cap <- returnOk $ excaps ! 1;\n\n    src_slot <- lookup_source_slot src_root_cap src_index src_depth;\n    pivot_slot <- lookup_pivot_slot pivot_root_cap pivot_index pivot_depth;\n\n    whenE (pivot_slot = src_slot \\<or> pivot_slot = dest_slot) $\n      throwError IllegalOperation;\n\n    unlessE (src_slot = dest_slot) $ ensure_empty dest_slot;\n\n    src_cap <- liftE $ get_cap src_slot;\n    whenE (src_cap = NullCap) $\n      throwError $ FailedLookup True $ MissingCapability src_depth;\n\n    pivot_cap <- liftE $ get_cap pivot_slot;\n    whenE (pivot_cap = NullCap) $\n      throwError $ FailedLookup False $ MissingCapability pivot_depth;\n\n    new_src_cap \\<leftarrow> returnOk $ update_cap_data True src_new_data src_cap;\n    new_pivot_cap \\<leftarrow> returnOk $ update_cap_data True pivot_new_data pivot_cap;\n\n    whenE (new_src_cap = NullCap) $ throwError IllegalOperation;\n    whenE (new_pivot_cap = NullCap) $ throwError IllegalOperation;\n\n    returnOk $ RotateCall new_src_cap new_pivot_cap src_slot pivot_slot dest_slot\n  odE\n  else\n    throwError TruncatedMessage\nodE\"", "property": "CNode Invocation Decoding: Decodes CNode invocations to perform various operations such as copying, moving, revoking, deleting, saving, canceling badged sends, and rotating capabilities. Ensures the integrity of the operation by validating the invocation type, arguments, and capability rights, and handles the appropriate actions based on the decoded information.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Threads", "comment": ""}
{"spec": "text \\<open>The definitions in this section decode invocations\non TCBs.\n\\<close>", "property": "Thread Invocation Decoding: Decode and process various TCB invocations, including actions such as suspending, resuming, reconfiguring, and managing capabilities and registers of threads. This ensures that the system can interpret and execute thread-related operations accurately, maintaining the integrity and functionality of the kernel.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Threads", "comment": ""}
{"spec": "definition\n  decode_read_registers :: \"data list \\<Rightarrow> cap \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_read_registers data cap \\<equiv> case data of\n  flags#n#_ \\<Rightarrow> doE\n    range_check n 1 $ of_nat (length frameRegisters + length gpRegisters);\n    p \\<leftarrow> case cap of ThreadCap p \\<Rightarrow> returnOk p;\n    self \\<leftarrow> liftE $ gets cur_thread;\n    whenE (p = self) $ throwError IllegalOperation;\n    returnOk $ ReadRegisters p (flags !! 0) n ArchDefaultExtraRegisters\n  odE\n| _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition\n  decode_copy_registers :: \"data list \\<Rightarrow> cap \\<Rightarrow> cap list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_copy_registers data cap extra_caps \\<equiv> case data of\n  flags#_ \\<Rightarrow>  doE\n    suspend_source \\<leftarrow> returnOk (flags !! 0);\n    resume_target \\<leftarrow> returnOk (flags !! 1);\n    transfer_frame \\<leftarrow> returnOk (flags !! 2);\n    transfer_integer \\<leftarrow> returnOk (flags !! 3);\n    whenE (extra_caps = []) $ throwError TruncatedMessage;\n    src_tcb \\<leftarrow> (case extra_caps of\n      ThreadCap p # _ \\<Rightarrow> returnOk p\n    | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n    p \\<leftarrow> case cap of ThreadCap p \\<Rightarrow> returnOk p;\n    returnOk $ CopyRegisters p src_tcb\n                             suspend_source resume_target\n                             transfer_frame transfer_integer\n                             ArchDefaultExtraRegisters\n  odE\n| _ \\<Rightarrow>  throwError TruncatedMessage\"\n\n\ndefinition\n  decode_write_registers :: \"data list \\<Rightarrow> cap \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_write_registers data cap \\<equiv> case data of\n  flags#n#values \\<Rightarrow> doE\n    whenE (length values < unat n) $ throwError TruncatedMessage;\n    p \\<leftarrow> case cap of ThreadCap p \\<Rightarrow> returnOk p;\n    self \\<leftarrow> liftE $ gets cur_thread;\n    whenE (p = self) $ throwError IllegalOperation;\n    returnOk $ WriteRegisters p (flags !! 0)\n               (take (unat n) values) ArchDefaultExtraRegisters\n  odE\n| _ \\<Rightarrow> throwError TruncatedMessage\"\n\n\ndefinition\n  check_prio :: \"data \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"check_prio new_prio auth_tcb \\<equiv>\n    doE\n      mcp \\<leftarrow> liftE $ thread_get tcb_mcpriority auth_tcb;\n      whenE (new_prio > ucast mcp) $ throwError (RangeError 0 (ucast mcp))\n    odE\"\n\n\ndefinition\n  decode_set_priority :: \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_priority args cap slot extra_caps \\<equiv> doE\n     whenE (length args = 0 \\<or> length extra_caps = 0) $ throwError TruncatedMessage;\n     prio \\<leftarrow> returnOk $ ucast (args ! 0);\n     auth_tcb \\<leftarrow> case fst (extra_caps ! 0) of\n         ThreadCap tcb_ptr \\<Rightarrow> returnOk tcb_ptr\n       | _ \\<Rightarrow> throwError (InvalidCapability 1);\n     check_prio (args ! 0) auth_tcb;\n     returnOk (ThreadControl (obj_ref_of cap) slot None None\n                             (Some (prio, auth_tcb)) None None None)\n     odE\"\n\n\ndefinition\n  decode_set_mcpriority :: \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_mcpriority args cap slot extra_caps \\<equiv> doE\n     whenE (length args = 0 \\<or> length extra_caps = 0) $ throwError TruncatedMessage;\n     new_mcp \\<leftarrow> returnOk $ ucast $ args ! 0;\n     auth_tcb \\<leftarrow> case fst (extra_caps ! 0) of\n         ThreadCap tcb_ptr \\<Rightarrow> returnOk tcb_ptr\n       | _ \\<Rightarrow> throwError (InvalidCapability 1);\n     check_prio (args ! 0) auth_tcb;\n     returnOk (ThreadControl (obj_ref_of cap) slot None (Some (new_mcp, auth_tcb))\n                             None None None None)\n     odE\"\n\n\ndefinition\n  decode_set_sched_params :: \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_sched_params args cap slot extra_caps \\<equiv> doE\n     whenE (length args < 2) $ throwError TruncatedMessage;\n     whenE (length extra_caps = 0) $ throwError TruncatedMessage;\n     new_mcp \\<leftarrow> returnOk $ ucast $ args ! 0;\n     new_prio \\<leftarrow> returnOk $ ucast $ args ! 1;\n     auth_tcb \\<leftarrow> case fst (extra_caps ! 0) of\n         ThreadCap tcb_ptr \\<Rightarrow> returnOk tcb_ptr\n       | _ \\<Rightarrow> throwError (InvalidCapability 1);\n     check_prio (args ! 0) auth_tcb;\n     check_prio (args ! 1) auth_tcb;\n     returnOk (ThreadControl (obj_ref_of cap) slot None\n                             (Some (new_mcp, auth_tcb)) (Some (new_prio, auth_tcb)) None None None)\n     odE\"\n\n\ndefinition\n  decode_set_ipc_buffer ::\n  \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_set_ipc_buffer args cap slot excs \\<equiv> doE\n  whenE (length args = 0) $ throwError TruncatedMessage;\n  whenE (length excs = 0) $ throwError TruncatedMessage;\n  buffer \\<leftarrow> returnOk $ data_to_vref $ args ! 0;\n  (bcap, bslot) \\<leftarrow> returnOk $ excs ! 0;\n  newbuf \\<leftarrow> if buffer = 0 then returnOk None\n           else doE\n      buffer_cap \\<leftarrow> derive_cap bslot bcap;\n      check_valid_ipc_buffer buffer buffer_cap;\n      returnOk $ Some (buffer_cap, bslot)\n    odE;\n  returnOk $\n    ThreadControl (obj_ref_of cap) slot None None None None None (Some (buffer, newbuf))\nodE\"\n\n\ndefinition\n  decode_set_space\n  :: \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_space args cap slot excaps \\<equiv> doE\n   whenE (length args < 3 \\<or> length excaps < 2) $ throwError TruncatedMessage;\n   fault_ep \\<leftarrow> returnOk $ args ! 0;\n   croot_data  \\<leftarrow> returnOk $ args ! 1;\n   vroot_data  \\<leftarrow> returnOk $ args ! 2;\n   croot_arg  \\<leftarrow> returnOk $ excaps ! 0;\n   vroot_arg  \\<leftarrow> returnOk $ excaps ! 1;\n   can_chg_cr \\<leftarrow> liftE $ liftM Not $ slot_cap_long_running_delete\n                      $ get_tcb_ctable_ptr $ obj_ref_of cap;\n   can_chg_vr \\<leftarrow> liftE $ liftM Not $ slot_cap_long_running_delete\n                      $ get_tcb_vtable_ptr $ obj_ref_of cap;\n   unlessE (can_chg_cr \\<and> can_chg_vr) $ throwError IllegalOperation;\n\n   croot_cap  \\<leftarrow> returnOk $ fst croot_arg;\n   croot_slot \\<leftarrow> returnOk $ snd croot_arg;\n   croot_cap' \\<leftarrow> derive_cap croot_slot $\n                   (if croot_data = 0 then id else update_cap_data False croot_data)\n                   croot_cap;\n   unlessE (is_cnode_cap croot_cap') $ throwError IllegalOperation;\n   croot \\<leftarrow> returnOk (croot_cap', croot_slot);\n\n   vroot_cap  \\<leftarrow> returnOk $ fst vroot_arg;\n   vroot_slot \\<leftarrow> returnOk $ snd vroot_arg;\n   vroot_cap' \\<leftarrow> derive_cap vroot_slot $\n                   (if vroot_data = 0 then id else update_cap_data False vroot_data)\n                   vroot_cap;\n   unlessE (is_valid_vtable_root vroot_cap') $ throwError IllegalOperation;\n   vroot \\<leftarrow> returnOk (vroot_cap', vroot_slot);\n\n   returnOk $ ThreadControl (obj_ref_of cap) slot (Some (to_bl fault_ep)) None None\n                            (Some croot) (Some vroot) None\n odE\"\n\n\ndefinition\n  decode_tcb_configure ::\n  \"data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_tcb_configure args cap slot extra_caps \\<equiv> doE\n     whenE (length args < 4) $ throwError TruncatedMessage;\n     whenE (length extra_caps < 3) $ throwError TruncatedMessage;\n     fault_ep \\<leftarrow> returnOk $ args ! 0;\n     croot_data \\<leftarrow> returnOk $ args ! 1;\n     vroot_data \\<leftarrow> returnOk $ args ! 2;\n     crootvroot \\<leftarrow> returnOk $ take 2 extra_caps;\n     buffer_cap \\<leftarrow> returnOk $ extra_caps ! 2;\n     buffer \\<leftarrow> returnOk $ args ! 3;\n     set_params \\<leftarrow> decode_set_ipc_buffer [buffer] cap slot [buffer_cap];\n     set_space \\<leftarrow> decode_set_space [fault_ep, croot_data, vroot_data] cap slot crootvroot;\n     returnOk $ ThreadControl (obj_ref_of cap) slot (tc_new_fault_ep set_space)\n                              None None\n                              (tc_new_croot set_space) (tc_new_vroot set_space)\n                              (tc_new_buffer set_params)\n   odE\"\n\ndefinition\n  decode_bind_notification ::\n  \"cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_bind_notification cap extra_caps \\<equiv> case cap of\n    ThreadCap tcb \\<Rightarrow> doE\n     whenE (length extra_caps = 0) $ throwError TruncatedMessage;\n     nTFN \\<leftarrow> liftE $ get_bound_notification tcb;\n     case nTFN of\n         Some _ \\<Rightarrow> throwError IllegalOperation\n       | None \\<Rightarrow> returnOk ();\n     (ntfnptr, rights) \\<leftarrow> case fst (hd extra_caps) of\n         NotificationCap ptr _ r \\<Rightarrow> returnOk (ptr, r)\n       | _ \\<Rightarrow> throwError IllegalOperation;\n     whenE (AllowRecv \\<notin> rights) $ throwError IllegalOperation;\n     ntfn \\<leftarrow> liftE  $ get_notification ntfnptr;\n     case (ntfn_obj ntfn, ntfn_bound_tcb ntfn) of\n         (IdleNtfn, None) \\<Rightarrow> returnOk ()\n       | (ActiveNtfn _, None) \\<Rightarrow> returnOk ()\n       | _ \\<Rightarrow> throwError IllegalOperation;\n      returnOk $ NotificationControl tcb (Some ntfnptr)\n   odE\n | _ \\<Rightarrow> throwError IllegalOperation\"\n\n\ndefinition\n  decode_unbind_notification :: \"cap \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_unbind_notification cap \\<equiv> case cap of\n     ThreadCap tcb \\<Rightarrow> doE\n       nTFN \\<leftarrow> liftE $ get_bound_notification tcb;\n       case nTFN of\n           None \\<Rightarrow> throwError IllegalOperation\n         | Some _ \\<Rightarrow> returnOk ();\n       returnOk $ NotificationControl tcb None\n    odE\n | _ \\<Rightarrow> throwError IllegalOperation\"\n\ndefinition\n  decode_set_tls_base :: \"data list \\<Rightarrow> cap \\<Rightarrow> (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_set_tls_base args cap \\<equiv> doE\n     whenE (length args = 0) $ throwError TruncatedMessage;\n     returnOk (SetTLSBase (obj_ref_of cap) (ucast (args ! 0)))\n   odE\"\n\ndefinition\n  decode_tcb_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n  (tcb_invocation,'z::state_ext) se_monad\"\nwhere\n \"decode_tcb_invocation label args cap slot excs \\<equiv>\n  case gen_invocation_type label of\n      TCBReadRegisters \\<Rightarrow> decode_read_registers args cap\n    | TCBWriteRegisters \\<Rightarrow> decode_write_registers args cap\n    | TCBCopyRegisters \\<Rightarrow> decode_copy_registers args cap $ map fst excs\n    | TCBSuspend \\<Rightarrow> returnOk $ Suspend $ obj_ref_of cap\n    | TCBResume \\<Rightarrow> returnOk $ Resume $ obj_ref_of cap\n    | TCBConfigure \\<Rightarrow> decode_tcb_configure args cap slot excs\n    | TCBSetPriority \\<Rightarrow> decode_set_priority args cap slot excs\n    | TCBSetMCPriority \\<Rightarrow> decode_set_mcpriority args cap slot excs\n    | TCBSetSchedParams \\<Rightarrow> decode_set_sched_params args cap slot excs\n    | TCBSetIPCBuffer \\<Rightarrow> decode_set_ipc_buffer args cap slot excs\n    | TCBSetSpace \\<Rightarrow> decode_set_space args cap slot excs\n    | TCBBindNotification \\<Rightarrow> decode_bind_notification cap excs\n    | TCBUnbindNotification \\<Rightarrow> decode_unbind_notification cap\n    | TCBSetTLSBase \\<Rightarrow> decode_set_tls_base args cap\n    | _ \\<Rightarrow> throwError IllegalOperation\"\n\ndefinition\n  decode_domain_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    ((obj_ref \\<times> domain), 'z::state_ext) se_monad\"\nwhere\n  \"decode_domain_invocation label args excs \\<equiv> doE\n     whenE (gen_invocation_type label \\<noteq> DomainSetSet) $ throwError IllegalOperation;\n     domain \\<leftarrow> (case args of\n       x # xs \\<Rightarrow> doE\n         whenE (unat x \\<ge> numDomains) $ throwError $ InvalidArgument 0;\n         returnOk (ucast x)\n       odE\n       | _ \\<Rightarrow> throwError TruncatedMessage);\n     whenE (length excs = 0) $ throwError TruncatedMessage;\n     case (fst (hd excs)) of ThreadCap ptr \\<Rightarrow> returnOk $ (ptr, domain)\n       | _ \\<Rightarrow> throwError $ InvalidArgument 1\n   odE\"", "property": "System Call Decoding: Decode various system calls related to thread control block (TCB) operations, including reading, writing, and copying registers, setting priorities, configuring IPC buffers, managing notification bindings, and setting TLS base. The decoding process ensures that the provided arguments and capabilities are valid, and it constructs the appropriate TCB invocation based on the system call type.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Threads", "comment": "This definition checks whether the first argument is\nbetween the second and third.\n"}
{"spec": "text \\<open>The following two definitions decode system calls for the\ninterrupt controller and interrupt handlers\\<close>\n\ndefinition\n  decode_irq_control_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list\n                                     \\<Rightarrow> (irq_control_invocation,'z::state_ext) se_monad\" where\n \"decode_irq_control_invocation label args src_slot cps \\<equiv>\n  (if gen_invocation_type label = IRQIssueIRQHandler\n    then if length args \\<ge> 3 \\<and> length cps \\<ge> 1\n      then let irq_word = args ! 0;\n               index = args ! 1;\n               depth = args ! 2;\n               cnode = cps ! 0;\n               irq = ucast irq_word\n      in doE\n        arch_check_irq irq_word;\n        irq_active \\<leftarrow> liftE $ is_irq_active irq;\n        whenE irq_active $ throwError RevokeFirst;\n\n        dest_slot \\<leftarrow> lookup_target_slot\n               cnode (data_to_cptr index) (unat depth);\n        ensure_empty dest_slot;\n\n        returnOk $ IRQControl irq dest_slot src_slot\n      odE\n    else throwError TruncatedMessage\n  else liftME ArchIRQControl $ arch_decode_irq_control_invocation label args src_slot cps)\"\n\ndefinition\n  decode_irq_handler_invocation :: \"data \\<Rightarrow> irq \\<Rightarrow> (cap \\<times> cslot_ptr) list\n                                     \\<Rightarrow> (irq_handler_invocation,'z::state_ext) se_monad\" where\n \"decode_irq_handler_invocation label irq cps \\<equiv>\n  if gen_invocation_type label = IRQAckIRQ\n    then returnOk $ ACKIrq irq\n  else if gen_invocation_type label = IRQSetIRQHandler\n    then if cps \\<noteq> []\n      then let (cap, slot) = hd cps in\n      if is_ntfn_cap cap \\<and> AllowSend \\<in> cap_rights cap\n      then returnOk $ SetIRQHandler irq cap slot\n      else throwError $ InvalidCapability 0\n    else throwError TruncatedMessage\n  else if gen_invocation_type label = IRQClearIRQHandler\n    then returnOk $ ClearIRQHandler irq\n  else throwError IllegalOperation\"", "property": "Decode IRQ System Calls: Decode system calls related to interrupt control and handling. For interrupt control, validate the arguments and capabilities, check if the IRQ is active, and ensure the destination slot is empty before returning an IRQ control invocation. For interrupt handlers, decode different types of IRQ operations such as acknowledging, setting, and clearing IRQ handlers, ensuring the provided capabilities are valid.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "IRQ", "comment": ""}
{"spec": "text \\<open>The definitions in this section deal with decoding invocations\nof untyped memory capabilities.\n\\<close>\n\ndefinition\n  data_to_obj_type :: \"data \\<Rightarrow> (apiobject_type,'z::state_ext) se_monad\" where\n  \"data_to_obj_type type \\<equiv> doE\n    n \\<leftarrow> returnOk $ data_to_nat type;\n    if n = 0 then\n      returnOk $ Untyped\n    else if n = 1 then\n      returnOk $ TCBObject\n    else if n = 2 then\n      returnOk $ EndpointObject\n    else if n = 3 then\n      returnOk $ NotificationObject\n    else if n = 4 then\n      returnOk $ CapTableObject\n    else (case arch_data_to_obj_type (n - 5)\n       of Some tp \\<Rightarrow> returnOk (ArchObject tp)\n        | None \\<Rightarrow> throwError (InvalidArgument 0))\n  odE\"\n\ndefinition\n  decode_untyped_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> cap list \\<Rightarrow> (untyped_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_untyped_invocation label args slot cap excaps \\<equiv> doE\n  unlessE (gen_invocation_type label = UntypedRetype) $ throwError IllegalOperation;\n  whenE (length args < 6) $ throwError TruncatedMessage;\n  whenE (length excaps = 0) $ throwError TruncatedMessage;\n  root_cap \\<leftarrow> returnOk $ excaps ! 0;\n  new_type \\<leftarrow> data_to_obj_type (args!0);\n\n  user_obj_size \\<leftarrow> returnOk $ data_to_nat (args!1);\n  object_size \\<leftarrow> returnOk (obj_bits_api new_type user_obj_size);\n  unlessE (user_obj_size < word_bits \\<and> object_size \\<le> untyped_max_bits)\n    $ throwError (RangeError 0 (of_nat untyped_max_bits));\n  whenE (new_type = CapTableObject \\<and> user_obj_size = 0)\n    $ throwError (InvalidArgument 1);\n  whenE (new_type = Untyped \\<and> user_obj_size < untyped_min_bits)\n    $ throwError (InvalidArgument 1);\n  node_index \\<leftarrow> returnOk $ data_to_cptr (args!2);\n  node_depth \\<leftarrow> returnOk $ data_to_nat (args!3);\n\n  node_cap \\<leftarrow> if node_depth = 0\n        then returnOk root_cap\n        else doE\n            node_slot \\<leftarrow> lookup_target_slot\n                root_cap node_index node_depth;\n            liftE $ get_cap node_slot\n        odE;\n\n  if is_cnode_cap node_cap\n        then  returnOk ()\n        else  throwError $ FailedLookup False $ MissingCapability node_depth;\n\n  node_offset \\<leftarrow> returnOk $ data_to_nat (args ! 4);\n  node_window \\<leftarrow> returnOk $ data_to_nat (args ! 5);\n  radix_bits \\<leftarrow> returnOk $ bits_of node_cap;\n  node_size \\<leftarrow> returnOk (2 ^ radix_bits);\n\n  whenE (node_offset < 0 \\<or> node_offset > node_size - 1) $\n    throwError $ RangeError 0 (of_nat (node_size - 1));\n\n  whenE (node_window < 1 \\<or> node_window > unat retypeFanOutLimit) $ throwError $ RangeError 1 retypeFanOutLimit;\n\n  whenE (node_window < 1 \\<or> node_window > node_size - node_offset) $\n    throwError $ RangeError 1 (of_nat (node_size - node_offset));\n\n  oref \\<leftarrow> returnOk $ obj_ref_of node_cap;\n  offsets \\<leftarrow> returnOk $ map (nat_to_cref radix_bits)\n                           [node_offset ..< node_offset + node_window];\n  slots \\<leftarrow> returnOk $ map (\\<lambda>cref. (oref, cref)) offsets;\n\n  mapME_x ensure_empty slots;\n\n  reset \\<leftarrow> liftE $ const_on_failure False $ (doE\n    ensure_no_children slot;\n    returnOk True\n  odE);\n\n  free_index \\<leftarrow> returnOk (if reset then 0 else free_index_of cap);\n  free_ref \\<leftarrow> returnOk (get_free_ref (obj_ref_of cap) free_index);\n  aligned_free_ref \\<leftarrow> returnOk (alignUp free_ref object_size);\n  untyped_free_bytes \\<leftarrow> returnOk (obj_size cap - of_nat (free_index));\n\n  max_count \\<leftarrow> returnOk ( untyped_free_bytes >> object_size);\n  whenE (unat max_count < node_window) $\n        throwError $ NotEnoughMemory $ untyped_free_bytes;\n\n  not_frame \\<leftarrow> returnOk (\\<not> is_frame_type new_type);\n  (ptr, is_device) \\<leftarrow> case cap of\n                        UntypedCap dev p n f \\<Rightarrow> returnOk (p,dev)\n                      | _ \\<Rightarrow> fail;\n  whenE (is_device \\<and> not_frame \\<and> new_type \\<noteq> Untyped) $\n           throwError $ InvalidArgument 1;\n  returnOk $ Retype slot reset ptr aligned_free_ref new_type user_obj_size slots is_device\nodE\"", "property": "Untyped Memory Capability Invocation: Decodes and validates untyped memory capability invocations, ensuring that the operation is of the correct type, the arguments are complete, and the provided capabilities and parameters are valid. It checks the object type, size, and alignment, verifies the node and offset values, and ensures that the target slots are empty before proceeding with the retype operation.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Untyped", "comment": ""}
{"spec": "text \\<open>This definition is the toplevel decoding definition; it dispatches\nto the above definitions, after checking, in some cases, whether the\ninvocation is allowed.\n\\<close>\n\ndefinition\n  decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_invocation label args cap_index slot cap excaps \\<equiv>\n  case cap of\n    EndpointCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeEndpoint ptr badge (AllowGrant \\<in> rights) (AllowGrantReply \\<in> rights)\n      else throwError $ InvalidCapability 0\n  | NotificationCap ptr badge rights \\<Rightarrow>\n      if AllowSend \\<in> rights then\n        returnOk $ InvokeNotification ptr badge\n      else throwError $ InvalidCapability 0\n  | ReplyCap thread False rights \\<Rightarrow>\n      returnOk $ InvokeReply thread slot (AllowGrant \\<in> rights)\n  | IRQControlCap \\<Rightarrow>\n      liftME InvokeIRQControl\n        $ decode_irq_control_invocation label args slot (map fst excaps)\n  | IRQHandlerCap irq \\<Rightarrow>\n      liftME InvokeIRQHandler\n        $ decode_irq_handler_invocation label irq excaps\n  | ThreadCap ptr \\<Rightarrow>\n      liftME InvokeTCB $ decode_tcb_invocation label args cap slot excaps\n  | DomainCap \\<Rightarrow>\n      liftME (case_prod InvokeDomain) $ decode_domain_invocation label args excaps\n  | CNodeCap ptr bits _ \\<Rightarrow>\n      liftME InvokeCNode $ decode_cnode_invocation label args cap (map fst excaps)\n  | UntypedCap dev ptr sz fi \\<Rightarrow>\n      liftME InvokeUntyped $ decode_untyped_invocation label args slot cap (map fst excaps)\n  | ArchObjectCap arch_cap \\<Rightarrow>\n      liftME InvokeArchObject $\n        arch_decode_invocation label args cap_index slot arch_cap excaps\n  | _ \\<Rightarrow>\n      throwError $ InvalidCapability 0\"\n\nend", "property": "Decode System Call Invocations: Decodes and validates system call invocations based on the provided capability, ensuring that the invocation is allowed and dispatching to the appropriate handler. If the capability does not have the required rights, it returns an error.", "title": "./spec/abstract/Decode_A.thy", "chapter": "Decoding System Calls", "section": "Toplevel invocation decode.", "comment": ""}
{"spec": "definition\n  get_ep_queue :: \"endpoint \\<Rightarrow> (obj_ref list,'z::state_ext) s_monad\"\nwhere\n \"get_ep_queue ep \\<equiv> case ep of SendEP q \\<Rightarrow> return q\n                              | RecvEP q \\<Rightarrow> return q\n                              | _ \\<Rightarrow> fail\"\n\nprimrec (nonexhaustive)\n  update_ep_queue :: \"endpoint \\<Rightarrow> obj_ref list \\<Rightarrow> endpoint\"\nwhere\n  \"update_ep_queue (RecvEP q) q' = RecvEP q'\"\n| \"update_ep_queue (SendEP q) q' = SendEP q'\"", "property": "Endpoint Queue Management: Retrieve and update the queue of an endpoint. The queue can be either for sending or receiving, and the operations ensure that the queue is correctly accessed and modified.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Getting and setting endpoint queues."}
{"spec": "definition\n  cancel_all_ipc :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_all_ipc epptr \\<equiv> do\n     ep \\<leftarrow> get_endpoint epptr;\n     case ep of IdleEP \\<Rightarrow> return ()\n               | _ \\<Rightarrow> do\n                        queue \\<leftarrow> get_ep_queue ep;\n                        set_endpoint epptr IdleEP;\n                        mapM_x (\\<lambda>t. do set_thread_state t Restart;\n                                       do_extended_op (tcb_sched_action (tcb_sched_enqueue) t) od) $ queue;\n                        do_extended_op (reschedule_required)\n                     od\n   od\"", "property": "Cancel Synchronous Message Operations: Cancels all message operations for threads queued within a synchronous message endpoint, transitioning them to the Restart state and re-enqueueing them for rescheduling. This ensures that the threads will reattempt their previous operations once they are scheduled again.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel all message operations on threads currently queued within this\nsynchronous message endpoint. Threads so queued are placed in the Restart state.\nOnce scheduled they will reattempt the operation that previously caused them\nto be queued here."}
{"spec": "primrec (nonexhaustive)\n  blocking_ipc_badge :: \"thread_state \\<Rightarrow> badge\"\nwhere\n  \"blocking_ipc_badge (BlockedOnSend t payload) = sender_badge payload\"", "property": "Badge Retrieval for Blocked Threads: Extract the badge from the payload of a thread that is blocked on a message send operation.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "The badge stored by thread waiting on a message send operation."}
{"spec": "definition\n  cancel_badged_sends :: \"obj_ref \\<Rightarrow> badge \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_badged_sends epptr badge \\<equiv> do\n    ep \\<leftarrow> get_endpoint epptr;\n    case ep of\n          IdleEP \\<Rightarrow> return ()\n        | RecvEP _ \\<Rightarrow>  return ()\n        | SendEP queue \\<Rightarrow>  do\n            set_endpoint epptr IdleEP;\n            queue' \\<leftarrow> (swp filterM queue) (\\<lambda> t. do\n                st \\<leftarrow> get_thread_state t;\n                if blocking_ipc_badge st = badge then do\n                  set_thread_state t Restart;\n                  do_extended_op (tcb_sched_action (tcb_sched_enqueue) t);\n                  return False od\n                else return True\n            od);\n            ep' \\<leftarrow> return (case queue' of\n                           [] \\<Rightarrow> IdleEP\n                         | _ \\<Rightarrow> SendEP queue');\n            set_endpoint epptr ep';\n            do_extended_op (reschedule_required)\n        od\n  od\"", "property": "Cancel Badged Sends: Cancels all message send operations for threads queued in a specific endpoint and using a particular badge. Threads with the matching badge are set to the restart state and re-enqueued, while the endpoint is updated to reflect the remaining or cleared queue.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel all message send operations on threads queued in this endpoint\nand using a particular badge."}
{"spec": "abbreviation\n  do_unbind_notification :: \"obj_ref \\<Rightarrow> notification \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"do_unbind_notification ntfnptr ntfn tcbptr \\<equiv> do\n      ntfn' \\<leftarrow> return $ ntfn_set_bound_tcb ntfn None;\n      set_notification ntfnptr ntfn';\n      set_bound_notification tcbptr None\n    od\"\n\ndefinition\n  unbind_notification :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"unbind_notification tcb \\<equiv> do\n     ntfnptr \\<leftarrow> get_bound_notification tcb;\n     case ntfnptr of\n         Some ntfnptr' \\<Rightarrow> do\n             ntfn \\<leftarrow> get_notification ntfnptr';\n             do_unbind_notification ntfnptr' ntfn tcb\n          od\n       | None \\<Rightarrow> return ()\n   od\"\n\ndefinition\n  unbind_maybe_notification :: \"obj_ref \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"unbind_maybe_notification ntfnptr \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     (case ntfn_bound_tcb ntfn of\n       Some t \\<Rightarrow> do_unbind_notification ntfnptr ntfn t\n     | None \\<Rightarrow> return ())\n   od\"\n\ndefinition\n  cancel_all_signals :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_all_signals ntfnptr \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     case ntfn_obj ntfn of WaitingNtfn queue \\<Rightarrow> do\n                      _ \\<leftarrow> set_notification ntfnptr $ ntfn_set_obj ntfn IdleNtfn;\n                      mapM_x (\\<lambda>t. do set_thread_state t Restart;\n                                     do_extended_op (tcb_sched_action tcb_sched_enqueue t) od) queue;\n                      do_extended_op (reschedule_required)\n                     od\n               | _ \\<Rightarrow> return ()\n   od\"", "property": "Cancel All Signals: Cancels all message operations on threads queued in a notification endpoint, transitioning the notification object to an idle state and re-enqueueing the affected threads for execution.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel all message operations on threads queued in a notification\nendpoint."}
{"spec": "definition\n  get_blocking_object :: \"thread_state \\<Rightarrow> (obj_ref,'z::state_ext) s_monad\"\nwhere\n \"get_blocking_object state \\<equiv>\n       case state of BlockedOnReceive epptr x \\<Rightarrow> return epptr\n                    | BlockedOnSend epptr x \\<Rightarrow> return epptr\n                    | _ \\<Rightarrow> fail\"", "property": "Get Blocking Object: Retrieve the endpoint pointer for a thread that is blocked on either sending or receiving a message. If the thread is not in a blocked state, the operation fails.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "The endpoint pointer stored by a thread waiting for a message to be\ntransferred in either direction."}
{"spec": "definition\n  blocked_cancel_ipc :: \"thread_state \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"blocked_cancel_ipc state tptr \\<equiv> do\n     epptr \\<leftarrow> get_blocking_object state;\n     ep \\<leftarrow> get_endpoint epptr;\n     queue \\<leftarrow> get_ep_queue ep;\n     queue' \\<leftarrow> return $ remove1 tptr queue;\n     ep' \\<leftarrow> return (case queue' of [] \\<Rightarrow> IdleEP\n                                |  _ \\<Rightarrow> update_ep_queue ep queue');\n     set_endpoint epptr ep';\n     set_thread_state tptr Inactive\n   od\"", "property": "Cancel IPC Operation: Cancels the IPC operation that a thread is currently engaged in by removing the thread from the endpoint's queue and setting the thread's state to inactive.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel whatever IPC operation a thread is engaged in."}
{"spec": "fun\n  fast_finalise :: \"cap \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"fast_finalise NullCap                  final = return ()\"\n| \"fast_finalise (ReplyCap r m R)         final = return ()\"\n| \"fast_finalise (EndpointCap r b R)      final =\n      (when final $ cancel_all_ipc r)\"\n| \"fast_finalise (NotificationCap r b R) final =\n      (when final $ do\n          unbind_maybe_notification r;\n          cancel_all_signals r\n       od)\"\n| \"fast_finalise (CNodeCap r bits g)      final = fail\"\n| \"fast_finalise (ThreadCap r)            final = fail\"\n| \"fast_finalise DomainCap                final = fail\"\n| \"fast_finalise (Zombie r b n)           final = fail\"\n| \"fast_finalise IRQControlCap            final = fail\"\n| \"fast_finalise (IRQHandlerCap irq)      final = fail\"\n| \"fast_finalise (UntypedCap dev r n f)       final = fail\"\n| \"fast_finalise (ArchObjectCap a)        final = fail\"", "property": "Fast Finalise Capability: Finalises a capability if it is of a type that can be immediately finalised, such as an Endpoint or Notification capability. For other types of capabilities, the operation fails.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Finalise a capability if the capability is known to be of the kind\nwhich can be finalised immediately. This is a simplified version of the\n@{text finalise_cap} operation."}
{"spec": "definition\n  cap_irq_opt :: \"cap \\<Rightarrow> irq option\" where\n \"cap_irq_opt cap \\<equiv> case cap of IRQHandlerCap irq \\<Rightarrow> Some irq | _ \\<Rightarrow> None\"\n\ndefinition\n  cap_irqs :: \"cap \\<Rightarrow> irq set\" where\n \"cap_irqs cap \\<equiv> set_option (cap_irq_opt cap)\"", "property": "IRQ Capability Management: Extract and represent the IRQ associated with a capability, either as an optional value or a set.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "The optional IRQ stored in a capability, presented either as an optional\nvalue or a set."}
{"spec": "datatype gen_obj_ref =\n    ObjRef obj_ref\n  | IRQRef irq\n  | ArchRef arch_gen_obj_ref\n\ndefinition\n  arch_cap_set_map :: \"(arch_cap \\<Rightarrow> 'a set) \\<Rightarrow> cap \\<Rightarrow> 'a set\"\nwhere\n  \"arch_cap_set_map f cap \\<equiv> case cap of\n       ArchObjectCap acap \\<Rightarrow> f acap\n     | _ \\<Rightarrow> {}\"\n\nabbreviation\n  arch_gen_refs :: \"cap \\<Rightarrow> arch_gen_obj_ref set\"\nwhere\n  \"arch_gen_refs \\<equiv> arch_cap_set_map arch_gen_obj_refs\"\n\ndefinition\n  gen_obj_refs :: \"cap \\<Rightarrow> gen_obj_ref set\"\nwhere\n  \"gen_obj_refs c \\<equiv> ObjRef ` (obj_refs c)\n                      \\<union> IRQRef ` (cap_irqs c)\n                      \\<union> ArchRef ` (arch_gen_refs c)\"\n\ndefinition\n  cap_cleanup_opt :: \"cap \\<Rightarrow> cap\"\nwhere\n  \"cap_cleanup_opt c \\<equiv> case c of\n      IRQHandlerCap _ \\<Rightarrow> c\n    | ArchObjectCap acap \\<Rightarrow> arch_cap_cleanup_opt acap\n    | _ \\<Rightarrow> NullCap\"", "property": "Generic Object References: A generic reference to an object can be an object reference, an IRQ reference, or an architecture-specific reference. These references are used for finalization and comparison to determine if capabilities refer to the same object. The system defines a mapping to extract architecture-specific references from capabilities and combines these with object and IRQ references to form a complete set of generic references. Additionally, a cleanup operation is defined to handle specific types of capabilities, ensuring they are appropriately managed or converted to a null capability.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "A generic reference to an object. Used for the purposes of finalisation,\nwhere we want to be able to compare caps to decide if they refer to the \"same object\",\nwhich can be determined in several ways"}
{"spec": "definition\n  is_final_cap' :: \"cap \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n \"is_final_cap' cap s \\<equiv>\n    \\<exists>cref. {cref. \\<exists>cap'. fst (get_cap cref s) = {(cap', s)}\n                       \\<and> (gen_obj_refs cap \\<inter> gen_obj_refs cap' \\<noteq> {})}\n         = {cref}\"\n\ndefinition\n  is_final_cap :: \"cap \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n  \"is_final_cap cap \\<equiv> gets (is_final_cap' cap)\"", "property": "Final Capability Detection: Determine if a given capability is the last remaining reference to an object in the system, triggering finalization actions when the final capability to the object is deleted.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Detect whether a capability is the final capability to a given object\nremaining in the system. Finalisation actions need to be taken when the final\ncapability to the object is deleted."}
{"spec": "definition\n  deleted_irq_handler :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"deleted_irq_handler irq \\<equiv> set_irq_state IRQInactive irq\"", "property": "IRQ Handler Deletion: Set the state of the specified IRQ to inactive after its handler capability is deleted.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after an IRQ handler capability is deleted."}
{"spec": "definition\n  post_cap_deletion :: \"cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"post_cap_deletion cap \\<equiv> case cap of\n       IRQHandlerCap irq \\<Rightarrow> deleted_irq_handler irq\n     | ArchObjectCap acap \\<Rightarrow> arch_post_cap_deletion acap\n     | _ \\<Rightarrow> return ()\"", "property": "Post-Capability Deletion Actions: Perform specific actions based on the type of capability deleted, such as handling IRQ handler capabilities and arch-specific capabilities. For other types of capabilities, no action is taken.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "definition\n  empty_slot :: \"cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"empty_slot slot cleanup_info \\<equiv> do\n      cap \\<leftarrow> get_cap slot;\n      if cap = NullCap then\n        return ()\n      else do\n        slot_p \\<leftarrow> gets (\\<lambda>s. cdt s slot);\n        cdt \\<leftarrow> gets cdt;\n        parent \\<leftarrow> return $ cdt slot;\n        set_cdt ((\\<lambda>p. if cdt p = Some slot\n                     then parent\n                     else cdt p) (slot := None));\n        do_extended_op (empty_slot_ext slot slot_p);\n        set_original slot False;\n        set_cap NullCap slot;\n\n        post_cap_deletion cleanup_info\n      od\n  od\"", "property": "Empty a Capability Slot: Ensures that a capability slot is emptied by setting it to `NullCap` and updating the CDT (Capability Descriptor Table) to remove any references to the slot. If the slot is not already empty, it performs additional cleanup operations, including updating parent references and executing extended operations for slot finalization.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Empty a capability slot assuming that the capability in it has been\nfinalised already."}
{"spec": "definition\n  cap_delete_one :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"cap_delete_one slot \\<equiv> do\n    cap \\<leftarrow> get_cap slot;\n    unless (cap = NullCap) $ do\n      final \\<leftarrow> is_final_cap cap;\n      fast_finalise cap final;\n      empty_slot slot NullCap\n    od\n  od\"", "property": "Capability Deletion: Delete a capability from the specified slot, ensuring that the fast finalization process is applied if the capability is not null. This ensures that the capability is properly removed and its resources are efficiently released.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Delete a capability with the assumption that the fast finalisation\nprocess will be sufficient."}
{"spec": "definition\n  reply_cancel_ipc :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"reply_cancel_ipc tptr \\<equiv> do\n    thread_set (\\<lambda>tcb. tcb \\<lparr> tcb_fault := None \\<rparr>) tptr;\n    cap \\<leftarrow> get_cap (tptr, tcb_cnode_index 2);\n    descs \\<leftarrow> gets (descendants_of (tptr, tcb_cnode_index 2) o cdt);\n    when (descs \\<noteq> {}) $ do\n      assert (\\<exists>cslot_ptr. descs = {cslot_ptr});\n      cslot_ptr \\<leftarrow> select descs;\n      cap_delete_one cslot_ptr\n    od\n  od\"", "property": "Cancel Reply IPC Operation: Cancels the message receive operation for a thread waiting on a reply capability by clearing the thread's fault, retrieving the capability from the specified CNode slot, and deleting the descendant capability if it exists.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel the message receive operation of a thread waiting for a Reply\ncapability it has issued to be invoked."}
{"spec": "definition\n  cancel_signal :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_signal threadptr ntfnptr \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     queue \\<leftarrow> (case ntfn_obj ntfn of WaitingNtfn queue \\<Rightarrow> return queue\n                        | _ \\<Rightarrow> fail);\n     queue' \\<leftarrow> return $ remove1 threadptr queue;\n     newNTFN \\<leftarrow> return $ ntfn_set_obj ntfn (case queue' of [] \\<Rightarrow> IdleNtfn\n                                                      | _  \\<Rightarrow> WaitingNtfn queue');\n     set_notification ntfnptr newNTFN;\n     set_thread_state threadptr Inactive\n   od\"", "property": "Cancel Signal Operation: Removes a thread from the notification object's queue and updates the notification object's state. If the queue becomes empty, the notification object is set to an idle state. The thread's state is also updated to inactive.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel the message receive operation of a thread queued in an\nnotification object."}
{"spec": "definition\n  cancel_ipc :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cancel_ipc tptr \\<equiv> do\n     state \\<leftarrow> get_thread_state tptr;\n     case state\n       of\n          BlockedOnSend x y \\<Rightarrow> blocked_cancel_ipc state tptr\n        | BlockedOnReceive x y \\<Rightarrow> blocked_cancel_ipc state tptr\n        | BlockedOnNotification event \\<Rightarrow> cancel_signal tptr event\n        | BlockedOnReply \\<Rightarrow> reply_cancel_ipc tptr\n        | _ \\<Rightarrow> return ()\n   od\"", "property": "Cancel IPC Operations: Cancels any message operations that a given thread is waiting on, including send, receive, notification, and reply operations. This ensures that the thread can be unblocked and resume normal execution.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Cancel any message operations a given thread is waiting on."}
{"spec": "definition\n  update_restart_pc :: \"obj_ref \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"update_restart_pc thread_ptr =\n        as_user thread_ptr (getRegister nextInstructionRegister\n                            >>= setRegister faultRegister)\"", "property": "Update Restart PC: Update the fault register of a thread with the value from the next instruction register, ensuring that the thread's restart point is correctly set for fault handling.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Currently, @{text update_restart_pc} can be defined generically up to\nthe actual register numbers."}
{"spec": "definition\n  suspend :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"suspend thread \\<equiv> do\n     cancel_ipc thread;\n     state \\<leftarrow> get_thread_state thread;\n     (if state = Running then update_restart_pc thread else return ());\n     set_thread_state thread Inactive;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) thread)\n   od\"\n\nend", "property": "Thread Suspension: Suspends a thread by cancelling any pending IPC operations, updating the restart PC if the thread was running, setting the thread state to Inactive, and dequeuing it from the scheduler. This ensures that the thread is no longer eligible for execution and its state is properly managed.", "title": "./spec/abstract/IpcCancel_A.thy", "chapter": "", "section": "", "comment": "Suspend a thread, cancelling any pending operations and preventing it\nfrom further execution by setting it to the Inactive state."}
{"spec": "datatype rights = AllowRead | AllowWrite | AllowGrant | AllowGrantReply\n\ndefinition\n  \"AllowSend \\<equiv> AllowWrite\"\ndefinition\n  \"AllowRecv \\<equiv> AllowRead\"\ndefinition\n  \"CanModify \\<equiv> AllowWrite\"", "property": "Access Control Rights: Define the possible access-control rights in the system, including read, write, grant, and grant reply. Some rights are synonymous, where AllowSend is equivalent to AllowWrite, AllowRecv is equivalent to AllowRead, and CanModify is also equivalent to AllowWrite.", "title": "./spec/abstract/CapRights_A.thy", "chapter": "", "section": "", "comment": "The possible access-control rights that exist in the system.\n        Note that some rights are synonyms for others."}
{"spec": "type_synonym cap_rights = \"rights set\"", "property": "Cap Rights Definition: A cap_rights is a set of access rights that defines the permissions associated with a capability.", "title": "./spec/abstract/CapRights_A.thy", "chapter": "", "section": "", "comment": "Cap rights are just a set of access rights"}
{"spec": "definition\n  all_rights :: cap_rights\nwhere\n \"all_rights \\<equiv> UNIV\"\n\nend", "property": "All Rights: Represents the complete set of possible rights that can be associated with a capability, encompassing all potential permissions and authorities.", "title": "./spec/abstract/CapRights_A.thy", "chapter": "", "section": "", "comment": "The set of all rights:"}
{"spec": "definition\n  store_word_offs :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"store_word_offs ptr offs v \\<equiv>\n    do s \\<leftarrow> get;\n       assert (in_user_frame (ptr + of_nat (offs * word_size)) s);\n       do_machine_op $ storeWord (ptr + of_nat (offs * word_size)) v\n    od\"", "property": "Store Word at Offset: Store a machine word at a specified offset in the IPC buffer, ensuring that the operation is within the user frame.", "title": "./spec/abstract/TcbAcc_A.thy", "chapter": "", "section": "", "comment": "Store or load a word at an offset from an IPC buffer."}
{"spec": "definition\n  set_message_info :: \"obj_ref \\<Rightarrow> message_info \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_message_info thread info \\<equiv>\n     as_user thread $ setRegister msg_info_register $\n                      message_info_to_data info\"\n\n\ndefinition\n  set_mrs :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> message list \\<Rightarrow> (length_type,'z::state_ext) s_monad\" where\n  \"set_mrs thread buf msgs \\<equiv>\n   do\n     tcb \\<leftarrow> gets_the $ get_tcb thread;\n     context \\<leftarrow> return (arch_tcb_get_registers (tcb_arch tcb));\n     new_regs \\<leftarrow> return (\\<lambda>reg. if reg \\<in> set (take (length msgs) msg_registers)\n                              then msgs ! (the_index msg_registers reg)\n                              else context reg);\n     set_object thread (TCB (tcb \\<lparr> tcb_arch := arch_tcb_set_registers new_regs (tcb_arch tcb) \\<rparr>));\n     remaining_msgs \\<leftarrow> return (drop (length msg_registers) msgs);\n     case buf of\n     None      \\<Rightarrow> return $ nat_to_len (min (length msg_registers) (length msgs))\n   | Some pptr \\<Rightarrow> do\n       zipWithM_x (\\<lambda>x. store_word_offs pptr x)\n          [length msg_registers + 1 ..< Suc msg_max_length] remaining_msgs;\n       return $ nat_to_len $ min (length msgs) msg_max_length\n     od\n   od\"\n\nend", "property": "Set Message Information and Registers: Updates the message information and registers for a thread, ensuring that the message data is correctly stored in the thread's context. If a buffer is provided, additional message data beyond the initial set of message registers is stored in the specified buffer, allowing for the handling of larger messages.", "title": "./spec/abstract/TcbAcc_A.thy", "chapter": "", "section": "", "comment": " Needed for page invocations. "}
{"spec": "datatype apiobject_type =\n    Untyped\n  | TCBObject\n  | EndpointObject\n  | NotificationObject\n  | CapTableObject\n  | ArchObject aobject_type\n\ndefinition\n  is_frame_type :: \"apiobject_type \\<Rightarrow> bool\"\nwhere\n  \"is_frame_type obj \\<equiv> case obj of\n        ArchObject aobj \\<Rightarrow> arch_is_frame_type aobj\n      | _ \\<Rightarrow> False\"", "property": "Object Types and Frame Identification: Defines a set of object types that can be created by retype operations, including untyped objects, TCBs, endpoints, notifications, capability tables, and architecture-specific objects. Additionally, it provides a predicate to determine if an object type represents a frame.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "\n  User mode can request these objects to be created by retype:\n"}
{"spec": "type_synonym badge = data\ntype_synonym msg_label = data\ntype_synonym message = data", "property": "Type Definitions for IPC: Define types for badges, message labels, and messages to provide more informative type signatures for IPC operations.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "These allow more informative type signatures for IPC operations."}
{"spec": "type_synonym cnode_index = \"bool list\"\ntype_synonym cslot_ptr = \"obj_ref \\<times> cnode_index\"", "property": "Capability Slot References: A capability slot reference is modeled as a tuple where the first element points to the object containing the capability, and the second element is the index of the slot within that object. This structure allows for precise identification and manipulation of capability slots within objects.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "This type models refences to capability slots. The first element\n  of the tuple points to the object the capability is contained in. The second\n  element is the index of the slot inside a slot-containing object. The default\n  slot-containing object is a cnode, thus the name @{text cnode_index}.\n"}
{"spec": "datatype cap\n         = NullCap\n         | UntypedCap bool obj_ref nat nat\n           \\<comment> \\<open>device flag, pointer, size in bits (i.e. @{text \"size = 2^bits\"}) and freeIndex (i.e. @{text \"freeRef = obj_ref + (freeIndex * 2^4)\"})\\<close>\n         | EndpointCap obj_ref badge cap_rights\n         | NotificationCap obj_ref badge cap_rights\n         | ReplyCap obj_ref bool cap_rights\n         | CNodeCap obj_ref nat \"bool list\"\n           \\<comment> \\<open>CNode ptr, number of bits translated, guard\\<close>\n         | ThreadCap obj_ref\n         | DomainCap\n         | IRQControlCap\n         | IRQHandlerCap irq\n         | Zombie obj_ref \"nat option\" nat\n           \\<comment> \\<open>@{text \"cnode ptr * nat + tcb or cspace ptr\"}\\<close>\n         | ArchObjectCap (the_arch_cap: arch_cap)\n\nlemmas cap_cases =\n  cap.induct[where cap=cap and P=\"\\<lambda>cap'. cap' = cap \\<longrightarrow> P cap'\" for cap P, simplified, rule_format]\n\nlemmas cap_cases_asm =\ncap.induct[where cap=cap and P=\"\\<lambda>cap'. cap = cap' \\<longrightarrow> P cap' \\<longrightarrow> R\" for P R cap,\n  simplified, rule_format, rotated -1]", "property": "Capabilities and Their Authorities: Define various types of capabilities, each conferring specific authority to manipulate or interact with different kernel objects and resources. These include null, untyped, endpoint, notification, reply, CNode, thread, domain, IRQ control, IRQ handler, zombie, and architecture-specific capabilities, ensuring controlled access and operations within the system.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "Capabilities. Capabilities represent explicit authority to perform some\naction and are required for all system calls. Capabilities to Endpoint,\nNotification, Thread and CNode objects allow manipulation of standard kernel\nobjects. Untyped capabilities allow the creation and removal of kernel objects\nfrom a memory region. Reply capabilities allow sending a one-off message to\na thread waiting for a reply. IRQHandler and IRQControl caps allow a user to\nconfigure the way interrupts on one or all IRQs are handled. Capabilities to\narchitecture-specific facilities are provided through the @{text arch_cap} type.\nNull capabilities are the contents of empty capability slots; they confer no\nauthority and can be freely replaced. Zombie capabilities are stored when\nthe deletion of CNode and Thread objects is partially completed; they confer no\nauthority but cannot be replaced until the deletion is finished.\n"}
{"spec": "type_synonym cnode_contents = \"cnode_index \\<Rightarrow> cap option\"", "property": "CNode Representation: A CNode is represented as a function that maps cnode indices to optional capabilities, where empty slots are denoted by `None` and occupied slots contain a capability.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "The CNode object is an array of capability slots. The domain of the\nfunction will always be the set of boolean lists of some specific length.\nEmpty slots contain a Null capability.\n"}
{"spec": "definition\n  the_cnode_cap :: \"cap \\<Rightarrow> obj_ref \\<times> nat \\<times> bool list\" where\n  \"the_cnode_cap cap \\<equiv>\n  case cap of\n    CNodeCap oref bits guard \\<Rightarrow> (oref, bits, guard)\"\n\nprimrec (nonexhaustive)\n  cap_ep_badge :: \"cap \\<Rightarrow> badge\"\nwhere\n  \"cap_ep_badge (EndpointCap _ badge _) = badge\"\n| \"cap_ep_badge (NotificationCap _ badge _) = badge\"\n\nprimrec (nonexhaustive)\n  cap_ep_ptr :: \"cap \\<Rightarrow> badge\"\nwhere\n  \"cap_ep_ptr (EndpointCap obj_ref _ _) = obj_ref\"\n| \"cap_ep_ptr (NotificationCap obj_ref _ _) = obj_ref\"\n\ndefinition\n  bits_of :: \"cap \\<Rightarrow> nat\" where\n  \"bits_of cap \\<equiv> case cap of\n    UntypedCap _ _ bits _ \\<Rightarrow> bits\n  | CNodeCap _ radix_bits _ \\<Rightarrow> radix_bits\"\n\ndefinition\n  free_index_of :: \"cap \\<Rightarrow> nat\" where\n  \"free_index_of cap \\<equiv> case cap of\n    UntypedCap _ _ _ free_index \\<Rightarrow> free_index\"\n\ndefinition\n  is_reply_cap :: \"cap \\<Rightarrow> bool\" where\n  \"is_reply_cap cap \\<equiv> case cap of ReplyCap _ m _ \\<Rightarrow> \\<not> m | _ \\<Rightarrow> False\"\ndefinition\n  is_master_reply_cap :: \"cap \\<Rightarrow> bool\" where\n  \"is_master_reply_cap cap \\<equiv> case cap of ReplyCap _ m _ \\<Rightarrow> m | _ \\<Rightarrow> False\"\ndefinition\n  is_zombie :: \"cap \\<Rightarrow> bool\" where\n  \"is_zombie cap \\<equiv> case cap of Zombie _ _ _ \\<Rightarrow> True | _ \\<Rightarrow> False\"\ndefinition\n  is_arch_cap :: \"cap \\<Rightarrow> bool\" where\n  \"is_arch_cap cap \\<equiv> case cap of ArchObjectCap _ \\<Rightarrow> True | _ \\<Rightarrow> False\"\n\ncontext\nnotes [[function_internals =true]]\nbegin\n\nfun is_cnode_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_cnode_cap (CNodeCap _ _ _) = True\"\n| \"is_cnode_cap _                = False\"\n\nfun is_thread_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_thread_cap (ThreadCap _) = True\"\n| \"is_thread_cap _             = False\"\n\nfun is_domain_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_domain_cap DomainCap = True\"\n| \"is_domain_cap _ = False\"\n\nfun is_untyped_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_untyped_cap (UntypedCap _ _ _ _) = True\"\n| \"is_untyped_cap _                  = False\"\n\nfun is_ep_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_ep_cap (EndpointCap _ _ _) = True\"\n| \"is_ep_cap _                   = False\"\n\nfun is_ntfn_cap :: \"cap \\<Rightarrow> bool\"\nwhere\n  \"is_ntfn_cap (NotificationCap _ _ _) = True\"\n| \"is_ntfn_cap _                        = False\"\n\nprimrec (nonexhaustive)\n  cap_rights :: \"cap \\<Rightarrow> cap_rights\"\nwhere\n  \"cap_rights (EndpointCap _ _ cr) = cr\"\n| \"cap_rights (NotificationCap _ _ cr) = cr\"\n| \"cap_rights (ReplyCap _ _ cr) = cr\"\n| \"cap_rights (ArchObjectCap acap) = acap_rights acap\"\nend", "property": "Cap Type Access Functions: Provide various functions to extract and determine specific properties of capability objects, such as badge, pointer, bits, free index, and type-specific attributes. These functions enable efficient and accurate manipulation and inspection of capabilities, ensuring the integrity and security of the system.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "Various access functions for the cap type are defined for\nconvenience."}
{"spec": "definition\n  cap_rights_update :: \"cap_rights \\<Rightarrow> cap \\<Rightarrow> cap\" where\n  \"cap_rights_update cr' cap \\<equiv>\n   case cap of\n     EndpointCap oref badge cr \\<Rightarrow> EndpointCap oref badge cr'\n   | NotificationCap oref badge cr\n     \\<Rightarrow> NotificationCap oref badge (cr' - {AllowGrant, AllowGrantReply})\n   | ReplyCap t m cr \\<Rightarrow> ReplyCap t m (cr' - {AllowRead, AllowGrantReply} \\<union> {AllowWrite})\n   | ArchObjectCap acap \\<Rightarrow> ArchObjectCap (acap_rights_update cr' acap)\n   | _ \\<Rightarrow> cap\"\n\ndefinition\n  badge_update :: \"badge \\<Rightarrow> cap \\<Rightarrow> cap\" where\n  \"badge_update data cap \\<equiv>\n   case cap of\n     EndpointCap oref badge cr \\<Rightarrow> EndpointCap oref (data && mask badge_bits) cr\n   | NotificationCap oref badge cr \\<Rightarrow> NotificationCap oref (data && mask badge_bits) cr\n   | _ \\<Rightarrow> cap\"\n\n\ndefinition\n  mask_cap :: \"cap_rights \\<Rightarrow> cap \\<Rightarrow> cap\" where\n  \"mask_cap rights cap \\<equiv> cap_rights_update (cap_rights cap \\<inter> rights) cap\"", "property": "Cap Data Update: Modify the rights and badge of a capability. The `cap_rights_update` function updates the rights of different types of capabilities, while the `badge_update` function updates the badge of endpoint and notification capabilities. The `mask_cap` function restricts the rights of a capability to a specified set of rights.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "", "comment": "Various update functions for cap data common to various kinds of\ncap are defined here."}
{"spec": "text \\<open>The message info is the first thing interpreted on a user system call\nand determines the structure of the message the user thread is sending either to\nanother user or to a system service. It is also passed to user threads receiving\na message to indicate the structure of the message they have received. The\n@{text mi_length} parameter is the number of data words in the body of the\nmessage. The @{text mi_extra_caps} parameter is the number of caps to be passed\ntogether with the message. The @{text mi_caps_unwrapped} parameter is a bitmask\nallowing threads receiving a message to determine how extra capabilities were\ntransferred. The @{text mi_label} parameter is transferred directly from sender\nto receiver as part of the message.\n\\<close>\n\ndatatype message_info =\n  MI (mi_length: length_type)\n     (mi_extra_caps: length_type)\n     (mi_caps_unwrapped: data)\n     (mi_label: msg_label)", "property": "Message Information Structure: Defines the structure of a message, including the number of data words, the number of extra capabilities, a bitmask for capability transfer details, and a label. This structure is used to interpret and convey the message's content and metadata during system calls and message passing.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": ""}
{"spec": "primrec\n  message_info_to_data :: \"message_info \\<Rightarrow> data\"\nwhere\n  \"message_info_to_data (MI len exc unw mlabel) =\n   (let\n        extra = exc << 7;\n        unwrapped = unw << 9;\n        label = mlabel << 12\n    in\n       label || extra || unwrapped || len)\"\n\ndefinition\n  data_to_message_info :: \"data \\<Rightarrow> message_info\"\nwhere\n  \"data_to_message_info w \\<equiv>\n   MI (let v = w && mask 7 in if v > 120 then 120 else v)\n      ((w >> 7) && mask 2)\n      ((w >> 9) && mask 3)\n      ((w >> 12) && mask msg_label_bits)\"", "property": "Message Encoding and Decoding: Encode a message information structure into a single data word by packing the length, extra capabilities, unwrapped status, and message label into specific bit positions. Decode a data word back into a message information structure by extracting and interpreting the packed values from their respective bit positions.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Message infos are encoded to or decoded from a data word."}
{"spec": "text \\<open>Endpoints are synchronous points of communication for threads. At any\ntime an endpoint may contain a queue of threads waiting to send, a queue of\nthreads waiting to receive or be idle. Whenever threads would be waiting to\nsend and receive simultaneously messages are transferred immediately.\n\\<close>\n\ndatatype endpoint\n           = IdleEP\n           | SendEP \"obj_ref list\"\n           | RecvEP \"obj_ref list\"", "property": "Endpoint Communication States: An endpoint can be in one of three states: idle, waiting to send, or waiting to receive. When both sending and receiving threads are present, messages are transferred immediately.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": ""}
{"spec": "datatype ntfn\n           = IdleNtfn\n           | WaitingNtfn \"obj_ref list\"\n           | ActiveNtfn badge\n\nrecord notification =\n  ntfn_obj :: ntfn\n  ntfn_bound_tcb :: \"obj_ref option\"\n\n\ndefinition\n  default_ep :: endpoint where\n  \"default_ep \\<equiv> IdleEP\"\n\ndefinition\n  default_ntfn :: ntfn where\n  \"default_ntfn \\<equiv> IdleNtfn\"\n\ndefinition\n  default_notification :: notification where\n  \"default_notification \\<equiv> \\<lparr>\n     ntfn_obj = default_ntfn,\n     ntfn_bound_tcb = None \\<rparr>\"", "property": "Notification States: Notifications can be in one of three states: idle, waiting, or active. An idle notification is not in use, a waiting notification has a list of threads waiting to receive, and an active notification contains a badge indicating it has been triggered. Notifications also have an optional bound thread control block (TCB) that can be associated with them.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Notifications are sets of binary semaphores (stored in the\n\\emph{badge word}). Unlike endpoints, threads may choose to block waiting to\nreceive, but not to send."}
{"spec": "record sender_payload =\n sender_badge           :: badge\n sender_can_grant       :: bool\n sender_can_grant_reply :: bool\n sender_is_call         :: bool\n\nrecord receiver_payload =\n receiver_can_grant :: bool\n\ndatatype thread_state\n  = Running\n  | Inactive\n  | Restart\n  | BlockedOnReceive obj_ref receiver_payload\n  | BlockedOnSend obj_ref sender_payload\n  | BlockedOnReply\n  | BlockedOnNotification obj_ref\n  | IdleThreadState\n\ntype_synonym priority = word8\n\nrecord tcb =\n tcb_ctable        :: cap\n tcb_vtable        :: cap\n tcb_reply         :: cap\n tcb_caller        :: cap\n tcb_ipcframe      :: cap\n tcb_state         :: thread_state\n tcb_fault_handler :: cap_ref\n tcb_ipc_buffer    :: vspace_ref\n tcb_fault         :: \"fault option\"\n tcb_bound_notification     :: \"obj_ref option\"\n tcb_mcpriority    :: priority\n tcb_arch          :: arch_tcb (* arch_tcb must have a field for user context *)", "property": "Thread Control Block Representation: A TCB represents a thread in the kernel, containing its state (Running, Inactive, Restart, BlockedOnReceive, BlockedOnSend, BlockedOnReply, BlockedOnNotification, IdleThreadState), capabilities for system calls and virtual address space, and additional fields for fault handling, IPC, and notification. The TCB also includes special-purpose capability slots such as CTable, VTable, Reply, Caller, and IPCFrame, which manage the thread's access to system resources and communication.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Thread Control Blocks are the in-kernel representation of a thread.\n\nThreads which can execute are either in the Running state for normal execution,\nin the Restart state if their last operation has not completed yet or in the\nIdleThreadState for the unique system idle thread. Threads can also be blocked\nwaiting for any of the different kinds of system messages. The Inactive state\nindicates that the TCB is not currently used by a running thread.\n\nTCBs also contain some special-purpose capability slots. The CTable slot is a\ncapability to a CNode through which the thread accesses capabilities with which\nto perform system calls. The VTable slot is a capability to a virtual address\nspace (an architecture-specific capability type) in which the thread runs. If\nthe thread has issued a Reply cap to another thread and is awaiting a reply,\nthat cap will have a \"master\" Reply cap as its parent in the Reply slot. The\nCaller slot is used to initially store any Reply cap issued to this thread. The\nIPCFrame slot stores a capability to a memory frame (an architecture-specific\ncapability type) through which messages will be sent and received.\n\nIf the thread has encountered a fault and is waiting to send it to its\nsupervisor the fault is stored in @{text tcb_fault}. The user register file is\nstored in @{text tcb_context}, the pointer to the cap in the IPCFrame slot in\n@{text tcb_ipc_buffer} and the identity of the Endpoint cap through which faults\nare to be sent in @{text tcb_fault_handler}.\n"}
{"spec": "primrec\n  runnable :: \"Structures_A.thread_state \\<Rightarrow> bool\"\nwhere\n  \"runnable (Running)               = True\"\n| \"runnable (Inactive)              = False\"\n| \"runnable (Restart)               = True\"\n| \"runnable (BlockedOnReceive x y)  = False\"\n| \"runnable (BlockedOnSend x y)     = False\"\n| \"runnable (BlockedOnNotification x) = False\"\n| \"runnable (IdleThreadState)       = False\"\n| \"runnable (BlockedOnReply)        = False\"\n\n\ndefinition\n  default_tcb :: tcb where\n  \"default_tcb \\<equiv> \\<lparr>\n      tcb_ctable   = NullCap,\n      tcb_vtable   = NullCap,\n      tcb_reply    = NullCap,\n      tcb_caller   = NullCap,\n      tcb_ipcframe = NullCap,\n      tcb_state    = Inactive,\n      tcb_fault_handler = to_bl (0::machine_word),\n      tcb_ipc_buffer = 0,\n      tcb_fault      = None,\n      tcb_bound_notification  = None,\n      tcb_mcpriority = minBound,\n      tcb_arch       = default_arch_tcb\\<rparr>\"", "property": "Thread Scheduling Eligibility: Determines the schedulability of a thread based on its state. A thread is considered runnable if it is in the Running or Restart state, and not runnable if it is in any other state such as Inactive, BlockedOnReceive, BlockedOnSend, BlockedOnNotification, IdleThreadState, or BlockedOnReply.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Determines whether a thread in a given state may be scheduled."}
{"spec": "datatype kernel_object\n         = CNode nat cnode_contents \\<comment> \\<open>size in bits, and contents\\<close>\n         | TCB tcb\n         | Endpoint endpoint\n         | Notification notification\n         | ArchObj (the_arch_obj: arch_kernel_obj)\n\nlemmas kernel_object_cases =\n  kernel_object.induct[where kernel_object=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P, simplified, rule_format]\n\nlemmas kernel_object_cases_asm =\nkernel_object.induct[where kernel_object=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n  simplified, rule_format, rotated -1]\n\ndefinition aobj_of :: \"kernel_object \\<Rightarrow> arch_kernel_obj option\"\n  where\n  \"aobj_of ko \\<equiv> case ko of ArchObj aobj \\<Rightarrow> Some aobj | _ \\<Rightarrow> None\"", "property": "Kernel Object Types: The system defines a set of kernel objects, which can be CNodes, TCBs, Endpoints, Notifications, or architecture-specific objects. Each type of object has a distinct structure and purpose, ensuring that the kernel can manage different resources and functionalities effectively.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "\nAll kernel objects are CNodes, TCBs, Endpoints, Notifications or architecture\nspecific.\n"}
{"spec": "definition\n  well_formed_cnode_n :: \"nat \\<Rightarrow> cnode_contents \\<Rightarrow> bool\" where\n \"well_formed_cnode_n n \\<equiv> \\<lambda>cs. dom cs = {x. length x = n}\"\n\nprimrec\n  obj_bits :: \"kernel_object \\<Rightarrow> nat\"\nwhere\n  \"obj_bits (CNode sz cs) = cte_level_bits + sz\"\n| \"obj_bits (TCB t) = tcb_bits\"\n| \"obj_bits (Endpoint ep) = endpoint_bits\"\n| \"obj_bits (Notification ntfn) = ntfn_bits\"\n| \"obj_bits (ArchObj ao) = arch_kobj_size ao\"\n\nprimrec (nonexhaustive)\n  obj_size :: \"cap \\<Rightarrow> machine_word\"\nwhere\n  \"obj_size NullCap = 0\"\n| \"obj_size (UntypedCap dev r bits f) = 1 << bits\"\n| \"obj_size (EndpointCap r b R) = 1 << obj_bits (Endpoint undefined)\"\n| \"obj_size (NotificationCap r b R) = 1 << obj_bits (Notification undefined)\"\n| \"obj_size (CNodeCap r bits g) = 1 << (cte_level_bits + bits)\"\n| \"obj_size (ThreadCap r) = 1 << obj_bits (TCB undefined)\"\n| \"obj_size (Zombie r zb n) = (case zb of None \\<Rightarrow> 1 << obj_bits (TCB undefined)\n                                        | Some n \\<Rightarrow> 1 << (cte_level_bits + n))\"\n| \"obj_size (ArchObjectCap a) = 1 << arch_obj_size a\"", "property": "Well-Formed CNode: Ensures that a cnode's contents are well-formed by verifying that the domain of the cnode's contents matches the expected size.\n\nObject Size Calculation: Determines the size of different kernel objects and capabilities, ensuring that each object and capability has a defined size based on its type and attributes.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Checks whether a cnode's contents are well-formed."}
{"spec": "datatype a_type =\n    ATCB\n  | AEndpoint\n  | ANTFN\n  | ACapTable nat\n  | AGarbage nat \\<comment> \\<open>number of bytes of garbage\\<close>\n  | AArch aa_type\n\ndefinition\n  a_type :: \"kernel_object \\<Rightarrow> a_type\"\nwhere\n \"a_type ob \\<equiv> case ob of\n           CNode sz cspace           \\<Rightarrow> if well_formed_cnode_n sz cspace\n                                        then ACapTable sz else AGarbage (cte_level_bits + sz)\n         | TCB tcb                   \\<Rightarrow> ATCB\n         | Endpoint endpoint         \\<Rightarrow> AEndpoint\n         | Notification notification \\<Rightarrow> ANTFN\n         | ArchObj ao                \\<Rightarrow> AArch (aa_type ao)\"", "property": "Kernel Object Types: Categorizes kernel objects into distinct types including TCB, Endpoint, Notification, Capability Table, and Architecture-specific objects. Each type is determined based on the structure and content of the kernel object, ensuring that objects are correctly identified and managed within the system.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel Objects", "comment": "Object types:"}
{"spec": "text \\<open>The kernel's heap is a partial function containing kernel objects.\\<close>\ntype_synonym kheap = \"obj_ref \\<Rightarrow> kernel_object option\"", "property": "Kernel Heap Structure: The kernel's heap is represented as a partial function that maps object references to optional kernel objects, allowing for the storage and retrieval of various kernel entities.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel State", "comment": ""}
{"spec": "type_synonym cdt = \"cslot_ptr \\<Rightarrow> cslot_ptr option\"\n\ndatatype irq_state =\n   IRQInactive\n | IRQSignal\n | IRQTimer\n | IRQReserved", "property": "Capability Derivation Tree (CDT): The kernel maintains a capability derivation tree, which is a partial mapping from capability slots to their parent capability slots, supporting the Revoke operation that deletes all capabilities derived from a specific capability.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel State", "comment": "\nCapabilities are created either by cloning an existing capability or by creating\na subordinate capability from it. This results in a capability derivation tree\nor CDT. The kernel provides a Revoke operation which deletes all capabilities\nderived from one particular capability. To support this, the kernel stores the\nCDT explicitly. It is here stored as a tree, a partial mapping from\ncapability slots to parent capability slots.\n"}
{"spec": "record abstract_state =\n  kheap              :: kheap\n  cdt                :: cdt\n  is_original_cap    :: \"cslot_ptr \\<Rightarrow> bool\"\n  cur_thread         :: obj_ref\n  idle_thread        :: obj_ref\n  machine_state      :: machine_state\n  interrupt_irq_node :: \"irq \\<Rightarrow> obj_ref\"\n  interrupt_states   :: \"irq \\<Rightarrow> irq_state\"\n  arch_state         :: arch_state", "property": "Kernel State: The kernel state encompasses a heap, a capability derivation tree, a bitmap for tracking original capabilities, pointers to the current and idle threads, the machine state, per-IRQ pointers to cnodes for interrupt delivery, an array for managing interrupt usage, and the architecture-specific state. This comprehensive state ensures the kernel's functionality, security, and efficient management of resources and interrupts.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel State", "comment": "The kernel state includes a heap, a capability derivation tree\n(CDT), a bitmap used to determine if a capability is the original\ncapability to that object, a pointer to the current thread, a pointer\nto the system idle thread, the state of the underlying machine,\nper-irq pointers to cnodes (each containing one notification through which\ninterrupts are delivered), an array recording which\ninterrupts are used for which purpose, and the state of the\narchitecture-specific kernel module.\n\nNote: for each irq, @{text \"interrupt_irq_node irq\"} points to a cnode which\ncan contain the notification cap through which interrupts are delivered. In\nC, this all lives in a single array. In the abstract spec though, to prove\nsecurity, we can't have a single object accessible by everyone. Hence the need\nto separate irq handlers.\n"}
{"spec": "record 'a state = abstract_state + exst :: 'a", "property": "Kernel State Extension: The kernel state is extended with an additional field of type 'a, allowing for different levels of abstraction and customization by choosing an appropriate concrete type for the extension.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Kernel State", "comment": "The following record extends the abstract kernel state with extra\nstate of type @{typ \"'a\"}. The specification operates over states of\nthis extended type. By choosing an appropriate concrete type for @{typ \"'a\"}\nwe may obtain different \\emph{instantiations} of the kernel specifications\nat differing levels of abstraction. See \\autoref{c:ext-spec} for further\ninformation.\n"}
{"spec": "text \\<open>This wrapper lifts monadic operations on the underlying machine state to\nmonadic operations on the kernel state.\\<close>\ndefinition\n  do_machine_op :: \"(machine_state, 'a) nondet_monad \\<Rightarrow> ('z state, 'a) nondet_monad\"\nwhere\n \"do_machine_op mop \\<equiv> do\n    ms \\<leftarrow> gets machine_state;\n    (r, ms') \\<leftarrow> select_f (mop ms);\n    modify (\\<lambda>state. state \\<lparr> machine_state := ms' \\<rparr>);\n    return r\n  od\"", "property": "Machine State Operation Wrapper: Lifts monadic operations on the underlying machine state to monadic operations on the kernel state, ensuring that the machine state is updated and the result is returned within the kernel state context.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": ""}
{"spec": "definition\n  tcb_cnode_index :: \"nat \\<Rightarrow> cnode_index\" where\n  \"tcb_cnode_index n \\<equiv> to_bl (of_nat n :: 3 word)\"", "property": "TCB CNode Index Generation: Generate the cnode indices for addressing capability slots within a TCB by converting natural numbers to their binary representation.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "This function generates the cnode indices used when addressing the\ncapability slots within a TCB.\n"}
{"spec": "definition\n  zombie_cte_bits :: \"nat option \\<Rightarrow> nat\" where\n \"zombie_cte_bits N \\<equiv> case N of Some n \\<Rightarrow> n | None \\<Rightarrow> 3\"\n\nlemma zombie_cte_bits_simps[simp]:\n \"zombie_cte_bits (Some n) = n\"\n \"zombie_cte_bits None     = 3\"\n  by (simp add: zombie_cte_bits_def)+", "property": "Zombie CTE Bits: Determine the bit size of the CNode cap from which a zombie capability was created. If the capability was created from a TCB cap, it defaults to 3 bits.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "Zombie capabilities store the bit size of the CNode cap they were\ncreated from or None if they were created from a TCB cap. This function\ndecodes the bit-length of cnode indices into the relevant kernel objects.\n"}
{"spec": "primrec (nonexhaustive)\n  first_cslot_of :: \"cap \\<Rightarrow> cslot_ptr\"\nwhere\n  \"first_cslot_of (ThreadCap oref) = (oref, tcb_cnode_index 0)\"\n| \"first_cslot_of (CNodeCap oref bits g) = (oref, replicate bits False)\"\n| \"first_cslot_of (Zombie oref bits n) = (oref, replicate (zombie_cte_bits bits) False)\"", "property": "First Capability Slot Determination: Identify the first capability slot of a given kernel object, such as a thread, CNode, or zombie, by returning the appropriate cslot pointer.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "The first capability slot of the relevant kernel object."}
{"spec": "primrec\n  obj_refs :: \"cap \\<Rightarrow> obj_ref set\"\nwhere\n  \"obj_refs NullCap = {}\"\n| \"obj_refs (ReplyCap r m cr) = {}\"\n| \"obj_refs IRQControlCap = {}\"\n| \"obj_refs (IRQHandlerCap irq) = {}\"\n| \"obj_refs (UntypedCap dev r s f) = {}\"\n| \"obj_refs (CNodeCap r bits guard) = {r}\"\n| \"obj_refs (EndpointCap r b cr) = {r}\"\n| \"obj_refs (NotificationCap r b cr) = {r}\"\n| \"obj_refs (ThreadCap r) = {r}\"\n| \"obj_refs DomainCap = {}\"\n| \"obj_refs (Zombie ptr b n) = {ptr}\"\n| \"obj_refs (ArchObjectCap x) = set_option (aobj_ref x)\"", "property": "Object References of Capabilities: The function `obj_refs` determines the set of all objects referenced by a given capability. It returns an empty set for capabilities that do not reference any objects, and it returns a set containing the object references for those that do, such as CNodeCap, EndpointCap, NotificationCap, ThreadCap, and Zombie.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "The set of all objects referenced by a capability."}
{"spec": "primrec (nonexhaustive)\n  obj_ref_of :: \"cap \\<Rightarrow> obj_ref\"\nwhere\n  \"obj_ref_of (UntypedCap dev r s f) = r\"\n| \"obj_ref_of (ReplyCap r m cr) = r\"\n| \"obj_ref_of (CNodeCap r bits guard) = r\"\n| \"obj_ref_of (EndpointCap r b cr) = r\"\n| \"obj_ref_of (NotificationCap r b cr) = r\"\n| \"obj_ref_of (ThreadCap r) = r\"\n| \"obj_ref_of (Zombie ptr b n) = ptr\"\n| \"obj_ref_of (ArchObjectCap x) = the (aobj_ref x)\"\n\nprimrec (nonexhaustive)\n  cap_bits_untyped :: \"cap \\<Rightarrow> nat\"\nwhere\n  \"cap_bits_untyped (UntypedCap dev r s f) = s\"\n\ndefinition tcb_cnode_map :: \"tcb \\<Rightarrow> cnode_index \\<Rightarrow> cap option\"\n  where\n  \"tcb_cnode_map tcb \\<equiv>\n   [tcb_cnode_index 0 \\<mapsto> tcb_ctable tcb,\n    tcb_cnode_index 1 \\<mapsto> tcb_vtable tcb,\n    tcb_cnode_index 2 \\<mapsto> tcb_reply tcb,\n    tcb_cnode_index 3 \\<mapsto> tcb_caller tcb,\n    tcb_cnode_index 4 \\<mapsto> tcb_ipcframe tcb]\"\n\ndefinition cap_of :: \"kernel_object \\<Rightarrow> cnode_index \\<Rightarrow> cap option\"\n  where\n  \"cap_of kobj \\<equiv> case kobj of CNode _ cs \\<Rightarrow> cs | TCB tcb \\<Rightarrow> tcb_cnode_map tcb | _ \\<Rightarrow> Map.empty\"", "property": "Object Reference Extraction: Extracts the object reference from a given capability, supporting various types of capabilities including UntypedCap, ReplyCap, CNodeCap, EndpointCap, NotificationCap, ThreadCap, Zombie, and ArchObjectCap. Additionally, it defines a mapping for TCB capabilities to their respective cnode indices.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "\n  The partial definition below is sometimes easier to work with.\n  It also provides cases for UntypedCap and ReplyCap which are not\n  true object references in the sense of the other caps.\n"}
{"spec": "definition\n  caps_of :: \"kernel_object \\<Rightarrow> cap set\" where\n  \"caps_of kobj \\<equiv> ran (cap_of kobj)\"", "property": "Caps of Kernel Object: Extracts the set of all capabilities contained within a given kernel object.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Helper functions", "comment": "The set of all caps contained in a kernel object."}
{"spec": "record captransfer =\n  ct_receive_root :: cap_ref\n  ct_receive_index :: cap_ref\n  ct_receive_depth :: data", "property": "Cap Transfer Structure: Defines a structure for capability transfers, including the root, index, and depth of the receiving capability.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Cap transfers", "comment": ""}
{"spec": "definition cap_transfer_data_size :: nat\n  where\n  \"cap_transfer_data_size \\<equiv> 3\"\n\ndefinition msg_max_length :: nat\n  where\n  \"msg_max_length \\<equiv> 120\"\n\ndefinition msg_max_extra_caps :: nat\n  where\n  \"msg_max_extra_caps \\<equiv> 3\"\n\ndefinition max_ipc_length :: nat\n  where\n  \"max_ipc_length \\<equiv> cap_transfer_data_size + msg_max_length + msg_max_extra_caps + 2\"\n\ndefinition msg_align_bits :: nat\n  where\n  \"msg_align_bits \\<equiv> word_size_bits + (LEAST n. max_ipc_length \\<le> 2 ^ n)\"\n\nlemma msg_align_bits':\n  \"msg_align_bits = word_size_bits + 7\"\nproof -\n  have \"(LEAST n. (cap_transfer_data_size + msg_max_length + msg_max_extra_caps + 2) \\<le> 2 ^ n) = 7\"\n  proof (rule Least_equality)\n    show \"(cap_transfer_data_size + msg_max_length + msg_max_extra_caps + 2)  \\<le> 2 ^ 7\"\n      by (simp add: cap_transfer_data_size_def msg_max_length_def msg_max_extra_caps_def)\n  next\n    fix y\n    assume \"(cap_transfer_data_size + msg_max_length + msg_max_extra_caps + 2) \\<le> 2 ^ y\"\n    hence \"(2 :: nat) ^ 7 \\<le> 2 ^ y\"\n      by (simp add: cap_transfer_data_size_def msg_max_length_def msg_max_extra_caps_def)\n    thus \"7 \\<le> y\"\n      by (rule power_le_imp_le_exp [rotated], simp)\n  qed\n  thus ?thesis unfolding msg_align_bits_def max_ipc_length_def by simp\nqed\n\nend", "property": "IPC Buffer Alignment: The IPC buffer must be aligned to a page that can fully contain the maximum possible IPC message, including data, extra capabilities, and additional metadata, without spilling over into another page. This ensures the integrity and proper handling of the IPC buffer during capability transfers.", "title": "./spec/abstract/Structures_A.thy", "chapter": "", "section": "Cap transfers", "comment": "A thread's IPC buffer capability must be to a page that is capable of\ncontaining the IPC buffer without the end of the buffer spilling into another\npage."}
{"spec": "text \\<open>Interpret a set of rights from a user data word.\\<close>\ndefinition\n  data_to_rights :: \"data \\<Rightarrow> cap_rights\" where\n  \"data_to_rights data \\<equiv> let\n    w = data_to_16 data\n   in {x. case x of AllowWrite \\<Rightarrow> w !! 0\n                  | AllowRead \\<Rightarrow> w !! 1\n                  | AllowGrant \\<Rightarrow> w !! 2\n                  | AllowGrantReply \\<Rightarrow> w !! 3}\"", "property": "Interpret Capability Rights: Convert a user data word into a set of capability rights, including AllowWrite, AllowRead, AllowGrant, and AllowGrantReply, based on the bits in the data.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Resolving capability references", "comment": ""}
{"spec": "definition\n  ensure_no_children :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"ensure_no_children cslot_ptr \\<equiv> doE\n    cdt \\<leftarrow> liftE $ gets cdt;\n    whenE (\\<exists>c. cdt c = Some cslot_ptr) (throwError RevokeFirst)\n  odE\"\n\ndefinition\n  max_free_index :: \"nat \\<Rightarrow> nat\" where\n  \"max_free_index magnitude_bits \\<equiv> 2 ^ magnitude_bits\"\n\ndefinition\n  free_index_update :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> cap \\<Rightarrow> cap\"\nwhere\n  \"free_index_update g cap \\<equiv>\n   case cap of UntypedCap dev ref sz f \\<Rightarrow> UntypedCap dev ref sz (g f) | _ \\<Rightarrow> cap\"\n\nprimrec (nonexhaustive)\n  untyped_sz_bits :: \"cap \\<Rightarrow> nat\"\nwhere\n  \"untyped_sz_bits (UntypedCap dev ref sz f) = sz\"\n\nabbreviation\n  max_free_index_update :: \"cap \\<Rightarrow> cap\"\nwhere\n  \"max_free_index_update cap \\<equiv> cap \\<lparr> free_index:= max_free_index (untyped_sz_bits cap) \\<rparr>\"\n\ndefinition\n  set_untyped_cap_as_full :: \"cap \\<Rightarrow> cap \\<Rightarrow> obj_ref \\<times> bool list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_untyped_cap_as_full src_cap new_cap src_slot \\<equiv>\n   if (is_untyped_cap src_cap \\<and> is_untyped_cap new_cap\n       \\<and> obj_ref_of src_cap = obj_ref_of new_cap \\<and> cap_bits_untyped src_cap = cap_bits_untyped new_cap)\n       then set_cap (max_free_index_update src_cap) src_slot else return ()\"", "property": "Ensure No Children: Verify that a capability stored in a slot does not have any children. If the capability is a parent, an error is thrown to prevent further operations.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Resolving capability references", "comment": "Check that a capability stored in a slot is not a parent of any other\ncapability."}
{"spec": "definition\nderive_cap :: \"cslot_ptr \\<Rightarrow> cap \\<Rightarrow> (cap,'z::state_ext) se_monad\" where\n\"derive_cap slot cap \\<equiv>\n case cap of\n    ArchObjectCap c \\<Rightarrow> arch_derive_cap c\n    | UntypedCap dev ptr sz f \\<Rightarrow> doE ensure_no_children slot; returnOk cap odE\n    | Zombie ptr n sz \\<Rightarrow> returnOk NullCap\n    | ReplyCap ptr m cr \\<Rightarrow> returnOk NullCap\n    | IRQControlCap \\<Rightarrow> returnOk NullCap\n    | _ \\<Rightarrow> returnOk cap\"", "property": "Derive Capability: Transform a capability into a form suitable for copying, considering the specific constraints and limitations of different capability types. Some capabilities may be converted to a null capability or left unchanged based on their type.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Resolving capability references", "comment": "Derive a cap into a form in which it can be copied. For internal reasons\nnot all capability types can be copied at all times and not all capability types\ncan be copied unchanged."}
{"spec": "definition\n  update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> cap \\<Rightarrow> cap\" where\n\"update_cap_data preserve w cap \\<equiv>\n  if is_ep_cap cap then\n    if cap_ep_badge cap = 0 \\<and> \\<not> preserve then\n      badge_update w cap\n    else NullCap\n  else if is_ntfn_cap cap then\n    if cap_ep_badge cap = 0 \\<and> \\<not> preserve then\n      badge_update w cap\n    else NullCap\n  else if is_cnode_cap cap then\n    let\n        (oref, bits, guard) = the_cnode_cap cap;\n        (guard_size', guard'') = update_cnode_cap_data w;\n        guard' = drop (size guard'' - guard_size') (to_bl guard'')\n    in\n        if guard_size' + bits > word_bits\n        then NullCap\n        else CNodeCap oref bits guard'\n  else if is_arch_cap cap then\n    arch_update_cap_data preserve w (the_arch_cap cap)\n  else\n    cap\"", "property": "Transform Capability Data: Update a capability based on user-supplied data, with the transformation rules varying by capability type. If the preserve flag is set, the update is performed in-place, and certain changes are disallowed to maintain existing CDT relationships. For endpoint and notification capabilities, the badge is updated if it is zero and the preserve flag is not set. For CNode capabilities, the guard and bits are updated, and the result is validated. For architecture-specific capabilities, a specialized update function is used.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Resolving capability references", "comment": "Transform a capability on request from a user thread. The user-supplied\nargument word is interpreted differently for different cap types. If the\npreserve flag is set this transformation is being done in-place which means some\nchanges are disallowed because they would invalidate existing CDT relationships.\n"}
{"spec": "text \\<open>\nRecursively looks up a capability address to a CNode slot by walking over\nmultiple CNodes until all the bits in the address are used or there are\nno further CNodes.\n\\<close>\nfunction resolve_address_bits' :: \"'z itself \\<Rightarrow> cap \\<times> cap_ref \\<Rightarrow> (cslot_ptr \\<times> cap_ref,'z::state_ext) lf_monad\"\nwhere\n  \"resolve_address_bits' z (cap, cref) =\n  (case cap of\n     CNodeCap oref radix_bits guard  \\<Rightarrow>\n     if radix_bits + size guard = 0 then\n       fail \\<comment> \\<open>nothing is translated: table broken\\<close>\n     else doE\n       whenE (\\<not> guard \\<le> cref)\n             \\<comment> \\<open>guard does not match\\<close>\n             (throwError $ GuardMismatch (size cref) guard);\n\n       whenE (size cref < radix_bits + size guard)\n             \\<comment> \\<open>not enough bits to resolve: table malformed\\<close>\n             (throwError $ DepthMismatch (size cref) (radix_bits+size guard));\n\n       offset \\<leftarrow> returnOk $ take radix_bits (drop (size guard) cref);\n       rest \\<leftarrow> returnOk $ drop (radix_bits + size guard) cref;\n       if rest = [] then\n         returnOk ((oref,offset), [])\n       else doE\n         next_cap \\<leftarrow> liftE $ get_cap (oref, offset);\n         if is_cnode_cap next_cap then\n           resolve_address_bits' z (next_cap, rest)\n         else\n           returnOk ((oref,offset), rest)\n       odE\n     odE\n   | _ \\<Rightarrow> throwError InvalidRoot)\"\n  by auto\n\nlemma rab_termination:\n  \"\\<forall>cref guard radix_bits.\n    \\<not> length cref \\<le> radix_bits + length guard \\<and>\n    (0 < radix_bits \\<or> guard \\<noteq> []) \\<longrightarrow>\n      length cref - (radix_bits + length guard) < length cref\"\n  apply clarsimp\n  apply (erule disjE)\n   apply arith\n  apply (clarsimp simp: neq_Nil_conv)\n  apply arith\n  done\n\ntermination\n  apply (relation \"measure (\\<lambda>(z,cap, cs). size cs)\")\n  apply (auto simp: whenE_def returnOk_def return_def rab_termination)\n  done\n\ndeclare resolve_address_bits'.simps[simp del]\n\ndefinition resolve_address_bits where\n\"resolve_address_bits \\<equiv> resolve_address_bits' TYPE('z::state_ext)\"", "property": "Resolve Capability Address: Recursively resolves a capability address to a CNode slot by traversing multiple CNodes. Ensures that the guard matches and there are enough bits to resolve, and continues until all bits in the address are used or no further CNodes are available.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Transferring capabilities", "comment": ""}
{"spec": "definition\n  lookup_slot_for_thread :: \"obj_ref \\<Rightarrow> cap_ref \\<Rightarrow> (cslot_ptr \\<times> cap_ref,'z::state_ext) lf_monad\"\nwhere\n  \"lookup_slot_for_thread thread cref \\<equiv> doE\n     tcb \\<leftarrow> liftE $ gets_the $ get_tcb thread;\n     resolve_address_bits (tcb_ctable tcb, cref)\n  odE\"\n\ndefinition\n  lookup_cap_and_slot :: \"obj_ref \\<Rightarrow> cap_ref \\<Rightarrow> (cap \\<times> cslot_ptr,'z::state_ext) lf_monad\" where\n  \"lookup_cap_and_slot thread cptr \\<equiv> doE\n      (slot, cr) \\<leftarrow> lookup_slot_for_thread thread cptr;\n      cap \\<leftarrow> liftE $ get_cap slot;\n      returnOk (cap, slot)\n  odE\"\n\ndefinition\n  lookup_cap :: \"obj_ref \\<Rightarrow> cap_ref \\<Rightarrow> (cap,'z::state_ext) lf_monad\" where\n  \"lookup_cap thread ref \\<equiv> doE\n     (ref', _) \\<leftarrow> lookup_slot_for_thread thread ref;\n     liftE $ get_cap ref'\n   odE\"\n\ndefinition\n  lookup_slot_for_cnode_op ::\n  \"bool \\<Rightarrow> cap \\<Rightarrow> cap_ref \\<Rightarrow> nat \\<Rightarrow> (cslot_ptr,'z::state_ext) se_monad\"\nwhere\n \"lookup_slot_for_cnode_op is_source croot ptr depth \\<equiv>\n  if is_cnode_cap croot then\n  doE\n    whenE (depth < 1 \\<or> depth > word_bits)\n      $ throwError (RangeError 1 (of_nat word_bits));\n    lookup_error_on_failure is_source $ doE\n      ptrbits_for_depth \\<leftarrow> returnOk $ drop (length ptr - depth) ptr;\n      (slot, rem) \\<leftarrow> resolve_address_bits (croot, ptrbits_for_depth);\n      case rem of\n        [] \\<Rightarrow> returnOk slot\n      | _  \\<Rightarrow> throwError $ DepthMismatch (length rem) 0\n    odE\n  odE\n  else\n    throwError (FailedLookup is_source InvalidRoot)\"\n\ndefinition\n  lookup_source_slot :: \"cap \\<Rightarrow> cap_ref \\<Rightarrow> nat \\<Rightarrow> (cslot_ptr,'z::state_ext) se_monad\"\nwhere\n \"lookup_source_slot \\<equiv> lookup_slot_for_cnode_op True\"\n\ndefinition\n  lookup_target_slot :: \"cap \\<Rightarrow> cap_ref \\<Rightarrow> nat \\<Rightarrow> (cslot_ptr,'z::state_ext) se_monad\"\nwhere\n \"lookup_target_slot \\<equiv> lookup_slot_for_cnode_op False\"\n\ndefinition\n  lookup_pivot_slot :: \"cap \\<Rightarrow> cap_ref \\<Rightarrow> nat \\<Rightarrow> (cslot_ptr,'z::state_ext) se_monad\"\nwhere\n \"lookup_pivot_slot  \\<equiv> lookup_slot_for_cnode_op True\"", "property": "Capability Lookup: Provides specialized methods for looking up capabilities and their slots in the CSpace, supporting various standard cases such as resolving addresses, checking for valid cnode capabilities, and handling depth mismatches. These methods ensure that the correct capability and slot are retrieved or an appropriate error is thrown, maintaining the integrity and security of the CSpace.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Transferring capabilities", "comment": "Specialisations of the capability lookup process to various standard\ncases."}
{"spec": "text \\<open>These functions are used in interpreting from user arguments the manner\nin which a capability transfer should take place.\\<close>\n\ndefinition\n  captransfer_from_words :: \"machine_word \\<Rightarrow> (captransfer,'z::state_ext) s_monad\"\nwhere\n  \"captransfer_from_words ptr \\<equiv> do\n     w0 \\<leftarrow> do_machine_op $ loadWord ptr;\n     w1 \\<leftarrow> do_machine_op $ loadWord (ptr + word_size);\n     w2 \\<leftarrow> do_machine_op $ loadWord (ptr + 2 * word_size);\n     return \\<lparr> ct_receive_root = data_to_cptr w0,\n              ct_receive_index = data_to_cptr w1,\n              ct_receive_depth = w2 \\<rparr>\n   od\"\n\ndefinition\n  load_cap_transfer :: \"obj_ref \\<Rightarrow> (captransfer,'z::state_ext) s_monad\" where\n \"load_cap_transfer buffer \\<equiv> do\n     offset \\<leftarrow> return $ msg_max_length + msg_max_extra_caps + 2;\n     captransfer_from_words (buffer + of_nat offset * word_size)\n  od\"\n\nfun\n  get_receive_slots :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow>\n                         (cslot_ptr list,'z::state_ext) s_monad\"\nwhere\n  \"get_receive_slots thread (Some buffer) = do\n     ct \\<leftarrow> load_cap_transfer buffer;\n\n     empty_on_failure $ doE\n       cnode \\<leftarrow> unify_failure $\n                  lookup_cap thread (ct_receive_root ct);\n       slot \\<leftarrow> unify_failure $ lookup_target_slot cnode\n                  (ct_receive_index ct) (unat (ct_receive_depth ct));\n\n       cap \\<leftarrow> liftE $ get_cap slot;\n\n       whenE (cap \\<noteq> NullCap) (throwError ());\n\n       returnOk [slot]\n     odE\n   od\"\n|  \"get_receive_slots x None = return []\"", "property": "Capability Transfer Interpretation: Interprets user-provided data to determine the parameters for a capability transfer, including the receive root, index, and depth. It ensures that the specified slots are valid and empty before proceeding with the transfer, maintaining the integrity of the capability space.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Transferring capabilities", "comment": ""}
{"spec": "text \\<open>Deletion of the final capability to any object is a long running\noperation if the capability is of these types.\\<close>\ndefinition\n  long_running_delete :: \"cap \\<Rightarrow> bool\" where\n \"long_running_delete cap \\<equiv> case cap of\n    CNodeCap ptr bits gd \\<Rightarrow> True\n  | Zombie ptr bits n \\<Rightarrow> True\n  | ThreadCap ptr \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"\n\n\ndefinition\n  slot_cap_long_running_delete :: \"cslot_ptr \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"slot_cap_long_running_delete slot \\<equiv> do\n     cap \\<leftarrow> get_cap slot;\n     case cap of\n         NullCap \\<Rightarrow> return False\n       | _ \\<Rightarrow> do\n           final \\<leftarrow> is_final_cap cap;\n           return (final \\<and> long_running_delete cap)\n         od\n   od\"", "property": "Long-Running Deletion: Determine if the deletion of a capability is a long-running operation based on its type. The deletion is considered long-running for CNode, Zombie, and Thread capabilities, and it checks if the capability is the final one in the slot.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": ""}
{"spec": "definition\n  cap_swap :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cap_swap cap1 slot1 cap2 slot2 \\<equiv>\n  do\n    set_cap cap2 slot1;\n    set_cap cap1 slot2;\n    slot1_p \\<leftarrow> gets (\\<lambda>s. cdt s slot1);\n    slot2_p \\<leftarrow> gets (\\<lambda>s. cdt s slot2);\n    cdt \\<leftarrow> gets cdt;\n    \\<comment> \\<open>update children:\\<close>\n    cdt' \\<leftarrow> return (\\<lambda>n. if cdt n = Some slot1\n                        then Some slot2\n                        else if cdt n = Some slot2\n                        then Some slot1\n                        else cdt n);\n    \\<comment> \\<open>update parents:\\<close>\n    set_cdt (cdt' (slot1 := cdt' slot2, slot2 := cdt' slot1));\n    do_extended_op (cap_swap_ext slot1 slot2 slot1_p slot2_p);\n    is_original \\<leftarrow> gets is_original_cap;\n    set_original slot1 (is_original slot2);\n    set_original slot2 (is_original slot1)\n  od\"", "property": "Capability Swap: Exchanges the contents of two capability slots, including updating their states and transforming them as requested. The operation also updates the children and parents in the capability derivation tree (CDT) to reflect the swap, ensuring the integrity of the CSpace structure.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Swap the contents of two capability slots. The capability parameters are\nthe new states of the capabilities, as the user may request that the\ncapabilities are transformed as they are swapped."}
{"spec": "definition\n  cap_move :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cap_move new_cap src_slot dest_slot \\<equiv> do\n    set_cap new_cap dest_slot;\n    set_cap NullCap src_slot;\n    src_p \\<leftarrow> gets (\\<lambda>s. cdt s src_slot);\n    dest_p \\<leftarrow> gets (\\<lambda>s. cdt s dest_slot);\n    cdt \\<leftarrow> gets cdt;\n    parent \\<leftarrow> return $ cdt src_slot;\n    cdt' \\<leftarrow> return $ cdt(dest_slot := parent, src_slot := None);\n    set_cdt (\\<lambda>r. if cdt' r = Some src_slot then Some dest_slot else cdt' r);\n    do_extended_op (cap_move_ext src_slot dest_slot src_p dest_p);\n    is_original \\<leftarrow> gets is_original_cap;\n    set_original dest_slot (is_original src_slot);\n    set_original src_slot False\n  od\"", "property": "Capability Movement: Move a capability from one slot to another, updating the capability table and parent references to reflect the new location of the capability. The original capability in the source slot is replaced with a null capability, and the originality flag is updated accordingly.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Move a capability from one slot to another. Once again the new\ncapability is a parameter as it may be transformed while it is moved."}
{"spec": "definition\n  cap_swap_for_delete :: \"cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"cap_swap_for_delete slot1 slot2 \\<equiv>\n  when (slot1 \\<noteq> slot2) $ do\n    cap1 \\<leftarrow> get_cap slot1;\n    cap2 \\<leftarrow> get_cap slot2;\n    cap_swap cap1 slot1 cap2 slot2\n  od\"", "property": "Capability Swap for Deletion: Swaps the capabilities between two different capability slots without altering the capabilities themselves, ensuring that the existing capabilities are preserved during the swap.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "This version of capability swap does not change the capabilities that\nare swapped, passing the existing capabilities to the more general function."}
{"spec": "datatype\n  rec_del_call\n  = CTEDeleteCall cslot_ptr bool\n  | FinaliseSlotCall cslot_ptr bool\n  | ReduceZombieCall cap cslot_ptr bool", "property": "Recursive Deletion Calls: Define the types of recursive deletion operations, including deleting a capability table entry, finalizing a slot, and reducing a zombie capability. These operations are parameterized with a capability slot pointer and a boolean flag to indicate specific behaviors.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "The type of possible recursive deletes."}
{"spec": "definition\n  locate_slot :: \"cslot_ptr \\<Rightarrow> nat \\<Rightarrow> cslot_ptr\" where\n \"locate_slot \\<equiv> \\<lambda>(a, b) n. (a, drop (32 - length b)\n                           (to_bl (of_bl b + of_nat n :: word32)))\"", "property": "Locate Capability Slot: Determine the location of a capability slot by calculating the nth slot beyond a specified base slot. This ensures that capabilities can be accurately referenced and managed within the CSpace.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Locate the nth capability beyond some base capability slot."}
{"spec": "definition\n  deleting_irq_handler :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n \"deleting_irq_handler irq \\<equiv> do\n    slot \\<leftarrow> get_irq_slot irq;\n    cap_delete_one slot\n  od\"", "property": "Revoking and Deleting IRQ Handler Capabilities: Upon deletion of an IRQ handler capability, the system retrieves the slot associated with the specified IRQ and deletes the capability from that slot.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Actions to be taken after deleting an IRQ Handler capability."}
{"spec": "fun\n  finalise_cap :: \"cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"finalise_cap NullCap                  final = return (NullCap, NullCap)\"\n| \"finalise_cap (UntypedCap dev r bits f)    final = return (NullCap, NullCap)\"\n| \"finalise_cap (ReplyCap r m R)         final = return (NullCap, NullCap)\"\n| \"finalise_cap (EndpointCap r b R)      final =\n      (liftM (K (NullCap, NullCap)) $ when final $ cancel_all_ipc r)\"\n| \"finalise_cap (NotificationCap r b R)  final =\n      (liftM (K (NullCap, NullCap)) $ when final $ do\n          unbind_maybe_notification r;\n          cancel_all_signals r\n        od)\"\n| \"finalise_cap (CNodeCap r bits g)  final =\n      return (if final then Zombie r (Some bits) (2 ^ bits) else NullCap, NullCap)\"\n| \"finalise_cap (ThreadCap r)            final =\n      do\n         when final $ unbind_notification r;\n         when final $ suspend r;\n         when final $ prepare_thread_delete r;\n         return (if final then (Zombie r None 5) else NullCap, NullCap)\n      od\"\n| \"finalise_cap DomainCap                final = return (NullCap, NullCap)\"\n| \"finalise_cap (Zombie r b n)           final =\n      do assert final; return (Zombie r b n, NullCap) od\"\n| \"finalise_cap IRQControlCap            final = return (NullCap, NullCap)\"\n| \"finalise_cap (IRQHandlerCap irq)      final = (\n       if final then do\n         deleting_irq_handler irq;\n         return (NullCap, (IRQHandlerCap irq))\n       od\n       else return (NullCap, NullCap))\"\n| \"finalise_cap (ArchObjectCap a)        final =\n      (arch_finalise_cap a final)\"\n\ndefinition\n  can_fast_finalise :: \"cap \\<Rightarrow> bool\" where\n \"can_fast_finalise cap \\<equiv> case cap of\n    ReplyCap r m R \\<Rightarrow> True\n  | EndpointCap r b R \\<Rightarrow> True\n  | NotificationCap r b R \\<Rightarrow> True\n  | NullCap \\<Rightarrow> True\n  | _ \\<Rightarrow> False\"", "property": "Capability Finalization: When a capability is deleted, the system performs specific actions based on the type of capability. It returns two capabilities: one to be re-inserted into the slot (often a Zombie for long-running operations) and another representing any post-deletion actions required, such as clearing an IRQ or unbinding notifications. The finalization process ensures that the system handles the deletion of capabilities correctly and maintains the integrity of the CSpace.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Actions that must be taken when a capability is deleted. Returns two\ncapabilities: The first is a capability to be re-inserted into the slot in place\nof the deleted capability; in particular, this will be a Zombie if the deletion\nrequires a long-running operation. The second represents some further\npost-deletion action to be performed after the slot is cleared. For example,\nan IRQHandlerCap indicates an IRQ to be cleared. Arch capabilities may also be\nassociated with arch-specific post-deletion actions. For most cases, however,\nNullCap is used to indicate that no post-deletion action is required."}
{"spec": "lemma fast_finalise_def2:\n  \"fast_finalise cap final = do\n     assert (can_fast_finalise cap);\n     result \\<leftarrow> finalise_cap cap final;\n     assert (result = (NullCap, NullCap))\n   od\"\n  supply K_def[simp]\n  by (cases cap, simp_all add: liftM_def assert_def can_fast_finalise_def)", "property": "Fast Finalisation: Ensures that a capability is deleted when it is known that a long-running operation is impossible, by finalising the capability and verifying that the result is a null capability.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "This operation is used to delete a capability when it is known that a\nlong-running operation is impossible. It is equivalent to calling the regular\nfinalisation operation. It cannot be defined in that way as doing so\nwould create a circular definition."}
{"spec": "primrec (nonexhaustive)\n  cap_removeable :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\"\nwhere\n  \"cap_removeable NullCap slot = True\"\n| \"cap_removeable (Zombie slot' bits n) slot =\n    ((n = 0) \\<or> (n = 1 \\<and> (slot', replicate (zombie_cte_bits bits) False) = slot))\"", "property": "Capability Removability: Determines if a capability can be removed based on its type and the slots it covers. Null capabilities are always removable, and Zombie capabilities are removable if they cover no slots or only the slot in which they are currently stored.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "The finalisation process on a Zombie or Null capability is finished for\nall Null capabilities and for Zombies that cover no slots or only the slot they\nare currently stored in."}
{"spec": "definition\n  cap_cyclic_zombie :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> bool\" where\n \"cap_cyclic_zombie cap slot \\<equiv> case cap of\n         Zombie slot' bits n \\<Rightarrow> (slot', replicate (zombie_cte_bits bits) False) = slot\n       | _ \\<Rightarrow> False\"", "property": "Cyclic Zombie Check: Ensures that a capability is not a zombie referring to the CNode or TCB slot in which it is stored, preventing cyclic references and maintaining the integrity of the capability system.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Checks for Zombie capabilities that refer to the CNode or TCB they are\nstored in."}
{"spec": "function (sequential)\n  rec_del :: \"rec_del_call \\<Rightarrow> (bool * cap,'z::state_ext) p_monad\"\nwhere\n  \"rec_del (CTEDeleteCall slot exposed) s =\n (doE\n    (success, cleanup_info) \\<leftarrow> rec_del (FinaliseSlotCall slot exposed);\n    without_preemption $ when (exposed \\<or> success) $ empty_slot slot cleanup_info;\n    returnOk undefined\n  odE) s\"\n|\n  \"rec_del (FinaliseSlotCall slot exposed) s =\n (doE\n    cap \\<leftarrow> without_preemption $ get_cap slot;\n    if (cap = NullCap)\n    then returnOk (True, NullCap)\n    else (doE\n      is_final \\<leftarrow> without_preemption $ is_final_cap cap;\n      (remainder, cleanup_info) \\<leftarrow> without_preemption $ finalise_cap cap is_final;\n      if (cap_removeable remainder slot)\n      then returnOk (True, cleanup_info)\n      else if (cap_cyclic_zombie remainder slot \\<and> \\<not> exposed)\n      then doE\n        without_preemption $ set_cap remainder slot;\n        returnOk (False, NullCap)\n      odE\n      else doE\n        without_preemption $ set_cap remainder slot;\n        rec_del (ReduceZombieCall remainder slot exposed);\n        preemption_point;\n        rec_del (FinaliseSlotCall slot exposed)\n      odE\n    odE)\n  odE) s\"\n\n| \"rec_del (ReduceZombieCall (Zombie ptr bits (Suc n)) slot False) s =\n (doE\n    cn \\<leftarrow> returnOk $ first_cslot_of (Zombie ptr bits (Suc n));\n    assertE (cn \\<noteq> slot);\n    without_preemption $ cap_swap_for_delete cn slot;\n    returnOk undefined\n  odE) s\"\n|\n \"rec_del (ReduceZombieCall (Zombie ptr bits (Suc n)) slot True) s =\n (doE\n    end_slot \\<leftarrow> returnOk (ptr, nat_to_cref (zombie_cte_bits bits) n);\n    rec_del (CTEDeleteCall end_slot False);\n    new_cap \\<leftarrow> without_preemption $ get_cap slot;\n    if (new_cap = Zombie ptr bits (Suc n))\n    then without_preemption $ set_cap (Zombie ptr bits n) slot\n    else assertE (new_cap = NullCap \\<or>\n                  is_zombie new_cap \\<and> first_cslot_of new_cap = slot\n                   \\<and> first_cslot_of (Zombie ptr bits (Suc n)) \\<noteq> slot);\n    returnOk undefined\n  odE) s\"\n|\n \"rec_del (ReduceZombieCall cap slot exposed) s =\n  fail s\"\n  by pat_completeness auto", "property": "Recursive Capability Deletion: Perform a complete recursive deletion of capabilities, including finalizing slots, handling cyclic zombies, and reducing zombie capabilities. The operation ensures that all related capabilities are properly cleaned up and slots are emptied, maintaining the integrity of the capability space.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "The complete recursive delete operation."}
{"spec": "definition\n  cap_delete :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n \"cap_delete slot \\<equiv> doE rec_del (CTEDeleteCall slot True); returnOk () odE\"", "property": "Capability Deletion: Recursively delete a capability from the specified slot, ensuring that all associated resources and references are properly removed.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Delete a capability by calling the recursive delete operation."}
{"spec": "definition\n  finalise_slot :: \"cslot_ptr \\<Rightarrow> bool \\<Rightarrow> (bool * cap,'z::state_ext) p_monad\"\nwhere\n  \"finalise_slot p e \\<equiv> rec_del (FinaliseSlotCall p e)\"", "property": "Prepare Capability for Deletion: Finalize the capability in a specified slot, preparing it for deletion without actually removing it. This ensures that the capability is in a state where it can be safely deleted later.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Prepare the capability in a slot for deletion but do not delete it."}
{"spec": "primrec\n  exposed_rdcall :: \"rec_del_call \\<Rightarrow> bool\"\nwhere\n  \"exposed_rdcall (CTEDeleteCall slot exposed) = exposed\"\n| \"exposed_rdcall (FinaliseSlotCall slot exposed) = exposed\"\n| \"exposed_rdcall (ReduceZombieCall cap slot exposed) = exposed\"\n\nprimrec\n  isCTEDeleteCall :: \"rec_del_call \\<Rightarrow> bool\"\nwhere\n  \"isCTEDeleteCall (CTEDeleteCall slot exposed) = True\"\n| \"isCTEDeleteCall (FinaliseSlotCall slot exposed) = False\"\n| \"isCTEDeleteCall (ReduceZombieCall cap slot exposed) = False\"\n\nprimrec\n  slot_rdcall :: \"rec_del_call \\<Rightarrow> cslot_ptr\"\nwhere\n  \"slot_rdcall (CTEDeleteCall slot exposed) = slot\"\n| \"slot_rdcall (FinaliseSlotCall slot exposed) = slot\"\n| \"slot_rdcall (ReduceZombieCall cap slot exposed) = slot\"", "property": "Recursive Delete Call Properties: Determine if a recursive delete call is exposed, identify if it is a CTE delete call, and extract the slot associated with the call. These properties help in managing the revocation and deletion of capabilities by providing information about the type and exposure status of the delete operation.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Helper functions for the type of recursive delete calls."}
{"spec": "function cap_revoke :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n\"cap_revoke slot s = (doE\n    cap \\<leftarrow> without_preemption $ get_cap slot;\n    cdt \\<leftarrow> without_preemption $ gets cdt;\n    descendants \\<leftarrow> returnOk $ descendants_of slot cdt;\n    whenE (cap \\<noteq> NullCap \\<and> descendants \\<noteq> {}) (doE\n      child \\<leftarrow> without_preemption $ select_ext (next_revoke_cap slot) descendants;\n      cap \\<leftarrow> without_preemption $ get_cap child;\n      assertE (cap \\<noteq> NullCap);\n      cap_delete child;\n      preemption_point;\n      cap_revoke slot\n    odE)\nodE) s\"\nby auto", "property": "Revoke and Delete Derived Capabilities: Recursively revoke and delete all derived capabilities of a given capability, ensuring that the capability tree is properly cleaned up.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Revoking and deleting capabilities", "comment": "Revoke the derived capabilities of a given capability, deleting them\nall."}
{"spec": "definition\n  get_badge :: \"cap \\<Rightarrow> badge option\" where\n \"get_badge cap \\<equiv> case cap of\n    NotificationCap oref badge cr \\<Rightarrow> Some badge\n  | EndpointCap oref badge cr      \\<Rightarrow> Some badge\n  | _                              \\<Rightarrow> None\"\n\n\ndefinition\n  is_physical :: \"cap \\<Rightarrow> bool\" where\n  \"is_physical cap \\<equiv> case cap of\n    NullCap \\<Rightarrow> False\n  | DomainCap \\<Rightarrow> False\n  | IRQControlCap \\<Rightarrow> False\n  | IRQHandlerCap _ \\<Rightarrow> False\n  | ReplyCap _ _ _ \\<Rightarrow> False\n  | ArchObjectCap c \\<Rightarrow> arch_is_physical c\n  | _ \\<Rightarrow> True\"\n\nfun\n  same_region_as :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"same_region_as NullCap c' = False\"\n| \"same_region_as (UntypedCap dev r bits free) c' =\n    (is_physical c' \\<and>\n     r \\<le> obj_ref_of c' \\<and>\n     obj_ref_of c' \\<le> obj_ref_of c' + obj_size c' - 1 \\<and>\n     obj_ref_of c' + obj_size c' - 1 \\<le> r + (1 << bits) - 1)\"\n| \"same_region_as (EndpointCap r b R) c' =\n    (is_ep_cap c' \\<and> obj_ref_of c' = r)\"\n| \"same_region_as (NotificationCap r b R) c' =\n    (is_ntfn_cap c' \\<and> obj_ref_of c' = r)\"\n| \"same_region_as (CNodeCap r bits g) c' =\n    (is_cnode_cap c' \\<and> obj_ref_of c' = r \\<and> bits_of c' = bits)\"\n| \"same_region_as (ReplyCap n m cr) c' = (\\<exists>m' cr. c' = ReplyCap n m' cr)\"\n| \"same_region_as (ThreadCap r) c' =\n    (is_thread_cap c' \\<and> obj_ref_of c' = r)\"\n| \"same_region_as (Zombie r b n) c' = False\"\n| \"same_region_as (IRQControlCap) c' =\n    (c' = IRQControlCap \\<or> (\\<exists>n. c' = IRQHandlerCap n))\"\n| \"same_region_as DomainCap c' = (c' = DomainCap)\"\n| \"same_region_as (IRQHandlerCap n) c' =\n    (c' = IRQHandlerCap n)\"\n| \"same_region_as (ArchObjectCap a) c' =\n    (case c' of ArchObjectCap a' \\<Rightarrow> arch_same_region_as a a' | _ \\<Rightarrow> False)\"", "property": "Capability Region Comparison: Determines if two capabilities refer to the same memory region or object. This is based on the type and properties of the capabilities, including their references, sizes, and specific attributes, ensuring that only compatible and overlapping capabilities are considered to be in the same region.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": ""}
{"spec": "definition\n  same_object_as :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\" where\n \"same_object_as cp cp' \\<equiv>\n   (case (cp, cp') of\n      (UntypedCap dev r bits free, _) \\<Rightarrow> False\n    | (IRQControlCap, IRQHandlerCap n) \\<Rightarrow> False\n    | (ArchObjectCap ac, ArchObjectCap ac') \\<Rightarrow> same_aobject_as ac ac'\n    | _ \\<Rightarrow> same_region_as cp cp')\"", "property": "Check Capabilities for Same Object: Determine if two capabilities refer to the same object by comparing their types and properties, ensuring that they are either of the same region or, in the case of architecture-specific capabilities, that they refer to the same architectural object.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "Check whether two capabilities are to the same object."}
{"spec": "definition\n  should_be_parent_of :: \"cap \\<Rightarrow> bool \\<Rightarrow> cap \\<Rightarrow> bool \\<Rightarrow> bool\" where\n  \"should_be_parent_of c original c' original' \\<equiv>\n   original \\<and>\n   same_region_as c c' \\<and>\n   (case c of\n      EndpointCap ref badge R \\<Rightarrow> badge \\<noteq> 0 \\<longrightarrow> cap_ep_badge c' = badge \\<and> \\<not>original'\n    | NotificationCap ref badge R \\<Rightarrow> badge \\<noteq> 0 \\<longrightarrow> cap_ep_badge c' = badge \\<and> \\<not>original'\n    | _ \\<Rightarrow> True)\"", "property": "Parent-Child Relationship for Capabilities: A capability \\( c \\) should be a parent of another capability \\( c' \\) if \\( c \\) is the original capability to the object and covers the same memory region as \\( c' \\). For endpoint and notification capabilities, \\( c \\) should also have a non-zero badge, and \\( c' \\) should have the same badge but not be an original badged endpoint or notification capability.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "\nThe function @{text \"should_be_parent_of\"}\nchecks whether an existing capability should be a parent of\nanother to-be-inserted capability. The test is the following:\nFor capability @{term c} to be a parent of capability @{term c'},\n@{term c} needs to be the original capability to the object and needs\nto cover the same memory region as @{term c'} (i.e.\\ cover the same\nobject). In the case of endpoint capabilities, if @{term c} is a\nbadged endpoint cap (@{text \"badge \\<noteq> 0\"}), then it should be a parent\nof @{text c'} if @{text c'} has the same badge and is itself not an\noriginal badged endpoint cap.\n\n\\begin{figure}\n\\begin{center}\n\\includegraphics[width=0.8\\textwidth]{imgs/CDT}\n\\end{center}\n\\caption{Example capability derivation tree.}\\label{fig:CDT}\n\\end{figure}\n\nFigure \\ref{fig:CDT} shows an example capability derivation tree that\nillustrates a standard scenario: the top level is a large untyped\ncapability, the second level splits this capability into two regions\ncovered by their own untyped caps, both are children of the first\nlevel.  The third level on the left is a copy of the level 2 untyped\ncapability.  Untyped capabilities when copied always create children,\nnever siblings.  In this scenario, the untyped capability was typed\ninto two separate objects, creating two capabilities on level 4, both\nare the original capability to the respective object, both are\nchildren of the untyped capability they were created from.\n\n Ordinary original capabilities can have one level of derived capabilities\n(created, for instance, by the copy or mint operations). Further copies\nof these derived capabilities will create sibling, in this case\nremaining on level 5. There is an exception to this scheme for endpoint\ncapabilities --- they support an additional layer of depth with the\nconcept of badged and unbadged endpoints. The original endpoint\ncapability will be unbadged. Using the mint operation, a copy of\nthe capability with a specific badge can be created. This new, badged\ncapability to the same object is treated as an original capability\n(the ``original badged endpoint capability'') and supports one level\nof derived children like other capabilities.\n"}
{"spec": "definition\n  is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"is_cap_revocable new_cap src_cap \\<equiv> case new_cap of\n      ArchObjectCap acap \\<Rightarrow> arch_is_cap_revocable new_cap src_cap\n    | EndpointCap _ _ _ \\<Rightarrow> cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n    | NotificationCap _ _ _ \\<Rightarrow> cap_ep_badge new_cap \\<noteq> cap_ep_badge src_cap\n    | IRQHandlerCap _ \\<Rightarrow> src_cap = IRQControlCap\n    | UntypedCap _ _ _ _ \\<Rightarrow> True\n    | _ \\<Rightarrow> False\"", "property": "Cap Revocability: Determines if a new capability should be considered revocable based on its type and attributes. Specifically, it checks for newly badged endpoint capabilities, IRQ handlers, untyped capabilities, and certain architecture-specific capabilities.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "This helper function determines if the new capability\nshould be counted as the original capability to the object. This test\nis usually false, apart from the exceptions listed (newly badged\nendpoint capabilities, irq handlers, untyped caps, and possibly some\narch caps)."}
{"spec": "definition\n  cap_insert :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"cap_insert new_cap src_slot dest_slot \\<equiv> do\n    src_cap \\<leftarrow> get_cap src_slot;\n\n    dest_original \\<leftarrow> return $ is_cap_revocable new_cap src_cap;\n\n    old_cap \\<leftarrow> get_cap dest_slot;\n    assert (old_cap = NullCap);\n    set_untyped_cap_as_full src_cap new_cap src_slot;\n    set_cap new_cap dest_slot;\n\n    is_original \\<leftarrow> gets is_original_cap;\n    src_parent \\<leftarrow> return $\n       should_be_parent_of src_cap (is_original src_slot) new_cap dest_original;\n    src_p \\<leftarrow> gets (\\<lambda>s. cdt s src_slot);\n    dest_p \\<leftarrow> gets (\\<lambda>s. cdt s dest_slot);\n    update_cdt (\\<lambda>cdt. cdt (dest_slot := if src_parent\n                                        then Some src_slot\n                                        else cdt src_slot));\n    do_extended_op (cap_insert_ext src_parent src_slot dest_slot src_p dest_p);\n    set_original dest_slot dest_original\n  od\"\n\n\ndefinition\n  has_cancel_send_rights :: \"cap \\<Rightarrow> bool\" where\n  \"has_cancel_send_rights cap \\<equiv> case cap of\n   EndpointCap _ _ R \\<Rightarrow> R = all_rights\n   | _ \\<Rightarrow> False\"", "property": "Capability Insertion and Movement: Insert a new capability into the CSpace as either a sibling or child of an existing capability, determined by the function `should_be_parent_of`. The operation ensures that the destination slot is empty, updates the capability tables, and sets the originality status of the new capability.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "Insert a new capability as either a sibling or child of an\nexisting capability. The function @{const should_be_parent_of}\ndetermines which it will be.\n\nThe term for @{text dest_original} determines if the new capability\nshould be counted as the original capability to the object. This test\nis usually false, apart from the exceptions listed (newly badged\nendpoint capabilities, irq handlers, and untyped caps).\n"}
{"spec": "definition\n  tcb_registers_caps_merge :: \"tcb \\<Rightarrow> tcb \\<Rightarrow> tcb\"\nwhere\n \"tcb_registers_caps_merge regtcb captcb \\<equiv>\n  regtcb \\<lparr> tcb_ctable := tcb_ctable captcb,\n           tcb_vtable := tcb_vtable captcb,\n           tcb_reply := tcb_reply captcb,\n           tcb_caller := tcb_caller captcb,\n           tcb_ipcframe := tcb_ipcframe captcb \\<rparr>\"", "property": "TCB Registers and Capabilities Merge: Overwrite the capabilities stored in a TCB (such as ctable, vtable, reply, caller, and ipcframe) with those from another TCB while preserving the register set and other fields.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Inserting and moving capabilities", "comment": "Overwrite the capabilities stored in a TCB while preserving the register\nset and other fields."}
{"spec": "text \\<open>The CNode capability confers authority to various methods\nwhich act on CNodes and the capabilities within them. Copies of\ncapabilities may be inserted in empty CNode slots by\nInsert. Capabilities may be moved to empty slots with Move or swapped\nwith others in a three way rotate by Rotate. A Reply capability stored\nin a thread's last-caller slot may be saved into a regular CNode slot\nwith Save.  The Revoke, Delete and Recycle methods may also be\ninvoked on the capabilities stored in the CNode.\\<close>\n\ndefinition\n  invoke_cnode :: \"cnode_invocation \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"invoke_cnode i \\<equiv> case i of\n    RevokeCall dest_slot \\<Rightarrow> cap_revoke dest_slot\n  | DeleteCall dest_slot \\<Rightarrow> cap_delete dest_slot\n  | InsertCall cap src_slot dest_slot \\<Rightarrow>\n       without_preemption $ cap_insert cap src_slot dest_slot\n  | MoveCall cap src_slot dest_slot \\<Rightarrow>\n       without_preemption $ cap_move cap src_slot dest_slot\n  | RotateCall cap1 cap2 slot1 slot2 slot3 \\<Rightarrow>\n       without_preemption $\n       if slot1 = slot3 then\n         cap_swap cap1 slot1 cap2 slot2\n       else\n         do cap_move cap2 slot2 slot3; cap_move cap1 slot1 slot2 od\n  | SaveCall slot \\<Rightarrow> without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    src_slot \\<leftarrow> return (thread, tcb_cnode_index 3);\n    cap \\<leftarrow> get_cap src_slot;\n    (case cap of\n          NullCap \\<Rightarrow> return ()\n        | ReplyCap _ False _ \\<Rightarrow> cap_move cap src_slot slot\n        | _ \\<Rightarrow> fail) od\n  | CancelBadgedSendsCall (EndpointCap ep b R) \\<Rightarrow>\n    without_preemption $ when (b \\<noteq> 0) $ cancel_badged_sends ep b\n  | CancelBadgedSendsCall _ \\<Rightarrow> fail\"", "property": "CNode Capability Operations: Authorize various operations on capabilities within CNodes, including inserting, moving, rotating, saving, revoking, deleting, and recycling capabilities. These operations ensure the proper management and manipulation of capabilities, maintaining the integrity and security of the capability space.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Invoking CNode capabilities", "comment": ""}
{"spec": "datatype capclass =\n  PhysicalClass | ReplyClass \"obj_ref\" | IRQClass | ASIDMasterClass | NullClass | DomainClass | IOPortClass\n\nend", "property": "Cap Classification: Defines different classes of capabilities, including physical, reply, IRQ, ASID master, null, domain, and I/O port, to establish invariants and ensure the correct handling and management of capabilities within the system.", "title": "./spec/abstract/CSpace_A.thy", "chapter": "CSpace", "section": "Cap classification used to define invariants", "comment": ""}
{"spec": "definition\n  get_object :: \"obj_ref \\<Rightarrow> (kernel_object,'z::state_ext) s_monad\"\nwhere\n  \"get_object ptr \\<equiv> do\n     kh \\<leftarrow> gets kheap;\n     assert (kh ptr \\<noteq> None);\n     return $ the $ kh ptr\n   od\"\n\ndefinition\n  set_object :: \"obj_ref \\<Rightarrow> kernel_object \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_object ptr obj \\<equiv> do\n     kobj <- get_object ptr;\n     assert (a_type kobj = a_type obj);\n     s \\<leftarrow> get;\n     put (s\\<lparr>kheap := (kheap s)(ptr \\<mapsto> obj)\\<rparr>)\n   od\"", "property": "Kernel Object Management: Access and modify kernel objects in the kernel heap. Ensure that the object being set has the same type as the existing object at the specified reference, maintaining the integrity and consistency of the kernel's data structures.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "TCBs", "comment": ""}
{"spec": "definition\n  get_tcb :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> tcb option\"\nwhere\n  \"get_tcb tcb_ref state \\<equiv>\n   case kheap state tcb_ref of\n      None      \\<Rightarrow> None\n    | Some kobj \\<Rightarrow> (case kobj of\n        TCB tcb \\<Rightarrow> Some tcb\n      | _       \\<Rightarrow> None)\"\n\ndefinition\n  thread_get :: \"(tcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"thread_get f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     return $ f tcb\n   od\"\n\ndefinition\n  thread_set :: \"(tcb \\<Rightarrow> tcb) \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"thread_set f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     set_object tptr $ TCB $ f tcb\n   od\"\n\ndefinition\n  arch_thread_get :: \"(arch_tcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"arch_thread_get f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     return $ f (tcb_arch tcb)\n   od\"\n\ndefinition\n  arch_thread_set :: \"(arch_tcb \\<Rightarrow> arch_tcb) \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"arch_thread_set f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb tptr;\n     set_object tptr $ TCB $ tcb \\<lparr> tcb_arch := f (tcb_arch tcb) \\<rparr>\n   od\"\n\ndefinition\n  get_thread_state :: \"obj_ref \\<Rightarrow> (thread_state,'z::state_ext) s_monad\"\nwhere\n  \"get_thread_state ref \\<equiv> thread_get tcb_state ref\"\n\ndefinition\n  get_bound_notification :: \"obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\"\nwhere\n  \"get_bound_notification ref \\<equiv> thread_get tcb_bound_notification ref\"\n\ndefinition\n  set_bound_notification :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"set_bound_notification ref ntfn \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb ref;\n     set_object ref (TCB (tcb \\<lparr> tcb_bound_notification := ntfn \\<rparr>))\n   od\"\n\ndefinition set_thread_state_ext :: \"obj_ref \\<Rightarrow> unit det_ext_monad\" where\n  \"set_thread_state_ext t \\<equiv> do\n     ts \\<leftarrow> get_thread_state t;\n     cur \\<leftarrow> gets cur_thread;\n     action \\<leftarrow> gets scheduler_action;\n     when (\\<not> (runnable ts) \\<and> cur = t \\<and> action = resume_cur_thread) (set_scheduler_action choose_new_thread)\n   od\"\n\ndefinition\n  set_thread_state :: \"obj_ref \\<Rightarrow> thread_state \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_thread_state ref ts \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_tcb ref;\n     set_object ref (TCB (tcb \\<lparr> tcb_state := ts \\<rparr>));\n     do_extended_op (set_thread_state_ext ref)\n   od\"\n\ndefinition\n  set_priority :: \"obj_ref \\<Rightarrow> priority \\<Rightarrow> unit det_ext_monad\" where\n  \"set_priority tptr prio \\<equiv> do\n     tcb_sched_action tcb_sched_dequeue tptr;\n     thread_set_priority tptr prio;\n     ts \\<leftarrow> get_thread_state tptr;\n     when (runnable ts) $ do\n       cur \\<leftarrow> gets cur_thread;\n       if tptr = cur then reschedule_required else possible_switch_to tptr\n     od\n   od\"\n\ndefinition\n  set_mcpriority :: \"obj_ref \\<Rightarrow> priority \\<Rightarrow> (unit, 'z::state_ext) s_monad\"  where\n  \"set_mcpriority ref mcp \\<equiv> thread_set (\\<lambda>tcb. tcb\\<lparr>tcb_mcpriority:=mcp\\<rparr>) ref \"", "property": "Thread Control Block (TCB) Management: Provides mechanisms to access, retrieve, and modify TCBs and their associated fields, including thread state, bound notifications, and priorities. These operations ensure that the kernel can effectively manage and update thread properties, maintaining the integrity and performance of the system.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "TCBs", "comment": ""}
{"spec": "(* to be used for abstraction unifying kernel objects other than TCB and CNode *)\n\ndefinition\n  partial_inv :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('b \\<Rightarrow> 'a option)\"\nwhere\n  \"partial_inv f x = (if \\<exists>!y. f y = x then Some (THE y. f y = x) else None)\"\n\nlemma proj_inj: \"inj f \\<Longrightarrow> (partial_inv f ko = Some v) = (f v = ko)\"\n  by (auto simp: partial_inv_def the_equality injD)\n\nlemma inj_Endpoint: \"inj Endpoint\" by (auto intro: injI)\nlemma inj_Notification: \"inj Notification\"  by (auto intro: injI)\n\nlemmas proj_inj_ep[simp] = proj_inj[OF inj_Endpoint]\nlemma proj_ko_type_ep[simp]: \"(\\<exists>v. partial_inv Endpoint  ko = Some (v::endpoint)) = (a_type ko = AEndpoint)\"\n  by (cases ko; auto simp: partial_inv_def a_type_def)\n\nlemmas proj_inj_ntfn[simp] = proj_inj[OF inj_Notification]\nlemma proj_ko_type_ntfn[simp]:\n  \"(\\<exists>v. partial_inv Notification  ko = Some (v::notification)) = (a_type ko = ANTFN)\"\n  by (cases ko; auto simp: partial_inv_def a_type_def)\n\n\nabbreviation\n  \"is_simple_type \\<equiv> (\\<lambda>ob. a_type ob \\<in> {AEndpoint, ANTFN})\"\n\n\ndefinition\n  get_simple_ko :: \"('a \\<Rightarrow> kernel_object) \\<Rightarrow> obj_ref \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"get_simple_ko f ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     assert (is_simple_type kobj);\n     (case partial_inv f kobj of Some e \\<Rightarrow> return e | _ \\<Rightarrow> fail)\n   od\"\n\n\ndefinition\n  set_simple_ko :: \"('a \\<Rightarrow> kernel_object) \\<Rightarrow> obj_ref \\<Rightarrow> 'a \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_simple_ko f ptr ep \\<equiv> do\n     obj \\<leftarrow> get_object ptr;\n     assert (is_simple_type obj);\n     assert (partial_inv f obj \\<noteq> None);\n     set_object ptr (f ep)\n   od\"", "property": "Kernel Object Management: Manage simple kernel objects (such as endpoints and notifications) by retrieving and setting their values. Ensure that the object type is valid and use a partial inverse function to safely convert between the kernel object and its specific type.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "simple kernel objects", "comment": ""}
{"spec": "abbreviation\n  get_endpoint :: \"obj_ref \\<Rightarrow> (endpoint,'z::state_ext) s_monad\" where\n  \"get_endpoint \\<equiv> get_simple_ko Endpoint\"\n\nabbreviation\n  set_endpoint :: \"obj_ref \\<Rightarrow> endpoint \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_endpoint \\<equiv> set_simple_ko Endpoint\"\n\nabbreviation\n  get_notification :: \"obj_ref \\<Rightarrow> (notification,'z::state_ext) s_monad\" where\n  \"get_notification \\<equiv> get_simple_ko Notification\"\n\nabbreviation\n  set_notification :: \"obj_ref \\<Rightarrow> notification \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_notification \\<equiv> set_simple_ko Notification\"\n\nabbreviation\n  ntfn_set_bound_tcb :: \"notification \\<Rightarrow> obj_ref option \\<Rightarrow> notification\" where\n  \"ntfn_set_bound_tcb ntfn t \\<equiv> ntfn \\<lparr> ntfn_bound_tcb := t \\<rparr>\"\n\nabbreviation\n  ntfn_set_obj :: \"notification \\<Rightarrow> ntfn \\<Rightarrow> notification\" where\n  \"ntfn_set_obj ntfn a \\<equiv> ntfn \\<lparr> ntfn_obj := a \\<rparr>\"", "property": "Endpoint and Notification Management: Provides operations to get and set the state of endpoints and notifications, allowing for the management of their bound threads and associated objects. This ensures that the kernel can effectively handle synchronous and asynchronous communication and signaling between threads.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "Synchronous and Asyncronous Endpoints", "comment": ""}
{"spec": "definition\n  get_irq_state :: \"irq \\<Rightarrow> (irq_state,'z::state_ext) s_monad\" where\n \"get_irq_state irq \\<equiv> gets (\\<lambda>s. interrupt_states s irq)\"\n\ndefinition\n  set_irq_state :: \"irq_state \\<Rightarrow> irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"set_irq_state state irq \\<equiv> do\n    modify (\\<lambda>s. s \\<lparr> interrupt_states := (interrupt_states s) (irq := state)\\<rparr>);\n    do_machine_op $ maskInterrupt (state = IRQInactive) irq\n  od\"\n\ndefinition\n  get_irq_slot :: \"irq \\<Rightarrow> (cslot_ptr,'z::state_ext) s_monad\" where\n \"get_irq_slot irq \\<equiv> gets (\\<lambda>st. (interrupt_irq_node st irq, []))\"", "property": "IRQ State and Slot Management: Access and modify the state of an IRQ, and retrieve the slot associated with an IRQ. Ensures that the IRQ state is updated in the system state and the corresponding interrupt is masked or unmasked based on the new state.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "IRQ State and Slot", "comment": ""}
{"spec": "definition\n  is_irq_active :: \"irq \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n \"is_irq_active irq \\<equiv> liftM (\\<lambda>st. st \\<noteq> IRQInactive) $ get_irq_state irq\"", "property": "IRQ State Check: Determines if a specified IRQ identifier is currently active by checking its state and ensuring it is not marked as inactive.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "IRQ State and Slot", "comment": "Tests whether an IRQ identifier is in use."}
{"spec": "text \\<open>\n  Changes user context of specified thread by running\n  specified user monad.\n\\<close>\ndefinition\n  as_user :: \"obj_ref \\<Rightarrow> 'a user_monad \\<Rightarrow> ('a,'z::state_ext) s_monad\"\nwhere\n  \"as_user tptr f \\<equiv> do\n    tcb \\<leftarrow> gets_the $ get_tcb tptr;\n    uc \\<leftarrow> return $ arch_tcb_context_get (tcb_arch tcb);\n    (a, uc') \\<leftarrow> select_f $ f uc;\n    new_tcb \\<leftarrow> return $ tcb \\<lparr> tcb_arch := arch_tcb_context_set uc' (tcb_arch tcb)\\<rparr>;\n    set_object tptr (TCB new_tcb);\n    return a\n  od\"", "property": "Change User Context: Allows the execution of a specified user monad in the context of a given thread, updating the thread's architectural context and ensuring that the changes are reflected in the system state.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "User Context", "comment": ""}
{"spec": "definition\nthrow_on_false :: \"'e \\<Rightarrow> (bool,'z::state_ext) s_monad \\<Rightarrow> ('e + unit,'z::state_ext) s_monad\" where\n\"throw_on_false ex f \\<equiv> doE v \\<leftarrow> liftE f; unlessE v $ throwError ex odE\"\n\nend", "property": "Raise Exception on Condition Failure: Throws an exception if a given condition does not hold, ensuring that the system maintains its integrity and handles errors appropriately.", "title": "./spec/abstract/KHeap_A.thy", "chapter": "Accessing the Kernel Heap", "section": "User Context", "comment": "Raise an exception if a property does not hold."}
{"spec": "datatype lookup_failure\n     = InvalidRoot\n     | MissingCapability nat\n     | DepthMismatch nat nat\n     | GuardMismatch nat \"bool list\"\n\ndatatype fault\n         = CapFault obj_ref bool lookup_failure\n         | UnknownSyscallException data\n         | UserException data data\n         | ArchFault arch_fault\n\ndatatype syscall_error\n         = InvalidArgument nat\n         | InvalidCapability nat\n         | IllegalOperation\n         | RangeError data data\n         | AlignmentError\n         | FailedLookup bool lookup_failure\n         | TruncatedMessage\n         | DeleteFirst\n         | RevokeFirst\n         | NotEnoughMemory data", "property": "Exception Handling: The system distinguishes between faults and errors, where faults are reported to the user's fault handler and errors are reported directly to the user. Capability lookup failures can be classified as either a fault or an error based on the context, ensuring that the appropriate response is triggered for different types of issues.", "title": "./spec/abstract/ExceptionTypes_A.thy", "chapter": "", "section": "", "comment": "\n  There are two types of exceptions that can occur in the kernel:\n  faults and errors. Faults are reported to the user's fault handler.\n  Errors are reported to the user directly.\n\n  Capability lookup failures can be be either fault or error,\n  depending on context.\n"}
{"spec": "primrec\n  msg_from_lookup_failure :: \"lookup_failure \\<Rightarrow> data list\"\nwhere\n  \"msg_from_lookup_failure InvalidRoot           = [1]\"\n| \"msg_from_lookup_failure (MissingCapability n) = [2, of_nat n]\"\n| \"msg_from_lookup_failure (DepthMismatch n m)   = [3, of_nat n, of_nat m]\"\n| \"msg_from_lookup_failure (GuardMismatch n g)   = [4, of_nat n, of_bl g, of_nat (size g)]\"\n\nprimrec\n  msg_from_syscall_error :: \"syscall_error \\<Rightarrow> (data \\<times> data list)\"\nwhere\n  \"msg_from_syscall_error (InvalidArgument n)    = (1, [of_nat n])\"\n| \"msg_from_syscall_error (InvalidCapability n)  = (2, [of_nat n])\"\n| \"msg_from_syscall_error IllegalOperation       = (3, [])\"\n| \"msg_from_syscall_error (RangeError minv maxv) = (4, [minv, maxv])\"\n| \"msg_from_syscall_error AlignmentError         = (5, [])\"\n| \"msg_from_syscall_error (FailedLookup s lf)    = (6, [if s then 1 else 0]@(msg_from_lookup_failure lf))\"\n| \"msg_from_syscall_error TruncatedMessage       = (7, [])\"\n| \"msg_from_syscall_error DeleteFirst            = (8, [])\"\n| \"msg_from_syscall_error RevokeFirst            = (9, [])\"\n| \"msg_from_syscall_error (NotEnoughMemory n)    = (10, [n])\"\n\nend", "property": "System Call Error Messaging: Generate a message from a system call error, encoding the type of error and any associated data into a structured format. This allows for clear and consistent communication of failure conditions back to the thread attempting the operation.", "title": "./spec/abstract/ExceptionTypes_A.thy", "chapter": "", "section": "", "comment": "Create a message from a system-call failure to be returned to the\nthread attempting the operation that failed."}
{"spec": "definition trans_state :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a state \\<Rightarrow> 'b state\" where\n\"trans_state t s = \\<lparr>kheap = kheap s, cdt = cdt s, is_original_cap = is_original_cap s,\n                     cur_thread = cur_thread s, idle_thread = idle_thread s,\n                     machine_state = machine_state s,\n                     interrupt_irq_node = interrupt_irq_node s,\n                     interrupt_states = interrupt_states s, arch_state = arch_state s,\n                     exst = t(exst s)\\<rparr>\"", "property": "State Transformation: Transforms a state of type `'a state` to a state of type `'b state` by applying a function `t` to the `exst` field, while preserving all other fields of the state.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "", "comment": "Translate a state of type @{typ \"'a state\"} to one of type @{typ \"'b state\"}\n  via a function @{term t} from @{typ \"'a\"} to @{typ \"'b\"}.\n"}
{"spec": "lemma trans_state[simp]: \"kheap (trans_state t s) = kheap s\"\n                            \"cdt (trans_state t s) = cdt s\"\n                            \"is_original_cap (trans_state t s) = is_original_cap s\"\n                            \"cur_thread (trans_state t s) = cur_thread s\"\n                            \"idle_thread (trans_state t s) = idle_thread s\"\n                            \"machine_state (trans_state t s) = machine_state s\"\n                            \"interrupt_irq_node (trans_state t s) = interrupt_irq_node s\"\n                           \"interrupt_states (trans_state t s) = interrupt_states s\"\n                            \"arch_state (trans_state t s) = arch_state s\"\n                            \"exst (trans_state t s) = (t (exst s))\"\n                            \"exst (trans_state (\\<lambda>_. e) s) = e\"\n  apply (simp add: trans_state_def)+\n  done\n\nlemma trans_state_update[simp]:\n \"trans_state t (kheap_update f s) = kheap_update f (trans_state t s)\"\n \"trans_state t (cdt_update g s) = cdt_update g (trans_state t s)\"\n \"trans_state t (is_original_cap_update h s) = is_original_cap_update h (trans_state t s)\"\n \"trans_state t (cur_thread_update i s) = cur_thread_update i (trans_state t s)\"\n \"trans_state t (idle_thread_update j s) = idle_thread_update j (trans_state t s)\"\n \"trans_state t (machine_state_update k s) = machine_state_update k (trans_state t s)\"\n \"trans_state t (interrupt_irq_node_update l s) = interrupt_irq_node_update l (trans_state t s)\"\n \"trans_state t (arch_state_update m s) = arch_state_update m (trans_state t s)\"\n \"trans_state t (interrupt_states_update p s) = interrupt_states_update p (trans_state t s)\"\n  apply (simp add: trans_state_def)+\n  done\n\n\nlemma trans_state_update':\n  \"trans_state f = exst_update f\"\n  apply (rule ext)\n  apply simp\n  done\n\nlemma trans_state_update''[simp]:\n  \"trans_state t' (trans_state t s) = trans_state (\\<lambda>e. t' (t e)) s\"\n  apply simp\n  done", "property": "State Transformation: The `trans_state` function updates the extended state (`exst`) of the system while preserving other state components such as `kheap`, `cdt`, `is_original_cap`, `cur_thread`, `idle_thread`, `machine_state`, `interrupt_irq_node`, `interrupt_states`, and `arch_state`. This ensures that the transformation is isolated to the extended state, maintaining the integrity of the rest of the system's state.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "", "comment": "<"}
{"spec": "abbreviation \"truncate_state \\<equiv> trans_state (\\<lambda>_. ())\"", "property": "Truncate State: Remove all extended state information, effectively discarding the additional data and retaining only the base state.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "", "comment": "Truncate an extended state of type @{typ \"'a state\"}\n  by effectively throwing away all the @{typ \"'a\"} information.\n"}
{"spec": "text \\<open>\\label{s:det-spec}\n  The deterministic abstract specification tracks the state of the scheduler\nand ordering information about sibling nodes in the CDT.\\<close>", "property": "Deterministic Abstract Specification: Tracks the state of the scheduler and maintains ordering information about sibling nodes in the CDT, ensuring predictable and consistent behavior.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": ""}
{"spec": "datatype scheduler_action =\n    resume_cur_thread\n  | switch_thread (sch_act_target : obj_ref)\n  | choose_new_thread\n\ntype_synonym domain = word8\n\nrecord etcb =\n tcb_priority :: \"priority\"\n tcb_time_slice :: \"nat\"\n tcb_domain :: \"domain\"\n\ndefinition default_priority :: \"priority\" where\n  \"default_priority \\<equiv> minBound\"\n\ndefinition default_domain :: \"domain\" where\n  \"default_domain \\<equiv> minBound\"\n\ndefinition default_etcb :: \"etcb\" where\n  \"default_etcb \\<equiv> \\<lparr>tcb_priority = default_priority, tcb_time_slice = timeSlice, tcb_domain = default_domain\\<rparr>\"\n\ntype_synonym ready_queue = \"obj_ref list\"", "property": "Scheduler Actions: Define the possible actions that the scheduler can take, including resuming the current thread, switching to a specified thread, or choosing a new thread. These actions are part of the scheduling state and determine the next thread to be executed.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "The current scheduler action,\n  which is part of the scheduling state."}
{"spec": "type_synonym cdt_list = \"cslot_ptr \\<Rightarrow> cslot_ptr list\"\n\ndefinition work_units_limit :: \"machine_word\" where\n  \"work_units_limit = 0x64\"", "property": "Ordered Child List in CDT: Each entry in the CDT maintains an ordered list of its children, encoding the order of sibling nodes.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  For each entry in the CDT, we record an ordered list of its children.\n  This encodes the order of sibling nodes in the CDT.\n"}
{"spec": "record det_ext =\n   work_units_completed_internal :: \"machine_word\"\n   scheduler_action_internal :: scheduler_action\n   ekheap_internal :: \"obj_ref \\<Rightarrow> etcb option\"\n   domain_list_internal :: \"(domain \\<times> machine_word) list\"\n   domain_index_internal :: nat\n   cur_domain_internal :: domain\n   domain_time_internal :: \"machine_word\"\n   ready_queues_internal :: \"domain \\<Rightarrow> priority \\<Rightarrow> ready_queue\"\n   cdt_list_internal :: cdt_list", "property": "Extended State Management: Maintains a detailed state including work units completed, scheduler actions, extended kernel heap, domain lists, current domain, domain time, and ready queues. This comprehensive state tracking supports the deterministic behavior and scheduling of the system.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  The extended state of the deterministic abstract specification.\n"}
{"spec": "type_synonym det_state = \"det_ext state\"", "property": "Nondeterministic Abstract State Extension: The state of the nondeterministic abstract specification includes an extension with the `det_ext` record, enriching the abstract state to support deterministic behavior.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  The state of the deterministic abstract specification extends the\n  abstract state with the @{typ det_ext} record.\n"}
{"spec": "abbreviation\n  \"work_units_completed (s::det_state) \\<equiv> work_units_completed_internal (exst s)\"\n\nabbreviation\n  \"work_units_completed_update f (s::det_state) \\<equiv>  trans_state (work_units_completed_internal_update f) s\"\n\nabbreviation\n  \"scheduler_action (s::det_state) \\<equiv> scheduler_action_internal (exst s)\"\n\nabbreviation\n  \"scheduler_action_update f (s::det_state) \\<equiv>  trans_state (scheduler_action_internal_update f) s\"\n\nabbreviation\n  \"ekheap (s::det_state) \\<equiv> ekheap_internal (exst s)\"\n\nabbreviation\n  \"ekheap_update f (s::det_state) \\<equiv> trans_state (ekheap_internal_update f) s\"\n\nabbreviation\n  \"domain_list (s::det_state) \\<equiv> domain_list_internal (exst s)\"\n\nabbreviation\n  \"domain_list_update f (s::det_state) \\<equiv> trans_state (domain_list_internal_update f) s\"\n\nabbreviation\n  \"domain_index (s::det_state) \\<equiv> domain_index_internal (exst s)\"\n\nabbreviation\n  \"domain_index_update f (s::det_state) \\<equiv> trans_state (domain_index_internal_update f) s\"\n\nabbreviation\n  \"cur_domain (s::det_state) \\<equiv> cur_domain_internal (exst s)\"\n\nabbreviation\n  \"cur_domain_update f (s::det_state) \\<equiv> trans_state (cur_domain_internal_update f) s\"\n\nabbreviation\n  \"domain_time (s::det_state) \\<equiv> domain_time_internal (exst s)\"\n\nabbreviation\n  \"domain_time_update f (s::det_state) \\<equiv> trans_state (domain_time_internal_update f) s\"\n\nabbreviation\n  \"ready_queues (s::det_state) \\<equiv> ready_queues_internal (exst s)\"\n\nabbreviation\n  \"ready_queues_update f (s::det_state) \\<equiv> trans_state (ready_queues_internal_update f) s\"\n\nabbreviation\n  \"cdt_list (s::det_state) \\<equiv> cdt_list_internal (exst s)\"\n\nabbreviation\n  \"cdt_list_update f (s::det_state) \\<equiv> trans_state (cdt_list_internal_update f) s\"\n\ntype_synonym 'a det_ext_monad = \"(det_state,'a) nondet_monad\"", "property": "State Access and Update: Provides accessor and update functions for various components of the deterministic abstract state, including work units completed, scheduler actions, extended kernel heap, domain lists, domain indices, current domain, domain time, ready queues, and CDT lists. These functions enable the manipulation and retrieval of state information in a consistent and controlled manner.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "Accessor and update functions for the extended state of the\n  deterministic abstract specification.\n"}
{"spec": "definition\n  get_etcb :: \"obj_ref \\<Rightarrow> det_state \\<Rightarrow> etcb option\"\nwhere\n  \"get_etcb tcb_ref es \\<equiv> ekheap es tcb_ref\"\n\ndefinition\n  ethread_get :: \"(etcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> 'a det_ext_monad\"\nwhere\n  \"ethread_get f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_etcb tptr;\n     return $ f tcb\n   od\"", "property": "Retrieve ETCB Information: Obtain and return a specific attribute of an extended thread control block (ETCB) by applying a given function to the ETCB.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  Basic monadic functions for operating on the extended state of the\n  deterministic abstract specification.\n"}
{"spec": "definition\n  ethread_get_when :: \"bool \\<Rightarrow> (etcb \\<Rightarrow> 'a) \\<Rightarrow> obj_ref \\<Rightarrow> 'a det_ext_monad\"\nwhere\n  \"ethread_get_when b f tptr \\<equiv> if b then (ethread_get f tptr) else return undefined\"\n\ndefinition set_eobject :: \"obj_ref \\<Rightarrow> etcb \\<Rightarrow> unit det_ext_monad\"\n  where\n \"set_eobject ptr obj \\<equiv>\n  do es \\<leftarrow> get;\n    ekh \\<leftarrow> return $ (ekheap es)(ptr \\<mapsto> obj);\n    put (es\\<lparr>ekheap := ekh\\<rparr>)\n  od\"\n\ndefinition\n  ethread_set :: \"(etcb \\<Rightarrow> etcb) \\<Rightarrow> obj_ref \\<Rightarrow> unit det_ext_monad\"\nwhere\n  \"ethread_set f tptr \\<equiv> do\n     tcb \\<leftarrow> gets_the $ get_etcb tptr;\n     set_eobject tptr $ f tcb\n   od\"\n\ndefinition\n  set_scheduler_action :: \"scheduler_action \\<Rightarrow> unit det_ext_monad\" where\n  \"set_scheduler_action action \\<equiv>\n     modify (\\<lambda>es. es\\<lparr>scheduler_action := action\\<rparr>)\"\n\ndefinition\n  thread_set_priority :: \"obj_ref \\<Rightarrow> priority \\<Rightarrow> unit det_ext_monad\" where\n  \"thread_set_priority tptr prio \\<equiv> ethread_set (\\<lambda>tcb. tcb\\<lparr>tcb_priority := prio\\<rparr>) tptr\"\n\ndefinition\n  thread_set_time_slice :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> unit det_ext_monad\" where\n  \"thread_set_time_slice tptr time \\<equiv> ethread_set (\\<lambda>tcb. tcb\\<lparr>tcb_time_slice := time\\<rparr>) tptr\"\n\ndefinition\n  thread_set_domain :: \"obj_ref \\<Rightarrow> domain \\<Rightarrow> unit det_ext_monad\" where\n  \"thread_set_domain tptr domain \\<equiv> ethread_set (\\<lambda>tcb. tcb\\<lparr>tcb_domain := domain\\<rparr>) tptr\"\n\n\ndefinition\n  get_tcb_queue :: \"domain \\<Rightarrow> priority \\<Rightarrow> ready_queue det_ext_monad\" where\n  \"get_tcb_queue d prio \\<equiv> do\n     queues \\<leftarrow> gets ready_queues;\n     return (queues d prio)\n   od\"\n\ndefinition\n  set_tcb_queue :: \"domain \\<Rightarrow> priority \\<Rightarrow> ready_queue \\<Rightarrow> unit det_ext_monad\" where\n  \"set_tcb_queue d prio queue \\<equiv>\n     modify (\\<lambda>es. es\\<lparr> ready_queues :=\n      (\\<lambda>d' p. if d' = d \\<and> p = prio then queue else ready_queues es d' p)\\<rparr>)\"\n\n\ndefinition\n  tcb_sched_action :: \"(obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list) \\<Rightarrow> obj_ref  \\<Rightarrow> unit det_ext_monad\" where\n  \"tcb_sched_action action thread \\<equiv> do\n     d \\<leftarrow> ethread_get tcb_domain thread;\n     prio \\<leftarrow> ethread_get tcb_priority thread;\n     queue \\<leftarrow> get_tcb_queue d prio;\n     set_tcb_queue d prio (action thread queue)\n   od\"\n\ndefinition\n  tcb_sched_enqueue :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list\" where\n  \"tcb_sched_enqueue thread queue \\<equiv> if (thread \\<notin> set queue) then thread # queue else queue\"\n\ndefinition\n  tcb_sched_append :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list\" where\n  \"tcb_sched_append thread queue \\<equiv> if (thread \\<notin> set queue) then queue @ [thread] else queue\"\n\ndefinition\n  tcb_sched_dequeue :: \"obj_ref \\<Rightarrow> obj_ref list \\<Rightarrow> obj_ref list\" where\n  \"tcb_sched_dequeue thread queue \\<equiv> filter (\\<lambda>x. x \\<noteq> thread) queue\"\n\n\ndefinition reschedule_required :: \"unit det_ext_monad\" where\n  \"reschedule_required \\<equiv> do\n     action \\<leftarrow> gets scheduler_action;\n     case action of switch_thread t \\<Rightarrow> tcb_sched_action (tcb_sched_enqueue) t | _ \\<Rightarrow> return ();\n     set_scheduler_action choose_new_thread\n   od\"\n\ndefinition\n  possible_switch_to :: \"obj_ref \\<Rightarrow> unit det_ext_monad\" where\n  \"possible_switch_to target \\<equiv> do\n     cur_dom \\<leftarrow> gets cur_domain;\n     target_dom \\<leftarrow> ethread_get tcb_domain target;\n     action \\<leftarrow> gets scheduler_action;\n\n     if (target_dom \\<noteq> cur_dom) then\n       tcb_sched_action tcb_sched_enqueue target\n     else if (action \\<noteq> resume_cur_thread) then\n       do\n         reschedule_required;\n         tcb_sched_action tcb_sched_enqueue target\n       od\n     else\n       set_scheduler_action $ switch_thread target\n   od\"\n\ndefinition\n  next_domain :: \"unit det_ext_monad\" where\n  \"next_domain \\<equiv>\n    modify (\\<lambda>s.\n      let domain_index' = (domain_index s + 1) mod length (domain_list s) in\n      let next_dom = (domain_list s)!domain_index'\n      in s\\<lparr> domain_index := domain_index',\n            cur_domain := fst next_dom,\n            domain_time := snd next_dom,\n            work_units_completed := 0\\<rparr>)\"\n\ndefinition\n  dec_domain_time :: \"unit det_ext_monad\" where\n  \"dec_domain_time = modify (\\<lambda>s. s\\<lparr>domain_time := domain_time s - 1\\<rparr>)\"\n\ndefinition set_cdt_list :: \"cdt_list \\<Rightarrow> (det_state, unit) nondet_monad\" where\n  \"set_cdt_list t \\<equiv> do\n    s \\<leftarrow> get;\n    put $ s\\<lparr> cdt_list := t \\<rparr>\n  od\"\n\ndefinition\n  update_cdt_list :: \"(cdt_list \\<Rightarrow> cdt_list) \\<Rightarrow> (det_state, unit) nondet_monad\"\nwhere\n  \"update_cdt_list f \\<equiv> do\n     t \\<leftarrow> gets cdt_list;\n     set_cdt_list (f t)\n  od\"", "property": "Nondeterministic Scheduling and Thread Management: The system provides mechanisms for managing thread priorities, domains, and scheduling actions, including enqueuing, dequeuing, and appending threads to ready queues. It also includes functions to set and get the current domain, decrement the domain time, and manage the control dependency tree (CDT) list. These operations ensure that threads are scheduled and managed correctly, while also allowing for nondeterministic updates to the CDT list.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": " For infoflow, we want to avoid certain read actions, such as reading the priority of the\n   current thread when it could be idle. Then we need to make sure we do not rely on the result.\n   undefined is the closest we have to a result that can't be relied on "}
{"spec": "definition next_child :: \"cslot_ptr \\<Rightarrow> cdt_list \\<Rightarrow> cslot_ptr option\" where\n  \"next_child slot t \\<equiv> case (t slot) of [] \\<Rightarrow> None |\n                                        x # xs \\<Rightarrow> Some x\"\n\ndefinition next_sib :: \"cslot_ptr \\<Rightarrow> cdt_list \\<Rightarrow> cdt \\<Rightarrow> cslot_ptr option\" where\n  \"next_sib slot t m \\<equiv> case m slot of None \\<Rightarrow> None |\n                       Some p \\<Rightarrow> after_in_list (t p) slot\"\n\n\nfunction (domintros) next_not_child :: \"cslot_ptr \\<Rightarrow> cdt_list \\<Rightarrow> cdt \\<Rightarrow> cslot_ptr option\" where\n  \"next_not_child slot t m = (if next_sib slot t m = None\n                             then (case m slot of\n                               None \\<Rightarrow> None |\n                               Some p \\<Rightarrow> next_not_child p t m)\n                             else next_sib slot t m)\"\n  by auto", "property": "Traversal of CDT Structure: Traverse the Capability Delegation Table (CDT) to find the next child, sibling, or non-child slot in prefix traversal order. This ensures that the structure can be navigated systematically, allowing for efficient and ordered access to the slots.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "The CDT in the implementation is stored in prefix traversal order.\n  The following functions traverse its abstract representation here to\n  yield corresponding information.\n"}
{"spec": "definition next_slot :: \"cslot_ptr \\<Rightarrow> cdt_list \\<Rightarrow> cdt \\<Rightarrow> cslot_ptr option\" where\n  \"next_slot slot t m \\<equiv> if t slot \\<noteq> []\n                        then next_child slot t\n                        else next_not_child slot t m\"", "property": "Traversal of CDT Slots: The function `next_slot` traverses the capability domain tree (CDT) to find the next slot. It first checks if the current slot has children; if so, it traverses to the first child using `next_child`. If the current slot has no children, it moves up the tree to find a sibling or an ancestor with a new node to visit using `next_not_child`.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": " next_slot traverses the cdt, replicating mdb_next in the Haskell spec.\n        The cdt is traversed child first, by next_child\n        going to a nodes first child when it exists,\n        otherwise next_not_child looks up the tree until it finds\n        a new node to visit as a sibling of its self or some ancestor "}
{"spec": "definition max_non_empty_queue :: \"(priority \\<Rightarrow> ready_queue) \\<Rightarrow> ready_queue\" where\n  \"max_non_empty_queue queues \\<equiv> queues (Max {prio. queues prio \\<noteq> []})\"\n\n\ndefinition default_ext :: \"apiobject_type \\<Rightarrow> domain \\<Rightarrow> etcb option\" where\n  \"default_ext type cdom \\<equiv>\n      case type of TCBObject \\<Rightarrow> Some (default_etcb\\<lparr>tcb_domain := cdom\\<rparr>)\n                         | _ \\<Rightarrow> None\"\n\ndefinition retype_region_ext :: \"obj_ref list \\<Rightarrow> apiobject_type \\<Rightarrow> unit det_ext_monad\" where\n  \"retype_region_ext ptrs type \\<equiv>  do\n                                     ekh \\<leftarrow> gets ekheap;\n                                     cdom \\<leftarrow> gets cur_domain;\n                                     ekh' \\<leftarrow> return $ foldr (\\<lambda>p ekh. (ekh(p := default_ext type cdom))) ptrs ekh;\n                                     modify (\\<lambda>s. s\\<lparr>ekheap := ekh'\\<rparr>)\n                                  od\"\n\ndefinition cap_swap_ext where\n\"cap_swap_ext \\<equiv> (\\<lambda> slot1 slot2 slot1_op slot2_op.\n      do\n       update_cdt_list (\\<lambda>list. list(slot1 := list slot2, slot2 := list slot1));\n       update_cdt_list\n        (\\<lambda>list. case if slot2_op = Some slot1 then Some slot2\n                     else if slot2_op = Some slot2 then Some slot1 else slot2_op of\n                None \\<Rightarrow> (case if slot1_op = Some slot1 then Some slot2\n                            else if slot1_op = Some slot2 then Some slot1 else slot1_op of\n                       None \\<Rightarrow> list\n                       | Some slot2_p \\<Rightarrow> list(slot2_p := list_replace (list slot2_p) slot1 slot2))\n                | Some slot1_p \\<Rightarrow>\n                    (case if slot1_op = Some slot1 then Some slot2\n                         else if slot1_op = Some slot2 then Some slot1 else slot1_op of\n                    None \\<Rightarrow> list(slot1_p := list_replace (list slot1_p) slot2 slot1)\n                    | Some slot2_p \\<Rightarrow>\n                        if slot1_p = slot2_p\n                        then list(slot1_p := list_swap (list slot1_p) slot1 slot2)\n                        else list(slot1_p := list_replace (list slot1_p) slot2 slot1,\n                                  slot2_p := list_replace (list slot2_p) slot1 slot2)))\n    od)\"\n\ndefinition cap_move_ext where\n\"cap_move_ext \\<equiv> (\\<lambda> src_slot dest_slot src_p dest_p.\n do\n\n    update_cdt_list (\\<lambda>list. case (dest_p) of\n      None \\<Rightarrow> list |\n      Some p \\<Rightarrow> list (p := list_remove (list p) dest_slot));\n\n   if (src_slot = dest_slot) then return () else\n\n    (do\n    update_cdt_list (\\<lambda>list. case (src_p) of\n      None \\<Rightarrow> list |\n      Some p \\<Rightarrow> list (p := list_replace (list p) src_slot dest_slot));\n\n    update_cdt_list (\\<lambda>list. list (src_slot := [], dest_slot := (list src_slot) @ (list dest_slot)))\n    od)\n\n  od)\"\n\n\ndefinition cap_insert_ext where\n\"cap_insert_ext \\<equiv> (\\<lambda> src_parent src_slot dest_slot src_p dest_p.\n do\n\n update_cdt_list (\\<lambda>list. case (dest_p) of\n      None \\<Rightarrow> list |\n      Some p \\<Rightarrow> (list (p := list_remove (list p) dest_slot)));\n\n    update_cdt_list (\\<lambda>list. case (src_p) of\n      None \\<Rightarrow> list (\n        src_slot := if src_parent then [dest_slot] @ (list src_slot) else list src_slot) |\n      Some p \\<Rightarrow> list (\n        src_slot := if src_parent then [dest_slot] @ (list src_slot) else list src_slot,\n        p := if (src_parent \\<and> p \\<noteq> src_slot) then (list p) else if (src_slot \\<noteq> dest_slot) then (list_insert_after (list p) src_slot dest_slot) else (dest_slot # (list p))))\n od)\"\n\ndefinition empty_slot_ext where\n\"empty_slot_ext \\<equiv> (\\<lambda> slot slot_p.\n\n    update_cdt_list (\\<lambda>list. case slot_p of None \\<Rightarrow> list (slot := []) |\n      Some p \\<Rightarrow> if (p = slot) then list(p := list_remove (list p) slot) else list (p := list_replace_list (list p) slot (list slot), slot := [])))\"\n\ndefinition create_cap_ext where\n\"create_cap_ext \\<equiv> (\\<lambda> untyped dest dest_p. do\n\n    update_cdt_list (\\<lambda>list. case dest_p of\n      None \\<Rightarrow> list |\n      Some p \\<Rightarrow> (list (p := list_remove (list p) dest)));\n\n    update_cdt_list (\\<lambda>list. list (untyped := [dest] @ (list untyped)))\n  od)\"\n\ndefinition next_revoke_cap where\n\"next_revoke_cap \\<equiv> (\\<lambda>slot ext. the (next_child slot (cdt_list ext)))\"\n\ndefinition\n  free_asid_select :: \"(asid_high_index \\<rightharpoonup> 'a) \\<Rightarrow> asid_high_index\"\nwhere\n  \"free_asid_select \\<equiv> \\<lambda>asid_table. fst (hd (filter (\\<lambda>(x,y). x \\<le> 2 ^ asid_high_bits - 1 \\<and> y = None) (assocs asid_table)))\"\n\ndefinition\n  free_asid_pool_select :: \"(asid_low_index \\<rightharpoonup> 'a) \\<Rightarrow> asid \\<Rightarrow> asid_low_index\"\nwhere\n  \"free_asid_pool_select \\<equiv> (\\<lambda>pool base.\n     fst (hd ((filter (\\<lambda> (x,y). ucast x + base \\<noteq> 0 \\<and> y = None) (assocs pool)))))\"\n\ndefinition update_work_units where\n  \"update_work_units \\<equiv>\n     modify (\\<lambda>s. s\\<lparr>work_units_completed := work_units_completed s + 1\\<rparr>)\"\n\ndefinition reset_work_units where\n  \"reset_work_units \\<equiv>\n     modify (\\<lambda>s. s\\<lparr>work_units_completed := 0\\<rparr>)\"\n\ndefinition work_units_limit_reached where\n  \"work_units_limit_reached \\<equiv> do\n     work_units \\<leftarrow> gets work_units_completed;\n     return (work_units_limit \\<le> work_units)\n   od\"", "property": "Extended Operations for Deterministic Abstract Specification: Manage and manipulate various system components, including ready queues, capabilities, and ASID pools. These operations include selecting the highest priority non-empty queue, re-typing memory regions, swapping and moving capabilities, inserting and creating capabilities, emptying slots, revoking capabilities, selecting free ASIDs, and updating and resetting work units. These operations ensure the system's state is correctly maintained and updated, supporting efficient and secure resource management.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\\emph{Extended operations} for the deterministic abstract specification."}
{"spec": "class state_ext =\n fixes unwrap_ext :: \"'a state \\<Rightarrow> det_ext state\"\n fixes wrap_ext :: \"(det_ext \\<Rightarrow> det_ext) \\<Rightarrow> ('a \\<Rightarrow> 'a)\"\n fixes wrap_ext_op :: \"unit det_ext_monad \\<Rightarrow> ('a state,unit) nondet_monad\"\n fixes wrap_ext_bool :: \"bool det_ext_monad \\<Rightarrow> ('a state,bool) nondet_monad\"\n fixes select_switch :: \"'a \\<Rightarrow> bool\"\n fixes ext_init :: \"'a\"\n\ndefinition detype_ext :: \"obj_ref set \\<Rightarrow> 'z::state_ext \\<Rightarrow> 'z\" where\n \"detype_ext S \\<equiv> wrap_ext (\\<lambda>s. s\\<lparr>ekheap_internal := (\\<lambda>x. if x \\<in> S then None else ekheap_internal s x)\\<rparr>)\"\n\ninstantiation  det_ext_ext :: (type) state_ext\nbegin\n\ndefinition \"unwrap_ext_det_ext_ext == (\\<lambda>x. x) :: det_ext state \\<Rightarrow> det_ext state\"\n\ndefinition \"wrap_ext_det_ext_ext == (\\<lambda>x. x) ::\n  (det_ext \\<Rightarrow> det_ext) \\<Rightarrow> det_ext \\<Rightarrow> det_ext\"\n\ndefinition \"wrap_ext_op_det_ext_ext == (\\<lambda>x. x) ::\n  (det_ext state \\<Rightarrow> ((unit \\<times> det_ext state) set) \\<times> bool)\n  \\<Rightarrow> det_ext state  \\<Rightarrow> ((unit \\<times> det_ext state) set) \\<times> bool\"\n\ndefinition \"wrap_ext_bool_det_ext_ext == (\\<lambda>x. x) ::\n  (det_ext state \\<Rightarrow> ((bool \\<times> det_ext state) set) \\<times> bool)\n  \\<Rightarrow> det_ext state \\<Rightarrow> ((bool \\<times> det_ext state) set) \\<times> bool\"\n\ndefinition \"select_switch_det_ext_ext == (\\<lambda>_. True)  :: det_ext\\<Rightarrow> bool\"", "property": "Abstract State Extension: Provides a framework for extending the state with deterministic and nondeterministic behaviors. It includes operations to unwrap and wrap the extended state, handle monadic operations, and select switch conditions, enabling flexible and modular state management.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  A type class for all instantiations of the abstract specification. In\n  practice, this is restricted to basically allow only two sensible\n  implementations at present: the deterministic abstract specification and\n  the nondeterministic one.\n"}
{"spec": "definition \"ext_init_det_ext_ext \\<equiv>\n     \\<lparr>work_units_completed_internal = 0,\n      scheduler_action_internal = resume_cur_thread,\n      ekheap_internal = Map.empty (idle_thread_ptr \\<mapsto> default_etcb),\n      domain_list_internal = [(0,15)],\n      domain_index_internal = 0,\n      cur_domain_internal = 0,\n      domain_time_internal = 15,\n      ready_queues_internal = const (const []),\n      cdt_list_internal = const []\\<rparr> :: det_ext\"\n\ninstance ..\n\nend", "property": "Initialization of Deterministic Extension: The deterministic extension is initialized with default values, including an empty heap with a single idle thread, a domain list, and ready queues. This setup provides a starting point for the system's execution, but it may not satisfy all invariants.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": " this probably doesn't satisfy the invariants "}
{"spec": "text \\<open>\\label{s:nondet-spec}\nThe nondeterministic abstract specification instantiates the extended state\nwith the unit type -- i.e. it doesn't have any meaningful extended state.\n\\<close>\n\ninstantiation unit :: state_ext\nbegin\n\n\ndefinition \"unwrap_ext_unit == (\\<lambda>_. undefined) :: unit state \\<Rightarrow> det_ext state\"\n\ndefinition \"wrap_ext_unit == (\\<lambda>f s. ()) :: (det_ext \\<Rightarrow> det_ext) \\<Rightarrow> unit \\<Rightarrow> unit\"\n\n\ndefinition \"wrap_ext_op_unit == (\\<lambda>m. return ()) ::\n  (det_ext state \\<Rightarrow> ((unit \\<times> det_ext state) set) \\<times> bool) \\<Rightarrow> unit state \\<Rightarrow> ((unit \\<times> unit state) set) \\<times> bool\"\n\ndefinition \"wrap_ext_bool_unit == (\\<lambda>m. select UNIV) ::\n  (det_ext state \\<Rightarrow> ((bool \\<times> det_ext state ) set) \\<times> bool) \\<Rightarrow> unit state \\<Rightarrow> ((bool \\<times> unit state) set) \\<times> bool\"\n\ndefinition \"select_switch_unit == (\\<lambda>s. False) :: unit \\<Rightarrow> bool\"\n\ndefinition \"ext_init_unit \\<equiv> () :: unit\"\n\ninstance ..\n\nend", "property": "Nondeterministic Abstract Specification: The specification defines an abstract state with no meaningful extended state, using the unit type. It includes functions to unwrap and wrap the extended state, handle operations, and initialize the state, all of which are defined to have no effect or return a default value, ensuring that the extended state remains trivial and nondeterministic.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": ""}
{"spec": "lemmas ext_init_def = ext_init_det_ext_ext_def ext_init_unit_def\n\ndefinition OR_choice :: \"bool det_ext_monad \\<Rightarrow> ('z::state_ext state,'a) nondet_monad \\<Rightarrow> ('z state,'a) nondet_monad \\<Rightarrow> ('z state,'a) nondet_monad\" where\n\"OR_choice c f g \\<equiv>\n  do\n    ex \\<leftarrow> get;\n    (rv,_) \\<leftarrow> select_f (mk_ef ((wrap_ext_bool c) ex));\n    if rv then f else g\n  od\"\n\ndefinition OR_choiceE :: \"bool det_ext_monad \\<Rightarrow> ('z::state_ext state,'e + 'a) nondet_monad \\<Rightarrow> ('z state,'e + 'a) nondet_monad \\<Rightarrow> ('z state,'e + 'a) nondet_monad\" where\n\"OR_choiceE c f g \\<equiv>\n  doE\n    ex \\<leftarrow> liftE get;\n    (rv,_) \\<leftarrow> liftE $ select_f (mk_ef ((wrap_ext_bool c) ex));\n    if rv then f else g\n  odE\"", "property": "Nondeterministic Choice Based on Extended Operation: Execute an extended operation to obtain a boolean value, which is then used to non-deterministically choose between two computations. The choice is made based on the result of the extended operation, ensuring that the extended state is not modified during the process.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "Run an extended operation over the extended state without\n  modifying it and use the return value to choose between two computations\n  to run.\n"}
{"spec": "definition do_extended_op :: \"unit det_ext_monad \\<Rightarrow> ('z::state_ext state,unit) nondet_monad\" where\n \"do_extended_op eop \\<equiv> do\n                         ex \\<leftarrow> get;\n                         (_,es') \\<leftarrow> select_f (mk_ef ((wrap_ext_op eop) ex));\n                         modify (\\<lambda> state. state\\<lparr>exst := (exst es')\\<rparr>)\n                        od\"", "property": "Execute Extended Operation: Perform an extended operation on the extended state, updating it based on the result of the operation while ignoring any return value.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "Run an extended operation over the extended state to update the\n  extended state, ignoring any return value that the extended operation might\n  yield.\n"}
{"spec": "definition select_ext :: \"(det_ext state \\<Rightarrow> 'd) \\<Rightarrow> ('d set) \\<Rightarrow> ('a::state_ext state,'d) nondet_monad\" where\n  \"select_ext a S \\<equiv> do\n                      s \\<leftarrow> get;\n                      x \\<leftarrow> if (select_switch (exst s)) then (return (a (unwrap_ext s)))\n                          else (select S);\n                      assert (x \\<in> S);\n                      return x\n                    od\"", "property": "Nondeterministic Selection: Select a value from a given set, using the extended state to determine the selection method. If the select switch in the extended state is true, the value is determined by a function of the extended state; otherwise, it is chosen nondeterministically from the set. The selected value is then asserted to be a member of the set.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "\n  Use the extended state to choose a value from a bounding set @{term S} when\n  @{term select_switch} is true. Otherwise just select from @{term S}.\n"}
{"spec": "definition valid_list_2 :: \"cdt_list \\<Rightarrow> cdt \\<Rightarrow> bool\" where\n  \"valid_list_2 t m \\<equiv> (\\<forall>p. set (t p) = {c. m c = Some p}) \\<and> (\\<forall>p. distinct (t p))\"\n\nabbreviation valid_list :: \"det_ext state \\<Rightarrow> bool\" where\n  \"valid_list s \\<equiv> valid_list_2 (cdt_list s) (cdt s)\"\n\nend", "property": "Valid CDT List: Ensures that for each pointer, the list of capabilities associated with it in the CDT list is exactly the set of capabilities that map to that pointer in the CDT, and all such lists are distinct.", "title": "./spec/abstract/Deterministic_A.thy", "chapter": "", "section": "Nondeterministic Abstract Specification", "comment": "Defined here because it's asserted before empty_slot"}
{"spec": "text \\<open>The original capability created when an object of a given type is\ncreated with a particular address and size.\\<close>\nprimrec\n  default_cap :: \"apiobject_type  \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> cap\"\nwhere\n  \"default_cap CapTableObject oref s _ = CNodeCap oref s []\"\n| \"default_cap Untyped oref s dev = UntypedCap dev oref s 0\"\n| \"default_cap TCBObject oref s _ = ThreadCap oref\"\n| \"default_cap EndpointObject oref s _ = EndpointCap oref 0 UNIV\"\n| \"default_cap NotificationObject oref s _ =\n     NotificationCap oref 0 {AllowRead, AllowWrite}\"\n| \"default_cap (ArchObject aobj) oref s dev = ArchObjectCap (arch_default_cap aobj oref s dev)\"", "property": "Default Capability Creation: Generates a default capability for a given object type, address, and size. The capability is specific to the object type, ensuring that the newly created object has the appropriate initial permissions and properties.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": ""}
{"spec": "definition\n  create_cap ::\n  \"apiobject_type \\<Rightarrow> nat \\<Rightarrow> cslot_ptr \\<Rightarrow> bool \\<Rightarrow> cslot_ptr \\<times> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"create_cap type bits untyped is_device \\<equiv> \\<lambda>(dest,oref). do\n    dest_p \\<leftarrow> gets (\\<lambda>s. cdt s dest);\n    cdt \\<leftarrow> gets cdt;\n    set_cdt (cdt (dest \\<mapsto> untyped));\n    do_extended_op (create_cap_ext untyped dest dest_p);\n    set_original dest True;\n    set_cap (default_cap type oref bits is_device) dest\n   od\"", "property": "Create and Install Capability: Create a new capability for a specified object type, size, and device status, and install it into the destination slot. This ensures that the newly created object is properly initialized and accessible through the installed capability.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": "Create and install a new capability to a newly created object."}
{"spec": "text \\<open>Properties of an empty CNode object.\\<close>\ndefinition\n  empty_cnode :: \"nat \\<Rightarrow> cnode_contents\" where\n  \"empty_cnode bits \\<equiv> \\<lambda>x. if length x = bits then Some NullCap else None\"", "property": "Empty CNode Object: An empty CNode object is defined such that it contains `NullCap` for all slots up to the specified number of bits, and `None` for any slot beyond that. This ensures that the CNode is initialized with a known, default state, facilitating safe and predictable behavior in the system.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": ""}
{"spec": "definition\n  default_object :: \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> kernel_object\" where\n  \"default_object api dev n \\<equiv> case api of\n           Untyped \\<Rightarrow> undefined\n         | CapTableObject \\<Rightarrow> CNode n (empty_cnode n)\n         | TCBObject \\<Rightarrow> TCB default_tcb\n         | EndpointObject \\<Rightarrow> Endpoint default_ep\n         | NotificationObject \\<Rightarrow> Notification default_notification\n         | ArchObject aobj \\<Rightarrow> ArchObj (default_arch_object aobj dev n)\"", "property": "Default Object Initialization: Define the initial state of various types of kernel objects when they are created, ensuring that each object is instantiated with a default configuration appropriate to its type.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": "The initial state objects of various types are in when created."}
{"spec": "definition\n  obj_bits_api :: \"apiobject_type \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"obj_bits_api type obj_size_bits \\<equiv> case type of\n           Untyped \\<Rightarrow> obj_size_bits\n         | CapTableObject \\<Rightarrow> obj_size_bits + slot_bits\n         | TCBObject \\<Rightarrow> obj_bits (TCB default_tcb)\n         | EndpointObject \\<Rightarrow> obj_bits (Endpoint undefined)\n         | NotificationObject \\<Rightarrow> obj_bits (Notification undefined)\n         | ArchObject aobj \\<Rightarrow> obj_bits $ ArchObj $ default_arch_object aobj False obj_size_bits\"", "property": "Object Size Determination: Calculate the size in bits of an object based on its type and requested size, ensuring that the object is appropriately sized for its intended use.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Creating Objects", "comment": "The size in bits of the objects that will be created when a given type\nand size is requested."}
{"spec": "text \\<open>\nCreate @{text \"numObjects\"} objects, starting from\n@{text obj_ref}, return of list pointers to them. For some types, each\nreturned pointer points to a group of objects.\n\\<close>\n\ndefinition\n  retype_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> apiobject_type \\<Rightarrow> bool \\<Rightarrow> (obj_ref list,'z::state_ext) s_monad\"\nwhere\n  \"retype_region ptr numObjects o_bits type dev \\<equiv> do\n    obj_size \\<leftarrow> return $ 2 ^ obj_bits_api type o_bits;\n    ptrs \\<leftarrow> return $ map (\\<lambda>p. ptr_add ptr (p * obj_size)) [0..< numObjects];\n    when (type \\<noteq> Untyped) (do\n      kh \\<leftarrow> gets kheap;\n      kh' \\<leftarrow> return $ foldr (\\<lambda>p kh. kh(p \\<mapsto> default_object type dev o_bits)) ptrs kh;\n      do_extended_op (retype_region_ext ptrs type);\n      modify $ kheap_update (K kh')\n    od);\n    return $ ptrs\n  od\"", "property": "Retype Region: Create a specified number of objects of a given type and size, starting from a base object reference. The function updates the kernel heap with the new objects and returns a list of pointers to the created objects. If the type is not untyped, it initializes each object with default settings and performs an extended operation for retype.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Main Retype Implementation", "comment": ""}
{"spec": "abbreviation (input) \"extended_state_update \\<equiv> trans_state\"", "property": "Untyped Capability Invocation: Allows the invocation of untyped capabilities, enabling the reconfiguration and management of memory regions by updating the system's extended state.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": ""}
{"spec": "definition\n  detype :: \"(obj_ref set) \\<Rightarrow> 'z::state_ext state \\<Rightarrow> 'z::state_ext state\" where\n \"detype S s \\<equiv> s \\<lparr> kheap := (\\<lambda>x. if x \\<in> S then None else kheap s x), extended_state := detype_ext S (exst s)\\<rparr>\"", "property": "Remove Objects from Heap: The detype operation removes a specified set of objects from the heap, effectively deallocating them and updating the extended state accordingly.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": "Remove objects from a region of the heap."}
{"spec": "definition\n  delete_objects :: \"machine_word \\<Rightarrow> nat \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"delete_objects ptr bits = do\n     do_machine_op (freeMemory ptr bits);\n     modify (detype {ptr..ptr + 2 ^ bits - 1})\n  od\"\n\ndefinition\n  get_free_ref :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> obj_ref\" where\n  \"get_free_ref base free_index \\<equiv> base +  (of_nat free_index)\"\n\ndefinition\n  get_free_index :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> nat\" where\n  \"get_free_index base free \\<equiv> unat $ (free - base)\"\n\nprimrec(nonexhaustive) is_device_untyped_cap\nwhere\n  \"is_device_untyped_cap (UntypedCap isdev _ _ _) = isdev\"", "property": "Delete Objects: Free and de-allocate memory within a specified region, ensuring that the memory is no longer accessible or usable.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": "Delete objects within a specified region."}
{"spec": "definition\n  reset_untyped_cap :: \"cslot_ptr \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"reset_untyped_cap src_slot = doE\n  cap \\<leftarrow> liftE $ get_cap src_slot;\n  sz \\<leftarrow> returnOk $ bits_of cap;\n  base \\<leftarrow> returnOk $ obj_ref_of cap;\n  if free_index_of cap = 0\n    then returnOk ()\n  else doE\n    liftE $ delete_objects base sz;\n  dev \\<leftarrow> returnOk $ is_device_untyped_cap cap;\n\n  if dev \\<or> sz < resetChunkBits\n      then liftE $ do\n        unless dev $ do_machine_op $ clearMemory base (2 ^ sz);\n        set_cap (UntypedCap dev base sz 0) src_slot\n      od\n    else mapME_x (\\<lambda>i. doE\n          liftE $ do_machine_op $ clearMemory (base + (of_nat i << resetChunkBits))\n              (2 ^ resetChunkBits);\n          liftE $ set_cap (UntypedCap dev base sz\n              (i * 2 ^ resetChunkBits)) src_slot;\n          preemption_point\n        odE) (rev [i \\<leftarrow> [0 ..< 2 ^ (sz - resetChunkBits)].\n            i * 2 ^ resetChunkBits < free_index_of cap])\n    odE\n  odE\"", "property": "Reset Untyped Capability: Clear and reset the underlying memory and object level representation of an untyped capability, progressively moving the free region pointer back to the start of the newly cleared region. If the capability is a device or its size is smaller than the reset chunk size, clear the entire memory region at once; otherwise, clear the memory in chunks and update the capability accordingly.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": "Untyped capabilities note a currently free region. Sometimes this\nregion is reset during a Retype operation. This progressively clears the\nunderlying memory and also the object level representation, moving the free\nregion pointer back to the start of the newly cleared region each time."}
{"spec": "definition\n  invoke_untyped :: \"untyped_invocation \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n\"invoke_untyped ui \\<equiv> case ui\n    of Retype src_slot reset base retype_base new_type obj_sz slots is_device \\<Rightarrow>\ndoE\n  whenE reset $ reset_untyped_cap src_slot;\n  liftE $ do\n\n  cap \\<leftarrow> get_cap src_slot;\n\n  \\<comment> \\<open>Update the untyped cap to track the amount of space used.\\<close>\n  total_object_size \\<leftarrow> return $ (of_nat (length slots) << (obj_bits_api new_type obj_sz));\n  free_ref \\<leftarrow> return $ retype_base + total_object_size;\n  set_cap (UntypedCap is_device base (bits_of cap) (unat (free_ref - base))) src_slot;\n\n  \\<comment> \\<open>Create new objects.\\<close>\n  orefs \\<leftarrow> retype_region retype_base (length slots) obj_sz new_type is_device;\n  init_arch_objects new_type is_device retype_base (length slots) obj_sz orefs;\n  sequence_x (map (create_cap new_type obj_sz src_slot is_device) (zip slots orefs))\nod odE\"\n\nend", "property": "Untyped Capability Retyping: Allows the reconfiguration of a memory region by clearing existing objects, creating new objects of a specified type, initializing them, and installing new capabilities. This process updates the untyped capability to reflect the space used and ensures that the new objects are properly set up and linked with their corresponding capabilities.", "title": "./spec/abstract/Retype_A.thy", "chapter": "Retyping and Untyped Invocations", "section": "Invoking Untyped Capabilities", "comment": "Untyped capabilities confer authority to the Retype method. This\nclears existing objects from a region, creates new objects of the requested type,\ninitialises them and installs new capabilities to them."}
{"spec": "type_synonym ('a,'z) s_monad = \"('z state, 'a) nondet_monad\"", "property": "Basic Kernel Monad: Represents a monadic computation in the kernel that does not handle faults, interrupts, or errors.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The basic kernel monad without faults, interrupts, or errors."}
{"spec": "type_synonym ('a,'z) f_monad = \"(fault + 'a,'z) s_monad\"\n\nterm \"a::(unit,'a) s_monad\"", "property": "Fault Monad: Handles exceptions by potentially throwing a fault, which is typically reported to the current thread's fault handler.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The fault monad: may throw a @{text fault} exception which\nwill usually be reported to the current thread's fault handler."}
{"spec": "type_synonym ('a,'z) se_monad = \"(syscall_error + 'a,'z) s_monad\"", "property": "Error Handling in System Calls: The error monad allows for the throwing of a `syscall_error` exception, which is typically reported to the current thread as the result of a system call.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The error monad: may throw a @{text syscall_error} exception\nwhich will usually be reported to the current thread as system call\nresult."}
{"spec": "type_synonym ('a,'z) lf_monad = \"(lookup_failure + 'a,'z) s_monad\"", "property": "Lookup Failure Monad: Handles exceptions by potentially throwing a `lookup_failure` exception, which can be reported either directly to the current thread or to its fault handler.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The lookup failure monad: may throw a @{text lookup_failure}\nexception. Depending on context it may either be reported directly to\nthe current thread or to its fault handler.\n"}
{"spec": "type_synonym ('a,'z) p_monad = \"(unit + 'a,'z) s_monad\"", "property": "Preemption Monad: Represents a computation that may throw an interrupt exception, allowing for the possibility of preemption during its execution.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "The preemption monad. May throw an interrupt exception."}
{"spec": "translations\n  (type) \"'a s_monad\" <= (type) \"state \\<Rightarrow> (('a \\<times> state) \\<Rightarrow> bool) \\<times> bool\"\n  (type) \"'a f_monad\" <= (type) \"(fault + 'a) s_monad\"\n  (type) \"'a se_monad\" <= (type) \"(syscall_error + 'a) s_monad\"\n  (type) \"'a lf_monad\" <= (type) \"(lookup_failure + 'a) s_monad\"\n  (type) \"'a p_monad\" <=(type) \"(unit + 'a) s_monad\"", "property": "Type Abbreviations: Define shorthand notations for various monad types to simplify the representation of state transformations, error handling, and system calls. These abbreviations streamline the specification and implementation of system behaviors.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "\n  Printing abbreviations for the above types.\n"}
{"spec": "definition\n  without_preemption :: \"('a,'z::state_ext) s_monad \\<Rightarrow> ('a,'z::state_ext) p_monad\"\nwhere without_preemption_def[simp]:\n \"without_preemption \\<equiv> liftE\"", "property": "Non-Preemptible Execution: Ensures that operations within preemptible blocks are executed without preemption, maintaining the atomicity and integrity of critical sections.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "Perform non-preemptible operations within preemptible blocks."}
{"spec": "definition\n  preemption_point :: \"(unit,'z::state_ext) p_monad\" where\n \"preemption_point \\<equiv> doE liftE $ do_extended_op update_work_units;\n                         OR_choiceE (work_units_limit_reached)\n                           (doE liftE $ do_extended_op reset_work_units;\n                                irq_opt \\<leftarrow> liftE $ do_machine_op (getActiveIRQ True);\n                                case_option (returnOk ()) (K (throwError $ ())) irq_opt\n                           odE) (returnOk ())\n                     odE\"", "property": "Preemption Point: Allows preemption at a specific point by updating work units and checking if the work units limit has been reached. If the limit is reached, it resets the work units and handles any active interrupt, otherwise, it continues without interruption.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "Allow preemption at this point."}
{"spec": "definition\n  cap_fault_on_failure :: \"obj_ref \\<Rightarrow> bool \\<Rightarrow> ('a,'z::state_ext) lf_monad \\<Rightarrow> ('a,'z::state_ext) f_monad\" where\n \"cap_fault_on_failure cptr rp m \\<equiv> handleE' m (throwError \\<circ> CapFault cptr rp)\"\n\ndefinition\n  lookup_error_on_failure ::  \"bool \\<Rightarrow> ('a,'z::state_ext) lf_monad \\<Rightarrow> ('a,'z::state_ext) se_monad\" where\n \"lookup_error_on_failure s m \\<equiv> handleE' m (throwError \\<circ> FailedLookup s)\"\n\ndefinition\n  null_cap_on_failure :: \"(cap,'z::state_ext) lf_monad \\<Rightarrow> (cap,'z::state_ext) s_monad\" where\n \"null_cap_on_failure \\<equiv> liftM (case_sum (\\<lambda>x. NullCap) id)\"\n\ndefinition\n  unify_failure :: \"('f + 'a,'z::state_ext) s_monad \\<Rightarrow> (unit + 'a,'z::state_ext) s_monad\" where\n \"unify_failure m \\<equiv> handleE' m (\\<lambda>x. throwError ())\"\n\ndefinition\n  empty_on_failure :: \"('f + 'a list,'z::state_ext) s_monad \\<Rightarrow> ('a list,'z::state_ext) s_monad\" where\n \"empty_on_failure m \\<equiv> m <catch> (\\<lambda>x. return [])\"\n\ndefinition\n  const_on_failure :: \"'a \\<Rightarrow> ('f + 'a,'z::state_ext) s_monad \\<Rightarrow> ('a,'z::state_ext) s_monad\" where\n \"const_on_failure c m \\<equiv> m <catch> (\\<lambda>x. return c)\"", "property": "Exception Handling and Conversion: Convert and handle different types of exceptions or failures by transforming them into various error types or return values, ensuring that the system can gracefully manage and respond to errors.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "Lift one kind of exception monad into another by converting the error\ninto various other kinds of error or return value."}
{"spec": "definition\n  range_check :: \"machine_word \\<Rightarrow> machine_word \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"range_check v min_v max_v \\<equiv>\n    unlessE (v \\<ge> min_v \\<and> v \\<le> max_v) $ throwError $ RangeError min_v max_v\"\n\nend", "property": "Range Check: Ensures that a given value is within a specified inclusive range, throwing a `RangeError` if the value is outside the range.", "title": "./spec/abstract/Exceptions_A.thy", "chapter": "", "section": "", "comment": "Checks whether first argument is between second and third (inclusive)."}
{"spec": "text\\<open>The @{term syscall} operation generically describes the usual\nexecution of system calls in three phases, where the first phase may\nresult in a fault, the second phase may result in an error and the third\nphase may be interrupted. The first two phases are used for argument decoding\nand checking. The last phase commits and executes the system call.\n\nThe @{term syscall} operation has five arguments:\n\\begin{itemize}\n\\item the first operation @{text m_fault} to execute, that may\nresult in a fault;\n\\item the fault handler @{text h_fault} to execute if the first\noperation resulted in a fault;\n\\item the second operation @{text m_error} to execute (if no fault\noccurred in the first operation); this second operation may result in\nan error;\n\\item the error handler @{text h_error} to execute if the second\noperation resulted in an error;\n\\item the third and last operation @{text m_finalise} to execute (if\nno error occurred in the second operation); this operation may be\ninterrupted.\n\\end{itemize}\n\\<close>\n\ndefinition\n  syscall :: \"('a,'z::state_ext) f_monad\n                  \\<Rightarrow> (fault \\<Rightarrow> ('c,'z::state_ext) s_monad)\n                  \\<Rightarrow> ('a \\<Rightarrow> ('b,'z::state_ext) se_monad)\n                  \\<Rightarrow> (syscall_error \\<Rightarrow> ('c,'z::state_ext) s_monad)\n               \\<Rightarrow> ('b \\<Rightarrow> ('c,'z::state_ext) p_monad) \\<Rightarrow> ('c,'z::state_ext) p_monad\"\nwhere\n\"syscall m_fault h_fault m_error h_error m_finalise \\<equiv> doE\n    r_fault \\<leftarrow> without_preemption $ m_fault;\n    case r_fault of\n          Inl f \\<Rightarrow>   without_preemption $ h_fault f\n        | Inr a \\<Rightarrow>   doE\n            r_error \\<leftarrow> without_preemption $ m_error a;\n            case r_error of\n                  Inl e \\<Rightarrow>   without_preemption $ h_error e\n                | Inr b \\<Rightarrow>   m_finalise b\n        odE\nodE\"", "property": "System Call Execution: The system call operation is divided into three phases, each with its own handler for faults and errors. The first phase may result in a fault, the second phase may result in an error, and the third phase may be interrupted. Handlers are provided to manage faults and errors, ensuring that the system call can be executed correctly and safely.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "System call entry point", "comment": ""}
{"spec": "text\\<open>The kernel user can perform seven kinds of system calls,\ndescribed by the enumerated type @{term syscall}, defined in \\autoref{s:spec_syscall}.\nThese seven system calls can be categorised into two broad\nfamilies: sending messages and receiving messages, the two main\nservices provided by the kernel.\n\nThe usual case for sending messages (@{text Send} event) consists of the user\nsending a message to an object, without expecting any answer. The sender is\nblocked until the receiver is waiting to receive. In case the\nreceiver is not trusted, an explicit non-blocking send operation can\nbe used (@{text NBSend} event). If a reply is requested from the\nreceiver, the Call operation can be used (@{text Call} event). The Call operation\nwill automatically provide a @{text Reply} capability to the receiver.\n\nAll three sending operations are handled by the @{text\nhandle_invocation} operation, which takes two boolean arguments, one\nto indicate if a reply is requested and the other to indicate if the\nsend is blocking or not.\n\nThe other direction is the reception of messages. This is done by\nperforming a Recv operation on an endpoint kernel object. The receiver\nis then blocked until a sender performs a Send operation on the\nendpoint object, resulting in a message transfer between the sender\nand the receiver. The receiver may also perform a Reply operation\n(@{text Reply} event) in response to a @{text Call}, which is always\nnon-blocking. When the receiver is a user-level server, it generally\nruns a loop waiting for messages. On handling a received message, the\nserver will send a reply and then return to waiting. To avoid\nexcessive switching between user and kernel mode, the kernel provides\na ReplyRecv operation, which is simply a Reply followed by Recv.\n\nFinally, the last event, @{text Yield}, enables the user to donate its\nremaining timeslice.\\<close>", "property": "System Call Operations: The system supports seven types of system calls, categorized into two main families: sending and receiving messages. Sending operations include blocking and non-blocking sends, as well as a call operation that provides a reply capability to the receiver. Receiving operations include receiving messages, replying to calls, and a combined reply-receive operation to optimize user-kernel mode switching. Additionally, a yield operation allows a user to donate its remaining timeslice.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "System call entry point", "comment": ""}
{"spec": "fun\n  perform_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"perform_invocation block call (InvokeUntyped i) =\n    doE\n      invoke_untyped i;\n      returnOk []\n    odE\"\n\n| \"perform_invocation block call (InvokeEndpoint ep badge canGrant canGrantReply) =\n    (without_preemption $ do\n       thread \\<leftarrow> gets cur_thread;\n       send_ipc block call badge canGrant canGrantReply thread ep;\n       return []\n     od)\"\n\n| \"perform_invocation block call (InvokeNotification ep badge) =\n    doE\n      without_preemption $ send_signal ep badge;\n      returnOk []\n    odE\"\n\n| \"perform_invocation block call (InvokeTCB i) = invoke_tcb i\"\n\n| \"perform_invocation block call (InvokeDomain tptr d) = invoke_domain tptr d\"\n\n| \"perform_invocation block call (InvokeReply thread slot grant) =\n    liftE (do\n      sender \\<leftarrow> gets cur_thread;\n      do_reply_transfer sender thread slot grant;\n      return []\n    od)\"\n\n| \"perform_invocation block call (InvokeCNode i) =\n    doE\n      invoke_cnode i;\n      returnOk []\n    odE\"\n\n| \"perform_invocation block call (InvokeIRQControl i) =\n   doE\n     invoke_irq_control i;\n     returnOk []\n   odE\"\n\n| \"perform_invocation block call (InvokeIRQHandler i) =\n   doE\n     liftE $ invoke_irq_handler i;\n     returnOk []\n   odE\"\n\n| \"perform_invocation block call (InvokeArchObject i) =\n    arch_perform_invocation i\"\n\n\ndefinition\n  handle_invocation :: \"bool \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_invocation calling blocking \\<equiv> doE\n    thread \\<leftarrow> liftE $ gets cur_thread;\n    info \\<leftarrow> without_preemption $ get_message_info thread;\n    ptr \\<leftarrow> without_preemption $ liftM data_to_cptr $\n          as_user thread $ getRegister cap_register;\n    syscall\n      (doE\n         (cap, slot) \\<leftarrow> cap_fault_on_failure (of_bl ptr) False $\n                           lookup_cap_and_slot thread ptr;\n         buffer \\<leftarrow> liftE $ lookup_ipc_buffer False thread;\n         extracaps \\<leftarrow> lookup_extra_caps thread buffer info;\n         returnOk (slot, cap, extracaps, buffer)\n       odE)\n      (\\<lambda>fault. when blocking $ handle_fault thread fault)\n      (\\<lambda>(slot,cap,extracaps,buffer). doE\n            args \\<leftarrow> liftE $ get_mrs thread buffer info;\n            decode_invocation (mi_label info) args ptr slot cap extracaps\n       odE)\n      (\\<lambda>err. when calling $\n            reply_from_kernel thread $ msg_from_syscall_error err)\n      (\\<lambda>oper. doE\n            without_preemption $ set_thread_state thread Restart;\n            reply \\<leftarrow> perform_invocation blocking calling oper;\n            without_preemption $ do\n                state \\<leftarrow> get_thread_state thread;\n                case state of\n                      Restart \\<Rightarrow> do\n                          when calling $\n                              reply_from_kernel thread (0, reply);\n                          set_thread_state thread Running\n                      od\n                    | _ \\<Rightarrow>  return ()\n            od\n       odE)\n  odE\"\n\n\ndefinition\n  handle_yield :: \"(unit,'z::state_ext) s_monad\" where\n  \"handle_yield \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) thread);\n     do_extended_op (tcb_sched_action (tcb_sched_append) thread);\n     do_extended_op (reschedule_required)\n   od\"\n\ndefinition\n  handle_send :: \"bool \\<Rightarrow> (unit,'z::state_ext) p_monad\" where\n  \"handle_send bl \\<equiv> handle_invocation False bl\"\n\ndefinition\n  handle_call :: \"(unit,'z::state_ext) p_monad\" where\n \"handle_call \\<equiv> handle_invocation True True\"\n\ndefinition\n  delete_caller_cap :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"delete_caller_cap t \\<equiv> cap_delete_one (t, tcb_cnode_index 3)\"\n\ndefinition\n  handle_recv :: \"bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"handle_recv is_blocking \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n\n     ep_cptr \\<leftarrow> liftM data_to_cptr $ as_user thread $\n                 getRegister cap_register;\n\n     (cap_fault_on_failure (of_bl ep_cptr) True $ doE\n        ep_cap \\<leftarrow> lookup_cap thread ep_cptr;\n\n        let flt = (throwError $ MissingCapability 0)\n        in\n        case ep_cap\n          of EndpointCap ref badge rights \\<Rightarrow>\n             (if AllowRecv \\<in> rights\n              then liftE $ do\n                 delete_caller_cap thread;\n                 receive_ipc thread ep_cap is_blocking\n                od\n              else flt)\n           | NotificationCap ref badge rights \\<Rightarrow>\n             (if AllowRecv \\<in> rights\n              then doE\n                ntfn \\<leftarrow> liftE $ get_notification ref;\n                boundTCB \\<leftarrow> returnOk $ ntfn_bound_tcb ntfn;\n                if boundTCB = Some thread \\<or> boundTCB = None\n                then liftE $ receive_signal thread ep_cap is_blocking\n                else flt\n               odE\n              else flt)\n           | _ \\<Rightarrow> flt\n      odE)\n      <catch> handle_fault thread\n   od\"\n\ndefinition\n  handle_reply :: \"(unit,'z::state_ext) s_monad\" where\n \"handle_reply \\<equiv> do\n    thread \\<leftarrow> gets cur_thread;\n    caller_cap \\<leftarrow> get_cap (thread, tcb_cnode_index 3);\n    case caller_cap of\n      ReplyCap caller False R \\<Rightarrow>\n        do_reply_transfer thread caller (thread, tcb_cnode_index 3) (AllowGrant \\<in> R)\n    | NullCap \\<Rightarrow> return ()\n    | _ \\<Rightarrow> fail\n  od\"", "property": "System Call Execution: The system call process involves three main phases: capability lookup, argument decoding, and invocation execution. Capability lookup ensures the validity of the invocation, while argument decoding checks for the correctness and sufficiency of the provided arguments. The actual invocation is then performed, which can be preempted, and the system state is updated accordingly.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "System call entry point", "comment": "The invocation is made up of three phases. The first phase\ncorresponds to a lookup of capabilities to check that the invocation\nis valid. This phase can result in a fault if a given CSpace address\nis invalid (see the function @{text \"resolve_address_bits\"}). The\nsecond phase is the decoding of the arguments given by the user. This\nis handled by the @{text decode_invocation} operation. This operation\ncan result in an error if, for example, the number of arguments is\nless than required by the operation, or if some argument capability\nhas the wrong type. Finally, the actual invocation is performed, using\nthe @{text perform_invocation} function. Note that this last phase is\npreemptable.\n"}
{"spec": "fun\n  handle_event :: \"event \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"handle_event (SyscallEvent call) =\n   (case call of\n          SysSend \\<Rightarrow> handle_send True\n        | SysNBSend \\<Rightarrow> handle_send False\n        | SysCall \\<Rightarrow> handle_call\n        | SysRecv \\<Rightarrow> without_preemption $ handle_recv True\n        | SysYield \\<Rightarrow> without_preemption handle_yield\n        | SysReply \\<Rightarrow> without_preemption handle_reply\n        | SysReplyRecv \\<Rightarrow> without_preemption $ do\n            handle_reply;\n            handle_recv True\n          od\n        | SysNBRecv \\<Rightarrow> without_preemption $ handle_recv False)\"\n\n| \"handle_event (UnknownSyscall n) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UnknownSyscallException $ of_nat n;\n    return ()\n  od)\"\n\n| \"handle_event (UserLevelFault w1 w2) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_fault thread $ UserException (w1 && mask 32) (w2 && mask 28);\n    return ()\n  od)\"\n\n| \"handle_event Interrupt = (without_preemption $ do\n    active \\<leftarrow> do_machine_op $ getActiveIRQ False;\n    case active of\n       Some irq \\<Rightarrow> handle_interrupt irq\n     | None \\<Rightarrow> return ()\n  od)\"\n\n| \"handle_event (VMFaultEvent fault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_vm_fault thread fault_type <catch> handle_fault thread;\n    return ()\n  od)\"\n\n| \"handle_event (HypervisorEvent hypfault_type) = (without_preemption $ do\n    thread \\<leftarrow> gets cur_thread;\n    handle_hypervisor_fault thread hypfault_type\n  od)\"", "property": "Event Handling: Manages different types of system events, including system calls, unknown system calls, user-level faults, interrupts, virtual memory faults, and hypervisor events. Each event is processed with specific handlers, and most operations are executed without preemption to ensure atomicity and consistency.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "Top-level event handling", "comment": ""}
{"spec": "text \\<open>\n  This function is the main kernel entry point. The main event loop of the\n  kernel handles events, handles a potential preemption interrupt, schedules\n  and switches back to the active thread.\n\\<close>\n\ndefinition\n  call_kernel :: \"event \\<Rightarrow> (unit,'z::state_ext_sched) s_monad\" where\n  \"call_kernel ev \\<equiv> do\n       handle_event ev <handle>\n           (\\<lambda>_. without_preemption $ do\n                  irq \\<leftarrow> do_machine_op $ getActiveIRQ True;\n                  when (irq \\<noteq> None) $ handle_interrupt (the irq)\n                od);\n       schedule;\n       activate_thread\n   od\"\n\nend", "property": "Kernel Entry Point: Manages the main event loop by handling events, managing potential preemption interrupts, and scheduling threads. It ensures that the system processes events, handles interruptions, and switches to the active thread efficiently.", "title": "./spec/abstract/Syscall_A.thy", "chapter": "System Calls", "section": "Kernel entry point", "comment": ""}
{"spec": "end", "property": "No code or comment provided for summarization. Please provide the necessary information to generate the property.", "title": "./spec/abstract/Intro_Doc.thy", "chapter": "", "section": "", "comment": "<"}
{"spec": "(*\n Generic functions for invocation labels\n*)\n\nchapter \"Kernel Object Invocations\"\n\ntheory InvocationLabels_A\nimports\n  MiscMachine_A\n  \"ExecSpec.ArchLabelFuns_H\"\nbegin\n\ndefinition\n  invocation_type :: \"data \\<Rightarrow> invocation_label\"\nwhere\n \"invocation_type x \\<equiv> if \\<exists>(v :: invocation_label). fromEnum v = data_to_nat x\n                      then toEnum (data_to_nat x) else GenInvocationLabel InvalidInvocation\"\n\ndefinition\n  gen_invocation_type :: \"data \\<Rightarrow> gen_invocation_labels\"\nwhere\n \"gen_invocation_type x \\<equiv>\n   case invocation_type x of\n     GenInvocationLabel l \\<Rightarrow> l\n   | ArchInvocationLabel _ \\<Rightarrow> InvalidInvocation\"\n\nend", "property": "Invocation Type Determination: Maps a data value to an invocation label, ensuring that the data is converted to a valid invocation type or defaults to an invalid invocation if no corresponding label exists.", "title": "./spec/abstract/InvocationLabels_A.thy", "chapter": "Kernel Object Invocations", "section": "", "comment": ""}
{"spec": "definition\n  getActiveTCB :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> tcb option\"\nwhere\n  \"getActiveTCB tcb_ref state \\<equiv>\n   case (get_tcb tcb_ref state)\n     of None           \\<Rightarrow> None\n      | Some tcb       \\<Rightarrow> if (runnable $ tcb_state tcb)\n                         then Some tcb else None\"", "property": "Retrieve Active TCB: Obtain the TCB at a given address if the thread is in a runnable state.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Gets the TCB at an address if the thread can be scheduled."}
{"spec": "definition\n  allActiveTCBs :: \"(obj_ref set,'z::state_ext) s_monad\" where\n  \"allActiveTCBs \\<equiv> do\n    state \\<leftarrow> get;\n    return {x. getActiveTCB x state \\<noteq> None}\n   od\"", "property": "Retrieve All Active Threads: Obtain a set of all threads in the system that are currently schedulable.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Gets all schedulable threads in the system."}
{"spec": "definition\n  switch_to_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"switch_to_thread t \\<equiv> do\n     state \\<leftarrow> get;\n     assert (get_tcb t state \\<noteq> None);\n     arch_switch_to_thread t;\n     do_extended_op (tcb_sched_action (tcb_sched_dequeue) t);\n     modify (\\<lambda>s. s \\<lparr> cur_thread := t \\<rparr>)\n   od\"", "property": "Switch to Specified Thread: Transitions the current execution context to the specified thread by dequeuing it from the scheduler, updating the current thread, and performing architecture-specific switch operations.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Switches the current thread to the specified one."}
{"spec": "definition guarded_switch_to :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"guarded_switch_to thread \\<equiv> do ts \\<leftarrow> get_thread_state thread;\n                    assert (runnable ts);\n                    switch_to_thread thread\n                 od\"", "property": "Thread State Validation: Ensures that a thread is in a runnable state before switching to it, preventing the kernel from scheduling non-runnable threads.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Asserts that a thread is runnable before switching to it."}
{"spec": "definition\n  switch_to_idle_thread :: \"(unit,'z::state_ext) s_monad\" where\n  \"switch_to_idle_thread \\<equiv> do\n     thread \\<leftarrow> gets idle_thread;\n     arch_switch_to_idle_thread;\n     modify (\\<lambda>s. s \\<lparr> cur_thread := thread \\<rparr>)\n   od\"\n\nclass state_ext_sched = state_ext +\n  fixes schedule :: \"(unit,'a) s_monad\"\n\ndefinition choose_thread :: \"det_ext state \\<Rightarrow> (unit \\<times> det_ext state) set \\<times> bool\" where\n\"choose_thread \\<equiv>\n      do\n        d \\<leftarrow> gets cur_domain;\n        queues \\<leftarrow> gets (\\<lambda>s. ready_queues s d);\n        if (\\<forall>prio. queues prio = []) then (switch_to_idle_thread)\n        else (guarded_switch_to (hd (max_non_empty_queue queues)))\n      od\"", "property": "Switch to Idle Thread: Switches the current thread to the idle thread, updating the system state to reflect this change. This ensures that the system remains in a valid state when no other threads are ready to run.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "Switches to the idle thread."}
{"spec": "definition\n  is_highest_prio :: \"domain \\<Rightarrow> priority \\<Rightarrow> det_ext state \\<Rightarrow> bool\"\nwhere\n  \"is_highest_prio d p s \\<equiv>\n    (\\<forall>prio. ready_queues s d prio = [])\n    \\<or> p \\<ge> Max {prio. ready_queues s d prio \\<noteq> []}\"\n\ninstantiation  det_ext_ext :: (type) state_ext_sched\nbegin\n\ndefinition\n  \"schedule_switch_thread_fastfail ct it ct_prio target_prio \\<equiv>\n     if ct \\<noteq> it\n     then return (target_prio < ct_prio)\n     else return True\"\n\ndefinition\n  \"schedule_choose_new_thread \\<equiv> do\n     dom_time \\<leftarrow> gets domain_time;\n     when (dom_time = 0) next_domain;\n     choose_thread;\n     set_scheduler_action resume_cur_thread\n   od\"\n\ndefinition\n  \"schedule_det_ext_ext \\<equiv> do\n     ct \\<leftarrow> gets cur_thread;\n     ct_st \\<leftarrow> get_thread_state ct;\n     ct_runnable \\<leftarrow> return $ runnable ct_st;\n     action \\<leftarrow> gets scheduler_action;\n     (case action\n       of resume_cur_thread \\<Rightarrow> do\n            id \\<leftarrow> gets idle_thread;\n            assert (ct_runnable \\<or> ct = id);\n            return ()\n         od\n       | choose_new_thread \\<Rightarrow> do\n           when ct_runnable (tcb_sched_action tcb_sched_enqueue ct);\n           schedule_choose_new_thread\n         od\n       | switch_thread candidate \\<Rightarrow> do\n           when ct_runnable (tcb_sched_action tcb_sched_enqueue ct);\n\n           it \\<leftarrow> gets idle_thread;\n           target_prio \\<leftarrow> ethread_get tcb_priority candidate;\n\n           \\<comment> \\<open>Infoflow does not like asking about the idle thread's priority or domain.\\<close>\n           ct_prio \\<leftarrow> ethread_get_when (ct \\<noteq> it) tcb_priority ct;\n           \\<comment> \\<open>When to look at the bitmaps. This optimisation is used in the C fast path,\n              but there we know @{text cur_thread} is not idle.\\<close>\n           fastfail \\<leftarrow> schedule_switch_thread_fastfail ct it ct_prio target_prio;\n\n           cur_dom \\<leftarrow> gets cur_domain;\n           highest \\<leftarrow> gets (is_highest_prio cur_dom target_prio);\n           if (fastfail \\<and> \\<not>highest)\n           then do\n               \\<comment> \\<open>Candidate is not best candidate, choose a new thread\\<close>\n               tcb_sched_action tcb_sched_enqueue candidate;\n               set_scheduler_action choose_new_thread;\n               schedule_choose_new_thread\n             od\n           else if (ct_runnable \\<and> ct_prio = target_prio)\n           then do\n               \\<comment> \\<open>Current thread was runnable and candidate is not strictly better\n                  want current thread to run next, so append the candidate to end of queue\n                  and choose again\\<close>\n               tcb_sched_action tcb_sched_append candidate;\n               set_scheduler_action choose_new_thread;\n               schedule_choose_new_thread\n             od\n           else do\n             guarded_switch_to candidate;\n             \\<comment> \\<open>Duplication assists in wp proof under different scheduler actions\\<close>\n             set_scheduler_action resume_cur_thread\n           od\n        od)\n    od\"\n\ninstance ..\nend\n\n\ninstantiation unit :: state_ext_sched\nbegin", "property": "Priority Scheduling: Determines if a given priority is the highest among the ready threads in a specified domain. If no threads are ready, it trivially returns true. This ensures that the scheduler can make informed decisions about thread prioritization and scheduling, maintaining efficient and fair execution of threads.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "\n  Determine whether given priority is highest among queued ready threads in given domain.\n  Trivially true if no threads are ready."}
{"spec": "definition schedule_unit :: \"(unit,unit) s_monad\" where\n\"schedule_unit \\<equiv> (do\n   cur \\<leftarrow> gets cur_thread;\n   threads \\<leftarrow> allActiveTCBs;\n   thread \\<leftarrow> select threads;\n   (if thread = cur then\n     return () \\<sqinter> switch_to_thread thread\n   else\n     switch_to_thread thread)\n od) \\<sqinter>\n (do\n   cur \\<leftarrow> gets cur_thread;\n   idl \\<leftarrow> gets idle_thread;\n   if idl = cur then\n     return () \\<sqinter> switch_to_idle_thread\n   else switch_to_idle_thread\n  od)\"\n\ninstance ..\nend\n\n\nlemmas schedule_def = schedule_det_ext_ext_def schedule_unit_def\n\nend", "property": "Scheduler Flexibility: The scheduler can choose any active thread or the idle thread for execution. If the selected thread is the current thread, it may skip the context switch. Similarly, if the idle thread is the current thread, it may omit the switch to the idle thread.", "title": "./spec/abstract/Schedule_A.thy", "chapter": "", "section": "", "comment": "\n  The scheduler is heavily underspecified.\n  It is allowed to pick any active thread or the idle thread.\n  If the thread the scheduler picked is the current thread, it\n  may omit the call to @{const switch_to_thread}. Likewise it\n  may omit the call to @{const switch_to_idle_thread} if the\n  idle thread is the current thread.\n"}
{"spec": "translations\n  (type) \"'a user_monad\" <= (type) \"user_context \\<Rightarrow> ('a \\<times> user_context) set \\<times> bool\"\n\ndefinition\n  asid_high_bits :: nat\nwhere\n  \"asid_high_bits \\<equiv> LENGTH(asid_high_len)\"\n\ndefinition\n  asid_low_bits :: nat\nwhere\n  \"asid_low_bits \\<equiv> LENGTH(asid_low_len)\"\n\ndefinition\n  asid_bits :: nat\nwhere\n  \"asid_bits \\<equiv> LENGTH(asid_len)\"\n\nlemmas asid_bits_defs =\n  asid_bits_def asid_high_bits_def asid_low_bits_def", "property": "ASID Bit Definitions: Define the number of bits for ASID, including high bits, low bits, and total bits, to specify the structure and size of the ASID used in the system.", "title": "./spec/abstract/MiscMachine_A.thy", "chapter": "", "section": "", "comment": " Needs to be done here after plain type names are exported "}
{"spec": "lemma asid_bits_len_checks:\n  \"asid_bits = asid_high_bits + asid_low_bits\"\n  \"asid_bits \\<le> LENGTH(asid_rep_len)\"\n  unfolding asid_bits_defs by auto\n\ndefinition ipa_size :: nat where\n  \"ipa_size \\<equiv> if config_ARM_PA_SIZE_BITS_40 then 40 else 44\"\n\nend", "property": "Sanity Checks for ASID and IPA Configuration: Ensure that the ASID bits are correctly split into high and low bits, and that the total number of ASID bits does not exceed the defined length. Additionally, define the IPA size based on the configuration setting.", "title": "./spec/abstract/MiscMachine_A.thy", "chapter": "", "section": "", "comment": " Sanity checks. "}
{"spec": "fun\n  invoke_irq_control :: \"irq_control_invocation \\<Rightarrow> (unit,'z::state_ext) p_monad\"\nwhere\n  \"invoke_irq_control (IRQControl irq handler_slot control_slot) =\n     liftE (do set_irq_state IRQSignal irq;\n               cap_insert (IRQHandlerCap irq) control_slot handler_slot od)\"\n| \"invoke_irq_control (ArchIRQControl invok) =\n     arch_invoke_irq_control invok\"", "property": "IRQ Control: Allows the creation and management of IRQHandler capabilities, as well as the execution of architecture-specific interrupt actions. This ensures that interrupts are handled correctly and efficiently, maintaining system stability and performance.", "title": "./spec/abstract/Interrupt_A.thy", "chapter": "", "section": "", "comment": "The IRQControl capability can be used to create a new IRQHandler\ncapability as well as to perform whatever architecture specific interrupt\nactions are available."}
{"spec": "fun\n  invoke_irq_handler :: \"irq_handler_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"invoke_irq_handler (ACKIrq irq) = arch_invoke_irq_handler (ACKIrq irq)\"\n| \"invoke_irq_handler (SetIRQHandler irq cap slot) = (do\n     irq_slot \\<leftarrow> get_irq_slot irq;\n     cap_delete_one irq_slot;\n     cap_insert cap slot irq_slot\n   od)\"\n| \"invoke_irq_handler (ClearIRQHandler irq) = (do\n     irq_slot \\<leftarrow> get_irq_slot irq;\n     cap_delete_one irq_slot\n   od)\"", "property": "IRQHandler Operations: Manage the delivery and acknowledgment of interrupts by configuring or clearing the Notification capabilities in the relevant per-IRQ slot. This ensures that interrupts are properly handled and acknowledged, maintaining the system's responsiveness and stability.", "title": "./spec/abstract/Interrupt_A.thy", "chapter": "", "section": "", "comment": "The IRQHandler capability may be used to configure how interrupts on an\nIRQ are delivered and to acknowledge a delivered interrupt. Interrupts are\ndelivered when Notification capabilities are installed in the relevant per-IRQ\nslot. The IRQHandler operations load or clear those capabilities."}
{"spec": "definition timer_tick :: \"unit det_ext_monad\" where\n  \"timer_tick \\<equiv> do\n     cur \\<leftarrow> gets cur_thread;\n     state \\<leftarrow> get_thread_state cur;\n     case state of Running \\<Rightarrow> do\n       ts \\<leftarrow> ethread_get tcb_time_slice cur;\n       let ts' = ts - 1 in\n       if (ts' > 0) then thread_set_time_slice cur ts' else do\n         thread_set_time_slice cur timeSlice;\n         tcb_sched_action tcb_sched_append cur;\n         reschedule_required\n       od\n     od\n     | _ \\<Rightarrow> return ();\n     when (numDomains > 1) (do\n       dec_domain_time;\n       dom_time \\<leftarrow> gets domain_time;\n       when (dom_time = 0) reschedule_required\n     od)\n   od\"\n\ndefinition\n  handle_interrupt :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"handle_interrupt irq \\<equiv>\n   if irq > maxIRQ then do_machine_op $ do\n    maskInterrupt True irq;\n    ackInterrupt irq\n    od\n  else do\n   st \\<leftarrow> get_irq_state irq;\n   case st of\n     IRQSignal \\<Rightarrow> do\n       slot \\<leftarrow> get_irq_slot irq;\n       cap \\<leftarrow> get_cap slot;\n       when (is_ntfn_cap cap \\<and> AllowSend \\<in> cap_rights cap)\n         $ send_signal (obj_ref_of cap) (cap_ep_badge cap);\n       arch_mask_irq_signal irq\n     od\n   | IRQTimer \\<Rightarrow> do\n       do_extended_op timer_tick;\n       do_machine_op resetTimer\n     od\n   | IRQInactive \\<Rightarrow> fail \\<comment> \\<open>not meant to be able to get IRQs from inactive lines\\<close>\n   | IRQReserved \\<Rightarrow> handle_reserved_irq irq;\n   do_machine_op $ ackInterrupt irq\n   od\"\n\nend", "property": "Handle Interrupt: Processes interrupts by checking the interrupt state and performing appropriate actions. For a timer interrupt, it decrements the current thread's time slice and reschedules if necessary, while for a signal interrupt, it sends a notification if a valid notification capability is present.", "title": "./spec/abstract/Interrupt_A.thy", "chapter": "", "section": "", "comment": "Handle an interrupt occurence. Timing and scheduling details are not\nincluded in this model, so no scheduling action needs to be taken on timer\nticks. If the IRQ has a valid Notification cap loaded a message is\ndelivered."}
{"spec": "type_synonym vm_rights = cap_rights\n\ndefinition vm_kernel_only :: vm_rights\nwhere\n  \"vm_kernel_only \\<equiv> {}\"\n\ndefinition vm_read_only :: vm_rights\nwhere\n  \"vm_read_only \\<equiv> {AllowRead}\"\n\ndefinition vm_read_write :: vm_rights\nwhere\n  \"vm_read_write \\<equiv> {AllowRead,AllowWrite}\"", "property": "Page Access Rights: Define different levels of access rights for pages, including kernel-only access, read-only access, and read-write access.", "title": "./spec/abstract/VMRights_A.thy", "chapter": "", "section": "", "comment": "Page access rights."}
{"spec": "definition valid_vm_rights :: \"vm_rights set\"\nwhere\n  \"valid_vm_rights \\<equiv> {vm_read_write, vm_read_only, vm_kernel_only}\"\n\ndefinition validate_vm_rights :: \"vm_rights \\<Rightarrow> vm_rights\"\nwhere\n  \"validate_vm_rights rs \\<equiv>\n     if AllowRead \\<in> rs\n     then if AllowWrite \\<in> rs then vm_read_write else vm_read_only\n     else vm_kernel_only\"", "property": "Valid Virtual Memory Rights: Ensures that only permitted combinations of virtual-memory rights are used, specifically allowing read-write, read-only, or kernel-only access. The validation function adjusts any given set of rights to the largest permissible subset according to these rules.", "title": "./spec/abstract/VMRights_A.thy", "chapter": "", "section": "", "comment": "\n  Note that only the above combinations of virtual-memory rights are permitted.\n  We introduce the following definitions to reflect this fact:\n  The predicate @{text valid_vm_rights} holds iff a given set of rights is valid\n  (i.e., a permitted combination).\n  The function @{text validate_vm_rights} takes an arbitrary set of rights and\n  returns the largest permitted subset.\n"}
{"spec": "definition mask_vm_rights :: \"vm_rights \\<Rightarrow> cap_rights \\<Rightarrow> vm_rights\"\nwhere\n  \"mask_vm_rights V R \\<equiv> validate_vm_rights (V \\<inter> R)\"\n\nend", "property": "Mask VM Rights: Ensures that the intersection of VM rights and capability rights is valid by applying a validation function, preventing invalid combinations such as `{AllowWrite}`.", "title": "./spec/abstract/VMRights_A.thy", "chapter": "", "section": "", "comment": "On the abstract level, capability and VM rights share the same type.\n  Nevertheless, a simple set intersection might lead to an invalid value like\n  @{term \"{AllowWrite}\"}.  Hence, @{const validate_vm_rights}."}
{"spec": "end", "property": "No code or comment is provided for summarization. Please provide the necessary code and, if available, the comment to generate the property.", "title": "./spec/abstract/Glossary_Doc.thy", "chapter": "", "section": "", "comment": "<"}
{"spec": "text \\<open>Threads that are active always have a master Reply capability to\nthemselves stored in their reply slot. This is so that a derived Reply\ncapability can be generated immediately if they wish to issue one. This function\nsets up a new master Reply capability if one does not exist.\\<close>\ndefinition\n  \"setup_reply_master thread \\<equiv> do\n     old_cap <- get_cap (thread, tcb_cnode_index 2);\n     when (old_cap = NullCap) $ do\n         set_original (thread, tcb_cnode_index 2) True;\n         set_cap (ReplyCap thread True {AllowGrant, AllowWrite}) (thread, tcb_cnode_index 2)\n     od\n  od\"", "property": "Ensure Reply Capability: If a thread does not already have a master Reply capability in its reply slot, this function sets up a new master Reply capability with permissions for granting and writing.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": ""}
{"spec": "definition\n  restart :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"restart thread \\<equiv> do\n    state \\<leftarrow> get_thread_state thread;\n    when (\\<not> runnable state \\<and> \\<not> idle state) $ do\n      cancel_ipc thread;\n      setup_reply_master thread;\n      set_thread_state thread Restart;\n      do_extended_op (tcb_sched_action (tcb_sched_enqueue) thread);\n      do_extended_op (possible_switch_to thread)\n    od\n  od\"", "property": "Thread Reactivation: Reactivates a thread if it is not already running or idle. This involves canceling any ongoing IPC, setting up the reply master, updating the thread state to Restart, and enqueuing the thread for scheduling. If the reactivated thread has higher priority, a context switch may be initiated.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Reactivate a thread if it is not already running."}
{"spec": "definition\n  activate_thread :: \"(unit,'z::state_ext) s_monad\" where\n  \"activate_thread \\<equiv> do\n     thread \\<leftarrow> gets cur_thread;\n     state \\<leftarrow> get_thread_state thread;\n     (case state\n       of Running \\<Rightarrow> return ()\n        | Restart \\<Rightarrow> (do\n            pc \\<leftarrow> as_user thread getRestartPC;\n            as_user thread $ setNextPC pc;\n            set_thread_state thread Running\n          od)\n        | IdleThreadState \\<Rightarrow> arch_activate_idle_thread thread\n        | _ \\<Rightarrow> fail)\n   od\"", "property": "Thread Activation: Activates the current thread by setting its state to running, restarting it with the correct program counter if necessary, and handling the idle thread specially.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "This action is performed at the end of a system call immediately before\ncontrol is restored to a used thread. If it needs to be restarted then its\nprogram counter is set to the operation it was performing rather than the next\noperation. The idle thread is handled specially."}
{"spec": "definition\n  load_word_offs :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n \"load_word_offs ptr offs \\<equiv>\n    do_machine_op $ loadWord (ptr + of_nat (offs * word_size))\"\ndefinition\n  load_word_offs_word :: \"obj_ref \\<Rightarrow> data \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n \"load_word_offs_word ptr offs \\<equiv>\n    do_machine_op $ loadWord (ptr + (offs * word_size))\"", "property": "Load Word Offsets: Retrieve a machine word from a specified offset in an object's memory. The function supports loading words using both natural number and data type offsets, ensuring flexibility in accessing memory contents.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": ""}
{"spec": "definition\n  copy_mrs :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> obj_ref \\<Rightarrow>\n               obj_ref option \\<Rightarrow> length_type \\<Rightarrow> (length_type,'z::state_ext) s_monad\" where\n  \"copy_mrs sender sbuf receiver rbuf n \\<equiv>\n   do\n     hardware_mrs \\<leftarrow> return $ take (unat n) msg_registers;\n     mapM (\\<lambda>r. do\n         v \\<leftarrow> as_user sender $ getRegister r;\n         as_user receiver $ setRegister r v\n       od) hardware_mrs;\n     buf_mrs \\<leftarrow> case (sbuf, rbuf) of\n       (Some sb_ptr, Some rb_ptr) \\<Rightarrow> mapM (\\<lambda>x. do\n                                       v \\<leftarrow> load_word_offs sb_ptr x;\n                                       store_word_offs rb_ptr x v\n                                     od)\n               [length msg_registers + 1 ..< Suc (unat n)]\n     | _ \\<Rightarrow> return [];\n     return $ min n $ nat_to_len $ length hardware_mrs + length buf_mrs\n   od\"", "property": "Copy Message Registers: Copy a specified number of message registers from the sender thread to the receiver thread, including both hardware and buffer message registers. The function ensures that the values are correctly transferred and returns the total number of registers copied.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Copy message registers from one thread to another."}
{"spec": "definition\n  get_tcb_ctable_ptr :: \"obj_ref \\<Rightarrow> cslot_ptr\" where\n  \"get_tcb_ctable_ptr tcb_ref \\<equiv> (tcb_ref, tcb_cnode_index 0)\"\n\ndefinition\n  get_tcb_vtable_ptr :: \"obj_ref \\<Rightarrow> cslot_ptr\" where\n  \"get_tcb_vtable_ptr tcb_ref \\<equiv> (tcb_ref, tcb_cnode_index 1)\"", "property": "TCB CTable and VTable Access: Retrieve the capability table (ctable) and virtual address table (vtable) pointers for a given TCB. These pointers are used to access the specific slots in the TCB's cnode.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "The ctable and vtable slots of the TCB."}
{"spec": "definition\n  option_update_thread :: \"obj_ref \\<Rightarrow> ('a \\<Rightarrow> tcb \\<Rightarrow> tcb) \\<Rightarrow> 'a option \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"option_update_thread thread fn \\<equiv> case_option (return ()) (\\<lambda>v. thread_set (fn v) thread)\"", "property": "Optional TCB Update: Conditionally update the TCB at a specified address based on the presence of an optional value. If the value is present, apply the given function to update the TCB; otherwise, do nothing.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Optionally update the tcb at an address."}
{"spec": "definition\n  check_cap_at :: \"cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"check_cap_at cap slot m \\<equiv> do\n    cap' \\<leftarrow> get_cap slot;\n    when (same_object_as cap cap') m\n  od\"", "property": "Check Cap at Slot: Ensures that a capability is present at a specified slot before performing an operation. This prevents issues where the parent capability might have been moved or deleted, maintaining the integrity of the capability system.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Check that a related capability is at an address. This is done before\ncalling @{const cap_insert} to avoid a corner case where the would-be parent of\nthe cap to be inserted has been moved or deleted."}
{"spec": "definition\n  bind_notification :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"bind_notification tcbptr ntfnptr \\<equiv> do\n     ntfn \\<leftarrow> get_notification ntfnptr;\n     ntfn' \\<leftarrow> return $ ntfn_set_bound_tcb ntfn (Some tcbptr);\n     set_notification ntfnptr ntfn';\n     set_bound_notification tcbptr $ Some ntfnptr\n   od\"", "property": "Bind Notification: Establishes a binding between a thread and a notification, updating the notification to reference the thread and setting the thread's bound notification.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Helper function for binding notifications"}
{"spec": "fun\n  invoke_tcb :: \"tcb_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"invoke_tcb (Suspend thread) = liftE (do suspend thread; return [] od)\"\n| \"invoke_tcb (Resume thread) = liftE (do restart thread; return [] od)\"\n\n| \"invoke_tcb (ThreadControl target slot faultep mcp priority croot vroot buffer)\n   = doE\n    liftE $ option_update_thread target (tcb_fault_handler_update o K) faultep;\n    liftE $  case mcp of None \\<Rightarrow> return()\n     | Some (newmcp, _) \\<Rightarrow> set_mcpriority target newmcp;\n    (case croot of None \\<Rightarrow> returnOk ()\n     | Some (new_cap, src_slot) \\<Rightarrow> doE\n      cap_delete (target, tcb_cnode_index 0);\n      liftE $ check_cap_at new_cap src_slot\n            $ check_cap_at (ThreadCap target) slot\n            $ cap_insert new_cap src_slot (target, tcb_cnode_index 0)\n    odE);\n    (case vroot of None \\<Rightarrow> returnOk ()\n     | Some (new_cap, src_slot) \\<Rightarrow> doE\n      cap_delete (target, tcb_cnode_index 1);\n      liftE $ check_cap_at new_cap src_slot\n            $ check_cap_at (ThreadCap target) slot\n            $ cap_insert new_cap src_slot (target, tcb_cnode_index 1)\n    odE);\n    (case buffer of None \\<Rightarrow> returnOk ()\n     | Some (ptr, frame) \\<Rightarrow> doE\n      cap_delete (target, tcb_cnode_index 4);\n      liftE $ thread_set (\\<lambda>t. t \\<lparr> tcb_ipc_buffer := ptr \\<rparr>) target;\n      liftE $ case frame of None \\<Rightarrow> return ()\n       | Some (new_cap, src_slot) \\<Rightarrow>\n            check_cap_at new_cap src_slot\n          $ check_cap_at (ThreadCap target) slot\n          $ cap_insert new_cap src_slot (target, tcb_cnode_index 4);\n      cur \\<leftarrow> liftE $ gets cur_thread;\n      liftE $ when (target = cur) (do_extended_op reschedule_required)\n    odE);\n    liftE $ case priority\n              of None \\<Rightarrow> return()\n               | Some (prio, _) \\<Rightarrow> do_extended_op (set_priority target prio);\n    returnOk []\n  odE\"\n\n| \"invoke_tcb (CopyRegisters dest src suspend_source resume_target transfer_frame transfer_integer transfer_arch) =\n  (liftE $ do\n    when suspend_source $ suspend src;\n    when resume_target $ restart dest;\n    when transfer_frame $ do\n        mapM_x (\\<lambda>r. do\n                v \\<leftarrow> as_user src $ getRegister r;\n                as_user dest $ setRegister r v\n        od) frame_registers;\n        pc \\<leftarrow> as_user dest getRestartPC;\n        as_user dest $ setNextPC pc\n    od;\n    when transfer_integer $\n        mapM_x (\\<lambda>r. do\n                v \\<leftarrow> as_user src $ getRegister r;\n                as_user dest $ setRegister r v\n        od) gpRegisters;\n    cur \\<leftarrow> gets cur_thread;\n    arch_post_modify_registers cur dest;\n    when (dest = cur) (do_extended_op reschedule_required);\n    return []\n  od)\"\n\n| \"invoke_tcb (ReadRegisters src suspend_source n arch) =\n  (liftE $ do\n    when suspend_source $ suspend src;\n    self \\<leftarrow> gets cur_thread;\n    regs \\<leftarrow> return (take (unat n) $ frame_registers @ gp_registers);\n    as_user src $ mapM getRegister regs\n  od)\"\n\n| \"invoke_tcb (WriteRegisters dest resume_target values arch) =\n  (liftE $ do\n    self \\<leftarrow> gets cur_thread;\n    b \\<leftarrow> arch_get_sanitise_register_info dest;\n    as_user dest $ do\n        zipWithM (\\<lambda>r v. setRegister r (sanitise_register b r v))\n            (frameRegisters @ gpRegisters) values;\n        pc \\<leftarrow> getRestartPC;\n        setNextPC pc\n    od;\n    arch_post_modify_registers self dest;\n    when resume_target $ restart dest;\n    when (dest = self) (do_extended_op reschedule_required);\n    return []\n  od)\"\n\n| \"invoke_tcb (NotificationControl tcb (Some ntfnptr)) =\n  (liftE $ do\n    bind_notification tcb ntfnptr;\n    return []\n  od)\"\n\n| \"invoke_tcb (NotificationControl tcb None) =\n  (liftE $ do\n    unbind_notification tcb;\n    return []\n  od)\"\n\n| \"invoke_tcb (SetTLSBase tcb tls_base) =\n  (liftE $ do\n    as_user tcb $ setRegister tlsBaseRegister tls_base;\n    cur \\<leftarrow> gets cur_thread;\n    when (tcb = cur) (do_extended_op reschedule_required);\n    return []\n  od)\"\n\ndefinition\n  set_domain :: \"obj_ref \\<Rightarrow> domain \\<Rightarrow> unit det_ext_monad\" where\n  \"set_domain tptr new_dom \\<equiv> do\n     cur \\<leftarrow> gets cur_thread;\n     tcb_sched_action tcb_sched_dequeue tptr;\n     thread_set_domain tptr new_dom;\n     ts \\<leftarrow> get_thread_state tptr;\n     when (runnable ts) (tcb_sched_action tcb_sched_enqueue tptr);\n     when (tptr = cur) reschedule_required\n   od\"\n\ndefinition invoke_domain:: \"obj_ref \\<Rightarrow> domain \\<Rightarrow> (data list,'z::state_ext) p_monad\"\nwhere\n  \"invoke_domain thread domain \\<equiv>\n     liftE (do do_extended_op (set_domain thread domain); return [] od)\"", "property": "TCB Invocation Actions: Allows threads to perform a variety of actions, including suspending and resuming other threads, reconfiguring thread settings (such as fault handlers, priorities, and capability roots), managing IPC buffers, copying and modifying register sets, controlling notifications, and setting the TLS base. These actions ensure that threads can manage their state and capabilities effectively, maintaining the integrity and performance of the system. \n\nDomain Management: Sets the scheduling domain for a thread, ensuring it is correctly dequeued, its domain is updated, and it is re-enqueued if runnable. If the thread being updated is the current thread, a reschedule is required, optimizing the system's scheduling and execution efficiency.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "TCB capabilities confer authority to perform seven actions. A thread can\nrequest to yield its timeslice to another, to suspend or resume another, to\nreconfigure another thread, or to copy register sets into, out of or between\nother threads."}
{"spec": "definition\n  get_mrs :: \"obj_ref \\<Rightarrow> obj_ref option \\<Rightarrow> message_info \\<Rightarrow>\n              (message list,'z::state_ext) s_monad\" where\n  \"get_mrs thread buf info \\<equiv> do\n     context \\<leftarrow> thread_get (arch_tcb_get_registers o tcb_arch) thread;\n     cpu_mrs \\<leftarrow> return (map context msg_registers);\n     buf_mrs \\<leftarrow> case buf\n       of None      \\<Rightarrow> return []\n        | Some pptr \\<Rightarrow> mapM (\\<lambda>x. load_word_offs pptr x)\n               [length msg_registers + 1 ..< Suc msg_max_length];\n     return (take (unat (mi_length info)) $ cpu_mrs @ buf_mrs)\n   od\"\n\nend", "property": "Message Register Retrieval: Collects message registers from both the sending thread's current register file and its IPC buffer, ensuring that all necessary data for the message is gathered.", "title": "./spec/abstract/Tcb_A.thy", "chapter": "Threads and TCBs", "section": "Thread Message Formats", "comment": "Get all of the message registers, both from the sending thread's current\nregister file and its IPC buffer."}
{"spec": "(*\nFormalisation of interrupt handling.\n*)\n\nchapter \"Arch-specific Interrupts\"\n\ntheory ArchInterrupt_A\nimports Ipc_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition handle_reserved_irq :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where \"handle_reserved_irq irq = return ()\"\n\nfun arch_invoke_irq_handler :: \"irq_handler_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"arch_invoke_irq_handler (ACKIrq irq) = (do_machine_op $ maskInterrupt False irq)\"\n| \"arch_invoke_irq_handler _ = return ()\"\n\ndefinition arch_mask_irq_signal :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"arch_mask_irq_signal irq \\<equiv> do_machine_op $ maskInterrupt True irq\"\n\nend\n\nend", "property": "Arch-specific Interrupt Handling: Manages the handling of reserved interrupts and invokes interrupt handlers, including acknowledging and masking interrupts.", "title": "./spec/abstract/ARM/ArchInterrupt_A.thy", "chapter": "Arch-specific Interrupts", "section": "", "comment": ""}
{"spec": "definition\n  arch_switch_to_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_switch_to_thread t \\<equiv> do\n     set_vm_root t;\n     do_machine_op $ clearExMonitor\n   od\"", "property": "Switch to Thread's Virtual Address Space: Transition the system to a specified thread's virtual address space context and clear the load-exclusive monitor, ensuring that the memory operations are correctly aligned with the new context.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "Switch to a thread's virtual address space context. Clear the load-exclusive monitor."}
{"spec": "definition\n   arch_switch_to_idle_thread :: \"(unit,'z::state_ext) s_monad\" where\n   \"arch_switch_to_idle_thread \\<equiv> do\n     thread \\<leftarrow> gets idle_thread;\n     set_vm_root thread\n   od\"\n\ndefinition\n  arch_activate_idle_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_activate_idle_thread t \\<equiv> return ()\"", "property": "Clear Globals Frame on Idle Thread Switch: When switching to the idle thread, the global frame is cleared to facilitate information flow reasoning.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": " Clear the globals frame when switching to the idle thread. This is\n    specificially to ease infoflow reasoning VER-207 "}
{"spec": "definition\nperform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_control_invocation iv \\<equiv> case iv of\n  MakePool frame slot parent base \\<Rightarrow> do\n    delete_objects frame page_bits;\n    pcap \\<leftarrow> get_cap parent;\n    set_cap (max_free_index_update pcap) parent;\n    retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n    cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n    assert (base && mask asid_low_bits = 0);\n    asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n    modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>arm_asid_table := asid_table'\\<rparr>\\<rparr>)\nod\"", "property": "ASID Control Invocation: Creates a new ASID pool object, provides a capability to it, and connects it to the global virtual ASID table. This ensures that the ASID pool is properly initialized and integrated into the system's memory management, maintaining the integrity and efficiency of address space identification.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDControl capability confers the authority to create a new ASID\npool object. This operation creates the new ASID pool, provides a capability\nto it and connects it to the global virtual ASID table."}
{"spec": "definition\nperform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_pool_invocation iv \\<equiv> case iv of Assign asid pool_ptr ct_slot \\<Rightarrow>\ndo\n    pd_cap \\<leftarrow> get_cap ct_slot;\n    case pd_cap of\n      ArchObjectCap (PageDirectoryCap pd_base _) \\<Rightarrow> do\n        pool \\<leftarrow> get_asid_pool pool_ptr;\n        pool' \\<leftarrow> return (pool (ucast asid \\<mapsto> pd_base));\n        set_cap (ArchObjectCap $ PageDirectoryCap pd_base (Some asid)) ct_slot;\n        set_asid_pool pool_ptr pool'\n      od\n    | _ \\<Rightarrow> fail\nod\"", "property": "Assign ASID to Page Directory: The ASIDPool capability allows the assignment of a virtual ASID to a page directory. This involves updating the page directory's ASID and the ASID pool with the new mapping, ensuring that the page directory is correctly associated with the specified ASID.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign a virtual ASID\nto a page directory."}
{"spec": "definition\n  perform_page_directory_invocation :: \"page_directory_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"perform_page_directory_invocation iv \\<equiv> case iv of\n       PageDirectoryFlush typ start end pstart pd asid \\<Rightarrow>\n         when (start < end) $ do\n           root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n           do_machine_op $ do_flush typ start end pstart;\n           when root_switched $ do\n             tcb \\<leftarrow> gets cur_thread;\n             set_vm_root tcb\n           od\n        od\n     | PageDirectoryNothing \\<Rightarrow> return ()\"\n\ndefinition\n  pte_check_if_mapped :: \"32 word \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pte_check_if_mapped slot \\<equiv> do\n     pt \\<leftarrow> get_master_pte slot;\n     return (pt \\<noteq> InvalidPTE)\n  od\"\n\ndefinition\n  pde_check_if_mapped :: \"32 word \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pde_check_if_mapped slot \\<equiv> do\n     pd \\<leftarrow> get_master_pde slot;\n     return (pd \\<noteq> InvalidPDE)\n  od\"", "property": "Page Directory Invocation: The PageDirectory capability allows for the flushing of cache entries associated with a specific page directory. It ensures that the virtual machine root is set for the flush operation, performs the cache flush, and resets the virtual machine root if it was switched, maintaining the integrity of the memory management system.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "The PageDirectory capability confers the authority to flush cache entries\nassociated with that PD"}
{"spec": "definition\nperform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n\"perform_page_invocation iv \\<equiv> case iv of\n  PageMap asid cap ct_slot entries \\<Rightarrow> do\n    set_cap cap ct_slot;\n    case entries of\n          Inl (pte, slots) \\<Rightarrow> do\n            flush \\<leftarrow> pte_check_if_mapped (hd slots);\n            store_pte (hd slots) pte;\n            mapM (swp store_pte InvalidPTE) (tl slots);\n            do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pte (last slots))\n                                                (addrFromPPtr (hd slots));\n            if flush then (invalidate_tlb_by_asid asid) else return ()\n          od\n        | Inr (pde, slots) \\<Rightarrow> do\n            flush \\<leftarrow> pde_check_if_mapped (hd slots);\n            store_pde (hd slots) pde;\n            mapM (swp store_pde InvalidPDE) (tl slots);\n            do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pde (last slots))\n                                                (addrFromPPtr (hd slots));\n            if flush then (invalidate_tlb_by_asid asid) else return ()\n          od;\n    return []\n  od\n| PageUnmap cap ct_slot \\<Rightarrow>\n    (case cap of\n      PageCap dev p R vp_size vp_mapped_addr \\<Rightarrow> do\n        case vp_mapped_addr of\n            Some (asid, vaddr) \\<Rightarrow> unmap_page vp_size asid vaddr p\n          | None \\<Rightarrow> return ();\n        cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n        set_cap (ArchObjectCap $ update_map_data cap None) ct_slot;\n        return []\n      od\n    | _ \\<Rightarrow> fail)\n| PageFlush typ start end pstart pd asid \\<Rightarrow> do\n    when (start < end) $ do\n      root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n      do_machine_op $ do_flush typ start end pstart;\n      when root_switched $ do\n        tcb \\<leftarrow> gets cur_thread;\n        set_vm_root tcb\n      od\n    od;\n    return []\n  od\n| PageGetAddr ptr \\<Rightarrow>\n    return [addrFromPPtr ptr]\n  \"", "property": "Page Capability Operations: The page capability allows for mapping, unmapping, and flushing memory pages. It ensures that pages can be correctly managed in the virtual memory system, including updating page tables, invalidating TLB entries, and cleaning cache ranges as necessary.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "The Page capability confers the authority to map, unmap and flush the\n  memory page."}
{"spec": "definition\nperform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_page_table_invocation iv \\<equiv>\ncase iv of PageTableMap cap ct_slot pde pd_slot \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pde pd_slot pde;\n    do_machine_op $ cleanByVA_PoU pd_slot (addrFromPPtr pd_slot)\n  od\n  | PageTableUnmap (ArchObjectCap (PageTableCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_page_table asid vaddr p;\n      pte_bits \\<leftarrow> return 2;\n      slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + (1 << pt_bits) - 1];\n      mapM_x (swp store_pte InvalidPTE) slots;\n      do_machine_op $ cleanCacheRange_PoU p (p + (1 << pt_bits) - 1)\n                                          (addrFromPPtr p)\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"", "property": "Page Table Management: Authorizes the mapping and unmapping of page tables. It allows setting and storing page directory entries for mapping, and unmaps page tables by invalidating the corresponding page table entries and cleaning the cache.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page\ntables."}
{"spec": "definition\n  arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\" where\n  \"arch_perform_invocation i \\<equiv> liftE $\n    case i of\n      InvokePageTable oper \\<Rightarrow> do\n        perform_page_table_invocation oper;\n        return []\n      od\n    | InvokePageDirectory oper \\<Rightarrow> do\n        perform_page_directory_invocation oper;\n        return []\n      od\n    | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n    | InvokeASIDControl oper \\<Rightarrow> do\n        perform_asid_control_invocation oper;\n        return []\n      od\n    | InvokeASIDPool oper \\<Rightarrow> do\n        perform_asid_pool_invocation oper;\n        return []\n      od\n  \"\n\nend\n\nend", "property": "Architectural Invocation Handling: Dispatches ARM-specific system calls by invoking the appropriate operations for page tables, page directories, pages, ASID control, and ASID pools. Each invocation is handled by a corresponding function that performs the specific operation and returns the result.", "title": "./spec/abstract/ARM/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call despatcher for all ARM-specific system calls."}
{"spec": "chapter \"Handle Hyperviser Fault Event\"\n\ntheory Hypervisor_A\nimports Exceptions_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"word32 \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n\"handle_hypervisor_fault thread ARMNoHypFaults = return ()\"\n\n\nend\nend", "property": "Handle Hypervisor Fault: The system handles hypervisor fault events, specifically returning without action when the fault type is ARMNoHypFaults.", "title": "./spec/abstract/ARM/Hypervisor_A.thy", "chapter": "Handle Hyperviser Fault Event", "section": "", "comment": ""}
{"spec": "definition\n  reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Reserve Memory Region: Reserve a specified number of bytes in memory, potentially tagging the region as kernel data. The function currently acts as a placeholder and does not perform any actual reservation or tagging.", "title": "./spec/abstract/ARM/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory."}
{"spec": "definition vs_apiobj_size where\n  \"vs_apiobj_size ty \\<equiv>\n     case ty of\n       ArchObject SmallPageObj \\<Rightarrow> pageBitsForSize ARMSmallPage\n     | ArchObject LargePageObj \\<Rightarrow> pageBitsForSize ARMLargePage\n     | ArchObject SectionObj \\<Rightarrow> pageBitsForSize ARMSection\n     | ArchObject SuperSectionObj \\<Rightarrow> pageBitsForSize ARMSuperSection\n     | ArchObject PageTableObj \\<Rightarrow> pt_bits\n     | ArchObject PageDirectoryObj \\<Rightarrow> pd_bits\"\n\ndefinition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv> do\n     when (new_type = ArchObject PageDirectoryObj) $ mapM_x copy_global_mappings refs;\n     if \\<not>is_device \\<and>\n        new_type \\<in> {ArchObject SmallPageObj, ArchObject LargePageObj,\n                    ArchObject SectionObj, ArchObject SuperSectionObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_RAM ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else if new_type \\<in> {ArchObject PageTableObj, ArchObject PageDirectoryObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_PoU ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else\n       return ()\n   od\"\n\ndefinition\n  empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context \\<rparr>\"\n\n\nend\n\nend", "property": "Initialization of Architecture-Specific Objects: Initialize architecture-specific objects, such as page directories, page tables, and various page sizes, by setting their sizes and performing cache cleaning operations. The initialization process ensures that the objects are properly configured and ready for use, with specific actions taken based on the type of object and whether it is a device or not.", "title": "./spec/abstract/ARM/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition\n  arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arch_post_cap_deletion _ \\<equiv> return ()\"", "property": "Arch Post Cap Deletion: Perform no additional actions after a capability is deleted.", "title": "./spec/abstract/ARM/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = unit\n\ndefinition\n  arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\"\nwhere\n  \"arch_gen_obj_refs _ = {}\"\n\ndefinition\n  arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_cap_cleanup_opt ac \\<equiv> NullCap\"\n\nend\nend", "property": "Arch-Specific Generic Object References: The system defines arch-specific generic object references, but they are not utilized, as the set of such references for any arch_cap is empty. Additionally, the cleanup operation for arch_caps results in a NullCap, indicating that no specific cleanup is required for these arch-specific capabilities.", "title": "./spec/abstract/ARM/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition\n  init_tcb_ptr :: word32 where\n  \"init_tcb_ptr = kernel_base + 0x2000\"\n\ndefinition\n  init_irq_node_ptr :: word32 where\n  \"init_irq_node_ptr = kernel_base + 0x8000\"", "property": "Dummy Initial State: Defines initial pointers for the TCB and IRQ node within a dummy kernel state, ensuring that the invariants and refinement relation are consistent.", "title": "./spec/abstract/ARM/Init_A.thy", "chapter": "", "section": "", "comment": "\n  This is not a specification of true kernel\n  initialisation. This theory describes a dummy initial state only, to\n  show that the invariants and refinement relation are consistent.\n"}
{"spec": "definition\n  init_globals_frame :: word32 where\n  \"init_globals_frame = kernel_base + 0x5000\"\n\ndefinition\n  init_global_pd :: word32 where\n  \"init_global_pd = kernel_base + 0x60000\"\n\ndefinition\n  \"init_arch_state \\<equiv> \\<lparr>\n    arm_asid_table = Map.empty,\n    arm_hwasid_table = Map.empty,\n    arm_next_asid = 0,\n    arm_asid_map = Map.empty,\n    arm_global_pd = init_global_pd,\n    arm_global_pts = [],\n    arm_kernel_vspace = \\<lambda>ref.\n      if ref \\<in> {kernel_base .. kernel_base + mask 20}\n      then ArmVSpaceKernelWindow\n      else ArmVSpaceInvalidRegion\n  \\<rparr>\"\n\ndefinition\n  [simp]:\n  \"global_pd \\<equiv> (\\<lambda>_. InvalidPDE)( ucast (kernel_base >> 20) := SectionPDE (addrFromPPtr kernel_base) {} 0 {})\"\n\ndefinition\n  \"init_kheap \\<equiv>\n  (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n       then Some (CNode 0 (empty_cnode 0)) else None)\n  (idle_thread_ptr \\<mapsto> TCB \\<lparr>\n    tcb_ctable = NullCap,\n    tcb_vtable = NullCap,\n    tcb_reply = NullCap,\n    tcb_caller = NullCap,\n    tcb_ipcframe = NullCap,\n    tcb_state = IdleThreadState,\n    tcb_fault_handler = replicate word_bits False,\n    tcb_ipc_buffer = 0,\n    tcb_fault = None,\n    tcb_bound_notification = None,\n    tcb_mcpriority = minBound,\n    tcb_arch = init_arch_tcb\n  \\<rparr>,\n  init_globals_frame \\<mapsto> ArchObj (DataPage False ARMSmallPage), \\<comment> \\<open>same reason as why we kept the definition of @{term init_globals_frame}\\<close>\n  init_global_pd \\<mapsto> ArchObj (PageDirectory global_pd)\n  )\"\n\ndefinition\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. Structures_A.IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\n\n\nend", "property": "Initialization of Kernel State: The kernel state is initialized with specific memory regions, including a global page directory and a data page, and an idle thread. The initialization ensures that the kernel has a well-defined starting point, with the necessary structures and objects set up to begin execution. This includes setting up the architecture-specific state, such as the ASID tables and the global page directory, and initializing the kernel heap with the idle thread and other essential components.", "title": "./spec/abstract/ARM/Init_A.thy", "chapter": "", "section": "", "comment": " It is easy to remove a memory slot here, but once if we want to reserve other slots of memory, we have to do the proof of disjoint for example state again.\n   Comment is left here so that next time we need 4k memory, we don't need to fix example state and can simply change its name. "}
{"spec": "definition largePagePTE_offsets :: \"obj_ref list\"\n  where\n  \"largePagePTE_offsets \\<equiv>\n    let pts = of_nat 2\n    in [0, 2 ^ pts  .e.  (15 << 2)]\"\n\ndefinition superSectionPDE_offsets :: \"obj_ref list\"\n  where\n  \"superSectionPDE_offsets \\<equiv>\n    let pts = of_nat 2\n    in [0, 2 ^ pts  .e.  (15 << 2)]\"\n\nfun create_mapping_entries ::\n  \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vm_rights \\<Rightarrow> vm_attributes \\<Rightarrow> word32 \\<Rightarrow>\n  ((pte * word32 list) + (pde * word32 list),'z::state_ext) se_monad\"\nwhere\n  \"create_mapping_entries base vptr ARMSmallPage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (SmallPagePTE base (attrib - {Global, ParityEnabled})\n                                 vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMLargePage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (LargePagePTE base (attrib - {Global, ParityEnabled})\n                                 vm_rights, map (\\<lambda>x. x + p) largePagePTE_offsets)\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SectionPDE base (attrib - {Global}) 0 vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSuperSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SuperSectionPDE base (attrib - {Global}) vm_rights, map (\\<lambda>x. x + p) superSectionPDE_offsets)\n  odE\"\n\ndefinition get_master_pde :: \"word32 \\<Rightarrow> (pde,'z::state_ext)s_monad\"\n  where \"get_master_pde ptr \\<equiv> do\n    pde \\<leftarrow> (get_pde (ptr && ~~ mask 6));\n    (case pde of SuperSectionPDE _ _ _ \\<Rightarrow> return pde\n    | _ \\<Rightarrow> get_pde ptr)\n  od\"\n\ndefinition get_master_pte :: \"word32 \\<Rightarrow> (pte, 'z::state_ext)s_monad\"\n  where \"get_master_pte ptr \\<equiv> do\n    pte \\<leftarrow> (get_pte (ptr && ~~ mask 6));\n    (case pte of LargePagePTE _ _ _ \\<Rightarrow> return pte\n    | _ \\<Rightarrow> get_pte ptr)\n  od\"", "property": "Create Mapping Entries: Generate the necessary page table entries (PTEs) or page directory entries (PDEs) to map a given frame size at a specified virtual address, ensuring the correct attributes and rights are applied. The function handles different frame sizes, including small pages, large pages, sections, and super sections, and calculates the appropriate offsets for large and super section mappings.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Save the set of entries that would be inserted into a page table or\npage directory to map various different sizes of frame at a given virtual\naddress."}
{"spec": "fun ensure_safe_mapping ::\n  \"(pte * word32 list) + (pde * word32 list) \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n\"ensure_safe_mapping (Inl (InvalidPTE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inl (SmallPagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda>slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | SmallPagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst)\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inl (LargePagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | LargePagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inr (InvalidPDE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inr (PageTablePDE _ _ _, _)) = fail\"\n|\n\"ensure_safe_mapping (Inr (SectionPDE _ _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SectionPDE _ _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"\n|\n\"ensure_safe_mapping (Inr (SuperSectionPDE _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SuperSectionPDE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"", "property": "Ensure Safe Mapping: Verify that new page table entries (PTEs) or page directory entries (PDEs) replace either invalid entries or entries of the same granularity, preventing unsafe mappings within larger frames.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Placing an entry which maps a frame within the set of entries that map a\nlarger frame is unsafe. This function checks that given entries replace either\ninvalid entries or entries of the same granularity."}
{"spec": "definition\nlookup_ipc_buffer :: \"bool \\<Rightarrow> word32 \\<Rightarrow> (word32 option,'z::state_ext) s_monad\" where\n\"lookup_ipc_buffer is_receiver thread \\<equiv> do\n    buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n    buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n    buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n    (case buffer_cap of\n      ArchObjectCap (PageCap _ p R vms _) \\<Rightarrow>\n        if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n        then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n        else return None\n    | _ \\<Rightarrow> return None)\nod\"", "property": "Lookup IPC Buffer: Verify a thread's authority to access its IPC buffer. Check if the thread has the necessary read or write permissions based on whether it is the receiver or not.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Look up a thread's IPC buffer and check that the thread has the right\nauthority to read or (in the receiver case) write to it."}
{"spec": "definition\nfind_pd_for_asid :: \"asid \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"find_pd_for_asid asid \\<equiv> doE\n    assertE (asid > 0);\n    asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n    pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of asid));\n    pool \\<leftarrow> (case pool_ptr of\n               Some ptr \\<Rightarrow> liftE $ get_asid_pool ptr\n             | None \\<Rightarrow> throwError InvalidRoot);\n    pd \\<leftarrow> returnOk (pool (ucast asid));\n    (case pd of\n          Some ptr \\<Rightarrow> returnOk ptr\n        | None \\<Rightarrow> throwError InvalidRoot)\nodE\"", "property": "Locate Page Directory: Find the page directory associated with a given virtual ASID by checking the ASID table and the corresponding ASID pool. If the ASID or the page directory is not found, an error is thrown.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory associated with a given virtual ASID."}
{"spec": "definition\nfind_pd_for_asid_assert :: \"asid \\<Rightarrow> (word32,'z::state_ext) s_monad\" where\n\"find_pd_for_asid_assert asid \\<equiv> do\n   pd \\<leftarrow> find_pd_for_asid asid <catch> K fail;\n   get_pde pd;\n   return pd\n od\"", "property": "Locate and Validate Page Directory: Find the page directory for a given ASID, ensuring that the process is successful and returns a valid pointer to a real page directory.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory and check that this process succeeds and\nreturns a pointer to a real page directory."}
{"spec": "fun\nhandle_vm_fault :: \"word32 \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n\"handle_vm_fault thread ARMDataAbort = doE\n    addr \\<leftarrow> liftE $ do_machine_op getFAR;\n    fault \\<leftarrow> liftE $ do_machine_op getDFSR;\n    throwError $ ArchFault $ VMFault addr [0, fault && mask 14]\nodE\"\n|\n\"handle_vm_fault thread ARMPrefetchAbort = doE\n    pc \\<leftarrow> liftE $ as_user thread $ getRestartPC;\n    fault \\<leftarrow> liftE $ do_machine_op getIFSR;\n    throwError $ ArchFault $ VMFault pc [1, fault && mask 14]\nodE\"", "property": "Handle VM Fault: Format and propagate a virtual machine fault message to the thread's supervisor after encountering a page fault, including the fault address and type-specific fault information.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Format a VM fault message to be passed to a thread's supervisor after\nit encounters a page fault."}
{"spec": "definition\nload_hw_asid :: \"asid \\<Rightarrow> (hardware_asid option,'z::state_ext) s_monad\" where\n\"load_hw_asid asid \\<equiv> do\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    return $ option_map fst $ asid_map asid\nod\"", "property": "Load Hardware ASID: Retrieve the optional hardware ASID currently associated with a given virtual ASID by consulting the ASID map in the system state.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Load the optional hardware ASID currently associated with this virtual\nASID."}
{"spec": "definition\nstore_hw_asid :: \"asid \\<Rightarrow> hardware_asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"store_hw_asid asid hw_asid \\<equiv> do\n    pd \\<leftarrow> find_pd_for_asid_assert asid;\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    asid_map' \\<leftarrow> return (asid_map (asid \\<mapsto> (hw_asid, pd)));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_map := asid_map' \\<rparr>\\<rparr>);\n    hw_asid_map \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n    hw_asid_map' \\<leftarrow> return (hw_asid_map (hw_asid \\<mapsto> asid));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_hwasid_table := hw_asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Associate a Hardware ASID: Map a virtual ASID to a hardware ASID and update the corresponding page directory. Ensure that both the ASID map and the hardware ASID table are updated to reflect the new association, maintaining the integrity of the address space mappings.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associate a hardware ASID with a virtual ASID."}
{"spec": "definition\ninvalidate_tlb_by_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_tlb_by_asid asid \\<equiv> do\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    (case maybe_hw_asid of\n          None \\<Rightarrow> return ()\n        | Some hw_asid \\<Rightarrow> do_machine_op $ invalidateLocalTLB_ASID hw_asid)\nod\"", "property": "Invalidate TLB by ASID: Clear all TLB mappings associated with a given virtual ASID. If the ASID is mapped to a hardware ASID, invalidate the corresponding TLB entries.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Clear all TLB mappings associated with this virtual ASID."}
{"spec": "definition\nflush_space :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_space asid \\<equiv> do\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    do_machine_op cleanCaches_PoU;\n    (case maybe_hw_asid of\n          None \\<Rightarrow> return ()\n        | Some hw_asid \\<Rightarrow> do_machine_op $ invalidateLocalTLB_ASID hw_asid)\nod\"", "property": "Flush Virtual ASID: Flush all cache and TLB entries associated with a given virtual ASID. If the ASID is mapped to a hardware ASID, invalidate the local TLB for that hardware ASID.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush all cache and TLB entries associated with this virtual ASID."}
{"spec": "definition\ninvalidate_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_asid asid \\<equiv> do\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    asid_map' \\<leftarrow> return (asid_map (asid:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_map := asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Invalidate ASID: Remove the mapping from a specified virtual ASID to its corresponding hardware ASID, ensuring that the ASID is no longer associated with any hardware ASID in the system.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this virtual ASID to a hardware ASID."}
{"spec": "definition\ninvalidate_hw_asid_entry :: \"hardware_asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_hw_asid_entry hw_asid \\<equiv> do\n  hw_asid_map \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n  hw_asid_map' \\<leftarrow> return (hw_asid_map (hw_asid:= None));\n  modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_hwasid_table := hw_asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Invalidate Hardware ASID Entry: Remove the mapping from a specified hardware ASID to any virtual ASID, ensuring that the hardware ASID is no longer associated with any virtual ASID in the system.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this hardware ASID to a virtual ASID."}
{"spec": "definition\ninvalidate_asid_entry :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_asid_entry asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  when (maybe_hw_asid \\<noteq> None) $ invalidate_hw_asid_entry (the maybe_hw_asid);\n  invalidate_asid asid\nod\"", "property": "Invalidate ASID Entry: Remove virtual to physical mappings associated with a given ASID, including invalidating the hardware ASID entry if it exists.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove virtual to physical mappings in either direction involving this\nvirtual ASID."}
{"spec": "definition\nfind_free_hw_asid :: \"(hardware_asid,'z::state_ext) s_monad\" where\n\"find_free_hw_asid \\<equiv> do\n    hw_asid_table \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n    next_asid \\<leftarrow> gets (arm_next_asid \\<circ> arch_state);\n    maybe_asid \\<leftarrow> return (find (\\<lambda>a. hw_asid_table a = None)\n                    (take (length [minBound :: hardware_asid .e. maxBound])\n                        ([next_asid .e. maxBound] @ [minBound .e. next_asid])));\n    (case maybe_asid of\n       Some hw_asid \\<Rightarrow> return hw_asid\n     | None \\<Rightarrow>  do\n            invalidate_asid $ the $ hw_asid_table next_asid;\n            do_machine_op $ invalidateLocalTLB_ASID next_asid;\n            invalidate_hw_asid_entry next_asid;\n            new_next_asid \\<leftarrow> return (next_asid + 1);\n            modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_next_asid := new_next_asid \\<rparr>\\<rparr>);\n            return next_asid\n       od)\nod\"", "property": "Find Free Hardware ASID: Locate an unused hardware ASID, and if none are available, reclaim one in a round-robin manner by invalidating the current next ASID and updating the next ASID pointer.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate a hardware ASID that is not in use, if necessary by reclaiming\none from another virtual ASID in a round-robin manner."}
{"spec": "definition\nget_hw_asid :: \"asid \\<Rightarrow> (hardware_asid,'z::state_ext) s_monad\" where\n\"get_hw_asid asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  (case maybe_hw_asid of\n    Some hw_asid \\<Rightarrow> return hw_asid\n  | None \\<Rightarrow>  do\n      new_hw_asid \\<leftarrow> find_free_hw_asid;\n      store_hw_asid asid new_hw_asid;\n      return new_hw_asid\n  od)\nod\"\n\n\nabbreviation\n  \"arm_context_switch_hwasid pd hwasid \\<equiv> do\n              set_current_pd $ addrFromPPtr pd;\n              setHardwareASID hwasid\n          od\"\n\ndefinition\n  arm_context_switch :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arm_context_switch pd asid \\<equiv> do\n      hwasid \\<leftarrow> get_hw_asid asid;\n      do_machine_op $ arm_context_switch_hwasid pd hwasid\n    od\"", "property": "Hardware ASID Retrieval and Assignment: Retrieve the hardware ASID associated with a given virtual ASID, and if none is assigned, find and assign a new hardware ASID. This ensures that each virtual ASID has a corresponding hardware ASID for proper memory management.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get the hardware ASID associated with a virtual ASID, assigning one if\nnone is already assigned."}
{"spec": "definition\n  set_vm_root :: \"word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"set_vm_root tcb \\<equiv> do\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    (case thread_root of\n       ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow> doE\n           pd' \\<leftarrow> find_pd_for_asid asid;\n           whenE (pd \\<noteq> pd') $ throwError InvalidRoot;\n           liftE $ arm_context_switch pd asid\n       odE\n     | _ \\<Rightarrow> throwError InvalidRoot) <catch>\n    (\\<lambda>_. do\n       global_pd \\<leftarrow> gets (arm_global_pd \\<circ> arch_state);\n       do_machine_op $ set_current_pd $ addrFromKPPtr global_pd\n    od)\nod\"", "property": "Set VM Root: Switch the address space to the given thread's configured page directory, or to the global address space if the thread's configuration is invalid. Ensures that the correct address space is active for the thread, maintaining the integrity of memory access and execution.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch into the address space of a given thread or the global address\nspace if none is correctly configured."}
{"spec": "definition\ndelete_asid_pool :: \"asid \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid_pool base ptr \\<equiv> do\n  assert (base && mask asid_low_bits = 0);\n  asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n  when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n    pool \\<leftarrow> get_asid_pool ptr;\n    mapM (\\<lambda>offset. (when (pool (ucast offset) \\<noteq> None) $ do\n                          flush_space $ base + offset;\n                          invalidate_asid_entry $ base + offset\n                    od)) [0  .e.  (1 << asid_low_bits) - 1];\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_table := asid_table' \\<rparr>\\<rparr>);\n    tcb \\<leftarrow> gets cur_thread;\n    set_vm_root tcb\n  od\nod\"", "property": "ASID Pool Deletion: Before deleting an ASID pool, deactivate all page directories installed in it by flushing and invalidating their entries. This ensures that the ASID pool is safely removed from the system, maintaining the integrity of the virtual memory management.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Before deleting an ASID pool object we must deactivate all page\ndirectories that are installed in it."}
{"spec": "definition\ndelete_asid :: \"asid \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid asid pd \\<equiv> do\n  asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n  (case asid_table (asid_high_bits_of asid) of\n    None \\<Rightarrow> return ()\n  | Some pool_ptr \\<Rightarrow>  do\n     pool \\<leftarrow> get_asid_pool pool_ptr;\n     when (pool (ucast asid) = Some pd) $ do\n                flush_space asid;\n                invalidate_asid_entry asid;\n                pool' \\<leftarrow> return (pool (ucast asid := None));\n                set_asid_pool pool_ptr pool';\n                tcb \\<leftarrow> gets cur_thread;\n                set_vm_root tcb\n            od\n    od)\nod\"", "property": "Delete ASID: Deactivates and removes a page directory from the ASID pool, ensuring that the associated ASID is flushed and invalidated. This process maintains the integrity of the virtual memory system by updating the ASID pool and setting the VM root for the current thread.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "When deleting a page directory from an ASID pool we must deactivate\nit."}
{"spec": "definition\nset_vm_root_for_flush :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n\"set_vm_root_for_flush pd asid \\<equiv> do\n    tcb \\<leftarrow> gets cur_thread;\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    not_is_pd \\<leftarrow> (case thread_root of\n                    ArchObjectCap (PageDirectoryCap cur_pd (Some _)) \\<Rightarrow> return (cur_pd \\<noteq> pd)\n                  | _ \\<Rightarrow> return True);\n    (if not_is_pd then do\n        arm_context_switch pd asid;\n        return True\n    od\n    else return False)\nod\"\n\ndefinition\ndo_flush :: \"flush_type \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\" where\n\"do_flush flush_type vstart vend pstart \\<equiv>\n    case flush_type of\n       Clean \\<Rightarrow> cleanCacheRange_RAM vstart vend pstart\n     | Invalidate \\<Rightarrow> invalidateCacheRange_RAM vstart vend pstart\n     | CleanInvalidate \\<Rightarrow> cleanInvalidateCacheRange_RAM vstart vend pstart\n     | Unify \\<Rightarrow> do\n         cleanCacheRange_PoU vstart vend pstart;\n         dsb;\n         invalidateCacheRange_I vstart vend pstart;\n         branchFlushRange vstart vend pstart;\n         isb\n     od\"", "property": "Set VM Root for Flush: Switch to a specific address space to perform a flush operation by checking and potentially updating the current thread's virtual memory root. If the current page directory does not match the target, a context switch is performed.\n\nFlush Operations: Perform different types of cache flush operations (clean, invalidate, clean and invalidate, or unify) on a specified range of virtual addresses, ensuring that the cache is synchronized with main memory.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch to a particular address space in order to perform a flush\noperation."}
{"spec": "definition\nflush_table :: \"word32 \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_table pd asid vptr pt \\<equiv> do\n    assert (vptr && mask (pageBitsForSize ARMSection) = 0);\n    root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    when (maybe_hw_asid \\<noteq> None) $ do\n      hw_asid \\<leftarrow> return (the maybe_hw_asid);\n      do_machine_op $ invalidateLocalTLB_ASID hw_asid;\n      when root_switched $ do\n        tcb \\<leftarrow> gets cur_thread;\n        set_vm_root tcb\n      od\n    od\nod\"", "property": "Flush Page Table Mappings: Invalidate the local TLB for a given ASID and flush mappings associated with a page table. Ensure that the virtual pointer is aligned to the section size, and if the hardware ASID is present, perform the TLB invalidation. If the root has been switched during the process, reset the VM root for the current thread.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a page table."}
{"spec": "definition\nflush_page :: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_page page_size pd asid vptr\\<equiv> do\n    assert (vptr && mask pageBits = 0);\n    root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    when (maybe_hw_asid \\<noteq> None) $ do\n      hw_asid \\<leftarrow> return (the maybe_hw_asid);\n      do_machine_op $ invalidateLocalTLB_VAASID (vptr || ucast hw_asid);\n      when root_switched $ do\n          tcb \\<leftarrow> gets cur_thread;\n          set_vm_root tcb\n      od\n   od\nod\"", "property": "Flush Page Mappings: Invalidate the mappings associated with a given page in the virtual memory, ensuring that the Translation Lookaside Buffer (TLB) is updated. If a hardware ASID is present, it is used to invalidate the TLB entry, and the virtual machine root is reset if it was switched during the operation.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a given page."}
{"spec": "definition\npage_table_mapped :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\" where\n\"page_table_mapped asid vaddr pt \\<equiv> doE\n    pd \\<leftarrow> find_pd_for_asid asid;\n    pd_slot \\<leftarrow> returnOk $ lookup_pd_slot pd vaddr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    case pde of\n      PageTablePDE addr _ _ \\<Rightarrow> returnOk $\n             if addrFromPPtr pt = addr then Some pd else None\n    | _ \\<Rightarrow> returnOk None\nodE <catch> (K $ return None)\"", "property": "Page Table Mapping: Determine the page directory in which a given page table is mapped, if any. This involves finding the page directory for the specified ASID, locating the appropriate slot, and checking if the page table address matches the one in the page directory entry.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Return the optional page directory a page table is mapped in."}
{"spec": "definition\nunmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page_table asid vaddr pt \\<equiv> do\n    pdOpt \\<leftarrow> page_table_mapped asid vaddr pt;\n    case pdOpt of\n      None \\<Rightarrow> return ()\n    | Some pd \\<Rightarrow> do\n        pd_slot \\<leftarrow> return $ lookup_pd_slot pd vaddr;\n        store_pde pd_slot InvalidPDE;\n        do_machine_op $ cleanByVA_PoU pd_slot (addrFromPPtr pd_slot);\n        flush_table pd asid vaddr pt\n    od\nod\"", "property": "Unmap Page Table: Unmaps a specified page table from its page directory. If the page table is mapped, it invalidates the corresponding page directory entry, cleans the cache, and flushes the table to ensure the changes are effective.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a page table from its page directory."}
{"spec": "definition\ncheck_mapping_pptr :: \"obj_ref \\<Rightarrow> vmpage_size \\<Rightarrow> (obj_ref + obj_ref) \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n\"check_mapping_pptr pptr pgsz tablePtr \\<equiv> case tablePtr of\n   Inl ptePtr \\<Rightarrow> do\n     pte \\<leftarrow> get_pte ptePtr;\n     return $ case pte of\n       SmallPagePTE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSmallPage\n     | LargePagePTE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMLargePage\n     | _ \\<Rightarrow> False\n   od\n | Inr pdePtr \\<Rightarrow> do\n     pde \\<leftarrow> get_pde pdePtr;\n     return $ case pde of\n       SectionPDE x _ _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSection\n     | SuperSectionPDE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSuperSection\n     | _ \\<Rightarrow> False\n   od\"\n\n\ndefinition\n  \"last_byte_pte x \\<equiv> let pte_bits = 2 in x + ((1 << pte_bits) - 1)\"\n\ndefinition\n  \"last_byte_pde x \\<equiv> let pde_bits = 2 in x + ((1 << pde_bits) - 1)\"", "property": "Check Mapping: Verify that a given frame is correctly mapped by a specified mapping entry. The function checks if the physical address and page size of the frame match the corresponding values in the page table or page directory entry.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Check that a given frame is mapped by a given mapping entry."}
{"spec": "definition\nunmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page pgsz asid vptr pptr \\<equiv> doE\n    pd \\<leftarrow> find_pd_for_asid asid;\n    (case pgsz of\n          ARMSmallPage \\<Rightarrow> doE\n            p \\<leftarrow> lookup_pt_slot pd vptr;\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inl p);\n            liftE $ do\n                store_pte p InvalidPTE;\n                do_machine_op $ cleanByVA_PoU p (addrFromPPtr p)\n            od\n          odE\n        | ARMLargePage \\<Rightarrow> doE\n            p \\<leftarrow> lookup_pt_slot pd vptr;\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inl p);\n            liftE $ do\n                assert $ p && mask 6 = 0;\n                slots \\<leftarrow> return (map (\\<lambda>x. x + p) [0, 4  .e.  60]);\n                mapM (swp store_pte InvalidPTE) slots;\n                do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pte (last slots))\n                                                    (addrFromPPtr (hd slots))\n            od\n          odE\n        | ARMSection \\<Rightarrow> doE\n            p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inr p);\n            liftE $ do\n                store_pde p InvalidPDE;\n                do_machine_op $ cleanByVA_PoU p (addrFromPPtr p)\n            od\n          odE\n        | ARMSuperSection \\<Rightarrow> doE\n            p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inr p);\n            liftE $ do\n                assert $ p && mask 6 = 0;\n                slots \\<leftarrow> return (map (\\<lambda>x. x + p) [0, 4  .e.  60]);\n                mapM (swp store_pde InvalidPDE) slots;\n                do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pde (last slots))\n                                                    (addrFromPPtr (hd slots))\n            od\n          odE);\n    liftE $ flush_page pgsz pd asid vptr\nodE <catch> (K $ return ())\"", "property": "Unmap Page: Unmaps a page from the virtual address space if the given mapping details are still current. This involves locating the appropriate page directory, checking the mapping, invalidating the page table entries or page directory entries, and cleaning the cache. The operation ensures that the page is properly unmapped and the cache is updated to reflect the changes.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition\n  arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\"\nwhere\n  \"arch_derive_cap c \\<equiv> case c of\n     PageTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageTableCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageDirectoryCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageDirectoryCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageCap dev r R pgs x \\<Rightarrow> returnOk (ArchObjectCap (PageCap dev r R pgs None))\n   | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n   | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\"", "property": "Arch Derive Capabilities: Ensures that PageTable and PageDirectory capabilities can only be derived if they have a virtual ASID and location assigned, preventing illegal operations and maintaining the integrity of address spaces.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "PageDirectory and PageTable capabilities cannot be copied until they\nhave a virtual ASID and location assigned. This is because page directories\ncannot have multiple current virtual ASIDs and page tables cannot be shared\nbetween address spaces or virtual locations."}
{"spec": "definition\n  arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "Arch Update Cap Data: Ensures that no user-modifiable data is stored in ARM-specific capabilities, maintaining the integrity and security of the capability system.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in ARM-specific capabilities."}
{"spec": "definition\n  arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n    (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n    delete_asid_pool b ptr;\n    return (NullCap, NullCap)\n    od\n  | (PageDirectoryCap ptr (Some a), True) \\<Rightarrow> do\n    delete_asid a ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageTableCap ptr (Some (a, v)), True) \\<Rightarrow> do\n    unmap_page_table a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageCap _ ptr _ s (Some (a, v)), _) \\<Rightarrow> do\n     unmap_page s a v ptr;\n     return (NullCap, NullCap)\n  od\n  | _ \\<Rightarrow> return (NullCap, NullCap)\"\n\n\ndefinition (* prepares a thread for deletion; nothing to do for ARM *)\n  prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"prepare_thread_delete p \\<equiv> return ()\"", "property": "Finalize ARM-Specific Capabilities: Perform necessary actions to finalize ARM-specific capabilities, including deleting ASID pools, page directories, and page tables, and unmapping pages. Upon finalization, the capabilities are replaced with null capabilities.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of ARM-specific\ncapabilities."}
{"spec": "definition\n  is_valid_vtable_root :: \"cap \\<Rightarrow> bool\" where\n  \"is_valid_vtable_root c \\<equiv> \\<exists>r a. c = ArchObjectCap (PageDirectoryCap r (Some a))\"\n\ndefinition\ncheck_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n\"check_valid_ipc_buffer vptr c \\<equiv> case c of\n  (ArchObjectCap (PageCap False _ _ _ _)) \\<Rightarrow> doE\n    whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError;\n    returnOk ()\n  odE\n| _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Valid IPC Buffer Check: Ensures that the virtual address space capability for an IPC buffer is a valid page directory, and checks the alignment of the virtual pointer. If the capability is not a valid page directory or the virtual pointer is not properly aligned, it throws an error.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A thread's virtual address space capability must be to a page directory\nto be valid on the ARM architecture."}
{"spec": "definition\nattribs_from_word :: \"word32 \\<Rightarrow> vm_attributes\" where\n\"attribs_from_word w \\<equiv>\n  let V = (if w !!0 then {PageCacheable} else {});\n      V' = (if w!!1 then insert ParityEnabled V else V)\n  in if w!!2 then insert XNever V' else V'\"", "property": "Decode VM Attributes: Extract and decode the virtual memory attributes from a 32-bit word, setting specific attributes based on the bits within the word. The attributes include PageCacheable, ParityEnabled, and XNever, which are conditionally included based on the corresponding bit values.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Decode a user argument word describing the kind of VM attributes a\nmapping is to have."}
{"spec": "definition\n  update_map_data :: \"arch_cap \\<Rightarrow> (word32 \\<times> word32) option \\<Rightarrow> arch_cap\" where\n  \"update_map_data cap m \\<equiv> case cap of PageCap dev p R sz _ \\<Rightarrow> PageCap dev p R sz m\n                                     | PageTableCap p _ \\<Rightarrow> PageTableCap p m\"", "property": "Update Mapping Data: Modify the mapping data associated with a page or page table capability. This ensures that the capability's metadata is updated to reflect the new mapping information.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Update the mapping data saved in a page or page table capability."}
{"spec": "definition\n  resolve_vaddr :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> ((vmpage_size \\<times> obj_ref) option, 'z::state_ext) s_monad\"\nwhere\n  \"resolve_vaddr pd vaddr \\<equiv> do\n     pd_slot \\<leftarrow> return $ lookup_pd_slot pd vaddr;\n     pde \\<leftarrow> get_master_pde pd_slot;\n     case pde of\n         SectionPDE f _ _ _ \\<Rightarrow> return $ Some (ARMSection, f)\n       | SuperSectionPDE f _ _ \\<Rightarrow> return $ Some (ARMSuperSection, f)\n       | PageTablePDE t _ _ \\<Rightarrow> (do\n           pt \\<leftarrow> return $ ptrFromPAddr t;\n           pte_slot \\<leftarrow> return $ lookup_pt_slot_no_fail pt vaddr;\n           pte \\<leftarrow> get_master_pte pte_slot;\n           case pte of\n               LargePagePTE f _ _ \\<Rightarrow> return $ Some (ARMLargePage, f)\n             | SmallPagePTE f _ _ \\<Rightarrow> return $ Some (ARMSmallPage, f)\n             | _ \\<Rightarrow> return None\n         od)\n       | _ \\<Rightarrow> return None\n   od\"", "property": "Resolve Virtual Address: Determine the frame and size of a given virtual address by traversing the page directory and page table, returning the corresponding frame and page size if the address is valid.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get information about the frame of a given virtual address"}
{"spec": "definition\n  in_user_frame :: \"word32 \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n  \"in_user_frame p s \\<equiv>\n   \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) =\n        Some (ArchObj (DataPage False sz))\"", "property": "Pointer in User Frame: A pointer is considered to be inside a user frame if its top bits, when masked, point to a data page in the kernel heap.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A pointer is inside a user frame if its top bits point to a @{text DataPage}.\n"}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\nend\nend", "property": "Numeric Value Visibility: Ensure the numeric value of `msg_align_bits` is explicitly visible by unfolding and simplifying its definition.", "title": "./spec/abstract/ARM/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition\n  asid_high_bits_of :: \"asid \\<Rightarrow> 7 word\" where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"\n\nlocale_abbrev\n  \"asid_table \\<equiv> \\<lambda>s. arm_asid_table (arch_state s)\"", "property": "Virtual ASID High Bits: Extract the high bits of a virtual ASID, which are used to index into the ASID table for managing address space identifiers in the ARM architecture.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "text \\<open>Manipulate ASID pools, page directories and page tables in the kernel\nheap.\\<close>", "property": "Manipulate VSpace Structures: Access and modify ASID pools, page directories, and page tables within the kernel heap to manage virtual memory mappings and address space identifiers.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\"\n  where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"\n\ndefinition\n  get_asid_pool :: \"obj_ref \\<Rightarrow> (10 word \\<rightharpoonup> obj_ref,'z::state_ext) s_monad\" where\n  \"get_asid_pool ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (ASIDPool pool) \\<Rightarrow> return pool\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_asid_pool :: \"obj_ref \\<Rightarrow> (10 word \\<rightharpoonup> obj_ref) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"set_asid_pool ptr pool \\<equiv> set_object ptr (ArchObj (arch_kernel_obj.ASIDPool pool))\"\n\ndefinition\n  get_pd :: \"obj_ref \\<Rightarrow> (12 word \\<Rightarrow> pde,'z::state_ext) s_monad\" where\n  \"get_pd ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageDirectory pd) \\<Rightarrow> return pd\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pd :: \"obj_ref \\<Rightarrow> (12 word \\<Rightarrow> pde) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pd ptr pd \\<equiv> set_object ptr (ArchObj (PageDirectory pd))\"\n\ndefinition\n  set_current_pd :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_current_pd pd \\<equiv> do\n     dsb;\n     writeTTBR0 ((pd && 0xffffe000) || 0x18);\n     isb\n   od\"", "property": "VSpace Access and Management: Provides functions to get and set ASID pools and page directories, allowing for the manipulation of virtual memory structures. Additionally, it includes a function to set the current page directory in the ARM architecture, ensuring that the translation table base register is updated and the changes are synchronized.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": " declared in Arch as workaround for VER-1099 "}
{"spec": "definition\n  get_pde :: \"obj_ref \\<Rightarrow> (pde,'z::state_ext) s_monad\" where\n  \"get_pde ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pd_bits);\n     offset \\<leftarrow> return ((ptr && mask pd_bits) >> 2);\n     pd \\<leftarrow> get_pd base;\n     return $ pd (ucast offset)\n   od\"\n\ndefinition\n  store_pde :: \"obj_ref \\<Rightarrow> pde \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pde p pde \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pd_bits);\n    offset \\<leftarrow> return ((p && mask pd_bits) >> 2);\n    pd \\<leftarrow> get_pd base;\n    pd' \\<leftarrow> return $ pd (ucast offset := pde);\n    set_pd base pd'\n  od\"\n\n\ndefinition\n  get_pt :: \"obj_ref \\<Rightarrow> (word8 \\<Rightarrow> pte,'z::state_ext) s_monad\" where\n  \"get_pt ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageTable pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pt :: \"obj_ref \\<Rightarrow> (word8 \\<Rightarrow> pte) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pt ptr pt \\<equiv> set_object ptr (ArchObj (PageTable pt))\"", "property": "Page Table and Page Directory Access: Provides functions to retrieve and modify entries in the page directory and page table. The `get_pde` and `store_pde` functions access and update specific entries in the page directory, while `get_pt` and `set_pt` functions handle the retrieval and modification of the entire page table.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PDE in kernel memory\n  and returns the actual PDE."}
{"spec": "definition\n  get_pte :: \"obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\" where\n  \"get_pte ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pt_bits);\n     offset \\<leftarrow> return ((ptr && mask pt_bits) >> 2);\n     pt \\<leftarrow> get_pt base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pte :: \"obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pte p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pt_bits);\n    offset \\<leftarrow> return ((p && mask pt_bits) >> 2);\n    pt \\<leftarrow> get_pt base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pt base pt'\n  od\"", "property": "Page Table Entry Access: Retrieve and store PTEs in the page table. The functions calculate the base address and offset of the PTE, access the page table, and either return or update the PTE at the specified location.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory\n  and returns the actual PTE."}
{"spec": "text \\<open>The kernel window is mapped into every virtual address space from the\n@{term kernel_base} pointer upwards. This function copies the mappings which\ncreate the kernel window into a new page directory object.\\<close>\ndefinition\ncopy_global_mappings :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"copy_global_mappings new_pd \\<equiv> do\n    global_pd \\<leftarrow> gets (arm_global_pd \\<circ> arch_state);\n    pde_bits \\<leftarrow> return 2;\n    pd_size \\<leftarrow> return (1 << (pd_bits - pde_bits));\n    mapM_x (\\<lambda>index. do\n        offset \\<leftarrow> return (index << pde_bits);\n        pde \\<leftarrow> get_pde (global_pd + offset);\n        store_pde (new_pd + offset) pde\n    od) [kernel_base >> 20  .e.  pd_size - 1]\nod\"", "property": "Copy Global Mappings: Copies the mappings that create the kernel window from the global page directory to a new page directory object, ensuring that the kernel window is consistently mapped in every virtual address space.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition\nlookup_pd_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\" where\n\"lookup_pd_slot pd vptr \\<equiv>\n    let pd_index = vptr >> 20\n    in pd + (pd_index << 2)\"", "property": "Compute Page Directory Entry Pointer: Given a page-directory reference and a virtual address, compute the pointer to the corresponding page directory entry in kernel memory.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PDE in kernel memory"}
{"spec": "definition\nlookup_pt_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"lookup_pt_slot pd vptr \\<equiv> doE\n    pd_slot \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    (case pde of\n          PageTablePDE ptab _ _ \\<Rightarrow>   (doE\n            pt \\<leftarrow> returnOk (ptrFromPAddr ptab);\n            pt_index \\<leftarrow> returnOk ((vptr >> 12) && 0xff);\n            pt_slot \\<leftarrow> returnOk (pt + (pt_index << 2));\n            returnOk pt_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability 20)\nodE\"", "property": "Lookup Page Table Slot: Given a page-directory reference and a virtual address, the function computes a pointer to the corresponding page table entry (PTE) in kernel memory. The function fails if the virtual address is mapped on a section or super section, ensuring that only valid PTEs are accessed.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PTE in kernel memory.\n  Note that the function fails if the virtual address is mapped on a section or\n  super section."}
{"spec": "definition\n  lookup_pt_slot_no_fail :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\"\nwhere\n  \"lookup_pt_slot_no_fail pt vptr \\<equiv>\n     let pt_index = ((vptr >> 12) && 0xff)\n     in pt + (pt_index << 2)\"\n\nend\n\nend", "property": "Lookup Page Table Slot: Computes the page table slot address for a given virtual page number (VPN) within a known page table, ensuring that the operation does not fail.", "title": "./spec/abstract/ARM/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pt_slot} when the pd is already known"}
{"spec": "text \\<open>This definition ensures that the given pointer is aligned\nto the given page size.\\<close>\n\ndefinition\n  check_vp_alignment :: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $\n       throwError AlignmentError\"", "property": "Check Virtual Page Alignment: Ensure that the given virtual page pointer is aligned to the specified page size, throwing an alignment error if the condition is not met.", "title": "./spec/abstract/ARM/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "definition\n  label_to_flush_type :: \"invocation_label \\<Rightarrow> flush_type\"\nwhere\n  \"label_to_flush_type label \\<equiv> case label of\n       ArchInvocationLabel ARMPDClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPageClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPDInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPageInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPDCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPageCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPDUnify_Instruction \\<Rightarrow> Unify\n     | ArchInvocationLabel ARMPageUnify_Instruction \\<Rightarrow> Unify\"", "property": "Convert Invocation Label to Flush Type: Maps architecture-specific invocation labels to corresponding flush types, enabling the system to determine the appropriate method for handling data and instruction cache operations.", "title": "./spec/abstract/ARM/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": "This definition converts a user-supplied argument into an\ninvocation label, used to determine the method to invoke.\n"}
{"spec": "text \\<open>This definition decodes architecture-specific invocations.\n\\<close>\n\ndefinition\n  page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\nwhere\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"\n\n\ndefinition\n  arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n\"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n\n  PageDirectoryCap _ _ \\<Rightarrow>\n    if isPDFlushLabel (invocation_type label) then\n    if length args > 1\n    then let start = args ! 0;\n             end = args ! 1\n    in doE\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            whenE (start \\<ge> kernel_base \\<or> end > kernel_base) $ throwError IllegalOperation;\n            (pd,asid) \\<leftarrow> (case cap of\n                    PageDirectoryCap pd (Some asid) \\<Rightarrow> returnOk (pd,asid)\n                  | _ \\<Rightarrow> throwError $ InvalidCapability 0);\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 0;\n            frame_info \\<leftarrow> liftE $ resolve_vaddr pd start;\n            case frame_info of\n                None \\<Rightarrow> returnOk $ InvokePageDirectory PageDirectoryNothing\n              | Some (frame_size, frame_base) \\<Rightarrow>\n                    let base_start = page_base start frame_size;\n                        base_end = page_base (end - 1) frame_size;\n                        offset = start && mask (pageBitsForSize frame_size);\n                        pstart = frame_base + offset\n                    in doE\n                        whenE (base_start \\<noteq> base_end) $ throwError $\n                            RangeError start (base_start + mask (pageBitsForSize frame_size));\n                        returnOk $ InvokePageDirectory $\n                            PageDirectoryFlush (label_to_flush_type (invocation_type label))\n                            start (end - 1) pstart pd asid\n                    odE\n    odE\n    else throwError TruncatedMessage\n    else throwError IllegalOperation\n\n| PageTableCap p mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageTableMap then\n    if length args > 1 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             attr = args ! 1;\n             pd_cap = fst (extra_caps ! 0)\n    in doE\n            whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            whenE (vaddr \\<ge> kernel_base) $ throwError $ InvalidArgument 0;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            pd_index \\<leftarrow> returnOk (shiftr vaddr 20);\n            vaddr' \\<leftarrow> returnOk (vaddr && ~~ mask 20);\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << 2));\n            oldpde \\<leftarrow> liftE $ get_master_pde pd_slot;\n            unlessE (oldpde = InvalidPDE) $ throwError DeleteFirst;\n            pde \\<leftarrow> returnOk (PageTablePDE (addrFromPPtr p)\n                               (attribs_from_word attr \\<inter> {ParityEnabled}) 0);\n            returnOk $ InvokePageTable $\n                PageTableMap\n                (ArchObjectCap $ PageTableCap p (Some (asid, vaddr')))\n                cte pde pd_slot\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageTableUnmap\n    then doE\n            final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n            unlessE final $ throwError RevokeFirst;\n            returnOk $ InvokePageTable $ PageTableUnmap (ArchObjectCap cap) cte\n    odE\n    else throwError IllegalOperation\n\n| PageCap dev p R pgsz mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageMap then\n    if length args > 2 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             rights_mask = args ! 1;\n             attr = args ! 2;\n             pd_cap = fst (extra_caps ! 0)\n        in doE\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            case mapped_address of\n              Some (asid', vaddr') \\<Rightarrow> doE\n                whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n                whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0)\n              odE\n            | None \\<Rightarrow> doE\n                vtop \\<leftarrow> returnOk (vaddr + (1 << (pageBitsForSize pgsz)) - 1);\n                whenE (vtop \\<ge> kernel_base) $ throwError $ InvalidArgument 0\n              odE;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            vm_rights \\<leftarrow> returnOk (mask_vm_rights R (data_to_rights rights_mask));\n            check_vp_alignment pgsz vaddr;\n            entries \\<leftarrow> create_mapping_entries (addrFromPPtr p)\n                                              vaddr pgsz vm_rights\n                                              (attribs_from_word attr) pd;\n            ensure_safe_mapping entries;\n            returnOk $ InvokePage $ PageMap asid\n                (ArchObjectCap $ PageCap dev p R pgsz (Some (asid, vaddr)))\n                cte entries\n        odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageUnmap\n    then  returnOk $ InvokePage $ PageUnmap cap cte\n    else if isPageFlushLabel (invocation_type label) then\n        if length args > 1\n        then let start = args ! 0;\n                 end = args ! 1\n        in doE\n            (asid, vaddr) \\<leftarrow> (case mapped_address of\n                Some a \\<Rightarrow> returnOk a\n              | _ \\<Rightarrow> throwError IllegalOperation);\n            pd \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            page_size \\<leftarrow> returnOk $ 1 << pageBitsForSize pgsz;\n            whenE (start \\<ge> page_size \\<or> end > page_size) $ throwError $ InvalidArgument 0;\n            returnOk $ InvokePage $ PageFlush\n                (label_to_flush_type (invocation_type label)) (start + vaddr)\n                (end + vaddr - 1) (addrFromPPtr p + start) pd asid\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageGetAddress\n    then returnOk $ InvokePage $ PageGetAddr p\n  else  throwError IllegalOperation\n\n| ASIDControlCap \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMASIDControlMakePool then\n    if length args > 1 \\<and> length extra_caps > 1\n    then let index = args ! 0;\n             depth = args ! 1;\n             (untyped, parent_slot) = extra_caps ! 0;\n             root = fst (extra_caps ! 1)\n         in doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            free_set \\<leftarrow> returnOk (- dom asid_table \\<inter> {x. x \\<le> 2 ^ asid_high_bits - 1});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n            base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n            (p,n) \\<leftarrow> (case untyped of UntypedCap False p n f \\<Rightarrow> returnOk (p,n)\n                                    | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            frame \\<leftarrow> (if n = pageBits\n                      then doE\n                        ensure_no_children parent_slot;\n                        returnOk p\n                      odE\n                      else  throwError $ InvalidCapability 1);\n            dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n            ensure_empty dest_slot;\n            returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n        odE\n    else  throwError TruncatedMessage\n    else  throwError IllegalOperation\n\n| ASIDPoolCap p base \\<Rightarrow>\n  if invocation_type label = ArchInvocationLabel ARMASIDPoolAssign then\n  if length extra_caps > 0\n  then\n    let (pd_cap, pd_cap_slot) = extra_caps ! 0\n     in case pd_cap of\n          ArchObjectCap (PageDirectoryCap _ None) \\<Rightarrow> doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n            whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n            whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n            pool \\<leftarrow> liftE $ get_asid_pool p;\n            free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n            returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pd_cap_slot\n          odE\n        | _ \\<Rightarrow>  throwError $ InvalidCapability 1\n  else  throwError TruncatedMessage\n  else  throwError IllegalOperation\"\n\n\ndefinition\n  arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\" where\n \"arch_data_to_obj_type n \\<equiv>\n  if n = 0 then Some PageDirectoryObj\n  else if n = 1 then Some SmallPageObj\n  else if n = 2 then Some LargePageObj\n  else if n = 3 then Some SectionObj\n  else if n = 4 then Some SuperSectionObj\n  else if n = 5 then Some PageTableObj\n  else None\"\n\ndefinition\n  arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"arch_check_irq irq \\<equiv> whenE (irq > maxIRQ) $ throwError (RangeError 0 maxIRQ)\"\n\ndefinition arch_decode_irq_control_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list \\<Rightarrow> (arch_irq_control_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_irq_control_invocation label args src_slot cps \\<equiv>\n    (if invocation_type label = ArchInvocationLabel ARMIRQIssueIRQHandler\n      then if length args \\<ge> 4 \\<and> length cps \\<ge> 1\n        then let irq_word = args ! 0;\n                 trigger = args ! 1;\n                 index = args ! 2;\n                 depth = args ! 3;\n                 cnode = cps ! 0;\n                 irq = ucast irq_word\n        in doE\n          arch_check_irq irq_word;\n          irq_active \\<leftarrow> liftE $ is_irq_active irq;\n          whenE irq_active $ throwError RevokeFirst;\n\n          dest_slot \\<leftarrow> lookup_target_slot cnode (data_to_cptr index) (unat depth);\n          ensure_empty dest_slot;\n\n          returnOk $ ArchIRQControlIssue irq dest_slot src_slot (trigger \\<noteq> 0)\n        odE\n      else throwError TruncatedMessage\n    else throwError IllegalOperation)\"\n\nend\n\nend", "property": "Architecture-specific Invocation Decoding: Decode and validate architecture-specific system calls, including operations on page directories, page tables, pages, ASID controls, and ASID pools. These operations ensure that the system call parameters are correctly interpreted and validated, and appropriate actions such as mapping, unmapping, flushing, and managing ASID pools are performed. \n\n- **Page Directory Operations**: Validate and perform operations like flushing page directories, ensuring valid addresses and permissions.\n- **Page Table Operations**: Map and unmap page tables, ensuring correct alignment and permissions, and handling additional capabilities.\n- **Page Operations**: Map, unmap, and flush pages, ensuring valid addresses, permissions, and alignments.\n- **ASID Control Operations**: Create ASID pools, ensuring free ASIDs and valid frame allocations.\n- **ASID Pool Operations**: Assign ASIDs to page directories, ensuring valid pool and directory associations.\n- **IRQ Control Operations**: Issue IRQ handlers, ensuring valid IRQ numbers and target slots.", "title": "./spec/abstract/ARM/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "datatype flush_type = Clean | Invalidate | CleanInvalidate | Unify\n\ndatatype page_directory_invocation =\n    PageDirectoryFlush (pd_flush_type: flush_type) (pd_flush_start: vspace_ref)\n                       (pd_flush_end: vspace_ref) (pd_flush_pstart: word32)\n                       (pd_flush_pd: obj_ref) (pd_flush_asid: asid)\n  | PageDirectoryNothing\n\ndatatype page_table_invocation =\n    PageTableMap cap cslot_ptr pde obj_ref\n  | PageTableUnmap cap cslot_ptr\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation\n     = PageMap\n         (page_map_asid: asid)\n         (page_map_cap: cap)\n         (page_map_ct_slot: cslot_ptr)\n         (page_map_entries: \"pte \\<times> (obj_ref list) + pde \\<times> (obj_ref list)\")\n     | PageUnmap\n         (page_unmap_cap: arch_cap)\n         (page_unmap_cap_slot: cslot_ptr)\n     | PageFlush\n         (page_flush_type: flush_type)\n         (page_flush_start: vspace_ref)\n         (page_flush_end: vspace_ref)\n         (page_flush_pstart: word32)\n         (page_flush_pd: obj_ref)\n         (page_flush_asid: asid)\n     | PageGetAddr\n         (page_get_paddr: obj_ref)\n\ndatatype arch_invocation\n     = InvokePageTable page_table_invocation\n     | InvokePageDirectory page_directory_invocation\n     | InvokePage page_invocation\n     | InvokeASIDControl asid_control_invocation\n     | InvokeASIDPool asid_pool_invocation\n\ndatatype arch_copy_register_sets = ARMNoExtraRegisters\n\ndefinition \"ArchDefaultExtraRegisters \\<equiv> ARMNoExtraRegisters\"\n\ndatatype arch_irq_control_invocation =\n    ArchIRQControlIssue irq cslot_ptr cslot_ptr bool\n\nend\n\nend", "property": "ARM System Call Arguments: Define the datatypes for arguments used in ARM-specific system calls, including operations for page directory and table management, ASID control, and page manipulation. These datatypes support various actions such as flushing, mapping, and unmapping, ensuring that the system can handle memory and address space management effectively.", "title": "./spec/abstract/ARM/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the various possible\nARM-specific system calls. Selectors are defined for various fields\nfor convenience elsewhere."}
{"spec": "text \\<open>An ASID is simply a word.\\<close>\ntype_synonym asid = \"word32\"\n\ndatatype vm_attribute = ParityEnabled | PageCacheable | Global | XNever\ntype_synonym vm_attributes = \"vm_attribute set\"", "property": "Define Architecture-Specific Capabilities: Introduce an ASID as a 32-bit word and define VM attributes including parity enable, page cacheability, global, and XNever. These attributes are used to specify various memory properties in the system.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific capabilities", "comment": ""}
{"spec": "text \\<open>The ARM kernel supports capabilities for ASID pools and an ASID controller capability,\nalong with capabilities for page directories, page tables, and page mappings.\\<close>\n\ndatatype arch_cap =\n   ASIDPoolCap obj_ref asid\n | ASIDControlCap\n | PageCap bool obj_ref cap_rights vmpage_size \"(asid * vspace_ref) option\"\n | PageTableCap obj_ref \"(asid * vspace_ref) option\"\n | PageDirectoryCap obj_ref \"asid option\"\n\nlemmas arch_cap_cases =\n  arch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P, simplified, rule_format]\n\nlemmas arch_cap_cases_asm =\narch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n  simplified, rule_format, rotated -1]\n\ndefinition\n  is_page_cap :: \"arch_cap \\<Rightarrow> bool\" where\n  \"is_page_cap c \\<equiv> \\<exists>x0 x1 x2 x3 x4. c = PageCap x0 x1 x2 x3 x4\"", "property": "ARM Architecture-Specific Capabilities: Defines a set of architecture-specific capabilities including ASID pools, ASID controller, page directories, page tables, and page mappings. These capabilities are used to manage memory and virtual address spaces in the ARM kernel.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "text \\<open>This section gives the types and auxiliary definitions for the\narchitecture-specific objects: a page directory entry (@{text \"pde\"})\ncontains either an invalid entry, a page table reference, a section\nreference, or a super-section reference; a page table entry contains\neither an invalid entry, a large page, or a small page mapping;\nfinally, an architecture-specific object is either an ASID pool, a\npage table, a page directory, or a data page used to model user\nmemory.\n\\<close>\n\ndatatype pde =\n   InvalidPDE\n | PageTablePDE obj_ref vm_attributes machine_word\n | SectionPDE obj_ref vm_attributes machine_word cap_rights\n | SuperSectionPDE obj_ref vm_attributes cap_rights\n\ndatatype pte =\n   InvalidPTE\n | LargePagePTE obj_ref vm_attributes cap_rights\n | SmallPagePTE obj_ref vm_attributes cap_rights\n\ndatatype arch_kernel_obj =\n   ASIDPool \"10 word \\<rightharpoonup> obj_ref\"\n | PageTable \"word8 \\<Rightarrow> pte\"\n | PageDirectory \"12 word \\<Rightarrow> pde\"\n | DataPage bool vmpage_size\n\nlemmas arch_kernel_obj_cases =\n  arch_kernel_obj.induct[where arch_kernel_obj=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P,\n                         simplified, rule_format]\n\nlemmas arch_kernel_obj_cases_asm =\n  arch_kernel_obj.induct[where arch_kernel_obj=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n                         simplified, rule_format, rotated -1]\n\ndefinition cte_level_bits :: nat where\n  \"cte_level_bits \\<equiv> 4\"\n\nprimrec\n  arch_obj_size :: \"arch_cap \\<Rightarrow> nat\"\nwhere\n  \"arch_obj_size (ASIDPoolCap p as) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (PageCap dev x rs sz as4) = pageBitsForSize sz\"\n| \"arch_obj_size (PageDirectoryCap x as2) = 14\"\n| \"arch_obj_size (PageTableCap x as3) = 10\"\n\nprimrec\n  arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_cap_is_device (PageCap dev x rs sz as4) = dev\"\n| \"arch_cap_is_device ASIDControlCap = False\"\n| \"arch_cap_is_device (ASIDPoolCap p as) = False\"\n| \"arch_cap_is_device (PageTableCap x as3) = False\"\n| \"arch_cap_is_device (PageDirectoryCap x as2) = False\"\n\ndefinition tcb_bits :: nat where\n  \"tcb_bits \\<equiv> 9\"\n\ndefinition endpoint_bits :: nat where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat where\n  \"ntfn_bits \\<equiv> 4\"\n\ndefinition untyped_min_bits :: nat where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat where\n  \"untyped_max_bits \\<equiv> 29\"\n\nprimrec\n  arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\"\nwhere\n  \"arch_kobj_size (ASIDPool p) = pageBits\"\n| \"arch_kobj_size (PageTable pte) = 10\"\n| \"arch_kobj_size (PageDirectory pde) = 14\"\n| \"arch_kobj_size (DataPage dev sz) = pageBitsForSize sz\"\n\nprimrec\n  aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\"\nwhere\n  \"aobj_ref (ASIDPoolCap p as) = Some p\"\n| \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref (PageCap dev x rs sz as4) = Some x\"\n| \"aobj_ref (PageDirectoryCap x as2) = Some x\"\n| \"aobj_ref (PageTableCap x as3) = Some x\"\n\nprimrec (nonexhaustive)\n  acap_rights :: \"arch_cap \\<Rightarrow> cap_rights\"\nwhere\n \"acap_rights (PageCap dev x rs sz as) = rs\"\n\ndefinition\n  acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\" where\n \"acap_rights_update rs ac \\<equiv> case ac of\n    PageCap dev x rs' sz as \\<Rightarrow> PageCap dev x (validate_vm_rights rs) sz as\n  | _                   \\<Rightarrow> ac\"", "property": "Architecture-Specific Objects: Define the structure and properties of architecture-specific objects, including page directory entries (PDEs) and page table entries (PTEs), which can contain various types of mappings and references. Additionally, it defines the size, device status, and object references for different types of architectural capabilities, ensuring that memory and capabilities are correctly managed and referenced in the system.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "datatype\n  aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | SectionObj\n  | SuperSectionObj\n  | PageTableObj\n  | PageDirectoryObj\n  | ASIDPoolObj\n\ndefinition\n  arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\"\nwhere\n  \"arch_is_frame_type aobj \\<equiv> case aobj of\n         SmallPageObj \\<Rightarrow> True\n       | LargePageObj \\<Rightarrow> True\n       | SectionObj \\<Rightarrow> True\n       | SuperSectionObj \\<Rightarrow> True\n       | _ \\<Rightarrow> False\"\n\ndefinition\n  arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\" where\n \"arch_default_cap tp r n dev \\<equiv> case tp of\n  SmallPageObj \\<Rightarrow> PageCap dev r vm_read_write ARMSmallPage None\n  | LargePageObj \\<Rightarrow> PageCap dev r vm_read_write ARMLargePage None\n  | SectionObj \\<Rightarrow> PageCap dev r vm_read_write ARMSection None\n  | SuperSectionObj \\<Rightarrow> PageCap dev r vm_read_write ARMSuperSection None\n  | PageTableObj \\<Rightarrow> PageTableCap r None\n  | PageDirectoryObj \\<Rightarrow> PageDirectoryCap r None\n  | ASIDPoolObj \\<Rightarrow> ASIDPoolCap r 0\" (* unused *)\n\ndefinition\n  default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\" where\n \"default_arch_object tp dev n \\<equiv> case tp of\n    SmallPageObj \\<Rightarrow> DataPage dev ARMSmallPage\n  | LargePageObj \\<Rightarrow> DataPage dev ARMLargePage\n  | SectionObj \\<Rightarrow> DataPage dev ARMSection\n  | SuperSectionObj \\<Rightarrow> DataPage dev ARMSuperSection\n  | PageTableObj \\<Rightarrow> PageTable (\\<lambda>x. InvalidPTE)\n  | PageDirectoryObj \\<Rightarrow> PageDirectory (\\<lambda>x. InvalidPDE)\n  | ASIDPoolObj \\<Rightarrow> ASIDPool (\\<lambda>_. None)\"\n\ntype_synonym hw_asid = word8\n\ntype_synonym arm_vspace_region_uses = \"vspace_ref \\<Rightarrow> arm_vspace_region_use\"", "property": "Architecture-Specific Object Types: Defines a set of ARM-specific object types, including different page sizes, page tables, and ASID pools. Each object type has a corresponding default capability and default object, which are used to initialize the architecture-specific objects with appropriate properties and permissions.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "text \\<open>The architecture-specific state for the ARM model\nconsists of the first level of the ASID table (@{text \"arm_asid_table\"}), a\nmap from hardware ASIDs to seL4 ASIDs (@{text \"arm_hwasid_table\"}),\nthe next hardware ASID to preempt (@{text \"arm_next_asid\"}), the\ninverse map from seL4 ASIDs to hardware ASIDs (first component of\n@{text \"arm_asid_map\"}), and the address of the page directory and\npage tables mapping the shared address space, along with a description\nof this space (@{text \"arm_global_pd\"}, @{text \"arm_global_pts\"}, and\n@{text \"arm_kernel_vspace\"} respectively).\n\nHardware ASIDs are only ever associated with seL4 ASIDs that have a\ncurrently active page directory. The second component of\n@{text \"arm_asid_map\"} values is the address of that page directory.\n\\<close>\n\nend\n\nqualify ARM_A (in Arch)\n\nrecord arch_state =\n  arm_asid_table    :: \"7 word \\<rightharpoonup> obj_ref\"\n  arm_hwasid_table  :: \"ARM_A.hw_asid \\<rightharpoonup> ARM_A.asid\"\n  arm_next_asid     :: ARM_A.hw_asid\n  arm_asid_map      :: \"ARM_A.asid \\<rightharpoonup> (ARM_A.hw_asid \\<times> obj_ref)\"\n  arm_global_pd     :: obj_ref\n  arm_global_pts    :: \"obj_ref list\"\n  arm_kernel_vspace :: ARM_A.arm_vspace_region_uses\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  pd_bits :: \"nat\" where\n  \"pd_bits \\<equiv> pageBits + 2\"\n\ndefinition\n  pt_bits :: \"nat\" where\n  \"pt_bits \\<equiv> pageBits - 2\"", "property": "Architecture-Specific State: The ARM-specific state includes the first level of the ASID table, a mapping from hardware ASIDs to seL4 ASIDs, the next hardware ASID to preempt, an inverse map from seL4 ASIDs to hardware ASIDs along with their associated page directories, and the address and description of the page directory and page tables for the shared address space. This ensures that the architecture-specific details are managed and maintained for efficient memory management and virtualization.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable\n  | APageDirectory\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\"\nwhere\n \"aa_type ao \\<equiv> (case ao of\n           PageTable pt             \\<Rightarrow> APageTable\n         | PageDirectory pd         \\<Rightarrow> APageDirectory\n         | DataPage dev sz          \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n         | ASIDPool f               \\<Rightarrow> AASIDPool)\"", "property": "ARM-Specific Data Types: Define a set of data types for ARM architecture-specific kernel objects, including AASIDPool, APageTable, APageDirectory, AUserData, and ADeviceData. These types are used to classify different kinds of memory management structures and data pages, ensuring that the system can correctly manage and interact with these objects based on their specific roles in the ARM architecture.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "definition\n  badge_bits :: nat where\n  badge_bits_def [simp]: \"badge_bits \\<equiv> 28\"\nend", "property": "Badge Bits Definition: The badge word is defined to have 28 bits.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": "For implementation reasons the badge word has differing amounts of bits"}
{"spec": "qualify ARM_A (in Arch)", "property": "ARM-Specific TCB: Defines architecture-specific data types and structures for the Thread Control Block (TCB) tailored to ARM architecture, ensuring that the TCB can effectively manage and represent ARM-specific thread state and control information.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Arch-specific tcb", "comment": ""}
{"spec": "definition\n  arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\nwhere\n  \"arch_tcb_set_registers regs a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := UserContext regs \\<rparr>\"\n\ndefinition\n  arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\"\nwhere\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\n\nend", "property": "Arch-specific TCB Register Management: Provides functions to set and get user registers in the architecture-specific part of the TCB, ensuring that the register context is correctly updated and accessed.", "title": "./spec/abstract/ARM/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Arch-specific tcb", "comment": "\n  Accessors for the user register part of the @{text \"arch_tcb\"}.\n  (Because @{typ \"register \\<Rightarrow> machine_word\"} might not be equal to @{typ user_context})."}
{"spec": "(*\nFunctions for fault handling.\n*)\n\nchapter \\<open>arch fault related functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\nwhere\n \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData) od\"\n\ndefinition\n  handle_arch_fault_reply :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"handle_arch_fault_reply vmf thread x y \\<equiv> return True\"\n\n\nend\n\nend", "property": "Arch Fault Handling: Generate and handle architecture-specific fault messages. The system constructs a fault message containing the program counter, virtual pointer, and architecture-specific data, and processes the reply to the fault, returning a boolean value indicating successful handling.", "title": "./spec/abstract/ARM/ArchFault_A.thy", "chapter": "arch fault related functions", "section": "", "comment": ""}
{"spec": "(*\nArch-specific functions for the abstract model of CSpace.\n*)\n\nchapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"sanitise_register t r v \\<equiv> case r of\n      CPSR \\<Rightarrow> (v && 0xf8000000) || 0x150\n    | _    \\<Rightarrow> v\"\n\n\ndefinition\n  arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\nwhere\n  \"arch_get_sanitise_register_info t \\<equiv> return False\"\n\ndefinition\n  arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\nwhere\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "Architecture-specific TCB Functions: Provide architecture-specific operations for sanitizing register values and managing post-modification actions. The sanitization function ensures that specific registers, such as the CPSR, are set to valid values, while the post-modification function handles any necessary actions after modifying thread registers.", "title": "./spec/abstract/ARM/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "definition\n  update_cnode_cap_data :: \"data \\<Rightarrow> nat \\<times> data\" where\n \"update_cnode_cap_data w \\<equiv>\n    let\n      guard_bits = 18;\n      guard_size' = unat ((w >> cnode_padding_bits) && mask cnode_guard_size_bits);\n      guard'' = (w >> (cnode_padding_bits + cnode_guard_size_bits)) && mask guard_bits\n    in (guard_size', guard'')\"", "property": "CNode Capability Update: Extract and update the guard size and guard bits from the provided data, ensuring that the new values are correctly masked and shifted to maintain the integrity of the cnode capability.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "On a user request to modify a cnode capability, extract new guard bits and guard."}
{"spec": "definition\n  arch_is_physical :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_is_physical cap \\<equiv> case cap of ASIDControlCap \\<Rightarrow> False | _ \\<Rightarrow> True\"", "property": "Architectural Capabilities: Distinguish between physical and non-physical capabilities, where ASIDControlCap is treated as a non-physical capability, and all other architectural capabilities are considered physical.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "For some purposes capabilities to physical objects are treated\ndifferently to others."}
{"spec": "fun\n  arch_same_region_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_same_region_as (PageCap dev r R s x) (PageCap dev' r' R' s' x') =\n   (let\n     topA = r + (1 << pageBitsForSize s) - 1;\n     topB = r' + (1 << pageBitsForSize s') - 1\n   in r \\<le> r' \\<and> topA \\<ge> topB \\<and> r' \\<le> topB)\"\n| \"arch_same_region_as (PageTableCap r x) (PageTableCap r' x') = (r' = r)\"\n| \"arch_same_region_as (PageDirectoryCap r x) (PageDirectoryCap r' x') = (r' = r)\"\n| \"arch_same_region_as ASIDControlCap ASIDControlCap = True\"\n| \"arch_same_region_as (ASIDPoolCap r a) (ASIDPoolCap r' a') = (r' = r)\"\n| \"arch_same_region_as _ _ = False\"", "property": "Check if Two Architectural Capabilities Refer to the Same or Overlapping Regions: Determine whether two architectural capabilities refer to the same object or if one capability's region is contained within the region of the other. This ensures that the capabilities are compatible in terms of their memory regions.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether the second capability is to the same object or an object\ncontained in the region of the first one."}
{"spec": "definition\n  same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n \"same_aobject_as cp cp' \\<equiv>\n   (case (cp, cp') of\n      (PageCap dev ref _ pgsz _,PageCap dev' ref' _ pgsz' _)\n          \\<Rightarrow> (dev, ref, pgsz) = (dev', ref', pgsz')\n              \\<and> ref \\<le> ref + 2 ^ pageBitsForSize pgsz - 1\n    | _ \\<Rightarrow> arch_same_region_as cp cp')\"", "property": "Check Arch Capabilities for Same Object: Determine if two architecture capabilities refer to the same object by comparing their device, reference, and page size, and ensuring the reference is within the valid range. If they are not of the same type, use a generic region comparison.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "declare same_aobject_as_def[simp]\n\ndefinition\n  arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"arch_is_cap_revocable c c' \\<equiv> False\"\n\nend\nend", "property": "Architectural Capability Revocation: Defines that no capability is revocable by another, as the function always returns false.", "title": "./spec/abstract/ARM/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": " Proofs don't want to see this definition "}
{"spec": "type_synonym obj_ref            = machine_word\ntype_synonym vspace_ref         = machine_word\n\ntype_synonym data               = machine_word\ntype_synonym cap_ref            = \"bool list\"\ntype_synonym length_type        = machine_word\n\ntype_synonym asid_low_len       = 10\ntype_synonym asid_low_index    = \"asid_low_len word\"\n\ntype_synonym asid_high_len      = 7\ntype_synonym asid_high_index    = \"asid_high_len word\"", "property": "Type Instantiation for ARM Architecture: Defines concrete types for abstract type names, including object references, virtual space references, data, capability references, and length types, as well as specific lengths and indices for ASID (Address Space Identifier) components.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object\n  references, user pointers, word-based data, cap references, and so\n  on. This theory provides an instantiation of these names to concrete\n  types for the ARM architecture. Other architectures may have slightly\n  different instantiations.\n"}
{"spec": "type_synonym asid_len           = 17\ntype_synonym asid_rep_len       = machine_word_len\ntype_synonym asid               = \"asid_rep_len word\"", "property": "ASID Representation: The ASID is represented as a machine word, with an invariant that the extra bits beyond the 17-bit ASID length must be zero.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": " Making asid a machine_word means that we need invariants that the extra bits are zero. "}
{"spec": "definition\n  oref_to_data   :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_oref   :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition\n  vref_to_data   :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_vref   :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition\n  nat_to_len     :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition\n  data_to_nat    :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition\n  data_to_16     :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition\n  data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition\n  combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition\n  combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Define conversions between different data types, including identity functions for object and virtual space references, conversion from natural numbers to length types, and bitwise operations for combining notification badges and messages. Additionally, it includes conversions from data to various word sizes and capability pointers.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "With the definitions above, most conversions between abstract\ntype names boil down to just the identity function, some convert from\n@{text word} to @{typ nat} and others between different word sizes\nusing @{const ucast}."}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversion Simplifications: Provide simplification rules for converting between different data types, including object references, virtual references, natural numbers, 16-bit values, and capability pointers. These conversions ensure consistency and facilitate automatic unfolding in proofs.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition\n  slot_bits :: nat where\n  \"slot_bits \\<equiv> 4\"\n\ndefinition\n  msg_label_bits :: nat where\n  [simp]: \"msg_label_bits \\<equiv> 20\"\n\ndefinition\n  new_context :: \"user_context\" where\n  \"new_context \\<equiv> UserContext ((\\<lambda>r. 0) (CPSR := 0x150))\"", "property": "Architecture-Dependent Sizes: Define the standard sizes for slots and message labels, as well as the initial user context, which are specific to the underlying machine architecture.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "The following definitions provide architecture-dependent sizes\n  such as the standard page size and capability size of the underlying\n  machine.\n"}
{"spec": "definition\n  kernel_base :: \"vspace_ref\" where\n  \"kernel_base \\<equiv> 0xe0000000\"\n\ndefinition\n  idle_thread_ptr :: vspace_ref where\n  \"idle_thread_ptr = kernel_base + 0x1000\"\n\nend\n\narch_requalify_consts (A) kernel_base idle_thread_ptr\n\ncontext Arch begin arch_global_naming (A)", "property": "Kernel Virtual Address Reservation: The kernel reserves a specific range of virtual addresses starting from a defined base address in every virtual address space, ensuring that this region is exclusively used by the kernel.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "The lowest virtual address in the kernel window. The kernel reserves the\nvirtual addresses from here up in every virtual address space."}
{"spec": "definition\n  nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\" where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len)\n                           (to_bl (of_nat n :: machine_word))\"\n\ndefinition\n \"msg_info_register \\<equiv> msgInfoRegister\"\ndefinition\n \"msg_registers \\<equiv> msgRegisters\"\ndefinition\n \"cap_register \\<equiv> capRegister\"\ndefinition\n \"badge_register \\<equiv> badgeRegister\"\ndefinition\n \"frame_registers \\<equiv> frameRegisters\"\ndefinition\n \"gp_registers \\<equiv> gpRegisters\"\ndefinition\n \"exception_message \\<equiv> exceptionMessage\"\ndefinition\n \"syscall_message \\<equiv> syscallMessage\"\n\ndatatype arch_fault\n    = VMFault vspace_ref \"machine_word list\"\n\nend\n\nend", "property": "Machine Operation Constants: Define constants for various machine operations, including message information, general-purpose and frame registers, capability and badge registers, and exception and syscall messages. These constants provide a standardized way to reference specific elements in the system's architecture.", "title": "./spec/abstract/ARM/Machine_A.thy", "chapter": "", "section": "", "comment": "Miscellaneous definitions of constants used in modelling machine\noperations."}
{"spec": "arch_requalify_consts\n  maxIRQ\n\nend", "property": "Maximum IRQ Definition: The maximum number of interrupts (maxIRQ) is defined either through the Kernel_Config for ARM architectures or manually for X64 architectures.", "title": "./spec/abstract/X64/ArchInterrupt_A.thy", "chapter": "", "section": "", "comment": " On Arm architectures, maxIRQ is defined in Kernel_Config. On X64 it is defined manually. "}
{"spec": "definition\n  arch_switch_to_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_switch_to_thread t \\<equiv> set_vm_root t\"\n\ndefinition\n   arch_switch_to_idle_thread :: \"(unit,'z::state_ext) s_monad\" where\n   \"arch_switch_to_idle_thread \\<equiv> do\n     thread \\<leftarrow> gets idle_thread;\n     set_vm_root thread\n   od\"\n\ndefinition\n  arch_activate_idle_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_activate_idle_thread t \\<equiv> return ()\"\n\ndefinition\n  \"store_asid_pool_entry pool_ptr asid pml4base \\<equiv> do\n    pool \\<leftarrow> get_asid_pool pool_ptr;\n    pool' \\<leftarrow> return (pool(asid_low_bits_of asid := pml4base));\n    set_asid_pool pool_ptr pool'\n  od\"", "property": "Virtual Address Space Switching: Switch the virtual address space context to a specified thread or the idle thread, ensuring that the correct memory mappings are in place.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "Switch to a thread's virtual address space context."}
{"spec": "definition\nperform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_control_invocation iv \\<equiv> case iv of\n  MakePool frame slot parent base \\<Rightarrow> do\n    delete_objects frame page_bits;\n    pcap \\<leftarrow> get_cap parent;\n    set_cap (max_free_index_update pcap) parent;\n    retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n    cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n    assert (asid_low_bits_of base = 0);\n    asid_table \\<leftarrow> gets (x64_asid_table \\<circ> arch_state);\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n    modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>x64_asid_table := asid_table'\\<rparr>\\<rparr>)\nod\"", "property": "ASID Control: Create a new ASID pool object, provide a capability to it, and connect it to the global virtual ASID table. This ensures that the ASID pool is properly initialized and integrated into the system's memory management.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDControl capability confers the authority to create a new ASID\npool object. This operation creates the new ASID pool, provides a capability\nto it and connects it to the global virtual ASID table."}
{"spec": "definition\nperform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_pool_invocation iv \\<equiv> case iv of Assign asid pool_ptr ct_slot \\<Rightarrow>\ndo\n    pml4_cap \\<leftarrow> get_cap ct_slot;\n    case pml4_cap of\n      ArchObjectCap (PML4Cap pml4_base _) \\<Rightarrow> do\n        set_cap (ArchObjectCap $ PML4Cap pml4_base (Some asid)) ct_slot;\n        store_asid_pool_entry pool_ptr asid (Some pml4_base)\n      od\n    | _ \\<Rightarrow> fail\nod\"\n\n\ndefinition\n  pte_check_if_mapped :: \"obj_ref \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pte_check_if_mapped slot \\<equiv> do\n     pt \\<leftarrow> get_pte slot;\n     return (pt \\<noteq> InvalidPTE)\n  od\"\n\ndefinition\n  pde_check_if_mapped :: \"obj_ref \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pde_check_if_mapped slot \\<equiv> do\n     pd \\<leftarrow> get_pde slot;\n     return (pd \\<noteq> InvalidPDE)\n  od\"\n\ndefinition\n  perform_page_invocation_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"perform_page_invocation_unmap cap ct_slot \\<equiv>\n      (case cap\n         of PageCap dev base rights map_type sz mapped \\<Rightarrow> do\n            case mapped of Some (asid, vaddr) \\<Rightarrow> unmap_page sz asid vaddr base\n                          | None \\<Rightarrow> return ();\n            cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n            set_cap (ArchObjectCap $ update_map_data cap None (Some VMNoMap)) ct_slot\n          od\n      | _ \\<Rightarrow> fail)\"", "property": "ASID Pool Assignment: Assigns a virtual ASID to a page directory, updating the capability and storing the ASID pool entry. Ensures that the page directory is correctly associated with the specified ASID, facilitating proper memory management and virtual address translation.\n\nPage Unmapping: Unmaps a page from the specified ASID and virtual address, updating the capability to reflect the unmapped state. Ensures that the page is no longer accessible in the virtual address space, maintaining the integrity of the memory management system.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign a virtual ASID\nto a page directory."}
{"spec": "definition\nperform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n\"perform_page_invocation iv \\<equiv> case iv of\n    PageMap cap ct_slot entries vspace \\<Rightarrow> do\n      set_cap cap ct_slot;\n      case entries of\n          (VMPTE pte, slot) \\<Rightarrow> store_pte slot pte\n        | (VMPDE pde, slot) \\<Rightarrow> store_pde slot pde\n        | (VMPDPTE pdpte, slot) \\<Rightarrow> store_pdpte slot pdpte;\n      asid \\<leftarrow> case cap of\n                  ArchObjectCap (PageCap _ _ _ _ _ (Some (as, _))) \\<Rightarrow> return as\n                | _ \\<Rightarrow> fail;\n      invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid;\n      return []\n    od\n  | PageUnmap cap ct_slot \\<Rightarrow>\n      (case cap of\n        PageCap dev base rights map_type sz mapped \\<Rightarrow> do\n            case mapped of\n              Some _ \\<Rightarrow> (case map_type of\n                          VMVSpaceMap \\<Rightarrow> perform_page_invocation_unmap cap ct_slot\n                        | _ \\<Rightarrow> fail)\n            | None \\<Rightarrow> return ();\n            return []\n        od\n      | _ \\<Rightarrow> fail)\n\\<^cancel>\\<open>| PageIOMap asid cap ct_slot entries \\<Rightarrow> undefined\\<close>\n  | PageGetAddr ptr \\<Rightarrow>\n      return [addrFromPPtr ptr]\"", "property": "Page Management: Allows the manipulation of memory pages, including mapping, unmapping, and flushing. The page capability is used to set or remove page table entries and invalidate the page structure cache, ensuring that the memory management operations are performed securely and efficiently.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "The Page capability confers the authority to map, unmap and flush the\n  memory page."}
{"spec": "definition\nperform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_page_table_invocation iv \\<equiv>\ncase iv of PageTableMap cap ct_slot pde pd_slot vspace \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pde pd_slot pde;\n    asid <- case cap of ArchObjectCap (PageTableCap  _ (Some (as, _))) \\<Rightarrow> return as\n            | _ \\<Rightarrow> fail;\n    invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n  od\n  | PageTableUnmap (ArchObjectCap (PageTableCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_page_table asid vaddr p;\n      pte_bits \\<leftarrow> return word_size_bits;\n      slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + (1 <<  pt_bits) - 1];\n      mapM_x (swp store_pte InvalidPTE) slots\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"", "property": "Page Table Management: Allows the mapping and unmapping of page tables. It involves setting and storing page directory entries, invalidating page structure caches, and updating capability mappings. Unmapping includes removing the page table from the address space, clearing relevant slots, and updating the capability to reflect the unmapped state.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page tables."}
{"spec": "definition\nperform_page_directory_invocation :: \"page_directory_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_page_directory_invocation iv \\<equiv>\ncase iv of PageDirectoryMap cap ct_slot pdpte pdpt_slot vspace \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pdpte pdpt_slot pdpte;\n    asid <- case cap of ArchObjectCap (PageDirectoryCap _ (Some (as, _))) \\<Rightarrow> return as\n            | _ \\<Rightarrow> fail;\n    invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n  od\n  | PageDirectoryUnmap (ArchObjectCap (PageDirectoryCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_pd asid vaddr p;\n      pde_bits \\<leftarrow> return word_size_bits;\n      slots \\<leftarrow> return [p, p + (1 << pde_bits) .e. p + (1 << pd_bits) - 1];\n      mapM_x (swp store_pde InvalidPDE) slots\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"", "property": "PageDirectory Invocation: Allows the mapping and unmapping of page tables. Mapping involves setting a capability, storing a page directory pointer table entry, and invalidating the page structure cache for the specified address space. Unmapping involves removing the page directory entry, updating the capability to remove the mapped address, and clearing the corresponding slots.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageDirectory capabilities confer the authority to map and unmap page\ntables."}
{"spec": "definition\nperform_pdpt_invocation :: \"pdpt_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_pdpt_invocation iv \\<equiv>\ncase iv of PDPTMap cap ct_slot pml4e pml4_slot vspace \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pml4e pml4_slot pml4e;\n    asid <- case cap of ArchObjectCap (PDPointerTableCap _ (Some (as, _))) \\<Rightarrow> return as\n            | _ \\<Rightarrow> fail;\n    invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n  od\n  | PDPTUnmap (ArchObjectCap (PDPointerTableCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_pdpt asid vaddr p;\n      pdept_bits \\<leftarrow> return word_size_bits;\n      slots \\<leftarrow> return [p, p + (1 << pdept_bits) .e. p + (1 << pdpt_bits) - 1];\n      mapM_x (swp store_pdpte InvalidPDPTE) slots\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"\n\ndefinition\n  port_out :: \"('a word \\<Rightarrow> unit machine_monad) \\<Rightarrow> ('a word) \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"port_out f w = do\n    do_machine_op $ f w;\n    return []\n  od\"\n\ndefinition\n  port_in :: \"(data machine_monad) \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"port_in f = do\n    res \\<leftarrow> do_machine_op f;\n    return [res]\n  od\"\n\ndefinition\n  perform_io_port_invocation :: \"io_port_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"perform_io_port_invocation i \\<equiv> (\n    case i of (IOPortInvocation port port_data) \\<Rightarrow> (\n      case port_data of\n        IOPortIn8 \\<Rightarrow> port_in (in8 port)\n      | IOPortIn16 \\<Rightarrow> port_in (in16 port)\n      | IOPortIn32 \\<Rightarrow> port_in (in32 port)\n      | IOPortOut8 w \\<Rightarrow> port_out (out8 port) w\n      | IOPortOut16 w \\<Rightarrow> port_out (out16 port) w\n      | IOPortOut32 w \\<Rightarrow> port_out (out32 port) w\n    )\n    )\"\n\ndefinition\n  perform_ioport_control_invocation :: \"io_port_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"perform_ioport_control_invocation i \\<equiv>\n    case i of (IOPortControlInvocation f l dest_slot control_slot) \\<Rightarrow> do\n      set_ioport_mask f l True;\n      c \\<leftarrow> return $ ArchObjectCap $ IOPortCap f l;\n      cap_insert (ArchObjectCap (IOPortCap f l)) control_slot dest_slot\n    od\"\n\nabbreviation\n  arch_no_return :: \"(unit, 'z::state_ext) s_monad \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\nwhere\n  \"arch_no_return oper \\<equiv> do oper; return [] od\"", "property": "PageDirectory and I/O Port Management: PageDirectory capabilities allow for mapping and unmapping of page tables, including updating the page table entries and invalidating the page structure cache. I/O port capabilities enable reading from and writing to I/O ports, as well as controlling I/O port access by setting masks and inserting I/O port capabilities into slots.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageDirectory capabilities confer the authority to map and unmap page\ntables."}
{"spec": "definition\n  arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\" where\n  \"arch_perform_invocation i \\<equiv> liftE $\n    case i of\n          InvokePageTable oper \\<Rightarrow> arch_no_return $ perform_page_table_invocation oper\n        | InvokePageDirectory oper \\<Rightarrow> arch_no_return $ perform_page_directory_invocation oper\n        | InvokePDPT oper \\<Rightarrow> arch_no_return $ perform_pdpt_invocation oper\n        | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n        | InvokeASIDControl oper \\<Rightarrow> arch_no_return $ perform_asid_control_invocation oper\n        | InvokeASIDPool oper \\<Rightarrow> arch_no_return $ perform_asid_pool_invocation oper\n        | InvokeIOPort oper \\<Rightarrow> perform_io_port_invocation oper\n        | InvokeIOPortControl oper \\<Rightarrow> arch_no_return $ perform_ioport_control_invocation oper\"\n\nend\nend", "property": "Architectural Invocation Handling: Dispatches and performs various x64-specific system calls, including operations on page tables, page directories, PDPTs, pages, ASID control, ASID pools, I/O ports, and I/O port control. Each invocation is handled by a corresponding function, ensuring the correct execution of architectural operations.", "title": "./spec/abstract/X64/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call despatcher for all x64-specific system calls."}
{"spec": "chapter \"Handle Hyperviser Fault Event\"\n\ntheory Hypervisor_A\nimports Exceptions_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"machine_word \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n\"handle_hypervisor_fault thread X64NoHypFaults = return ()\"\n\n\nend\nend", "property": "Handle Hypervisor Fault: Process hypervisor fault events, where the function `handle_hypervisor_fault` returns without any action if the fault type is `X64NoHypFaults`.", "title": "./spec/abstract/X64/Hypervisor_A.thy", "chapter": "Handle Hyperviser Fault Event", "section": "", "comment": ""}
{"spec": "definition\n  reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Reserve Memory Region: Reserve a specified number of bytes in memory, potentially tagging the region as kernel data. This function currently acts as a placeholder and does not perform any actual reservation or tagging.", "title": "./spec/abstract/X64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory."}
{"spec": "definition\n  init_arch_objects :: \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list\n   \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs\n    \\<equiv> when (new_type = ArchObject PML4Obj) (mapM_x copy_global_mappings refs)\"\n\ndefinition\n  empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0) (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context \\<rparr>\"\n\nend\nend", "property": "Initialize Architecture-Specific Objects: Initialize architecture-specific objects based on the object type. If the object type is a PML4 object, copy global mappings for the provided references. Additionally, define an empty user context and an initial architecture-specific thread control block with this empty context.", "title": "./spec/abstract/X64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition\n  arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arch_post_cap_deletion ac \\<equiv> case ac of\n       IOPortCap f l \\<Rightarrow> free_ioport_range f l\n     | _ \\<Rightarrow> return ()\"", "property": "Post-Capability Deletion Actions: Perform specific actions after a capability is deleted, such as freeing the I/O port range for an IOPortCap. For other types of capabilities, no action is taken.", "title": "./spec/abstract/X64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = IOPortRef io_port\n\ndefinition\n  arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\"\nwhere\n  \"arch_gen_obj_refs ac \\<equiv> case ac of\n      IOPortCap f l \\<Rightarrow> IOPortRef ` {f}\n    | _ \\<Rightarrow> {}\"\n\ndefinition\n  arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_cap_cleanup_opt ac \\<equiv> case ac of IOPortCap f l \\<Rightarrow> ArchObjectCap (IOPortCap f l) | _ \\<Rightarrow> NullCap\"\n\nend\nend", "property": "Arch-Specific Generic Object References: Defines a set of architecture-specific generic object references, specifically for I/O ports, and provides a cleanup operation to convert architecture-specific capabilities into a standard capability format.", "title": "./spec/abstract/X64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition\n  init_irq_node_ptr :: obj_ref where\n  \"init_irq_node_ptr = kernel_base + 0x2000\"", "property": "Initialization of IRQ Node Pointer: The IRQ node pointer is initialized to a specific memory address, which is 8KiB (0x2000) offset from the kernel base address.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " 8KiB "}
{"spec": "definition\n  init_global_pml4 :: obj_ref where\n  \"init_global_pml4 = kernel_base + 0x4000\"", "property": "Initialize Global PML4: Set the initial global page map level 4 (PML4) to a specific memory address, which is 4KiB offset from the kernel base.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " 4KiB "}
{"spec": "definition\n  init_global_pdpt :: obj_ref where\n  \"init_global_pdpt = kernel_base + 0x5000\"", "property": "Initialize Global Page Directory Pointer Table: Set the initial address of the global page directory pointer table to a fixed offset from the kernel base.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " 4KiB "}
{"spec": "definition\n  init_global_pd :: obj_ref where\n  \"init_global_pd = kernel_base + 0x6000\"\n\ndefinition\n  \"init_arch_state \\<equiv> \\<lparr>\n    x64_asid_table = Map.empty,\n    x64_global_pml4 = init_global_pml4,\n    x64_kernel_vspace =\n      \\<lambda>ref. if ref \\<in> {pptr_base .. pptr_base + mask pml4_shift_bits}\n              then X64VSpaceKernelWindow\n              else X64VSpaceInvalidRegion,\n    x64_global_pts = [],\n    x64_global_pdpts = [init_global_pdpt],\n    x64_global_pds = [init_global_pd],\n    x64_current_cr3 = cr3 0 0,\n    x64_allocated_io_ports = \\<lambda>_. False,\n    x64_num_ioapics = 1,\n    x64_ioapic_nirqs = \\<lambda>_. ucast ioapicIRQLines,\n    x64_irq_state = K IRQFree\n   \\<rparr>\"\n\ndefinition [simp]:\n  \"global_pml4 \\<equiv> (\\<lambda>_ :: 9 word. InvalidPML4E)\n    (0x1FF := PDPointerTablePML4E (addrFromPPtr init_global_pdpt) {} {})\"", "property": "Initialization of Architecture State: Initializes the architecture state with predefined values, including an empty ASID table, a global PML4, a kernel virtual space, and other essential components such as PDPTs, PDS, and IOAPIC settings. This ensures that the system is set up with a valid and consistent initial state for memory management and interrupt handling.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " 4KiB "}
{"spec": "definition [simp]:\n  \"global_pdpt \\<equiv> (\\<lambda> i :: 9 word. HugePagePDPTE (ucast i << 30) {} {})\n                    (0x1FF := PageDirectoryPDPTE (addrFromPPtr init_global_pd) {} {})\"", "property": "Global PDPT Mapping: The kernel utilizes huge page mappings in the global Page Directory Pointer Table (PDPT) to provide a comprehensive view of all physical memory, with the exception of the highest PDPT entry, which maps to the global page directory.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " The kernel uses huge page mappings in the global PDPT to get a view of all physical memory.\n   The exception is the upper-most PDPT entry, which maps to the global page directory. "}
{"spec": "definition [simp]:\n  \"global_pd \\<equiv> (\\<lambda> i :: 9 word. LargePagePDE (0x03FE00 + ucast i << 21) {} {})\"\n\ndefinition\n  \"init_kheap \\<equiv>\n    (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n           then Some (CNode 0 (empty_cnode 0))\n           else None)\n    (idle_thread_ptr \\<mapsto>\n       TCB \\<lparr>\n         tcb_ctable = NullCap,\n         tcb_vtable = NullCap,\n         tcb_reply = NullCap,\n         tcb_caller = NullCap,\n         tcb_ipcframe = NullCap,\n         tcb_state = IdleThreadState,\n         tcb_fault_handler = replicate word_bits False,\n         tcb_ipc_buffer = 0,\n         tcb_fault = None,\n         tcb_bound_notification = None,\n         tcb_mcpriority = minBound,\n         tcb_arch = init_arch_tcb\n         \\<rparr>,\n     init_global_pml4 \\<mapsto> ArchObj (PageMapL4 global_pml4),\n     init_global_pdpt \\<mapsto> ArchObj (PDPointerTable global_pdpt),\n     init_global_pd \\<mapsto> ArchObj (PageDirectory global_pd)\n    )\"\n\ndefinition\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. Structures_A.IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\nend", "property": "Initialization of Kernel State: The kernel initializes its state with a global page directory, an idle thread, and other essential components. The initial state includes setting up the kheap, capability derivation tree, interrupt controller, and architecture-specific state, ensuring that the system is ready for operation.", "title": "./spec/abstract/X64/Init_A.thy", "chapter": "", "section": "", "comment": " C kernel initialisation refines this down to small pages for devices, but we'll stop here. "}
{"spec": "definition\n  \"attr_mask = {Global,Dirty,PTAttr Accessed,PTAttr ExecuteDisable}\"\n\ndefinition\n  \"attr_mask' = attr_mask \\<union> {PAT}\"", "property": "Page Attributes Mask: Defines a set of page attributes that are always set to False when pages are mapped, including global, dirty, accessed, execute disable, and PAT attributes.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  These attributes are always set to @{const False} when pages are mapped.\n"}
{"spec": "primrec create_mapping_entries ::\n  \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vm_rights \\<Rightarrow> frame_attrs \\<Rightarrow> obj_ref \\<Rightarrow>\n  (vm_page_entry * obj_ref,'z::state_ext) se_monad\"\nwhere\n  \"create_mapping_entries base vptr X64SmallPage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ (VMPTE (SmallPagePTE base (attrib - attr_mask) vm_rights), p)\n  odE\"\n\n| \"create_mapping_entries base vptr X64LargePage vm_rights attrib pdpt =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pd_slot pdpt vptr;\n    returnOk $ (VMPDE (LargePagePDE base (attrib - attr_mask) vm_rights), p)\n  odE\"\n\n| \"create_mapping_entries base vptr X64HugePage vm_rights attrib pml4 =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pdpt_slot pml4 vptr;\n    returnOk $ (VMPDPTE (HugePagePDPTE base (attrib - attr_mask') vm_rights), p)\n  odE\"", "property": "Create Mapping Entries: Generate the necessary entries for mapping different sizes of memory frames (small, large, and huge pages) at a specified virtual address. The function ensures that the appropriate page table or directory entry is created with the given base address, rights, and attributes, and it returns the entry along with the corresponding slot.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Save the set of entries that would be inserted into a page table or\npage directory to map various different sizes of frame at a given virtual\naddress."}
{"spec": "fun ensure_safe_mapping ::\n  \"(vm_page_entry * obj_ref) \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n\"ensure_safe_mapping (VMPTE InvalidPTE, _) = returnOk ()\"\n|\n\"ensure_safe_mapping (VMPDE InvalidPDE, _) = returnOk ()\"\n|\n\"ensure_safe_mapping (VMPDPTE InvalidPDPTE, _) = returnOk ()\"\n|\n\"ensure_safe_mapping (VMPTE (SmallPagePTE _ _ _), pt_slot) = returnOk ()\"\n|\n\"ensure_safe_mapping (VMPDE (LargePagePDE _ _ _), pd_slot) =\n    doE\n        pde \\<leftarrow> liftE $ get_pde pd_slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | LargePagePDE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst)\n    odE\"\n|\n\"ensure_safe_mapping (VMPDPTE (HugePagePDPTE _ _ _), pdpt_slot) =\n    doE\n        pdpt \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n        (case pdpt of\n              InvalidPDPTE \\<Rightarrow> returnOk ()\n            | HugePagePDPTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst)\n    odE\"\n|\n\"ensure_safe_mapping (VMPDE (PageTablePDE _ _ _), _) = fail\"\n|\n\"ensure_safe_mapping (VMPDPTE (PageDirectoryPDPTE _ _ _), _) = fail\"", "property": "Ensure Safe Mapping: Verify that the given virtual memory entries are either invalid or replace existing invalid entries, ensuring safe mapping and unmapping operations. It allows SmallPagePTE, LargePagePDE, and HugePagePDPTE entries if they are replacing invalid entries, and fails for PageTablePDE and PageDirectoryPDPTE entries.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "This function checks that given entries are either invalid entries (for unmapping)\nor replace invalid entries (for mapping)."}
{"spec": "definition\nlookup_ipc_buffer :: \"bool \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\" where\n\"lookup_ipc_buffer is_receiver thread \\<equiv> do\n    buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n    buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n    buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n    (case buffer_cap of\n      ArchObjectCap (PageCap _ p R _ vms _) \\<Rightarrow>\n        if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n        then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n        else return None\n    | _ \\<Rightarrow> return None)\nod\"", "property": "IPC Buffer Lookup: Verify the thread's authority to access its IPC buffer, ensuring that the thread has the appropriate read or write permissions based on whether it is the receiver or not.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Look up a thread's IPC buffer and check that the thread has the right\nauthority to read or (in the receiver case) write to it."}
{"spec": "definition\nfind_vspace_for_asid :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"find_vspace_for_asid asid \\<equiv> doE\n    assertE (asid > 0);\n    asid_table \\<leftarrow> liftE $ gets (x64_asid_table \\<circ> arch_state);\n    pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of asid));\n    pool \\<leftarrow> (case pool_ptr of\n               Some ptr \\<Rightarrow> liftE $ get_asid_pool ptr\n             | None \\<Rightarrow> throwError InvalidRoot);\n    pml4 \\<leftarrow> returnOk (pool (asid_low_bits_of asid));\n    (case pml4 of\n          Some ptr \\<Rightarrow> returnOk ptr\n        | None \\<Rightarrow> throwError InvalidRoot)\nodE\"", "property": "Locate Page Directory: Find the page directory associated with a given virtual ASID by navigating through the ASID table and ASID pool, ensuring the ASID is valid and returning the corresponding PML4 pointer. If the ASID or PML4 entry is not found, an error is thrown.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory associated with a given virtual ASID."}
{"spec": "definition\nfind_vspace_for_asid_assert :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) s_monad\" where\n\"find_vspace_for_asid_assert asid \\<equiv> do\n   pml4 \\<leftarrow> find_vspace_for_asid asid <catch> K fail;\n   get_pml4 pml4;\n   return pml4\n od\"", "property": "Locate and Validate Page Directory: Find the page directory for a given ASID, ensuring that the operation is successful and returns a valid pointer to an existing page directory.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory and check that this process succeeds and\nreturns a pointer to a real page directory."}
{"spec": "definition\nhandle_vm_fault :: \"obj_ref \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n\"handle_vm_fault thread fault_type = doE\n    addr \\<leftarrow> liftE $ do_machine_op getFaultAddress;\n    fault \\<leftarrow> liftE $ as_user thread $ getRegister ErrorRegister;\n    case fault_type of\n        X64DataFault \\<Rightarrow> throwError $ ArchFault $ VMFault addr [0, fault && mask 5]\n      | X64InstructionFault \\<Rightarrow> throwError $ ArchFault $ VMFault addr [1, fault && mask 5]\nodE\"\n\ndefinition\n  get_current_cr3 :: \"(cr3, 'z::state_ext) s_monad\"\nwhere\n  \"get_current_cr3 \\<equiv> gets (x64_current_cr3 \\<circ> arch_state)\"\n\ndefinition\n  set_current_cr3 :: \"cr3 \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_current_cr3 c \\<equiv>\n     modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>x64_current_cr3 := c\\<rparr>\\<rparr>)\"\n\ndefinition\n  invalidate_page_structure_cache_asid :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"invalidate_page_structure_cache_asid vspace asid \\<equiv>\n     do_machine_op $ invalidateLocalPageStructureCacheASID vspace (ucast asid)\"\n\ndefinition\n  getCurrentVSpaceRoot :: \"(obj_ref, 'z::state_ext) s_monad\"\nwhere\n  \"getCurrentVSpaceRoot \\<equiv> do\n      cur \\<leftarrow> get_current_cr3;\n      return $ cr3_base_address cur\n   od\"\n\ndefinition\n  \"cr3_addr_mask \\<equiv> mask pml4_shift_bits << asid_bits\"\n\ndefinition\n  make_cr3 :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> cr3\"\nwhere\n  \"make_cr3 vspace asid \\<equiv> cr3 (vspace && cr3_addr_mask) asid\"\n\ndefinition\n  set_current_vspace_root :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"set_current_vspace_root vspace asid \\<equiv> set_current_cr3 $ make_cr3 vspace asid\"", "property": "Handle VM Fault: Format and propagate a VM fault message to the thread's supervisor, including the fault address and error register value, based on the type of fault (data or instruction).", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Format a VM fault message to be passed to a thread's supervisor after\nit encounters a page fault."}
{"spec": "definition\n  set_vm_root :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"set_vm_root tcb \\<equiv> do\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    (case thread_root of\n       ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> doE\n           pml4' \\<leftarrow> find_vspace_for_asid asid;\n           whenE (pml4 \\<noteq> pml4') $ throwError InvalidRoot;\n           cur_cr3 \\<leftarrow> liftE $ get_current_cr3;\n           whenE (cur_cr3 \\<noteq> make_cr3 (addrFromPPtr pml4) asid) $\n              liftE $ set_current_cr3 $ make_cr3 (addrFromPPtr pml4) asid\n       odE\n     | _ \\<Rightarrow> throwError InvalidRoot) <catch>\n    (\\<lambda>_. do\n       global_pml4 \\<leftarrow> gets (x64_global_pml4 \\<circ> arch_state);\n       set_current_vspace_root (addrFromKPPtr global_pml4) 0\n    od)\nod\"", "property": "Set Virtual Memory Root: Switch the current address space to the one associated with a given thread's virtual memory root. If the thread's virtual memory root is invalid, switch to the global address space. This ensures that the system operates within a valid and correctly configured address space.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch into the address space of a given thread or the global address\nspace if none is correctly configured."}
{"spec": "definition\nhw_asid_invalidate :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"hw_asid_invalidate asid vspace \\<equiv>\n  do_machine_op $ invalidateASID vspace (ucast asid)\"\n\ndefinition\ndelete_asid_pool :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid_pool base ptr \\<equiv> do\n  assert (asid_low_bits_of base = 0);\n  asid_table \\<leftarrow> gets (x64_asid_table \\<circ> arch_state);\n  when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n    pool \\<leftarrow> get_asid_pool ptr;\n    mapM (\\<lambda>offset. (when (pool (ucast offset) \\<noteq> None) $\n                          hw_asid_invalidate (base + offset) (the (pool (ucast offset)))))\n                    [0 .e. (1 << asid_low_bits) - 1];\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> x64_asid_table := asid_table' \\<rparr>\\<rparr>);\n    tcb \\<leftarrow> gets cur_thread;\n    set_vm_root tcb\n  od\nod\"", "property": "ASID Pool Deletion: Remove the ASID pool associated with a given base ASID, invalidating all virtual to physical mappings for each ASID in the pool. This ensures that any mappings involving the virtual ASID are removed, maintaining the integrity of the virtual memory system.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove virtual to physical mappings in either direction involving this\nvirtual ASID."}
{"spec": "definition\ndelete_asid :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid asid pml4 \\<equiv> do\n  asid_table \\<leftarrow> gets (x64_asid_table \\<circ> arch_state);\n  case asid_table (asid_high_bits_of asid) of\n    None \\<Rightarrow> return ()\n  | Some pool_ptr \\<Rightarrow>  do\n     pool \\<leftarrow> get_asid_pool pool_ptr;\n     when (pool (asid_low_bits_of asid) = Some pml4) $ do\n                hw_asid_invalidate asid pml4;\n                pool' \\<leftarrow> return (pool (asid_low_bits_of asid := None));\n                set_asid_pool pool_ptr pool';\n                tcb \\<leftarrow> gets cur_thread;\n                set_vm_root tcb\n            od\n    od\nod\"\n\ndefinition\n  flush_all :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"flush_all vspace asid \\<equiv> do_machine_op $ invalidateASID vspace (ucast asid)\"\n\nabbreviation\n  flush_pdpt :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"flush_pdpt \\<equiv> flush_all\"\n\nabbreviation\n  flush_pd :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"flush_pd \\<equiv> flush_all\"", "property": "ASID Deletion: When deleting a Page Map Level 4 (PML4) from an ASID pool, the corresponding ASID is deactivated by invalidating the hardware ASID, updating the ASID pool to remove the PML4, and setting the virtual memory root for the current thread. This ensures that the ASID is properly deactivated and the system's memory management is maintained.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "When deleting a page map level 4 from an ASID pool we must deactivate\nit."}
{"spec": "definition\nflush_table :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_table pml4_ref vptr pt_ref asid \\<equiv> do\n    assert (vptr && mask (ptTranslationBits + pageBits) = 0);\n           pt \\<leftarrow> get_pt pt_ref;\n           forM_x [0 .e. (-1::9 word)] (\\<lambda>index. do\n             pte \\<leftarrow> return $ pt index;\n             case pte of\n               InvalidPTE \\<Rightarrow> return ()\n             | _ \\<Rightarrow> do_machine_op $ invalidateTranslationSingleASID (vptr + (ucast index << pageBits)) (ucast asid)\n           od)\nod\"", "property": "Flush Page Table Mappings: Invalidate mappings associated with a specified page table, ensuring that all entries are flushed for a given ASID. This process iterates over each entry in the page table, and if the entry is valid, it invalidates the corresponding translation for the specified virtual address and ASID.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a page table."}
{"spec": "definition\nunmap_pdpt :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_pdpt asid vaddr pdpt \\<equiv> doE\n  vspace \\<leftarrow> find_vspace_for_asid asid;\n  pm_slot \\<leftarrow> returnOk $ lookup_pml4_slot vspace vaddr;\n  pml4e \\<leftarrow> liftE $ get_pml4e pm_slot;\n  case pml4e of\n    PDPointerTablePML4E pt' _ _ \\<Rightarrow>\n      if pt' = addrFromPPtr pdpt then returnOk () else throwError InvalidRoot\n    | _ \\<Rightarrow> throwError InvalidRoot;\n  liftE $ do\n    flush_pdpt vspace asid;\n    store_pml4e pm_slot InvalidPML4E\n  od\nodE <catch> (K $ return ())\"", "property": "Unmap Page Directory Pointer Table: Unmaps a specified Page Directory Pointer Table (PDPT) from a given address space identifier (ASID) and virtual space reference. Ensures the PDPT is valid for the ASID, flushes the PDPT, and updates the PML4 entry to an invalid state.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a Page Directory Pointer Table from a PML4."}
{"spec": "definition\nunmap_pd :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_pd asid vaddr pd \\<equiv> doE\n  vspace \\<leftarrow> find_vspace_for_asid asid;\n  pdpt_slot \\<leftarrow> lookup_pdpt_slot vspace vaddr;\n  pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n  case pdpte of\n    PageDirectoryPDPTE pd' _ _ \\<Rightarrow>\n      if pd' = addrFromPPtr pd then returnOk () else throwError InvalidRoot\n    | _ \\<Rightarrow> throwError InvalidRoot;\n  liftE $ do\n    flush_pd vspace asid;\n    store_pdpte pdpt_slot InvalidPDPTE;\n    invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n  od\nodE <catch> (K $ return ())\"", "property": "Unmap Page Directory: Unmaps a specified page directory from the page directory pointer table. It ensures that the correct page directory is targeted, flushes the page directory, updates the page directory pointer table entry to an invalid state, and invalidates the page structure cache for the associated address space identifier.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a Page Directory from a Page Directory Pointer Table."}
{"spec": "definition\nunmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page_table asid vaddr pt \\<equiv> doE\n    vspace \\<leftarrow> find_vspace_for_asid asid;\n    pd_slot \\<leftarrow> lookup_pd_slot vspace vaddr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    case pde of\n      PageTablePDE addr _ _ \\<Rightarrow>\n        if addrFromPPtr pt = addr then returnOk () else throwError InvalidRoot\n      | _ \\<Rightarrow> throwError InvalidRoot;\n    liftE $ do\n      flush_table vspace vaddr pt asid;\n      store_pde pd_slot InvalidPDE;\n      invalidate_page_structure_cache_asid (addrFromPPtr vspace) asid\n    od\nodE <catch> (K $ return ())\"", "property": "Unmap Page Table: Unmaps a specified page table from its page directory by finding the corresponding page directory, validating the page table entry, and then flushing, invalidating, and clearing the page table entry. If the page table does not match or the entry is invalid, an error is thrown.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a page table from its page directory."}
{"spec": "definition\ncheck_mapping_pptr :: \"machine_word \\<Rightarrow> vm_page_entry \\<Rightarrow> bool\" where\n\"check_mapping_pptr pptr entry \\<equiv> case entry of\n   VMPTE (SmallPagePTE base _ _) \\<Rightarrow> base = addrFromPPtr pptr\n | VMPDE (LargePagePDE base _ _) \\<Rightarrow> base = addrFromPPtr pptr\n | VMPDPTE (HugePagePDPTE base _ _) \\<Rightarrow> base = addrFromPPtr pptr\n | _ \\<Rightarrow> False\"", "property": "Check Mapping Physical Pointer: Verify if a given physical page pointer is mapped by a specific virtual memory mapping entry. This ensures that the base address of the mapping entry matches the address derived from the physical page pointer.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Check that a given frame is mapped by a given mapping entry."}
{"spec": "definition\nunmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page pgsz asid vptr pptr \\<equiv> doE\n    vspace \\<leftarrow> find_vspace_for_asid asid;\n    case pgsz of\n          X64SmallPage \\<Rightarrow> doE\n            pt_slot \\<leftarrow> lookup_pt_slot vspace vptr;\n            pte \\<leftarrow> liftE $ get_pte pt_slot;\n            unlessE (check_mapping_pptr pptr (VMPTE pte)) $ throwError InvalidRoot;\n            liftE $ store_pte pt_slot InvalidPTE\n          odE\n        | X64LargePage \\<Rightarrow> doE\n            pd_slot \\<leftarrow> lookup_pd_slot vspace vptr;\n            pde \\<leftarrow> liftE $ get_pde pd_slot;\n            unlessE (check_mapping_pptr pptr (VMPDE pde)) $ throwError InvalidRoot;\n            liftE $ store_pde pd_slot InvalidPDE\n          odE\n        | X64HugePage \\<Rightarrow> doE\n            pdpt_slot \\<leftarrow> lookup_pdpt_slot vspace vptr;\n            pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n            unlessE (check_mapping_pptr pptr (VMPDPTE pdpte)) $ throwError InvalidRoot;\n            liftE $ store_pdpte pdpt_slot InvalidPDPTE\n          odE;\n    liftE $ do_machine_op $ invalidateTranslationSingleASID vptr (ucast asid)\nodE <catch> (K $ return ())\"", "property": "Unmap Page: Unmaps a page from the virtual address space if the given mapping details are still current. It checks the page size and corresponding page table entry, and if the physical page pointer matches, it invalidates the page table entry and flushes the translation cache for the specified ASID.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition\n  arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\"\nwhere\n  \"arch_derive_cap c \\<equiv> case c of\n     PageTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageTableCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageDirectoryCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageDirectoryCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PDPointerTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PDPointerTableCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PML4Cap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PML4Cap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageCap dev r R mt pgs x \\<Rightarrow> returnOk $ ArchObjectCap (PageCap dev r R VMNoMap pgs None)\n   | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n   | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\n\\<^cancel>\\<open>FIXME x64-vtd:\n   | IOSpaceCap _ _ \\<Rightarrow> returnOk c\n   | IOPageTableCap _ _ _ \\<Rightarrow> returnOk c\\<close>\n   | IOPortCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\n   | IOPortControlCap \\<Rightarrow> returnOk NullCap\"", "property": "Architectural Capability Derivation: Ensures that page table structure capabilities (PageTableCap, PageDirectoryCap, PDPointerTableCap, PML4Cap) can only be derived if they have a virtual ASID and location assigned. If these conditions are not met, an IllegalOperation error is thrown. Other architectural capabilities are derived without additional checks.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Page table structure capabilities cannot be copied until they\nhave a virtual ASID and location assigned. This is because they\ncannot have multiple current virtual ASIDs and cannot be shared\nbetween address spaces or virtual locations."}
{"spec": "definition\n  arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "Arch Capability Data Update: Ensures that the architecture-specific capability data is updated without allowing any user-modifiable data to be stored in x64-specific capabilities.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in x64-specific capabilities."}
{"spec": "definition\n  arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n    (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n    delete_asid_pool b ptr;\n    return (NullCap, NullCap)\n    od\n  | (PML4Cap ptr (Some a), True) \\<Rightarrow> do\n    delete_asid a ptr;\n    return (NullCap, NullCap)\n  od\n  | (PDPointerTableCap ptr (Some (a,v)), True) \\<Rightarrow> do\n    unmap_pdpt a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageDirectoryCap ptr (Some (a,v)), True) \\<Rightarrow> do\n    unmap_pd a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageTableCap ptr (Some (a, v)), True) \\<Rightarrow> do\n    unmap_page_table a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageCap _ ptr _ _ s (Some (a, v)), _) \\<Rightarrow> do\n     unmap_page s a v ptr;\n     return (NullCap, NullCap)\n  od\n  | (IOPortCap f l, True) \\<Rightarrow> return (NullCap, (ArchObjectCap (IOPortCap f l)))\n  \\<comment> \\<open>FIXME x64-vtd: IOSpaceCap and IOPageTableCap for @{text arch_finalise_cap}\\<close>\n  | _ \\<Rightarrow> return (NullCap, NullCap)\"", "property": "Arch Capability Finalization: Finalize x64-specific capabilities by performing specific actions such as deleting ASID pools, unmapping PML4, PDPT, page directories, and page tables, and unmap pages. The finalization process returns a pair of `NullCap` for most cases, except for IOPort capabilities, which return an `ArchObjectCap` containing the original IOPort capability.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of x64-specific\ncapabilities."}
{"spec": "definition\n  is_valid_vtable_root :: \"cap \\<Rightarrow> bool\" where\n  \"is_valid_vtable_root c \\<equiv> \\<exists>r a. c = ArchObjectCap (PML4Cap r (Some a))\"\n\ndefinition\ncheck_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n\"check_valid_ipc_buffer vptr c \\<equiv> case c of\n  (ArchObjectCap (PageCap False _ _ _ _ _)) \\<Rightarrow> doE\n    whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError;\n    returnOk ()\n  odE\n| _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Virtual Address Space Validation: Ensures that a thread's virtual address space capability is valid by checking if it points to a mapped PML4, which is a requirement for the x64 architecture. For IPC buffer validation, it specifically checks if the capability is a PageCap and if the provided virtual pointer is aligned; otherwise, it throws an error.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A thread's virtual address space capability must be to a mapped PML4 (page map level 4)\nto be valid on the x64 architecture."}
{"spec": "definition\nattribs_from_word :: \"machine_word \\<Rightarrow> frame_attrs\" where\n\"attribs_from_word w \\<equiv>\n  let V = (if w !!0 then {PTAttr WriteThrough} else {});\n      V' = (if w!!1 then insert (PTAttr CacheDisabled) V else V)\n  in if w!!2 then insert PAT V' else V'\"", "property": "Decode VM Attributes: Extract and decode the virtual memory attributes from a user-provided machine word, determining specific attributes such as write-through, cache disabled, and PAT (Page Attribute Table) based on the bit values.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Decode a user argument word describing the kind of VM attributes a\nmapping is to have."}
{"spec": "definition\n  update_map_data :: \"arch_cap \\<Rightarrow> (asid \\<times> vspace_ref) option \\<Rightarrow> vmmap_type option \\<Rightarrow> arch_cap\" where\n  \"update_map_data cap m mt \\<equiv> case cap of\n     PageCap dev p R _ sz _ \\<Rightarrow> PageCap dev p R (the mt) sz m\n   | PageTableCap p _ \\<Rightarrow> PageTableCap p m\n   | PageDirectoryCap p _ \\<Rightarrow> PageDirectoryCap p m\n   | PDPointerTableCap p _ \\<Rightarrow> PDPointerTableCap p m\"", "property": "Update Mapping Data: Modify the mapping data in a page or page table capability, updating the ASID and virtual space reference, as well as the type of the virtual memory mapping.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Update the mapping data saved in a page or page table capability."}
{"spec": "definition\n  in_user_frame :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n  \"in_user_frame p s \\<equiv>\n   \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) =\n        Some (ArchObj (DataPage False sz))\"\n\ndefinition\n  fpu_thread_delete :: \"obj_ref \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"fpu_thread_delete thread_ptr \\<equiv> do\n    using_fpu \\<leftarrow> do_machine_op (nativeThreadUsingFPU thread_ptr);\n    when using_fpu $ do_machine_op (switchFpuOwner 0 0)\n  od\"\n\ndefinition\n  prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"prepare_thread_delete thread_ptr \\<equiv> fpu_thread_delete thread_ptr\"", "property": "User Frame Check: Determine if a pointer is within a user frame by checking if the top bits of the pointer point to a DataPage in the kernel heap.\n\nThread Deletion Preparation: Prepare a thread for deletion by ensuring that if the thread is using the FPU, the FPU ownership is switched to a default state.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A pointer is inside a user frame if its top bits point to a @{text DataPage}.\n"}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\nend\nend", "property": "Numeric Value Visibility: Ensure the numeric value of `msg_align_bits` is explicitly visible by unfolding and simplifying its definition.", "title": "./spec/abstract/X64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition\n  asid_high_bits_of :: \"asid \\<Rightarrow> asid_high_index\" where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"", "property": "Extract High ASID Bits: Extract the high bits of a given ASID to form an ASID high index, which is used for accessing the virtual address space.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "definition\n  asid_low_bits_of :: \"asid \\<Rightarrow> asid_low_index\" where\n  \"asid_low_bits_of asid \\<equiv> ucast asid\"\n\nlemmas asid_bits_of_defs =\n  asid_high_bits_of_def asid_low_bits_of_def", "property": "ASID Low Bits Extraction: Extract the low bits of a virtual ASID and convert them to an ASID low index.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The low bits of a virtual ASID."}
{"spec": "text \\<open>Manipulate ASID pools, page directories and page tables in the kernel\nheap.\\<close>", "property": "Kernel Heap Access: Provides functions to manipulate ASID pools, page directories, and page tables within the kernel heap, enabling efficient management of virtual memory structures.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\"\n  where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"\n\ndefinition\n  get_asid_pool :: \"obj_ref \\<Rightarrow> (asid_low_index \\<rightharpoonup> obj_ref, 'z::state_ext) s_monad\" where\n  \"get_asid_pool ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (ASIDPool pool) \\<Rightarrow> return pool\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_asid_pool :: \"obj_ref \\<Rightarrow> (asid_low_index \\<rightharpoonup> obj_ref) \\<Rightarrow> (unit, 'z::state_ext) s_monad\" where\n \"set_asid_pool ptr pool \\<equiv> set_object ptr (ArchObj (ASIDPool pool))\"\n\ndefinition\n  get_pd :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pde,'z::state_ext) s_monad\" where\n  \"get_pd ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageDirectory pd) \\<Rightarrow> return pd\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pd :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pde) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pd ptr pd \\<equiv> set_object ptr (ArchObj (PageDirectory pd))\"", "property": "VSpace Access and Management: Provides functions to get and set ASID pools and page directories, enabling the kernel to manage virtual address spaces and their associated data structures.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": " declared in Arch as workaround for VER-1099 "}
{"spec": "definition\n  get_pde :: \"obj_ref \\<Rightarrow> (pde,'z::state_ext) s_monad\" where\n  \"get_pde ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pd_bits);\n     offset \\<leftarrow> return ((ptr && mask pd_bits) >> word_size_bits);\n     pd \\<leftarrow> get_pd base;\n     return $ pd (ucast offset)\n   od\"\n\ndefinition\n  store_pde :: \"obj_ref \\<Rightarrow> pde \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pde p pde \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pd_bits);\n    offset \\<leftarrow> return ((p && mask pd_bits) >> word_size_bits);\n    pd \\<leftarrow> get_pd base;\n    pd' \\<leftarrow> return $ pd (ucast offset := pde);\n    set_pd base pd'\n  od\"\n\n\ndefinition\n  get_pt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pte,'z::state_ext) s_monad\" where\n  \"get_pt ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageTable pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pte) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pt ptr pt \\<equiv> set_object ptr (ArchObj (PageTable pt))\"", "property": "Page Table and Page Directory Access: Provides functions to access and modify the page directory (PDE) and page table (PTE) entries in the x64 virtual space. The functions calculate the base and offset of the given pointer, retrieve or store the corresponding PDE, and handle the retrieval and setting of PTEs for a given page table.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PDE in kernel memory\n  and returns the actual PDE."}
{"spec": "definition\n  get_pte :: \"obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\" where\n  \"get_pte ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pt_bits);\n     offset \\<leftarrow> return ((ptr && mask pt_bits) >> word_size_bits);\n     pt \\<leftarrow> get_pt base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pte :: \"obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pte p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pt_bits);\n    offset \\<leftarrow> return ((p && mask pt_bits) >> word_size_bits);\n    pt \\<leftarrow> get_pt base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pt base pt'\n  od\"\n\ndefinition\n  get_pdpt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pdpte,'z::state_ext) s_monad\" where\n  \"get_pdpt ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PDPointerTable pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pdpt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pdpte) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pdpt ptr pt \\<equiv> set_object ptr (ArchObj (PDPointerTable pt))\"", "property": "VSpace Access and Modification: Provides functions to access and modify the x64 virtual space, including retrieving and storing PTEs, and getting and setting PDPTs. These functions ensure that the kernel can effectively manage and manipulate the virtual memory structures.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory\n  and returns the actual PTE."}
{"spec": "definition\n  get_pdpte :: \"obj_ref \\<Rightarrow> (pdpte,'z::state_ext) s_monad\" where\n  \"get_pdpte ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pdpt_bits);\n     offset \\<leftarrow> return ((ptr && mask pdpt_bits) >> word_size_bits);\n     pt \\<leftarrow> get_pdpt base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pdpte :: \"obj_ref \\<Rightarrow> pdpte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pdpte p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pdpt_bits);\n    offset \\<leftarrow> return ((p && mask pdpt_bits) >> word_size_bits);\n    pt \\<leftarrow> get_pdpt base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pdpt base pt'\n  od\"\n\ndefinition\n  get_pml4 :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pml4e,'z::state_ext) s_monad\" where\n  \"get_pml4 ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageMapL4 pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pml4 :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pml4e) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pml4 ptr pt \\<equiv> set_object ptr (ArchObj (PageMapL4 pt))\"", "property": "VSpace Access and Modification: Provides functions to access and modify the x64 virtual address space, including retrieving and storing PDPTEs, and getting and setting the PML4 table. These operations ensure that the kernel can manage and manipulate the virtual memory mappings effectively.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PDPTE in kernel memory\n  and returns the actual PDPTE."}
{"spec": "definition\n  get_pml4e :: \"obj_ref \\<Rightarrow> (pml4e,'z::state_ext) s_monad\" where\n  \"get_pml4e ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pml4_bits);\n     offset \\<leftarrow> return ((ptr && mask pml4_bits) >> word_size_bits);\n     pt \\<leftarrow> get_pml4 base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pml4e :: \"obj_ref \\<Rightarrow> pml4e \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pml4e p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pml4_bits);\n    offset \\<leftarrow> return ((p && mask pml4_bits) >> word_size_bits);\n    pt \\<leftarrow> get_pml4 base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pml4 base pt'\n  od\"", "property": "PML4E Access and Modification: Retrieve and modify the PML4E entry at a given pointer in kernel memory. The functions calculate the base address and offset, access the PML4 table, and either return or update the specific PML4E entry.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PML4E in kernel memory\n  and returns the actual PML4E."}
{"spec": "definition\nget_pt_index :: \"vspace_ref \\<Rightarrow> machine_word\" where\n\"get_pt_index vptr \\<equiv> (vptr >> pt_shift_bits) && mask ptTranslationBits\"\n\ndefinition\nget_pd_index :: \"vspace_ref \\<Rightarrow> machine_word\" where\n\"get_pd_index vptr \\<equiv> (vptr >> (pd_shift_bits)) && mask ptTranslationBits\"\n\ndefinition\nget_pdpt_index :: \"vspace_ref \\<Rightarrow> machine_word\" where\n\"get_pdpt_index vptr \\<equiv> (vptr >> (pdpt_shift_bits)) && mask ptTranslationBits\"\n\ndefinition\nget_pml4_index :: \"vspace_ref \\<Rightarrow> machine_word\" where\n\"get_pml4_index vptr \\<equiv> (vptr >> pml4_shift_bits) && mask ptTranslationBits\"", "property": "VSpace Index Calculation: Compute the indices for different levels of the x64 virtual address space (page table, page directory, page directory pointer table, and page map level 4) by shifting and masking the virtual pointer.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition\ncopy_global_mappings :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"copy_global_mappings new_pm \\<equiv> do\n    global_pm \\<leftarrow> gets (x64_global_pml4 \\<circ> arch_state);\n    base \\<leftarrow> return $ get_pml4_index pptr_base;\n    pme_bits \\<leftarrow> return word_size_bits;\n    pm_size \\<leftarrow> return (1 << ptTranslationBits);\n    mapM_x (\\<lambda>index. do\n        offset \\<leftarrow> return (index << pme_bits);\n        pme \\<leftarrow> get_pml4e (global_pm + offset);\n        store_pml4e (new_pm + offset) pme\n    od) [base  .e.  pm_size - 1]\n  od\"", "property": "Copy Global Mappings: Replicate the kernel window mappings from the global page directory into a new page directory object, ensuring that the kernel's virtual address space is consistently mapped across different page directories.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "The kernel window is mapped into every virtual address space from the\n@{term pptr_base} pointer upwards. This function copies the mappings which\ncreate the kernel window into a new page directory object."}
{"spec": "definition\nlookup_pml4_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\" where\n\"lookup_pml4_slot pm vptr \\<equiv> let pm_index = get_pml4_index vptr\n                             in pm + (pm_index << word_size_bits)\"\n\ndefinition\nlookup_pdpt_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"lookup_pdpt_slot pd vptr \\<equiv> doE\n    pml4_slot \\<leftarrow> returnOk (lookup_pml4_slot pd vptr);\n    pml4e \\<leftarrow> liftE $ get_pml4e pml4_slot;\n    (case pml4e of\n          PDPointerTablePML4E tab _ _ \\<Rightarrow> (doE\n            pd \\<leftarrow> returnOk (ptrFromPAddr tab);\n            pd_index \\<leftarrow> returnOk (get_pdpt_index vptr);\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << word_size_bits));\n            returnOk pd_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability pml4_shift_bits)\n odE\"", "property": "VSpace Lookup: Traverse the page directories and tables to locate the slot corresponding to a given virtual address. This involves walking the PML4 and PDPT levels, ensuring that the correct page directory pointer is retrieved and the appropriate slot is identified.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "Walk the page directories and tables in software."}
{"spec": "definition\n  lookup_pdpt_slot_no_fail :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\"\nwhere\n  \"lookup_pdpt_slot_no_fail pdpt vptr \\<equiv>\n     pdpt + (get_pdpt_index vptr << word_size_bits)\"", "property": "Lookup PDPT Slot: Provides a non-failing method to determine the slot in the Page Directory Pointer Table (PDPT) for a given virtual address, assuming the base address of the PDPT is known.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pdpt_slot} when the pml4 is already known"}
{"spec": "definition\nlookup_pd_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"lookup_pd_slot pd vptr \\<equiv> doE\n    pdpt_slot \\<leftarrow> lookup_pdpt_slot pd vptr;\n    pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n    (case pdpte of\n          PageDirectoryPDPTE tab _ _ \\<Rightarrow> (doE\n            pd \\<leftarrow> returnOk (ptrFromPAddr tab);\n            pd_index \\<leftarrow> returnOk (get_pd_index vptr);\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << word_size_bits));\n            returnOk pd_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability pdpt_shift_bits)\n odE\"", "property": "Lookup Page Directory Slot: Computes a pointer to the page directory entry (PDE) in kernel memory by first locating the corresponding page-directory-pointer-table entry (PDPTE) and then using it to find the page directory. If the PDPTE is not a valid page directory, an error is thrown.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PDE in kernel memory"}
{"spec": "definition\n  lookup_pd_slot_no_fail :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\"\nwhere\n  \"lookup_pd_slot_no_fail pd vptr \\<equiv>\n     pd + (get_pd_index vptr << word_size_bits)\"", "property": "Lookup PD Slot Without Failure: Provides a reliable method to determine the physical address of a page directory slot given a known page directory pointer table (PDPT) and a virtual space reference (vptr). This ensures that the lookup operation does not fail, facilitating efficient and predictable memory management.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pd_slot} when the pdpt is already known"}
{"spec": "definition\nlookup_pt_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n\"lookup_pt_slot vspace vptr \\<equiv> doE\n    pd_slot \\<leftarrow> lookup_pd_slot vspace vptr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    (case pde of\n          PageTablePDE ptab _ _ \\<Rightarrow>   (doE\n            pt \\<leftarrow> returnOk (ptrFromPAddr ptab);\n            pt_index \\<leftarrow> returnOk (get_pt_index vptr);\n            pt_slot \\<leftarrow> returnOk (pt + (pt_index << word_size_bits));\n            returnOk pt_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability pd_shift_bits)\n   odE\"", "property": "Page Table Slot Lookup: Given a virtual address, the function computes and returns a pointer to the corresponding page table entry (PTE) in kernel memory. If the virtual address is mapped on a section or super section, the function fails.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PTE in kernel memory.\n  Note that the function fails if the virtual address is mapped on a section or\n  super section."}
{"spec": "definition\n  lookup_pt_slot_no_fail :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\"\nwhere\n  \"lookup_pt_slot_no_fail pt vptr \\<equiv>\n     pt + (get_pt_index vptr << word_size_bits)\"\n\n\n\n\nend\nend", "property": "Lookup Page Table Slot: Provides a non-failing method to determine the page table slot for a given virtual address, assuming the page directory is already known. This ensures efficient and reliable access to the VSpace structure.", "title": "./spec/abstract/X64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the x64 VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pt_slot} when the pd is already known"}
{"spec": "text \\<open>This definition ensures that the given pointer is aligned\nto the given page size.\\<close>\n\ndefinition\n  check_vp_alignment :: \"vmpage_size \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $\n       throwError AlignmentError\"", "property": "Check Virtual Page Alignment: Ensure that the given virtual page pointer is aligned to the specified page size, throwing an alignment error if the condition is not met.", "title": "./spec/abstract/X64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "text \\<open>This definition decodes architecture-specific invocations.\n\\<close>\n\ndefinition\n  page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\nwhere\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"\n\n\n\n*)\n\ndefinition\ndecode_page_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap\n                            \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_page_invocation label args cte cap extra_caps \\<equiv> (case cap of\n  PageCap dev p R map_type pgsz mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel X64PageMap then\n    if length args > 2 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             rights_mask = args ! 1;\n             attr = args ! 2;\n             vspace_cap = fst (extra_caps ! 0)\n         in doE\n             (vspace, asid) \\<leftarrow> (case vspace_cap of\n                                   ArchObjectCap (PML4Cap pm (Some asid)) \\<Rightarrow>\n                                         returnOk (pm, asid)\n                                 | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n             case mapped_address of\n               Some (asid', vaddr') \\<Rightarrow> doE\n                 whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n                 whenE (map_type \\<noteq> VMVSpaceMap) $ throwError IllegalOperation;\n                 whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0)\n               odE\n             | None \\<Rightarrow> doE\n                 vtop \\<leftarrow> returnOk $ vaddr + bit (pageBitsForSize pgsz);\n                 whenE (vaddr > user_vtop \\<or> vtop > user_vtop) $ throwError $ InvalidArgument 0\n               odE;\n             vspace' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n             whenE (vspace' \\<noteq> vspace) $ throwError $ InvalidCapability 1;\n             vm_rights \\<leftarrow> returnOk $ mask_vm_rights R $ data_to_rights rights_mask;\n             check_vp_alignment pgsz vaddr;\n             entries \\<leftarrow> create_mapping_entries (addrFromPPtr p) vaddr pgsz vm_rights\n                                               (attribs_from_word attr) vspace;\n             ensure_safe_mapping entries;\n             returnOk $ InvokePage $ PageMap\n               (ArchObjectCap $ PageCap dev p R VMVSpaceMap pgsz (Some (asid,vaddr))) cte entries vspace\n          odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel X64PageUnmap then\n             \\<^cancel>\\<open>case map_type of\n                 VMIOSpaceMap \\<Rightarrow> decode_io_unmap_invocation label args cte cap extra_caps\n               | _ \\<Rightarrow>\\<close> returnOk $ InvokePage $ PageUnmap cap cte\n    \\<^cancel>\\<open>FIXME x64-vtd:\n    else if invocation_type label = ArchInvocationLabel X64PageMapIO\n    then decode_io_map_invocation label args cte cap extra_caps \\<close>\n    else if invocation_type label = ArchInvocationLabel X64PageGetAddress\n    then returnOk $ InvokePage $ PageGetAddr p\n  else throwError IllegalOperation\n | _ \\<Rightarrow> fail)\"\n\ndefinition filter_frame_attrs :: \"frame_attrs \\<Rightarrow> table_attrs\"\nwhere\n  \"filter_frame_attrs attrs \\<equiv> {s. \\<exists>s' \\<in> attrs. s' = PTAttr s}\"\n\ndefinition\n  decode_page_table_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow>\n                                  (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_page_table_invocation label args cte cap extra_caps \\<equiv> (case cap of\n    PageTableCap p mapped_address \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64PageTableMap then\n      if length args > 1 \\<and> length extra_caps > 0\n      then let vaddr = args ! 0;\n               attr = args ! 1;\n               pml4_cap = fst (extra_caps ! 0)\n      in doE\n               whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n               vaddr' \\<leftarrow> returnOk $ vaddr && ~~ mask pd_shift_bits;\n               (pml4, asid) \\<leftarrow> (case pml4_cap of\n                   ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> returnOk (pml4, asid)\n                   | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               whenE (user_vtop < vaddr') $ throwError $ InvalidArgument 0;\n               pml4' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n               whenE (pml4' \\<noteq> pml4) $ throwError $ InvalidCapability 1;\n               pd_slot \\<leftarrow> lookup_error_on_failure False $ lookup_pd_slot pml4 vaddr';\n               old_pde \\<leftarrow> liftE $ get_pde pd_slot;\n               unlessE (old_pde = InvalidPDE) $ throwError DeleteFirst;\n               pde \\<leftarrow> returnOk (PageTablePDE (addrFromPPtr p)\n                                  (filter_frame_attrs $ attribs_from_word attr) vm_read_write);\n               cap' <- returnOk $ ArchObjectCap $ PageTableCap p $ Some (asid, vaddr');\n               returnOk $ InvokePageTable $ PageTableMap cap' cte pde pd_slot pml4\n            odE\n      else throwError TruncatedMessage\n      else if invocation_type label = ArchInvocationLabel X64PageTableUnmap then doE\n               final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n               unlessE final $ throwError RevokeFirst;\n               returnOk $ InvokePageTable $ PageTableUnmap (ArchObjectCap cap) cte\n        odE\n      else throwError IllegalOperation\n  | _ \\<Rightarrow> fail)\"\n\ndefinition\n  decode_page_directory_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow>\n                                      (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_page_directory_invocation label args cte cap extra_caps \\<equiv> (case cap of\n    PageDirectoryCap p mapped_address \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64PageDirectoryMap then\n      if length args > 1 \\<and> length extra_caps > 0\n      then let vaddr = args ! 0;\n               attr = args ! 1;\n               pml4_cap = fst (extra_caps ! 0)\n      in doE\n               whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n               vaddr' \\<leftarrow> returnOk $ vaddr && ~~ mask pdpt_shift_bits;\n               (pml4, asid) \\<leftarrow> (case pml4_cap of\n                       ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> returnOk (pml4, asid)\n                       | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               whenE (user_vtop < vaddr') $ throwError $ InvalidArgument 0;\n               pml4' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n               whenE (pml4' \\<noteq> pml4) $ throwError $ InvalidCapability 1;\n               pdpt_slot \\<leftarrow> lookup_error_on_failure False $ lookup_pdpt_slot pml4 vaddr';\n               old_pdpte \\<leftarrow> liftE $ get_pdpte pdpt_slot;\n               unlessE (old_pdpte = InvalidPDPTE) $ throwError DeleteFirst;\n               pdpte \\<leftarrow> returnOk (PageDirectoryPDPTE (addrFromPPtr p)\n                          (filter_frame_attrs $ attribs_from_word attr) vm_read_write);\n               cap' <- returnOk $ ArchObjectCap $ PageDirectoryCap p $ Some (asid, vaddr');\n               returnOk $ InvokePageDirectory $ PageDirectoryMap cap' cte pdpte pdpt_slot pml4\n        odE\n      else throwError TruncatedMessage\n      else if invocation_type label = ArchInvocationLabel X64PageDirectoryUnmap then doE\n               final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n               unlessE final $ throwError RevokeFirst;\n               returnOk $ InvokePageDirectory $ PageDirectoryUnmap (ArchObjectCap cap) cte\n            odE\n      else throwError IllegalOperation\n  | _ \\<Rightarrow> fail)\"\n\ndefinition\n  decode_pdpt_invocation :: \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow>\n                                      (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_pdpt_invocation label args cte cap extra_caps \\<equiv> (case cap of\n    PDPointerTableCap p mapped_address \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64PDPTMap then\n      if length args > 1 \\<and> length extra_caps > 0\n      then let vaddr = args ! 0;\n               attr = args ! 1;\n               pml4_cap = fst (extra_caps ! 0)\n      in doE\n               whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n               vaddr' \\<leftarrow> returnOk $ vaddr && ~~ mask pml4_shift_bits;\n               (pml4 ,asid) \\<leftarrow> (case pml4_cap of\n                       ArchObjectCap (PML4Cap pml4 (Some asid)) \\<Rightarrow> returnOk (pml4, asid)\n                       | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               whenE (user_vtop < vaddr') $ throwError $ InvalidArgument 0;\n               pml4' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid (asid);\n               whenE (pml4' \\<noteq> pml4) $ throwError $ InvalidCapability 1;\n               pml_slot \\<leftarrow> returnOk $ lookup_pml4_slot pml4 vaddr';\n               old_pml4e \\<leftarrow> liftE $ get_pml4e pml_slot;\n               unlessE (old_pml4e = InvalidPML4E) $ throwError DeleteFirst;\n               pml4e \\<leftarrow> returnOk (PDPointerTablePML4E (addrFromPPtr p)\n                          (filter_frame_attrs $ attribs_from_word attr) vm_read_write);\n               cap' <- returnOk $ ArchObjectCap $ PDPointerTableCap p $ Some (asid, vaddr');\n               returnOk $ InvokePDPT $ PDPTMap cap' cte pml4e pml_slot pml4\n            odE\n      else throwError TruncatedMessage\n      else if invocation_type label = ArchInvocationLabel X64PDPTUnmap then doE\n               final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n               unlessE final $ throwError RevokeFirst;\n               returnOk $ InvokePDPT $ PDPTUnmap (ArchObjectCap cap) cte\n         odE\n      else throwError IllegalOperation\n  | _ \\<Rightarrow> fail)\"\n\ndefinition\n  arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n    PDPointerTableCap _ _ \\<Rightarrow> decode_pdpt_invocation label args cte cap extra_caps\n  | PageDirectoryCap _ _ \\<Rightarrow> decode_page_directory_invocation label args cte cap extra_caps\n  | PageTableCap _ _ \\<Rightarrow> decode_page_table_invocation label args cte cap extra_caps\n  | PageCap _ _ _ _ _ _ \\<Rightarrow> decode_page_invocation label args cte cap extra_caps\n  | ASIDControlCap \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64ASIDControlMakePool then\n      if length args > 1 \\<and> length extra_caps > 1\n      then let index = args ! 0;\n               depth = args ! 1;\n               (untyped, parent_slot) = extra_caps ! 0;\n               root = fst (extra_caps ! 1)\n      in doE\n               asid_table \\<leftarrow> liftE $ gets (x64_asid_table \\<circ> arch_state);\n               free_set \\<leftarrow> returnOk (- dom asid_table);\n               whenE (free_set = {}) $ throwError DeleteFirst;\n               free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n               base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n               (p,n) \\<leftarrow> (case untyped of UntypedCap False p n f \\<Rightarrow> returnOk (p,n)\n                                        | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n               frame \\<leftarrow> (if n = pageBits\n                        then doE\n                            ensure_no_children parent_slot;\n                            returnOk p\n                          odE\n                        else  throwError $ InvalidCapability 1);\n               dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n               ensure_empty dest_slot;\n               returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n           odE\n   else throwError TruncatedMessage\n   else throwError IllegalOperation\n\n  | ASIDPoolCap p base \\<Rightarrow>\n      if invocation_type label = ArchInvocationLabel X64ASIDPoolAssign then\n      if length extra_caps > 0\n      then let (pd_cap, pd_cap_slot) = extra_caps ! 0 in\n            case pd_cap of\n               ArchObjectCap (PML4Cap _ None) \\<Rightarrow> doE\n                  asid_table \\<leftarrow> liftE $ gets (x64_asid_table \\<circ> arch_state);\n                  pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n                  whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n                  whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n                  pool \\<leftarrow> liftE $ get_asid_pool p;\n                  free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n                  whenE (free_set = {}) $ throwError DeleteFirst;\n                  offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n                  returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pd_cap_slot\n              odE\n            | _ \\<Rightarrow> throwError $ InvalidCapability 1\n      else throwError TruncatedMessage\n      else throwError IllegalOperation\n\n  | IOPortCap f l \\<Rightarrow> decode_port_invocation label args (IOPortCap f l)\n  | IOPortControlCap \\<Rightarrow> decode_ioport_control_invocation label args cte cap (map fst extra_caps)\n  | PML4Cap a b \\<Rightarrow> throwError IllegalOperation\"\n\ndefinition\n  arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\" where\n \"arch_data_to_obj_type n \\<equiv>\n  if      n = 0 then Some PDPTObj\n  else if n = 1 then Some PML4Obj\n  else if n = 2 then Some HugePageObj\n  else if n = 3 then Some SmallPageObj\n  else if n = 4 then Some LargePageObj\n  else if n = 5 then Some PageTableObj\n  else if n = 6 then Some PageDirectoryObj\n  else None\"\n\ndefinition\n  arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"arch_check_irq irq \\<equiv> throwError IllegalOperation\"\n\nend (* context Arch *)\n\nend", "property": "Architecture-specific Invocation Decoding: Decode and validate architecture-specific system calls, including page, page table, page directory, and PDPT mappings and unmappings, as well as ASID pool assignments. This ensures that the system calls are correctly interpreted and executed, maintaining the integrity and security of the virtual memory system.", "title": "./spec/abstract/X64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "datatype pdpt_invocation =\n    PDPTMap cap cslot_ptr pml4e obj_ref obj_ref\n  | PDPTUnmap cap cslot_ptr\n\ndatatype page_directory_invocation =\n    PageDirectoryMap cap cslot_ptr pdpte obj_ref obj_ref\n  | PageDirectoryUnmap cap cslot_ptr\n\ndatatype page_table_invocation =\n    PageTableMap cap cslot_ptr pde obj_ref obj_ref\n  | PageTableUnmap cap cslot_ptr\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation\n     = PageMap\n         (page_map_cap: cap)\n         (page_map_ct_slot: cslot_ptr)\n         (page_map_entries: \"vm_page_entry \\<times> obj_ref\")\n         (page_map_vspace: obj_ref)\n     | PageUnmap\n         (page_unmap_cap: arch_cap)\n         (page_unmap_cap_slot: cslot_ptr)", "property": "Memory Management Invocations: Define the operations for managing memory structures, including mapping and unmapping of page directory pointer tables, page directories, and page tables, as well as creating ASID pools and assigning ASIDs. These operations ensure that memory is correctly allocated and deallocated, maintaining the integrity and efficiency of the virtual memory system.", "title": "./spec/abstract/X64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the various possible\nx64-specific system calls. Selectors are defined for various fields\nfor convenience elsewhere."}
{"spec": "| PageGetAddr\n         (page_get_paddr: obj_ref)\n\ndatatype io_port_invocation_data\n  = IOPortIn8 | IOPortIn16 | IOPortIn32\n  | IOPortOut8 \"8 word\" | IOPortOut16 \"16 word\" | IOPortOut32 \"32 word\"\n\ndatatype io_port_invocation = IOPortInvocation io_port io_port_invocation_data\n\ndatatype io_port_control_invocation = IOPortControlInvocation io_port io_port cslot_ptr cslot_ptr", "property": "Page and I/O Port Operations: Enable the management of page mappings and I/O port operations, including reading from and writing to I/O ports with different data sizes (8-bit, 16-bit, 32-bit). These operations ensure that memory and I/O interactions are controlled and secure.", "title": "./spec/abstract/X64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "     | PageIOMap\n         (page_iomap_cap: cap)\n         (page_iomap_ct_clot: cslot_ptr)\n         (page_iomap_asid: iopte)\n         (page_iomap_entries: \"obj_ref\") "}
{"spec": "datatype arch_invocation\n     = InvokePageTable page_table_invocation\n     | InvokePageDirectory page_directory_invocation\n     | InvokePDPT pdpt_invocation\n     | InvokePage page_invocation\n     | InvokeASIDControl asid_control_invocation\n     | InvokeASIDPool asid_pool_invocation\n     | InvokeIOPort io_port_invocation\n     | InvokeIOPortControl io_port_control_invocation", "property": "Architectural Invocations: Define a set of architectural operations including page table, page directory, PDPT, page, ASID control, ASID pool, I/O port, and I/O port control invocations. These operations allow for the management and manipulation of memory and I/O resources in the system.", "title": "./spec/abstract/X64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "\ndatatype io_pt_invocation\n     = IOPageTableMapContext cap cslot_ptr iocte obj_ref\n     | IOPageTableMap cap cslot_ptr iopte obj_ref\n     | IOPageTableUnmap cap cslot_ptr "}
{"spec": "datatype arch_copy_register_sets = X64NoExtraRegisters\n\ndefinition \"ArchDefaultExtraRegisters \\<equiv> X64NoExtraRegisters\"\n\ndatatype arch_irq_control_invocation\n  = IssueIRQHandlerIOAPIC irq cslot_ptr cslot_ptr\n      machine_word machine_word machine_word machine_word machine_word\n  | IssueIRQHandlerMSI irq cslot_ptr cslot_ptr\n      machine_word machine_word machine_word machine_word\n\nend\nend", "property": "Architectural IRQ Control: Supports the issuance of IRQ handlers for IOAPIC and MSI interrupts, allowing for the configuration of interrupt handling with specific control parameters.", "title": "./spec/abstract/X64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "| InvokeIOPT io_pt_invocation"}
{"spec": "type_synonym io_port = \"16 word\"\ntype_synonym io_asid = \"16 word\"", "property": "Architecture-Specific Data Types: Defines architecture-specific data types, including `io_port` and `io_asid`, both represented as 16-bit words.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific capabilities", "comment": ""}
{"spec": "text \\<open>The x64 kernel supports capabilities for ASID pools and an ASID controller capability,\nalong with capabilities for IO ports and spaces, as well as virtual memory mappings.\\<close>\n\ndatatype arch_cap =\n   ASIDPoolCap (acap_asid_pool : obj_ref) (acap_asid_base : asid)\n | ASIDControlCap\n | IOPortCap (acap_io_port_first_port : io_port) (acap_io_port_last_port : io_port)\n | IOPortControlCap\n\n | PageCap bool obj_ref (acap_rights : cap_rights) vmmap_type vmpage_size \"(asid * vspace_ref) option\"\n | PageTableCap obj_ref \"(asid * vspace_ref) option\"\n | PageDirectoryCap obj_ref \"(asid * vspace_ref) option\"\n | PDPointerTableCap obj_ref \"(asid * vspace_ref) option\"\n | PML4Cap obj_ref \"asid option\"", "property": "x64-Specific Capabilities: The x64 kernel supports various architecture-specific capabilities, including ASID pools, ASID controller, IO ports, IO port controller, and different types of virtual memory mappings such as page, page table, page directory, PD pointer table, and PML4. These capabilities enable the management and control of memory and I/O resources specific to the x64 architecture.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "datatype cr3 = cr3 obj_ref asid\n\nprimrec\n  cr3_base_address :: \"cr3 \\<Rightarrow> obj_ref\"\nwhere\n  \"cr3_base_address (cr3 addr _) = addr\"\n\nprimrec\n  cr3_pcid :: \"cr3 \\<Rightarrow> asid\"\nwhere\n  \"cr3_pcid (cr3 _ pcid) = pcid\"", "property": "CR3 Data Type: Represents a control register 3 (CR3) with a base address and a process context identifier (PCID). The base address and PCID can be extracted from the CR3 data type, allowing for the manipulation and retrieval of these architecture-specific properties.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific objects", "comment": " cr3 Stuff "}
{"spec": "datatype table_attr = Accessed | CacheDisabled | WriteThrough | ExecuteDisable\ntype_synonym table_attrs = \"table_attr set\"\n\ndatatype frame_attr = PTAttr table_attr | Global | PAT | Dirty\ntype_synonym frame_attrs = \"frame_attr set\"\n\ndatatype pml4e\n     = InvalidPML4E\n     | PDPointerTablePML4E\n         (pml4_table : obj_ref)\n         (pml4e_attrs : table_attrs)\n         (pml4e_rights : vm_rights)\n\ndatatype pdpte\n     = InvalidPDPTE\n     | PageDirectoryPDPTE\n         (pdpt_table : obj_ref)\n         (pdpt_table_attrs : table_attrs)\n         (pdpt_rights : vm_rights)\n     | HugePagePDPTE\n         (pdpt_frame : obj_ref)\n         (pdpt_frame_attrs : frame_attrs)\n         (pdpt_rights : vm_rights)\n\ndatatype pde\n      = InvalidPDE\n      | PageTablePDE\n         obj_ref\n         (pt_attrs : table_attrs)\n         (pde_rights : cap_rights)\n      | LargePagePDE\n         obj_ref\n         (pde_page_attrs : frame_attrs)\n         (pde_rights: cap_rights)\n\ndatatype pte\n      = InvalidPTE\n      | SmallPagePTE\n         (pte_frame: obj_ref)\n         (pte_frame_attrs : frame_attrs)\n         (pte_rights : cap_rights)\n\n\ndatatype vm_page_entry = VMPTE pte | VMPDE pde | VMPDPTE pdpte\n\ndatatype translation_type = NotTranslated | Translated\n\ndatatype iocte =\n   InvalidIOCTE\n | VTDCTE\n   (domain_id : word16)\n   (res_mem_reg: bool)\n   (address_width: nat)\n   (next_level_ptr: obj_ref)\n   (translation_type: translation_type)\n   (iocte_present : bool)\n\ndatatype iopte =\n   InvalidIOPTE\n | VTDPTE\n   (frame_ptr : obj_ref)\n   (io_pte_rights  : vm_rights)\n\ndatatype iorte =\n   InvalidIORTE\n | VTDRTE\n   (context_table : obj_ref)\n   (iorte_present : bool)\n\ndatatype arch_kernel_obj =\n   ASIDPool \"9 word \\<rightharpoonup> obj_ref\"\n | PageTable \"9 word \\<Rightarrow> pte\"\n | PageDirectory \"9 word \\<Rightarrow> pde\"\n | PDPointerTable \"9 word \\<Rightarrow> pdpte\"\n | PageMapL4 \"9 word \\<Rightarrow> pml4e\"\n | DataPage bool vmpage_size\n\n\ndefinition table_size :: nat where\n  \"table_size = ptTranslationBits + word_size_bits\"\n\ndefinition iotable_size :: nat where\n  \"iotable_size = ptTranslationBits + 2*word_size_bits\"\n\ndefinition cte_level_bits :: nat where\n  \"cte_level_bits \\<equiv> 5\"\n\nprimrec\n  arch_obj_size :: \"arch_cap \\<Rightarrow> nat\"\nwhere\n  \"arch_obj_size (ASIDPoolCap _ _) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (IOPortCap _ _) = 0\"\n| \"arch_obj_size IOPortControlCap = 0\"\n\n| \"arch_obj_size (PageCap _ _ _ _ sz _) = pageBitsForSize sz\"\n| \"arch_obj_size (PageTableCap _ _) = table_size\"\n| \"arch_obj_size (PageDirectoryCap _ _) = table_size\"\n| \"arch_obj_size (PDPointerTableCap _ _) = table_size\"\n| \"arch_obj_size (PML4Cap _ _) = table_size\"\n\nprimrec\n  arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_cap_is_device (ASIDPoolCap _ _) = False\"\n| \"arch_cap_is_device ASIDControlCap = False\"\n| \"arch_cap_is_device (IOPortCap _ _) = False\"\n| \"arch_cap_is_device IOPortControlCap = False\"\n\n| \"arch_cap_is_device (PageCap is_dev _ _ _ _ _) = is_dev\"\n| \"arch_cap_is_device (PageTableCap _ _) = False\"\n| \"arch_cap_is_device (PageDirectoryCap _ _) = False\"\n| \"arch_cap_is_device (PDPointerTableCap _ _) = False\"\n| \"arch_cap_is_device (PML4Cap _ _) = False\"\n\ndefinition tcb_bits :: nat where\n  \"tcb_bits \\<equiv> 11\"\n\ndefinition endpoint_bits :: nat where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat where\n  \"ntfn_bits \\<equiv> 5\"\n\ndefinition untyped_min_bits :: nat where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat where\n  \"untyped_max_bits \\<equiv> 47\"\n\nprimrec\n  arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\"\nwhere\n  \"arch_kobj_size (ASIDPool _) = pageBits\"\n| \"arch_kobj_size (PageTable _) = table_size\"\n| \"arch_kobj_size (PageDirectory _) = table_size\"\n| \"arch_kobj_size (PDPointerTable _) = table_size\"\n| \"arch_kobj_size (PageMapL4 _) = table_size\"\n| \"arch_kobj_size (DataPage _ sz) = pageBitsForSize sz\"\n\nprimrec\n  aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\"\nwhere\n  \"aobj_ref (ASIDPoolCap x _) = Some x\"\n| \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref (IOPortCap _ _) = None\"\n| \"aobj_ref IOPortControlCap = None\"\n\n| \"aobj_ref (PageCap _ x _ _ _ _) = Some x\"\n| \"aobj_ref (PageDirectoryCap x _) = Some x\"\n| \"aobj_ref (PageTableCap x _) = Some x\"\n| \"aobj_ref (PDPointerTableCap x _) = Some x\"\n| \"aobj_ref (PML4Cap x _) = Some x\"\n\n\ndefinition\n  acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\" where\n \"acap_rights_update rs ac \\<equiv> case ac of\n    PageCap dev x rs' m sz as \\<Rightarrow> PageCap dev x (validate_vm_rights rs) m sz as\n  | _                   \\<Rightarrow> ac\"", "property": "Architecture-Specific Data Types: Define various x64-specific data types and their attributes, including table and frame attributes, page table entries (PML4E, PDPTE, PDE, PTE), and I/O translation structures (IOCTE, IOPT, IORTE). These data types and their attributes are used to manage memory and I/O translations, ensuring proper access control and memory management.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "datatype\n  aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | HugePageObj\n  | PageTableObj\n  | PageDirectoryObj\n  | PDPTObj\n  | PML4Obj\n  | ASIDPoolObj\n\ndatatype X64IRQState =\n   IRQFree\n | IRQReserved\n | IRQMSI\n      (MSIBus : machine_word)\n      (MSIDev : machine_word)\n      (MSIFunc : machine_word)\n      (MSIHandle : machine_word)\n | IRQIOAPIC\n      (IRQioapic : machine_word)\n      (IRQPin : machine_word)\n      (IRQLevel : machine_word)\n      (IRQPolarity : machine_word)\n      (IRQMasked : bool)\n\ndefinition\n  arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\"\nwhere\n  \"arch_is_frame_type aobj \\<equiv> case aobj of\n         SmallPageObj \\<Rightarrow> True\n       | LargePageObj \\<Rightarrow> True\n       | HugePageObj \\<Rightarrow> True\n       | _ \\<Rightarrow> False\"\n\ndefinition\n  arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\" where\n \"arch_default_cap tp r n dev \\<equiv> case tp of\n    SmallPageObj \\<Rightarrow> PageCap dev r vm_read_write VMNoMap X64SmallPage None\n  | LargePageObj \\<Rightarrow> PageCap dev r vm_read_write VMNoMap X64LargePage None\n  | HugePageObj \\<Rightarrow> PageCap dev r vm_read_write VMNoMap X64HugePage None\n  | PageTableObj \\<Rightarrow> PageTableCap r None\n  | PageDirectoryObj \\<Rightarrow> PageDirectoryCap r None\n  | PDPTObj \\<Rightarrow> PDPointerTableCap r None\n  | PML4Obj \\<Rightarrow> PML4Cap r None\n  | ASIDPoolObj \\<Rightarrow> ASIDPoolCap r 0\" (* unused *)\n\ndefinition\n  default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\" where\n \"default_arch_object tp dev n \\<equiv> case tp of\n    SmallPageObj \\<Rightarrow> DataPage dev X64SmallPage\n  | LargePageObj \\<Rightarrow> DataPage dev X64LargePage\n  | HugePageObj \\<Rightarrow> DataPage dev X64HugePage\n  | PageTableObj \\<Rightarrow> PageTable (\\<lambda>x. InvalidPTE)\n  | PageDirectoryObj \\<Rightarrow> PageDirectory (\\<lambda>x. InvalidPDE)\n  | PDPTObj \\<Rightarrow> PDPointerTable (\\<lambda>x. InvalidPDPTE)\n  | PML4Obj \\<Rightarrow> PageMapL4 (\\<lambda>x. InvalidPML4E)\n  | ASIDPoolObj \\<Rightarrow> ASIDPool (\\<lambda>_. None)\"\n\ntype_synonym x64_vspace_region_uses = \"vspace_ref \\<Rightarrow> x64vspace_region_use\"\n\nend\n\nqualify X64_A (in Arch)", "property": "Architecture-Specific Object Types and Default Objects: Defines a set of architecture-specific object types, including various page sizes, page tables, and other memory management structures. For each object type, it specifies whether the object is a frame type and provides default capabilities and kernel objects, ensuring consistent initialization and management of x64-specific memory and interrupt resources.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "record arch_state =\n  x64_asid_table            :: \"3 word \\<rightharpoonup> obj_ref\"\n  x64_global_pml4           :: obj_ref\n  x64_kernel_vspace         :: X64_A.x64_vspace_region_uses\n  x64_global_pts            :: \"obj_ref list\"\n  x64_global_pdpts          :: \"obj_ref list\"\n  x64_global_pds            :: \"obj_ref list\"\n  x64_current_cr3           :: \"X64_A.cr3\"\n  x64_allocated_io_ports    :: \"X64_A.io_port \\<Rightarrow> bool\"\n  x64_num_ioapics           :: \"64 word\"\n  x64_ioapic_nirqs          :: \"machine_word \\<Rightarrow> 8 word\"\n  x64_irq_state             :: \"8 word \\<Rightarrow> X64_A.X64IRQState\"\n\n\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  pd_shift_bits :: \"nat\" where\n  \"pd_shift_bits \\<equiv> pageBits + ptTranslationBits\"\n\ndefinition\n  pt_shift_bits :: \"nat\" where\n  \"pt_shift_bits \\<equiv> pageBits\"\n\ndefinition\n  pdpt_shift_bits :: \"nat\" where\n  \"pdpt_shift_bits \\<equiv> pageBits + ptTranslationBits + ptTranslationBits\"\n\ndefinition\n  pml4_shift_bits :: \"nat\" where\n  \"pml4_shift_bits \\<equiv> pageBits + ptTranslationBits + ptTranslationBits + ptTranslationBits\"\n\ndefinition\n  pt_bits :: \"nat\" where\n  \"pt_bits \\<equiv> table_size\"\n\ndefinition\n  pd_bits :: \"nat\" where\n  \"pd_bits \\<equiv> table_size\"\n\ndefinition\n  pdpt_bits :: \"nat\" where\n  \"pdpt_bits \\<equiv> table_size\"\n\ndefinition\n  pml4_bits :: \"nat\" where\n  \"pml4_bits \\<equiv> table_size\"\n\ndefinition\n  iopt_bits :: \"nat\" where\n  \"iopt_bits \\<equiv> iotable_size\"\n\ndefinition\n  vtd_cte_size_bits :: \"nat\" where\n  \"vtd_cte_size_bits \\<equiv> 8\"\n\ndefinition\n  vtd_pt_bits :: \"nat\" where\n  \"vtd_pt_bits \\<equiv> iotable_size\"\n\ndefinition\n  x64_num_io_pt_levels :: \"nat\" where\n  \"x64_num_io_pt_levels \\<equiv> 4\"", "property": "Architecture-Specific State: Defines the x64-specific data types and structures, including ASID tables, global page tables (PML4, PDPT, PD, PT), kernel virtual space, I/O port allocations, and IRQ state. These structures and their associated bit definitions ensure proper memory management, virtual address translation, and I/O handling in the x64 architecture.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable\n  | APageDirectory\n  | APDPointerTable\n  | APageMapL4\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\"\nwhere\n \"aa_type ao \\<equiv> (case ao of\n           PageTable pt             \\<Rightarrow> APageTable\n         | PageDirectory pd         \\<Rightarrow> APageDirectory\n         | DataPage dev sz          \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n         | ASIDPool f               \\<Rightarrow> AASIDPool\n         | PDPointerTable pdpt      \\<Rightarrow> APDPointerTable\n         | PageMapL4 pm             \\<Rightarrow> APageMapL4)\"", "property": "Architectural Object Type Classification: Classifies architectural kernel objects into specific types such as AASIDPool, APageTable, APageDirectory, APDPointerTable, APageMapL4, AUserData, and ADeviceData. This classification ensures that each object is accurately represented and managed according to its type, facilitating proper memory management and system integrity.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "definition\n  badge_bits :: nat where\n  \"badge_bits \\<equiv> 64\"\n\nend", "property": "Badge Bits Definition: The badge word is defined with 64 bits.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": "For implementation reasons the badge word has differing amounts of bits"}
{"spec": "qualify X64_A (in Arch)", "property": "Arch-specific TCB: Defines x64-specific data types and structures for the Thread Control Block (TCB), ensuring that the TCB is tailored to the architectural requirements of x64 systems.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Arch-specific TCB", "comment": ""}
{"spec": "record arch_tcb =\n  tcb_context :: user_context\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  default_arch_tcb :: arch_tcb where\n  \"default_arch_tcb \\<equiv> \\<lparr>tcb_context = new_context\\<rparr>\"", "property": "Arch-specific TCB: Contains a field for user context, which is essential for managing the architectural state of a thread.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Arch-specific TCB", "comment": " Arch-specific part of a TCB: this must have at least a field for user context. "}
{"spec": "definition\n  arch_tcb_context_set :: \"user_context \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\nwhere\n  \"arch_tcb_context_set uc a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := uc \\<rparr>\"\n\ndefinition\n  arch_tcb_context_get :: \"arch_tcb \\<Rightarrow> user_context\"\nwhere\n  \"arch_tcb_context_get a_tcb \\<equiv> tcb_context a_tcb\"", "property": "Arch-specific TCB Context Management: Provides accessor functions to set and get the user context within the architecture-specific TCB, ensuring compatibility with the user monad for operations that need to be performed in the context of a specific user.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Arch-specific TCB", "comment": " Accessors for @{text \"tcb_context\"} inside @{text \"arch_tcb\"}.\n  These are later used to implement @{text as_user}, i.e.\\ need to be\n  compatible with @{text user_monad}."}
{"spec": "definition\n  arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\nwhere\n  \"arch_tcb_set_registers regs a_tcb \\<equiv>\n    a_tcb \\<lparr> tcb_context := UserContext (fpu_state (tcb_context a_tcb)) regs \\<rparr>\"\n\ndefinition\n  arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\"\nwhere\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\n\nend", "property": "Arch-specific TCB Register Management: Provides functions to set and get user registers in the architecture-specific part of the TCB, ensuring that the user context is correctly updated and retrieved.", "title": "./spec/abstract/X64/Arch_Structs_A.thy", "chapter": "x64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n Accessors for the user register part of the @{text \"arch_tcb\"}.\n (Because @{typ \"register \\<Rightarrow> machine_word\"} may not be equal to @{typ user_context}).\n"}
{"spec": "(*\nFunctions for fault handling.\n*)\n\nchapter \\<open>arch fault related functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\nwhere\n \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData) od\"\n\ndefinition\n  handle_arch_fault_reply :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"handle_arch_fault_reply vmf thread x y \\<equiv> return True\"\n\n\nend\n\nend", "property": "Arch Fault Handling: Generate and handle architecture-specific fault messages. The system creates a fault message containing the program counter, virtual pointer, and architecture-specific data, and processes the fault reply, returning a boolean value.", "title": "./spec/abstract/X64/ArchFault_A.thy", "chapter": "arch fault related functions", "section": "", "comment": ""}
{"spec": "(*\nArch-specific functions for the abstract model of CSpace.\n*)\n\nchapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  sanitise_or_flags :: machine_word\nwhere\n  \"sanitise_or_flags \\<equiv> bit 1 || bit 9\"\n\ndefinition\n  sanitise_and_flags :: machine_word\nwhere\n  \"sanitise_and_flags \\<equiv> mask 12 && ~~ bit 8 && ~~ bit 3 && ~~ bit 5\"\n\ndefinition\n  sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"sanitise_register t r v \\<equiv>\n    let val = (if r = FaultIP \\<or> r = NextIP \\<or> r = FS_BASE \\<or> r = GS_BASE\n               then if v > 0x00007fffffffffff \\<and> v < 0xffff800000000000 then 0 else v\n               else v)\n    in\n      if r = FLAGS then (val || sanitise_or_flags) && sanitise_and_flags else val\"\n\ndefinition\n  arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\nwhere\n  \"arch_get_sanitise_register_info t \\<equiv> return False\"\n\ndefinition\n  arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\nwhere\n  \"arch_post_modify_registers cur t \\<equiv> when (t \\<noteq> cur) $ as_user t $ setRegister ErrorRegister 0\"\n\nend\nend", "property": "Architecture-specific TCB Functions: Define and implement architecture-specific operations for sanitizing register values and handling post-modification of registers. Sanitization ensures that specific registers are set to safe values under certain conditions, and post-modification updates the error register if the target thread is not the current thread.", "title": "./spec/abstract/X64/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "| \"arch_same_region_as (IOPortCap frst lst) c' =\n   (\\<exists>frst' lst'. c' = IOPortCap frst' lst' \\<and> frst' = frst \\<and> lst' = lst)\"\n| \"arch_same_region_as IOPortControlCap c' = (c' = IOPortControlCap \\<or> (\\<exists>f l. c' = IOPortCap f l))\"", "property": "Architectural Region Equivalence: Determines if two I/O port capabilities refer to the same region, either by having identical first and last port numbers for IOPortCap, or by being an IOPortControlCap that encompasses all I/O port capabilities.", "title": "./spec/abstract/X64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n \"same_aobject_as cp cp' \\<equiv>\n   (case (cp, cp') of\n      (PageCap dev ref _ _ pgsz _, PageCap dev' ref' _ _ pgsz' _)\n          \\<Rightarrow> (dev, ref, pgsz) = (dev', ref', pgsz')\n              \\<and> ref \\<le> ref + 2 ^ pageBitsForSize pgsz - 1\n    | (IOPortControlCap, IOPortCap f' l') \\<Rightarrow> False\n    | _ \\<Rightarrow> arch_same_region_as cp cp')\"\n\ndeclare same_aobject_as_def[simp]\n\ndefinition\n  arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"arch_is_cap_revocable new_cap src_cap \\<equiv>\n           if \\<exists>f l. new_cap = ArchObjectCap (IOPortCap f l)\n             then src_cap = ArchObjectCap IOPortControlCap\n             else False\"\n\nend\nend", "property": "Check Arch Capabilities for Same Object: Determine if two architecture capabilities refer to the same object by comparing their device, reference, and page size. Additionally, check if an I/O port capability is revocable based on the presence of an I/O port control capability.", "title": "./spec/abstract/X64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "type_synonym obj_ref            = machine_word\ntype_synonym vspace_ref         = machine_word\n\ntype_synonym data               = machine_word\ntype_synonym cap_ref            = \"bool list\"\ntype_synonym length_type        = machine_word\n\ntype_synonym asid_low_len      = 9\ntype_synonym asid_low_index    = \"asid_low_len word\"\n\ntype_synonym asid_high_len      = 3\ntype_synonym asid_high_index    = \"asid_high_len word\"", "property": "Type Instantiation for x64 Architecture: Defines concrete types for abstract type names, including object references, virtual space references, data, capability references, and length types, as well as specific lengths and indices for ASID (Address Space Identifier) components.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object\n  references, user pointers, word-based data, cap references, and so\n  on. This theory provides an instantiation of these names to concrete\n  types for the x64 architecture. Other architectures may have slightly\n  different instantiations.\n"}
{"spec": "type_synonym asid_len           = 12\ntype_synonym asid_rep_len       = machine_word_len\ntype_synonym asid               = \"asid_rep_len word\"", "property": "ASID Representation: The ASID is represented as a machine word, requiring invariants to ensure that the extra bits beyond the 12-bit ASID length are zero.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": " Making asid a machine_word means that we need invariants that the extra bits are zero. "}
{"spec": "definition\n  oref_to_data   :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_oref   :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition\n  vref_to_data   :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_vref   :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition\n  nat_to_len     :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition\n  data_to_nat    :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition\n  data_to_16     :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition\n  data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition\n  combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition\n  combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Convert between different data types, including object references, virtual space references, natural numbers, lengths, and various word sizes. These conversions ensure seamless interoperability and data representation consistency across the system.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "With the definitions above, most conversions between abstract\ntype names boil down to just the identity function, some convert from\n@{text word} to @{typ nat} and others between different word sizes\nusing @{const ucast}."}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversion Simplifications: Provide simplification rules for converting between different data representations, including object references, virtual references, natural numbers, 16-bit values, and capability pointers.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition\n  slot_bits :: nat where\n  \"slot_bits \\<equiv> 5\"\n\ndefinition\n  msg_label_bits :: nat where\n  [simp]: \"msg_label_bits \\<equiv> 52\"\n\ndefinition\n  new_context :: \"user_context\" where\n  \"new_context \\<equiv> UserContext FPUNullState ((\\<lambda>r. 0)(CS := selCS3, SS := selDS3, FLAGS := 0x202))\"\n\ndefinition\n  pptr_base :: \"machine_word\" where\n  \"pptr_base = Platform.X64.pptrBase\"", "property": "Architecture-Dependent Sizes: Define the standard sizes for various architectural components, including slot bits, message label bits, and the base physical pointer, ensuring consistent and architecture-specific configurations.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "The following definitions provide architecture-dependent sizes\n  such as the standard page size and capability size of the underlying\n  machine.\n"}
{"spec": "definition\n  user_vtop :: \"machine_word\" where\n  \"user_vtop = Platform.X64.pptrUserTop\"", "property": "User Virtual Address Space: Defines the upper boundary of the virtual address space available to user processes, ensuring that user-level applications have a defined and restricted memory range.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": " Virtual address space available to users. "}
{"spec": "definition\n  kernel_base :: \"vspace_ref\" where\n  \"kernel_base \\<equiv> 0xffffffff80000000\"\n\ndefinition\n  idle_thread_ptr :: vspace_ref where\n  \"idle_thread_ptr = kernel_base + 0x1000\"\n\nend\n\narch_requalify_consts (A) idle_thread_ptr\n\ncontext Arch begin arch_global_naming (A)", "property": "Kernel Base and Idle Thread Pointer: The kernel reserves a specific range of virtual addresses starting from a defined base address, and the idle thread pointer is set to a fixed offset from this base.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": "The lowest virtual address in the kernel window. The kernel reserves the\nvirtual addresses from here up in every virtual address space."}
{"spec": "definition\n  nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\" where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len)\n                           (to_bl (of_nat n :: machine_word))\"\ndefinition\n \"msg_info_register \\<equiv> msgInfoRegister\"\ndefinition\n \"msg_registers \\<equiv> msgRegisters\"\ndefinition\n \"cap_register \\<equiv> capRegister\"\ndefinition\n \"badge_register \\<equiv> badgeRegister\"\ndefinition\n \"frame_registers \\<equiv> frameRegisters\"\ndefinition\n \"gp_registers \\<equiv> gpRegisters\"\ndefinition\n \"exception_message \\<equiv> exceptionMessage\"\ndefinition\n \"syscall_message \\<equiv> syscallMessage\"\n\ndatatype arch_fault\n  = VMFault vspace_ref \"machine_word list\"\n\nend\nend", "property": "Convert Natural Number to Capability Reference: Convert a natural number to a capability reference by dropping the higher-order bits that exceed the specified length and converting the remaining bits to a boolean list.", "title": "./spec/abstract/X64/Machine_A.thy", "chapter": "", "section": "", "comment": " is nat_to_cref arch specific ? "}
{"spec": "arch_requalify_consts\n  maxIRQ\n\nend", "property": "Max IRQ Definition: The maximum number of interrupts (maxIRQ) is defined either in the Kernel_Config for ARM architectures or manually for RISCV64 architectures.", "title": "./spec/abstract/RISCV64/ArchInterrupt_A.thy", "chapter": "", "section": "", "comment": " On Arm architectures, maxIRQ is defined in Kernel_Config. On RISCV64 it is defined manually. "}
{"spec": "definition perform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_asid_control_invocation iv \\<equiv> case iv of\n     MakePool frame slot parent base \\<Rightarrow> do\n       delete_objects frame pageBits;\n       pcap \\<leftarrow> get_cap parent;\n       set_cap (max_free_index_update pcap) parent;\n       retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n       cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n       assert (asid_low_bits_of base = 0);\n       asid_table \\<leftarrow> gets (riscv_asid_table \\<circ> arch_state);\n       asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n       modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>riscv_asid_table := asid_table'\\<rparr>\\<rparr>)\n     od\"", "property": "ASID Control: Creates a new ASID pool object, provides a capability to it, and connects it to the global virtual ASID table. This ensures that the new ASID pool is properly initialized and integrated into the system's memory management.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "\n  The ASIDControl capability confers the authority to create a new ASID pool object. This\n  operation creates the new ASID pool, provides a capability to it and connects it to the global\n  virtual ASID table.\n"}
{"spec": "definition perform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_asid_pool_invocation iv \\<equiv> case iv of\n     Assign asid pool_ptr ct_slot \\<Rightarrow> do\n       pt_cap \\<leftarrow> get_cap ct_slot;\n       assert $ is_ArchObjectCap pt_cap;\n       acap \\<leftarrow> return $ the_arch_cap pt_cap;\n       assert $ is_PageTableCap acap;\n       set_cap (ArchObjectCap $ update_map_data acap $ Some (asid,0)) ct_slot;\n       pt_base \\<leftarrow> return $ acap_obj acap;\n       copy_global_mappings pt_base;\n       store_asid_pool_entry pool_ptr asid (Some pt_base)\n     od\"\n\ndefinition perform_pg_inv_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_pg_inv_unmap cap ct_slot \\<equiv> do\n     assert $ is_FrameCap cap;\n     case acap_map_data cap of\n       Some (asid, vaddr) \\<Rightarrow> unmap_page (acap_fsize cap) asid vaddr (acap_obj cap)\n     | _ \\<Rightarrow> return ();\n     old_cap \\<leftarrow> get_cap ct_slot;\n     set_cap (ArchObjectCap $ update_map_data (the_arch_cap old_cap) None) ct_slot\n   od\"\n\ndefinition perform_pg_inv_map :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> pte \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_pg_inv_map cap ct_slot pte slot \\<equiv> do\n     set_cap (ArchObjectCap cap) ct_slot;\n     store_pte slot pte;\n     do_machine_op sfence\n   od\"\n\ndefinition perform_pg_inv_get_addr :: \"obj_ref \\<Rightarrow> (data list,'z::state_ext) s_monad\"\n  where\n  \"perform_pg_inv_get_addr ptr \\<equiv> return [addrFromPPtr ptr]\"", "property": "ASID Pool Assignment: Assign an ASID to a top-level page table, updating the capability and storing the ASID pool entry. This ensures that the page table is correctly associated with the ASID, enabling proper memory management and address translation.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign an ASID to a top-level page table."}
{"spec": "definition perform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\"\n  where\n  \"perform_page_invocation iv \\<equiv> case iv of\n     PageMap cap ct_slot (pte,slot) \\<Rightarrow> do perform_pg_inv_map cap ct_slot pte slot; return [] od\n   | PageUnmap cap ct_slot \\<Rightarrow> do perform_pg_inv_unmap cap ct_slot; return [] od\n   | PageGetAddr ptr \\<Rightarrow> perform_pg_inv_get_addr ptr\"\n\n\ndefinition perform_pt_inv_map :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> pte \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_pt_inv_map cap ct_slot pte slot = do\n     set_cap (ArchObjectCap cap) ct_slot;\n     store_pte slot pte;\n     do_machine_op sfence\n   od\"\n\ndefinition perform_pt_inv_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_pt_inv_unmap cap ct_slot = do\n     assert $ is_PageTableCap cap;\n     case acap_map_data cap of\n       Some (asid, vaddr) \\<Rightarrow> do\n         p \\<leftarrow> return $ acap_obj cap;\n         unmap_page_table asid vaddr p;\n         slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + (1 << pt_bits) - 1];\n         mapM_x (swp store_pte InvalidPTE) slots\n       od\n     | _ \\<Rightarrow> return ();\n     old_cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n     set_cap (ArchObjectCap $ update_map_data old_cap None) ct_slot\n   od\"", "property": "Frame Capability Authority: The frame capability allows for the mapping and unmapping of memory. It enables the setting and storing of page table entries, as well as the unmap and invalidation of page table entries, ensuring that memory is managed correctly and securely.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "The Frame capability confers the authority to map and unmap memory."}
{"spec": "definition perform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_page_table_invocation iv \\<equiv> case iv of\n     PageTableMap cap ct_slot pte slot \\<Rightarrow> perform_pt_inv_map cap ct_slot pte slot\n   | PageTableUnmap cap ct_slot \\<Rightarrow> perform_pt_inv_unmap cap ct_slot\"\n\nlocale_abbrev arch_no_return :: \"(unit, 'z::state_ext) s_monad \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\n  where\n  \"arch_no_return oper \\<equiv> do oper; return [] od\"", "property": "PageTable Invocation: Allows the mapping and unmapping of page tables. This ensures that the memory layout can be dynamically adjusted, providing the necessary control over the virtual address space.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page tables."}
{"spec": "definition arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\n  where\n  \"arch_perform_invocation i \\<equiv> liftE $ case i of\n     InvokePageTable oper \\<Rightarrow> arch_no_return $ perform_page_table_invocation oper\n   | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n   | InvokeASIDControl oper \\<Rightarrow> arch_no_return $ perform_asid_control_invocation oper\n   | InvokeASIDPool oper \\<Rightarrow> arch_no_return $ perform_asid_pool_invocation oper\"\n\nend\nend", "property": "Architectural Invocation Handling: Dispatches RISCV64-specific system calls to their respective handlers for page table, page, ASID control, and ASID pool operations. Ensures that each invocation is processed by the appropriate function, maintaining the integrity and security of the system's memory management.", "title": "./spec/abstract/RISCV64/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call dispatcher for all RISCV64-specific system calls."}
{"spec": "chapter \"Handle Hypervisor Fault Events\"\n\ntheory Hypervisor_A\nimports Exceptions_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"machine_word \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\n  where\n  \"handle_hypervisor_fault thread RISCVNoHypFaults = return ()\"\n\nend\nend", "property": "Handle Hypervisor Faults: The system handles hypervisor fault events by processing the specified fault type. If the fault type is `RISCVNoHypFaults`, no action is taken, and the function returns immediately.", "title": "./spec/abstract/RISCV64/Hypervisor_A.thy", "chapter": "Handle Hypervisor Fault Events", "section": "", "comment": ""}
{"spec": "definition reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Reserve Memory Region: Reserve a specified number of bytes in memory, optionally tagging the region as kernel data. This function currently acts as a placeholder and does not perform any actual reservation or tagging.", "title": "./spec/abstract/RISCV64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "\n  This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory.\n"}
{"spec": "definition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv> return ()\"\n\ndefinition empty_context :: user_context\n  where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb\n  where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context \\<rparr>\"\n\nend\nend", "property": "Initialize Architecture-Specific Objects: Initialize architecture-specific objects, including setting up the context for a new thread control block (TCB) with an empty user context.", "title": "./spec/abstract/RISCV64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\n  where\n  \"arch_post_cap_deletion ac \\<equiv> return ()\"", "property": "Post-Capability Deletion Actions: No specific actions are taken after a capability is deleted.", "title": "./spec/abstract/RISCV64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = unit\n\ndefinition arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\"\n  where\n  \"arch_gen_obj_refs ac \\<equiv> {}\"\n\ndefinition arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\"\n  where\n  \"arch_cap_cleanup_opt ac \\<equiv> NullCap\"\n\nend\nend", "property": "Arch-Specific Generic Object References: There are no arch-specific generic object references, as the set of such references for any arch_cap is empty. Additionally, the cleanup operation for any arch_cap results in a NullCap.", "title": "./spec/abstract/RISCV64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition riscv_global_pt_ptr :: obj_ref\n  where\n  \"riscv_global_pt_ptr = pptr_base + 0x2000\"", "property": "Global Page Table Pointer: The global page table pointer is set to a sufficiently aligned address for one page, specifically at the base physical pointer plus 0x2000.", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " Some address sufficiently aligned address for one page "}
{"spec": "definition init_irq_node_ptr :: obj_ref\n  where\n  \"init_irq_node_ptr = pptr_base + 0x3000\"", "property": "Initialization of IRQ Node Pointer: The IRQ node pointer is initialized to a memory address that is sufficiently aligned for the IRQ type and CTE level bits, ensuring proper alignment and access.", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " Sufficiently aligned for irq type + cte_level_bits "}
{"spec": "definition canonical_user :: \"vspace_ref\" where\n  \"canonical_user \\<equiv> mask canonical_bit\"", "property": "Canonical User Address: Defines the highest user-level virtual address that is still canonical, ensuring valid mappings in the page tables.", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " The highest user-level virtual address that is still canonical.\n   It can be larger than user_vtop, which is the highest address we allow to be mapped.\n   We need canonical_user, because the page tables have to have valid mappings there. "}
{"spec": "definition kernel_window_bits :: nat where\n  \"kernel_window_bits \\<equiv> 22\"\n\ndefinition init_vspace_uses :: \"vspace_ref \\<Rightarrow> riscvvspace_region_use\"\n  where\n  \"init_vspace_uses p \\<equiv>\n     if p \\<in> {pptr_base ..< pptr_base + (1 << kernel_window_bits)} then RISCVVSpaceKernelWindow\n     else if p \\<in> {kernel_elf_base ..< kernel_elf_base + (1 << pageBits)} then RISCVVSpaceKernelELFWindow\n     else if p \\<le> canonical_user then RISCVVSpaceUserRegion\n     else RISCVVSpaceInvalidRegion\"\n\ndefinition init_arch_state :: arch_state\n  where\n  \"init_arch_state \\<equiv> \\<lparr>\n     riscv_asid_table = Map.empty,\n     riscv_global_pts = (\\<lambda>level. if level = max_pt_level then {riscv_global_pt_ptr} else {}),\n     riscv_kernel_vspace = init_vspace_uses\n   \\<rparr>\"\n\ndefinition toplevel_bits :: nat\n  where\n  \"toplevel_bits = pt_bits_left max_pt_level\"\n\ndefinition elf_index :: pt_index\n  where\n  \"elf_index = ucast (pt_index max_pt_level kernel_elf_base)\"", "property": "Memory Region Initialization: The initial virtual space is divided into distinct regions, including a kernel window and an ELF window, each covered by a single maximum page table level entry. The sizes of these regions are chosen to be sufficiently large to accommodate necessary objects and constraints, ensuring that the invariants are consistent and suitable for real kernel configurations.", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " Kernel and ELF window are constructed so that they can be covered with one max_pt_level entry\n   each. This is not the layout the real kernel uses, but we are only trying to show that\n   the invariants are consistent.\n\n   The values we pick here for the size of these regions constrain pptr_base and kernel_elf_base in\n   real kernel configurations, so we pick relatively small values that are reasonable lower bounds\n   for real platforms and that are still large enough to work for the examples. In particular, the\n   InfoFlow example gives a constraint that the kernel window is at least large enough to contain a\n   RISCVLargePage and a minimal set of other objects. This leads to picking values of:\n   4M physical memory (1 << 22) and one page (1 << pageBits) for the kernel elf region. "}
{"spec": "definition global_pte :: \"pt_index \\<Rightarrow> pte\"\n  where\n  \"global_pte idx \\<equiv>\n     if idx = 0x100\n     then PagePTE ((ucast (idx && mask (ptTranslationBits - 1)) << ptTranslationBits * size max_pt_level))\n                  {} vm_kernel_only\n     else if idx = elf_index\n     then PagePTE (ucast ((kernelELFPAddrBase && ~~mask toplevel_bits) >> pageBits)) {} vm_kernel_only\n     else InvalidPTE\"\n\ndefinition init_global_pt :: kernel_object\n  where\n  \"init_global_pt \\<equiv> ArchObj $ PageTable (\\<lambda>idx. if idx \\<in> kernel_mapping_slots\n                                                then global_pte idx\n                                                else InvalidPTE)\"\n\ndefinition init_kheap :: kheap\n  where\n  \"init_kheap \\<equiv>\n    (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n           then Some (CNode 0 (empty_cnode 0))\n           else None)\n    (idle_thread_ptr \\<mapsto>\n       TCB \\<lparr>\n         tcb_ctable = NullCap,\n         tcb_vtable = NullCap,\n         tcb_reply = NullCap,\n         tcb_caller = NullCap,\n         tcb_ipcframe = NullCap,\n         tcb_state = IdleThreadState,\n         tcb_fault_handler = replicate word_bits False,\n         tcb_ipc_buffer = 0,\n         tcb_fault = None,\n         tcb_bound_notification = None,\n         tcb_mcpriority = minBound,\n         tcb_arch = init_arch_tcb\n         \\<rparr>,\n      riscv_global_pt_ptr \\<mapsto> init_global_pt\n    )\"\n\ndefinition init_cdt :: cdt\n  where\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition init_ioc :: \"cslot_ptr \\<Rightarrow> bool\"\n  where\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition init_A_st :: \"'z::state_ext state\"\n  where\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\nend", "property": "Initialization of Kernel State: The kernel state is initialized with specific mappings and objects, including a global page table, an idle thread, and an interrupt controller. The global page table includes special entries for the physical pointer base and the kernel ELF base, ensuring that the memory layout aligns with the required invariants.", "title": "./spec/abstract/RISCV64/Init_A.thy", "chapter": "", "section": "", "comment": " {pptr_base ..< pptr_base + (1 << kernel_window_bits)} is pt index 0x100 at max_pt_level,\n   {kernel_elf_base ..< kernel_elf_base + (1 << pageBits)} comes out to elf_index.\n   The rest is constructed such that the translation lines up with what the invariants want. "}
{"spec": "definition lookup_ipc_buffer :: \"bool \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\"\n  where\n  \"lookup_ipc_buffer is_receiver thread \\<equiv> do\n     buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n     buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n     buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n     case buffer_cap of\n       ArchObjectCap (FrameCap p R vms False _) \\<Rightarrow>\n         if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n         then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n         else return None\n     | _ \\<Rightarrow> return None\n   od\"\n\ndefinition pool_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> obj_ref option\"\n  where\n  \"pool_for_asid asid \\<equiv> \\<lambda>s. riscv_asid_table (arch_state s) (asid_high_bits_of asid)\"\n\ndefinition vspace_for_pool :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (obj_ref \\<rightharpoonup> asid_pool) \\<Rightarrow> obj_ref option\"\n  where\n  \"vspace_for_pool pool_ptr asid \\<equiv> do {\n     pool \\<leftarrow> oapply pool_ptr;\n     K $ pool (asid_low_bits_of asid)\n   }\"\n\ndefinition vspace_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> obj_ref option\"\n  where\n  \"vspace_for_asid asid = do {\n     oassert (0 < asid);\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     vspace_for_pool pool_ptr asid \\<circ> asid_pools_of\n   }\"", "property": "IPC Buffer Lookup and Authority Check: Verify a thread's authority to read or write to its IPC buffer. The function checks the buffer's capabilities to ensure the thread has the appropriate read or write permissions, depending on whether it is the receiver or not.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up a thread's IPC buffer and check that the thread has the authority to read or (in the\n  receiver case) write to it.\n"}
{"spec": "definition find_vspace_for_asid :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\"\n  where\n  \"find_vspace_for_asid asid \\<equiv> doE\n    vspace_opt \\<leftarrow> liftE $ gets $ vspace_for_asid asid;\n    throw_opt InvalidRoot vspace_opt\n  odE\"", "property": "Locate VSpace for ASID: Retrieve the top-level page table (vspace) associated with a given virtual ASID. If no vspace is found, an `InvalidRoot` exception is thrown.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the top-level page table associated with a given virtual ASID."}
{"spec": "definition handle_vm_fault :: \"obj_ref \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\n  where\n  \"handle_vm_fault thread fault_type = doE\n    addr \\<leftarrow> liftE $ do_machine_op read_stval;\n    let\n      loadf = (\\<lambda>a. throwError $ ArchFault $ VMFault a [0, vmFaultTypeFSR RISCVLoadAccessFault]);\n      storef = (\\<lambda>a. throwError $ ArchFault $ VMFault a [0, vmFaultTypeFSR RISCVStoreAccessFault]);\n      instrf = (\\<lambda>a. throwError $ ArchFault $ VMFault a [1, vmFaultTypeFSR RISCVInstructionAccessFault])\n    in\n      case fault_type of\n        RISCVLoadPageFault \\<Rightarrow> loadf addr\n      | RISCVLoadAccessFault \\<Rightarrow> loadf addr\n      | RISCVStorePageFault \\<Rightarrow> storef addr\n      | RISCVStoreAccessFault \\<Rightarrow> storef addr\n      | RISCVInstructionPageFault \\<Rightarrow> instrf addr\n      | RISCVInstructionAccessFault \\<Rightarrow> instrf addr\n  odE\"", "property": "VM Fault Handling: Format and propagate a VM fault message to the thread's supervisor based on the type of page fault encountered, including load, store, and instruction access faults.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Format a VM fault message to be passed to a thread's supervisor after it encounters a page fault.\n"}
{"spec": "definition set_vm_root :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"set_vm_root tcb \\<equiv> do\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    (case thread_root of\n       ArchObjectCap (PageTableCap pt (Some (asid, _))) \\<Rightarrow> doE\n           pt' \\<leftarrow> find_vspace_for_asid asid;\n           whenE (pt \\<noteq> pt') $ throwError InvalidRoot;\n           liftE $ do_machine_op $ setVSpaceRoot (addrFromPPtr pt) (ucast asid)\n       odE\n     | _ \\<Rightarrow> throwError InvalidRoot) <catch>\n    (\\<lambda>_. do\n       global_pt \\<leftarrow> gets global_pt;\n       do_machine_op $ setVSpaceRoot (addrFromKPPtr global_pt) 0\n    od)\n  od\"\n\n\ndefinition delete_asid_pool :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"delete_asid_pool base ptr \\<equiv> do\n     assert (asid_low_bits_of base = 0);\n     asid_table \\<leftarrow> gets (riscv_asid_table \\<circ> arch_state);\n     when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n       pool \\<leftarrow> get_asid_pool ptr;\n       asid_table' \\<leftarrow> return $ asid_table (asid_high_bits_of base:= None);\n       modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> riscv_asid_table := asid_table' \\<rparr>\\<rparr>);\n       tcb \\<leftarrow> gets cur_thread;\n       set_vm_root tcb\n     od\n   od\"\n\n\ndefinition delete_asid :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"delete_asid asid pt \\<equiv> do\n     asid_table \\<leftarrow> gets (riscv_asid_table \\<circ> arch_state);\n     case asid_table (asid_high_bits_of asid) of\n       None \\<Rightarrow> return ()\n     | Some pool_ptr \\<Rightarrow> do\n         pool \\<leftarrow> get_asid_pool pool_ptr;\n         when (pool (asid_low_bits_of asid) = Some pt) $ do\n           do_machine_op $ hwASIDFlush (ucast asid);\n           pool' \\<leftarrow> return $ pool (asid_low_bits_of asid := None);\n           set_asid_pool pool_ptr pool';\n           tcb \\<leftarrow> gets cur_thread;\n           set_vm_root tcb\n         od\n       od\n   od\"\n\ndefinition unmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"unmap_page_table asid vaddr pt \\<equiv> doE\n     top_level_pt \\<leftarrow> find_vspace_for_asid asid;\n     pt_slot \\<leftarrow> pt_lookup_from_level max_pt_level top_level_pt vaddr pt;\n     liftE $ store_pte pt_slot InvalidPTE;\n     liftE $ do_machine_op sfence\n   odE <catch> (K $ return ())\"", "property": "Address Space Management: Switch the address space to that of a specified thread or to the global address space if the thread's configuration is invalid. This ensures that the virtual memory root is correctly set, and any necessary ASID pool or page table mappings are updated or deleted, maintaining the integrity and consistency of the virtual memory system.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Switch into the address space of a given thread or the global address space if none is correctly\n  configured.\n"}
{"spec": "definition vs_lookup_table :: \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"vs_lookup_table bot_level asid vptr \\<equiv> do {\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     if bot_level = asid_pool_level\n     then oreturn (asid_pool_level, pool_ptr)\n     else do {\n       top_level_pt \\<leftarrow> vspace_for_pool pool_ptr asid \\<circ> asid_pools_of;\n       pt_walk max_pt_level bot_level top_level_pt vptr \\<circ> ptes_of\n     }\n   }\"", "property": "Page Table Lookup: Perform a lookup in the page table for a given ASID and virtual space reference, down to the specified level. If the lookup reaches the bottom level, return a pointer to the table at that level; otherwise, return the level and the corresponding object reference where the lookup terminated, which could be due to hitting a page or an invalid entry.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up an @{text \"asid+vspace_ref\"} down to the provided level in the page table.\n  For level @{term bot_level}, return a pointer to a table at the returned level.\n  The level can be higher than @{term bot_level} if the lookup terminates early because\n  it hit a page or an invalid entry.\n"}
{"spec": "definition vs_lookup_slot :: \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"vs_lookup_slot bot_level asid vref \\<equiv> do {\n     (level', table) \\<leftarrow> vs_lookup_table bot_level asid vref;\n     if level' = asid_pool_level then\n       oreturn (level', table)\n     else\n       oreturn (level', pt_slot_offset level' table vref)\n   }\"", "property": "Virtual Space Lookup Slot: Returns a pointer to a slot in the virtual space table at the specified level. If the level is the ASID pool level, it returns a pointer to the ASID pool itself, otherwise, it returns a pointer to the specific slot within the table.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Same as @{const vs_lookup_table}, but return a pointer to a slot in a table at the returned level.\n  For @{prop \"bot_level = asid_pool_level\"}, still return the pointer to the ASID pool (not a slot\n  inside it, since there are no slot functions for ASID pools).\n"}
{"spec": "definition unmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"unmap_page pgsz asid vptr pptr \\<equiv> doE\n     top_level_pt \\<leftarrow> find_vspace_for_asid asid;\n     (lev, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot top_level_pt vptr \\<circ> ptes_of;\n     unlessE (pt_bits_left lev = pageBitsForSize pgsz) $ throwError InvalidRoot;\n     pte \\<leftarrow> liftE $ get_pte slot;\n     unlessE (is_PagePTE pte \\<and> pptr_from_pte pte = pptr) $ throwError InvalidRoot;\n     liftE $ store_pte slot InvalidPTE;\n     liftE $ do_machine_op sfence\n   odE <catch> (K $ return ())\"", "property": "Unmap Page: Unmaps a page from the virtual address space if the provided mapping details are still current. It ensures that the page table entry is valid and matches the given physical page, then invalidates the entry and flushes the translation cache.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\"\n  where\n  \"arch_derive_cap c \\<equiv>\n     case c of\n       PageTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n     | PageTableCap _ None \\<Rightarrow> throwError IllegalOperation\n     | FrameCap r R sz dev mp \\<Rightarrow> returnOk $ ArchObjectCap (FrameCap r R sz dev None)\n     | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n     | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\"", "property": "Page Table Capabilities Derivation: Page table capabilities can only be derived if they have an assigned ASID and location, ensuring that they are not shared between address spaces or virtual locations. Other architectural capabilities, such as frame capabilities, ASID control capabilities, and ASID pool capabilities, can be derived without these constraints.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Page table structure capabilities cannot be copied until they have an ASID and location\n  assigned. This is because they cannot have multiple current ASIDs and cannot be shared between\n  address spaces or virtual locations.\n"}
{"spec": "definition arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\"\n  where\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "RISCV64 Capability Data Integrity: Ensures that no user-modifiable data is stored in RISCV64-specific capabilities, maintaining the integrity and security of the system.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in RISCV64-specific capabilities."}
{"spec": "definition arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\n  where\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n     (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n       delete_asid_pool b ptr;\n       return (NullCap, NullCap)\n     od\n   | (PageTableCap ptr (Some (a, v)), True) \\<Rightarrow> do\n       doE\n         vroot \\<leftarrow> find_vspace_for_asid a;\n         if vroot = ptr then liftE $ delete_asid a ptr else throwError InvalidRoot\n       odE <catch>\n       (\\<lambda>_. unmap_page_table a v ptr);\n       return (NullCap, NullCap)\n     od\n   | (FrameCap ptr _ sz _ (Some (a, v)), _) \\<Rightarrow> do\n       unmap_page sz a v ptr;\n       return (NullCap, NullCap)\n     od\n   | _ \\<Rightarrow> return (NullCap, NullCap)\"", "property": "Finalize RISCV64-Specific Capabilities: Perform specific actions to finalize RISCV64 capabilities, including deleting ASID pools, unmapping page tables, and unmapping frames, and return null capabilities.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of RISCV64-specific capabilities."}
{"spec": "definition is_valid_vtable_root :: \"cap \\<Rightarrow> bool\"\n  where\n  \"is_valid_vtable_root c \\<equiv>\n     case c of ArchObjectCap (PageTableCap _ (Some _)) \\<Rightarrow> True | _ \\<Rightarrow> False\"", "property": "Virtual Address Space Validity: A virtual address space capability is valid if and only if it points to a mapped page table.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A thread's virtual address space capability must be to a mapped page table to be valid on\n  the RISCV64 architecture.\n"}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\ndefinition check_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\"\n  where\n  \"check_valid_ipc_buffer vptr c \\<equiv>\n     case c of\n       ArchObjectCap (FrameCap _ _ _ False _) \\<Rightarrow>\n         whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError\n     | _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Check Valid IPC Buffer: Validate the alignment of the virtual pointer for an IPC buffer. If the virtual pointer is not aligned according to the specified `msg_align_bits`, an `AlignmentError` is thrown. For any other type of capability, an `IllegalOperation` error is thrown.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "definition in_user_frame :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\"\n  where\n  \"in_user_frame p s \\<equiv>\n     \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) = Some (ArchObj (DataPage False sz))\"\n\ndefinition prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"prepare_thread_delete thread_ptr \\<equiv> return ()\"\n\nend\nend", "property": "Pointer in User Frame: A pointer is considered to be inside a user frame if its top bits correspond to a DataPage in the kernel heap.", "title": "./spec/abstract/RISCV64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A pointer is inside a user frame if its top bits point to a @{const DataPage}."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition asid_high_bits_of :: \"asid \\<Rightarrow> asid_high_index\"\n  where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"", "property": "ASID High Bits Extraction: Extract the high bits of a virtual ASID by shifting and casting the ASID to an ASID high index.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "definition asid_low_bits_of :: \"asid \\<Rightarrow> asid_low_index\"\n  where\n  \"asid_low_bits_of asid \\<equiv> ucast asid\"\n\nlemmas asid_bits_of_defs = asid_high_bits_of_def asid_low_bits_of_def\n\nlocale_abbrev\n  \"asid_table \\<equiv> \\<lambda>s. riscv_asid_table (arch_state s)\"", "property": "ASID Low Bits Extraction: Extract the low bits of a virtual ASID and convert them to an ASID low index.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": "The low bits of a virtual ASID."}
{"spec": "(* declared in Arch as workaround for VER-1099 *)\nlocale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\"\n  where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"", "property": "Access VSpace Information: Provides a way to access the architecture-specific kernel objects, such as virtual space (VSpace) information, from the kernel heap. This allows the system to manage and interact with the VSpace effectively.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev asid_pools_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> asid_pool\"\n  where\n  \"asid_pools_of \\<equiv> \\<lambda>s. aobjs_of s |> asid_pool_of\"\n\nlocale_abbrev get_asid_pool :: \"obj_ref \\<Rightarrow> (asid_low_index \\<rightharpoonup> obj_ref, 'z::state_ext) s_monad\"\n  where\n  \"get_asid_pool \\<equiv> gets_map asid_pools_of\"\n\ndefinition set_asid_pool :: \"obj_ref \\<Rightarrow> (asid_low_index \\<rightharpoonup> obj_ref) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"set_asid_pool ptr pool \\<equiv> do\n     get_asid_pool ptr;\n     set_object ptr (ArchObj (ASIDPool pool))\n   od\"\n\nlocale_abbrev pts_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> pt\"\n  where\n  \"pts_of \\<equiv> \\<lambda>s. aobjs_of s |> pt_of\"\n\nlocale_abbrev get_pt :: \"obj_ref \\<Rightarrow> (pt_index \\<Rightarrow> pte,'z::state_ext) s_monad\"\n  where\n  \"get_pt \\<equiv> gets_map pts_of\"\n\ndefinition set_pt :: \"obj_ref \\<Rightarrow> (pt_index \\<Rightarrow> pte) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"set_pt ptr pt \\<equiv> do\n     get_pt ptr;\n     set_object ptr (ArchObj (PageTable pt))\n   od\"", "property": "ASID Pool and Page Table Management: Manipulate ASID pools and page tables in the kernel heap, allowing for the retrieval and updating of ASID mappings and page table entries.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": "Manipulate ASID pools, page directories and page tables in the kernel heap."}
{"spec": "locale_abbrev table_base :: \"obj_ref \\<Rightarrow> obj_ref\" where\n  \"table_base p \\<equiv> p && ~~mask pt_bits\"", "property": "Table Base Calculation: Compute the base address of the table containing a given page table entry, assuming proper alignment.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": " The base address of the table a page table entry at p is in (assuming alignment) "}
{"spec": "locale_abbrev table_index :: \"obj_ref \\<Rightarrow> pt_index\" where\n  \"table_index p \\<equiv> ucast (p && mask pt_bits >> pte_bits)\"", "property": "Page Table Index Calculation: Compute the index within the page table that a given page table entry addresses, using bitwise operations to extract and shift the relevant bits.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": " The index within the page table that a page table entry at p addresses "}
{"spec": "definition pte_of :: \"obj_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pt) \\<rightharpoonup> pte\"\n  where\n  \"pte_of p \\<equiv> do {\n     oassert (is_aligned p pte_bits);\n     pt \\<leftarrow> oapply (table_base p);\n     oreturn $ pt (table_index p)\n   }\"\n\nlocale_abbrev ptes_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> pte\"\n  where\n  \"ptes_of s \\<equiv> \\<lambda>p. pte_of p (pts_of s)\"", "property": "Page Table Entry Access: Retrieve the page table entry (PTE) at a given address, ensuring that the address is properly aligned to avoid accessing invalid regions between PTEs.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": " p is the address of the pte,\n   which consists of base (for the pt) and offset (for the index inside the pt).\n   We assert that we avoid addresses between ptes. "}
{"spec": "locale_abbrev get_pte :: \"obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\"\n  where\n  \"get_pte \\<equiv> gets_map ptes_of\"\n\ndefinition store_pte :: \"obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"store_pte p pte \\<equiv> do\n     assert (is_aligned p pte_bits);\n     base \\<leftarrow> return $ table_base p;\n     index \\<leftarrow> return $ table_index p;\n     pt \\<leftarrow> get_pt (table_base p);\n     pt' \\<leftarrow> return $ pt (index := pte);\n     set_pt base pt'\n   od\"", "property": "Kernel PTE Access and Modification: Retrieve and store page table entries (PTEs) in the kernel's memory. Ensures that PTEs are accessed and modified correctly, maintaining the integrity of the virtual address space.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory and returns the PTE."}
{"spec": "definition pt_bits_left :: \"vm_level \\<Rightarrow> nat\"\n  where\n  \"pt_bits_left level = ptTranslationBits * size level + pageBits\"\n\ndefinition pt_index :: \"vm_level \\<Rightarrow> vspace_ref \\<Rightarrow> machine_word\"\n  where\n  \"pt_index level vptr \\<equiv> (vptr >> pt_bits_left level) && mask ptTranslationBits\"", "property": "VSpace Access: Calculate the index for a given virtual address and level in the page table, using the remaining bits after shifting the virtual address by the sum of the translation bits and page bits, and masking with the translation bits.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition riscv_global_pt :: \"arch_state \\<Rightarrow> obj_ref\"\n  where\n  \"riscv_global_pt s = the_elem (riscv_global_pts s max_pt_level)\"\n\nlocale_abbrev global_pt :: \"'z state \\<Rightarrow> obj_ref\"\n  where\n  \"global_pt s \\<equiv> riscv_global_pt (arch_state s)\"", "property": "Extract Top-Level Global Page Table: Retrieve the single top-level global page table from the architecture state.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": "Interface function to extract the single top-level global page table:"}
{"spec": "definition copy_global_mappings :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"copy_global_mappings new_pm \\<equiv> do\n    global_pt \\<leftarrow> gets global_pt;\n    base \\<leftarrow> return $ pt_index max_pt_level pptr_base;\n    pt_size \\<leftarrow> return $ 1 << ptTranslationBits;\n    mapM_x (\\<lambda>index. do\n        offset \\<leftarrow> return (index << pte_bits);\n        pme \\<leftarrow> get_pte (global_pt + offset);\n        store_pte (new_pm + offset) pme\n    od) [base  .e.  pt_size - 1]\n  od\"", "property": "Copy Global Mappings: Replicate the kernel window mappings into a new top-level page table object. This ensures that the kernel's virtual address space is consistently available across different page tables, maintaining the integrity and accessibility of the kernel memory.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": "\n  The kernel window is mapped into every virtual address space from the @{term pptr_base}\n  pointer upwards. This function copies the mappings which create the kernel window into a new\n  top-level page table object.\n"}
{"spec": "definition pptr_from_pte :: \"pte \\<Rightarrow> vspace_ref\"\n  where\n  \"pptr_from_pte pte \\<equiv> ptrFromPAddr (addr_from_pte pte)\"\n\ndefinition pt_slot_offset :: \"vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\"\n  where\n  \"pt_slot_offset level pt_ptr vptr = pt_ptr + (pt_index level vptr << pte_bits)\"", "property": "Page Table Entry to Physical Pointer: Convert a page table entry (PTE) to a physical pointer, ensuring that the resulting address is at least page-aligned. \n\nPage Table Slot Offset: Calculate the offset of a specific slot in the page table based on the virtual address and the level of the page table, aligning it with the appropriate page table entry size.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " pte addresses will always be at least page aligned "}
{"spec": "fun pt_walk ::\n  \"vm_level \\<Rightarrow> vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pte) \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"pt_walk level bot_level pt_ptr vptr = do {\n     if bot_level < level\n     then do {\n       pte \\<leftarrow> oapply (pt_slot_offset level pt_ptr vptr);\n       if is_PageTablePTE pte\n         then pt_walk (level - 1) bot_level (pptr_from_pte pte) vptr\n         else oreturn (level, pt_ptr)\n     }\n     else oreturn (level, pt_ptr)\n   }\"\n\ndeclare pt_walk.simps[simp del]", "property": "Page Table Walk: Recursively traverses the page table structure from a specified level down to a base level or until a page is reached, returning the level and the pointer to the final page table or page.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": "\n  This is the base function for walking a page table structure.\n  The walk proceeds from higher-level tables at the provided @{term level} (e.g. 2) to lower\n  level tables, down to @{term bot_level} (e.g. 0). It returns a pointer to the page table where\n  the walk stopped and the level of that table. The lookup stops when @{term bot_level} or a\n  page is reached.\n"}
{"spec": "definition pt_lookup_slot_from_level ::\n  \"vm_level \\<Rightarrow> vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pte) \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"pt_lookup_slot_from_level level bot_level pt_ptr vptr = do {\n     (level', pt_ptr') \\<leftarrow> pt_walk level bot_level pt_ptr vptr;\n     oreturn (level', pt_slot_offset level' pt_ptr' vptr)\n   }\"\n\ndefinition pt_lookup_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pte) \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"pt_lookup_slot = pt_lookup_slot_from_level max_pt_level 0\"", "property": "Page Table Slot Lookup: Retrieves a slot in the page table structure corresponding to a given virtual space reference, returning the level and object pointer of the slot. The slot at level 0 is either an invalid or a page PTE, while higher levels may also include a page table PTE.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": "\n  Looking up a slot in a page table structure. The function returns a level and an object\n  pointer. The pointer is to a slot in a table at the returned level. If the returned level is 0,\n  this slot is either an @{const InvalidPTE} or a @{const PagePTE}. If the returned level is higher\n  the slot may also be a @{const PageTablePTE}.\n"}
{"spec": "fun pt_lookup_from_level ::\n  \"vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (machine_word, 'z::state_ext) lf_monad\"\n  where\n  \"pt_lookup_from_level level pt_ptr vptr target_pt_ptr s = (doE\n     unlessE (0 < level) $ throwError InvalidRoot;\n     slot <- returnOk $ pt_slot_offset level pt_ptr vptr;\n     pte <- liftE $ gets_the $ oapply slot o ptes_of;\n     unlessE (is_PageTablePTE pte) $ throwError InvalidRoot;\n     ptr <- returnOk (pptr_from_pte pte);\n     if ptr = target_pt_ptr\n       then returnOk slot\n       else pt_lookup_from_level (level - 1) ptr vptr target_pt_ptr\n   odE) s\"", "property": "Page Table Lookup: Recursively searches the page table hierarchy starting from a given level, using the provided virtual address and target page table pointer, to find the slot that points to the target page table. Ensures that the search is valid by checking the level and PTE type, and continues the search at lower levels if the current level does not match the target.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " Returns the slot that points to target_pt_ptr "}
{"spec": "declare pt_lookup_from_level.simps[simp del]", "property": "Access VSpace: Perform basic operations on the RISCV64 virtual space, ensuring type safety and maintaining the global free index counter.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " We apply \"s\" to avoid a type variable warning, and increase in global freeindex counter,\n   which we would get without the application "}
{"spec": "schematic_goal pt_lookup_from_level_simps:\n  \"pt_lookup_from_level level pt_ptr vptr target_pt_ptr = ?rhs\"\n  by (rule ext, rule pt_lookup_from_level.simps)", "property": "Page Table Lookup: Perform a lookup in the page table starting from a specified level to find the target page table pointer for a given virtual address.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " Recover simp rule without state applied: "}
{"spec": "definition kernel_mapping_slots :: \"pt_index set\" where\n  \"kernel_mapping_slots \\<equiv> {i. i \\<ge> ucast (pptr_base >> pt_bits_left max_pt_level)}\"\n\nend\nend", "property": "Kernel Mapping Slots: Defines the set of top-level table slots that are used for kernel mappings, starting from the base physical pointer and extending to the top of virtual memory. These slots encompass the kernel window, kernel ELF window, and kernel device window.", "title": "./spec/abstract/RISCV64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the RISCV64 VSpace", "section": "Basic Operations", "comment": " Kernel mappings go from pptr base to top of virtual memory. This definition encompasses\n   the kernel window, kernel ELF window, and kernel device window.\n   These indices identify the relevant top level table slots. "}
{"spec": "definition check_vp_alignment :: \"vmpage_size \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) se_monad\"\n  where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $ throwError AlignmentError\"\n\ndefinition page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\n  where\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"", "property": "Check Virtual Page Alignment: Ensure that the virtual page address is properly aligned for the specified page size. If the alignment check fails, an alignment error is thrown.", "title": "./spec/abstract/RISCV64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture-specific Decode Functions", "comment": ""}
{"spec": "definition\n  arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"arch_check_irq irq \\<equiv> whenE (irq > ucast maxIRQ \\<or> irq = ucast irqInvalid) $\n                          throwError (RangeError 1 (ucast maxIRQ))\"\n\ndefinition arch_decode_irq_control_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list \\<Rightarrow> (arch_irq_control_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_irq_control_invocation label args src_slot cps \\<equiv>\n     (if invocation_type label = ArchInvocationLabel RISCVIRQIssueIRQHandler\n      then if length args \\<ge> 4 \\<and> length cps \\<ge> 1\n        then let irq_word = args ! 0;\n                 trigger = args ! 1;\n                 index = args ! 2;\n                 depth = args ! 3;\n                 cnode = cps ! 0;\n                 irq = ucast irq_word\n        in doE\n          arch_check_irq irq_word;\n          irq_active \\<leftarrow> liftE $ is_irq_active irq;\n          whenE irq_active $ throwError RevokeFirst;\n          dest_slot \\<leftarrow> lookup_target_slot cnode (data_to_cptr index) (unat depth);\n          ensure_empty dest_slot;\n          returnOk $ RISCVIRQControlInvocation irq dest_slot src_slot (trigger \\<noteq> 0)\n        odE\n      else throwError TruncatedMessage\n    else throwError IllegalOperation)\"\n\ndefinition attribs_from_word :: \"machine_word \\<Rightarrow> vm_attributes\"\n  where\n  \"attribs_from_word w \\<equiv> if \\<not> w!!0 then {Execute} else {}\"\n\ndefinition make_user_pte :: \"vspace_ref \\<Rightarrow> vm_attributes \\<Rightarrow> vm_rights \\<Rightarrow> pte\"\n  where\n  \"make_user_pte addr attr rights \\<equiv>\n    if rights = {} \\<and> attr = {}\n    then InvalidPTE\n    else PagePTE (ucast (addr >> pageBits)) (attr \\<union> {User}) rights\"\n\ndefinition check_slot :: \"obj_ref \\<Rightarrow> (pte \\<Rightarrow> bool) \\<Rightarrow> (unit,'z::state_ext) se_monad\"\n  where\n  \"check_slot slot test = doE\n     pte \\<leftarrow> liftE $ get_pte slot;\n     unlessE (test pte) $ throwError DeleteFirst\n   odE\"\n\ntype_synonym 'z arch_decoder =\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    (arch_invocation,'z) se_monad\"\n\ndefinition decode_fr_inv_map :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_fr_inv_map label args cte cap extra_caps \\<equiv> case cap of\n     FrameCap p R pgsz dev mapped_address \\<Rightarrow>\n       if length args > 2 \\<and> length extra_caps > 0\n       then let\n           vaddr = args ! 0;\n           rights_mask = args ! 1;\n           attr = args ! 2;\n           vspace_cap = fst (extra_caps ! 0)\n         in doE\n           (pt, asid) \\<leftarrow> case vspace_cap of\n                           ArchObjectCap (PageTableCap pt (Some (asid, _))) \\<Rightarrow> returnOk (pt, asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1;\n           pt' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n           whenE (pt' \\<noteq> pt) $ throwError $ InvalidCapability 1;\n           pg_bits \\<leftarrow> returnOk $ pageBitsForSize pgsz;\n           vtop \\<leftarrow> returnOk $ vaddr + mask (pageBitsForSize pgsz);\n           whenE (vtop \\<ge> user_vtop) $ throwError $ InvalidArgument 0;\n           check_vp_alignment pgsz vaddr;\n           (level, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot pt vaddr \\<circ> ptes_of;\n           unlessE (pt_bits_left level = pg_bits) $\n             throwError $ FailedLookup False $ MissingCapability $ pt_bits_left level;\n           case mapped_address of\n             Some (asid', vaddr') \\<Rightarrow> doE\n               whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n               whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0);\n               check_slot slot (Not \\<circ> is_PageTablePTE)\n             odE\n           | None \\<Rightarrow> check_slot slot ((=) InvalidPTE);\n           vm_rights \\<leftarrow> returnOk $ mask_vm_rights R (data_to_rights rights_mask);\n           attribs \\<leftarrow> returnOk $ attribs_from_word attr;\n           pte \\<leftarrow> returnOk $ make_user_pte (addrFromPPtr p) attribs vm_rights;\n           returnOk $ InvokePage $ PageMap (FrameCap p R pgsz dev (Some (asid,vaddr))) cte (pte,slot)\n         odE\n       else throwError TruncatedMessage\n     | _ \\<Rightarrow> fail\"\n\ndefinition decode_frame_invocation :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_frame_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel RISCVPageMap\n     then decode_fr_inv_map label args cte cap extra_caps\n     else if invocation_type label = ArchInvocationLabel RISCVPageUnmap\n     then returnOk $ InvokePage $ PageUnmap cap cte\n     else if invocation_type label = ArchInvocationLabel RISCVPageGetAddress\n     then returnOk $ InvokePage $ PageGetAddr (acap_obj cap)\n     else throwError IllegalOperation\"\n\ndefinition decode_pt_inv_map :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_pt_inv_map label args cte cap extra_caps \\<equiv> case cap of\n     PageTableCap p mapped_address \\<Rightarrow>\n       if length args > 1 \\<and> length extra_caps > 0\n       then let\n           vaddr = args ! 0;\n           attr = args ! 1;\n           vspace_cap = fst (extra_caps ! 0)\n         in doE\n           whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n           (pt, asid) \\<leftarrow> case vspace_cap of\n                           ArchObjectCap (PageTableCap pt (Some (asid,_))) \\<Rightarrow> returnOk (pt, asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1;\n           whenE (user_vtop \\<le> vaddr) $ throwError $ InvalidArgument 0;\n           pt' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n           whenE (pt' \\<noteq> pt) $ throwError $ InvalidCapability 1;\n           (level, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot pt vaddr \\<circ> ptes_of;\n           old_pte \\<leftarrow> liftE $ get_pte slot;\n           whenE (pt_bits_left level = pageBits \\<or> old_pte \\<noteq> InvalidPTE) $ throwError DeleteFirst;\n           pte \\<leftarrow> returnOk $ PageTablePTE (ucast (addrFromPPtr p >> pageBits)) {};\n           cap' <- returnOk $ PageTableCap p $ Some (asid, vaddr && ~~mask (pt_bits_left level));\n           returnOk $ InvokePageTable $ PageTableMap cap' cte pte slot\n         odE\n       else throwError TruncatedMessage\n     | _ \\<Rightarrow> fail\"\n\ndefinition decode_page_table_invocation :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_page_table_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel RISCVPageTableMap\n     then decode_pt_inv_map label args cte cap extra_caps\n     else if invocation_type label = ArchInvocationLabel RISCVPageTableUnmap\n     then doE\n       final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n       unlessE final $ throwError RevokeFirst;\n       case cap of\n         PageTableCap pt (Some (asid, _)) \\<Rightarrow> doE\n             \\<comment> \\<open>cannot invoke unmap on top level page table\\<close>\n             pt_opt \\<leftarrow> liftE $ gets $ vspace_for_asid asid;\n             whenE (pt_opt = Some pt) $ throwError RevokeFirst\n           odE\n       | _ \\<Rightarrow> returnOk ();\n       returnOk $ InvokePageTable $ PageTableUnmap cap cte\n     odE\n     else throwError IllegalOperation\"\n\ndefinition decode_asid_control_invocation :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_asid_control_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel RISCVASIDControlMakePool\n     then if length args > 1 \\<and> length extra_caps > 1\n     then let\n         index = args ! 0;\n         depth = args ! 1;\n         (untyped, parent_slot) = extra_caps ! 0;\n         root = fst (extra_caps ! 1)\n       in doE\n         asid_table \\<leftarrow> liftE $ gets (riscv_asid_table \\<circ> arch_state);\n         free_set \\<leftarrow> returnOk (- dom asid_table);\n         whenE (free_set = {}) $ throwError DeleteFirst;\n         free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n         base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n         (p,n) \\<leftarrow> case untyped of\n                    UntypedCap False p n _ \\<Rightarrow> returnOk (p,n)\n                  | _ \\<Rightarrow> throwError $ InvalidCapability 1;\n         frame \\<leftarrow> if n = pageBits then doE\n                    ensure_no_children parent_slot;\n                    returnOk p\n                  odE\n                  else throwError $ InvalidCapability 1;\n         dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n         ensure_empty dest_slot;\n         returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n       odE\n     else throwError TruncatedMessage\n     else throwError IllegalOperation\"\n\ndefinition decode_asid_pool_invocation :: \"'z::state_ext arch_decoder\"\n  where\n  \"decode_asid_pool_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel RISCVASIDPoolAssign\n     then if length extra_caps > 0\n     then let\n         (pt_cap, pt_cap_slot) = extra_caps ! 0;\n         p = acap_obj cap;\n         base = acap_asid_base cap\n       in case pt_cap of\n         ArchObjectCap (PageTableCap _ None) \\<Rightarrow> doE\n           asid_table \\<leftarrow> liftE $ gets (riscv_asid_table \\<circ> arch_state);\n           pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n           whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n           whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n           pool \\<leftarrow> liftE $ get_asid_pool p;\n           free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n           whenE (free_set = {}) $ throwError DeleteFirst;\n           offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n           returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pt_cap_slot\n         odE\n       | _ \\<Rightarrow> throwError $ InvalidCapability 1\n     else throwError TruncatedMessage\n     else throwError IllegalOperation\"\n\ndefinition arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n     PageTableCap _ _   \\<Rightarrow> decode_page_table_invocation label args cte cap extra_caps\n   | FrameCap _ _ _ _ _ \\<Rightarrow> decode_frame_invocation label args cte cap extra_caps\n   | ASIDControlCap     \\<Rightarrow> decode_asid_control_invocation label args cte cap extra_caps\n   | ASIDPoolCap _ _    \\<Rightarrow> decode_asid_pool_invocation label args cte cap extra_caps\"", "property": "Architectural Invocation Decoding: Decode and validate architecture-specific system calls, ensuring that the provided arguments and capabilities are correct and complete. This includes handling IRQ control, frame mapping and unmapping, page table operations, and ASID pool management. Each invocation type is checked for proper argument length, capability validity, and alignment, with appropriate errors thrown for invalid or truncated messages.", "title": "./spec/abstract/RISCV64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Interface Functions used in Decode", "comment": ""}
{"spec": "definition arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\"\n  where\n  \"arch_data_to_obj_type n \\<equiv>\n     if      n = 0 then Some HugePageObj\n     else if n = 1 then Some SmallPageObj\n     else if n = 2 then Some LargePageObj\n     else if n = 3 then Some PageTableObj\n     else None\"\n\nend\nend", "property": "Architectural Data to Object Type Mapping: Convert a numerical value to a corresponding architecture-specific object type, such as HugePageObj, SmallPageObj, LargePageObj, or PageTableObj. If the numerical value does not match any of the predefined types, it returns None.", "title": "./spec/abstract/RISCV64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Interface Functions used in Decode", "comment": ""}
{"spec": "datatype page_table_invocation =\n    PageTableMap\n      (pt_inv_cap : arch_cap)\n      (pt_inv_cslot : cslot_ptr)\n      (pt_map_pte : pte)\n      (pt_map_slot : obj_ref)\n  | PageTableUnmap\n      (pt_inv_cap : arch_cap)\n      (pt_inv_cslot : cslot_ptr)\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation =\n    PageMap\n      (pg_inv_cap : arch_cap)\n      (pg_inv_cslot : cslot_ptr)\n      (pg_inv_entries : \"pte \\<times> obj_ref\")\n  | PageUnmap\n      (pg_inv_cap : arch_cap)\n      (pg_inv_cslot : cslot_ptr)\n  | PageGetAddr\n      (pg_get_paddr : obj_ref)\n\ndatatype arch_invocation =\n    InvokePageTable page_table_invocation\n  | InvokePage page_invocation\n  | InvokeASIDControl asid_control_invocation\n  | InvokeASIDPool asid_pool_invocation\n\ndatatype arch_copy_register_sets =\n    RISCVNoExtraRegisters\n\ndefinition ArchDefaultExtraRegisters :: arch_copy_register_sets\n  where\n  \"ArchDefaultExtraRegisters = RISCVNoExtraRegisters\"\n\ndatatype arch_irq_control_invocation =\n    RISCVIRQControlInvocation irq cslot_ptr cslot_ptr bool\n\nend\nend", "property": "Architectural Invocations: Define the structure and types for RISCV64-specific system calls, including page table mappings and unmappings, ASID pool assignments, page mappings, unmappings, and address retrieval, and IRQ control. These invocations provide a structured way to handle architectural operations, ensuring that the system can manage memory, interrupts, and other low-level resources effectively.", "title": "./spec/abstract/RISCV64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the various possible RISCV64-specific system calls.\nSelectors are defined for various fields for convenience elsewhere."}
{"spec": "text \\<open>\n  The RISCV64 kernel supports capabilities for ASID pools and an ASID controller capability,\n  along with capabilities for virtual memory mappings.\n\\<close>\n\ndatatype arch_cap =\n    ASIDPoolCap (acap_obj : obj_ref) (acap_asid_base : asid)\n  | ASIDControlCap\n  | FrameCap\n      (acap_obj : obj_ref)\n      (acap_rights : cap_rights)\n      (acap_fsize : vmpage_size)\n      (acap_is_device : bool)\n      (acap_map_data : \"(asid \\<times> vspace_ref) option\")\n  | PageTableCap (acap_obj : obj_ref) (acap_map_data : \"(asid \\<times> vspace_ref) option\")", "property": "RISCV64 Architecture-Specific Capabilities: Defines capabilities for ASID pools, ASID controller, frame, and page table. These capabilities include specific attributes such as object references, ASID bases, rights, frame sizes, device flags, and mapping data, enabling fine-grained control over virtual memory and address space management.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "definition update_map_data :: \"arch_cap \\<Rightarrow> (asid \\<times> vspace_ref) option \\<Rightarrow> arch_cap\"\n  where\n  \"update_map_data cap m \\<equiv> case cap of\n     FrameCap p R sz dev _  \\<Rightarrow> FrameCap p R sz dev m\n   | PageTableCap p _ \\<Rightarrow> PageTableCap p m\"", "property": "Update Mapping Data: Modify the mapping data in a frame or page table capability, updating the ASID and virtual space reference as needed.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific objects", "comment": "Update the mapping data saved in a frame or page table capability."}
{"spec": "(* This datatype does not match up with the executable spec directly:\n   This one here models all \"things\" one can set on a page or page table entry.\n   The attributes accessible to users are the ones returned by attribs_from_word. *)\ndatatype vm_attribute = Global | Execute | User\ntype_synonym vm_attributes = \"vm_attribute set\"", "property": "RISCV64 VM Attributes: Define a set of attributes that can be applied to page or page table entries, including global, execute, and user permissions. These attributes are used to control the access and behavior of memory regions in the RISCV64 architecture.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "type_synonym pte_ppn_len = 52 (* machine_word_len - pt_bits *)\ntype_synonym pte_ppn = \"pte_ppn_len word\"\n\ndefinition ppn_len :: nat where\n  \"ppn_len \\<equiv> LENGTH(pte_ppn_len)\"\n\ndatatype pte =\n    InvalidPTE\n  | PagePTE (pte_ppn : pte_ppn) (pte_attr : vm_attributes) (pte_rights : vm_rights)\n  | PageTablePTE (pte_ppn : pte_ppn) (pte_attr : vm_attributes)\n\ntype_synonym pt_index_len = 9\ntype_synonym pt_index = \"pt_index_len word\"", "property": "RISCV64 Page Table Entry (PTE) Structure: Defines a PTE with three possible types: `InvalidPTE`, `PagePTE`, and `PageTablePTE`. Each valid PTE type includes a page number (ppn) of 52 bits, attributes, and, for `PagePTE`, additional rights. The ppn is stored as a shifted address, and the actual address can be retrieved using `addr_from_pte`.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " The address of the target object is stored shifted right by pt_bits and stored as a ppn (page\n   number). To get the address, use addr_from_pte "}
{"spec": "lemma \"LENGTH(pt_index_len) = ptTranslationBits\"\n  by (simp add: ptTranslationBits_def)\n\ntype_synonym asid_pool = \"asid_low_index \\<rightharpoonup> obj_ref\"\ntype_synonym pt = \"pt_index \\<Rightarrow> pte\"", "property": "Architecture-Specific Data Types: Define and ensure the correctness of architecture-specific data types, such as `asid_pool` and `pt`, which are used to manage address space identifiers and page tables, respectively. The lemma ensures that the length of `pt_index_len` matches the defined `ptTranslationBits`, providing a sanity check for the translation bits.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": "Sanity check:"}
{"spec": "datatype (discs_sels) arch_kernel_obj =\n    ASIDPool asid_pool\n  | PageTable pt\n  | DataPage bool vmpage_size\n\ndefinition asid_pool_of :: \"arch_kernel_obj \\<rightharpoonup> asid_pool\"\n  where\n  \"asid_pool_of ko \\<equiv> case ko of ASIDPool pool \\<Rightarrow> Some pool | _ \\<Rightarrow> None\"\n\ndefinition pt_of :: \"arch_kernel_obj \\<rightharpoonup> pt\"\n  where\n  \"pt_of ko \\<equiv> case ko of PageTable pt \\<Rightarrow> Some pt | _ \\<Rightarrow> None\"\n\ndefinition pte_bits :: nat\n  where\n  \"pte_bits = word_size_bits\"\n\ndefinition table_size :: nat\n  where\n  \"table_size = ptTranslationBits + pte_bits\"\n\ndefinition pt_bits :: \"nat\"\n  where\n  \"pt_bits \\<equiv> table_size\"\n\ndefinition addr_from_ppn :: \"pte_ppn \\<Rightarrow> paddr\"\n  where\n  \"addr_from_ppn ppn = ucast ppn << pt_bits\"\n\nabbreviation addr_from_pte :: \"pte \\<Rightarrow> paddr\"\n  where\n  \"addr_from_pte pte \\<equiv> addr_from_ppn (pte_ppn pte)\"\n\nprimrec arch_obj_size :: \"arch_cap \\<Rightarrow> nat\"\n  where\n  \"arch_obj_size (ASIDPoolCap _ _) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (FrameCap _ _ sz _ _) = pageBitsForSize sz\"\n| \"arch_obj_size (PageTableCap _ _ ) = table_size\"\n\nfun arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\"\n  where\n  \"arch_cap_is_device (FrameCap _ _ _ is_dev _) = is_dev\"\n| \"arch_cap_is_device _ = False\"\n\ndefinition cte_level_bits :: nat\n  where\n  \"cte_level_bits \\<equiv> 5\"\n\ndefinition tcb_bits :: nat\n  where\n  \"tcb_bits \\<equiv> 10\"\n\ndefinition endpoint_bits :: nat\n  where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat\n  where\n  \"ntfn_bits \\<equiv> 5\"\n\ndefinition untyped_min_bits :: nat\n  where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat\n  where\n  \"untyped_max_bits \\<equiv> 38\"\n\nprimrec arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\"\n  where\n  \"arch_kobj_size (ASIDPool _) = pageBits\"\n| \"arch_kobj_size (PageTable _) = table_size\"\n| \"arch_kobj_size (DataPage _ sz) = pageBitsForSize sz\"\n\nfun aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\"\n  where\n  \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref c = Some (acap_obj c)\"\n\ndefinition acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\"\n  where\n  \"acap_rights_update R acap \\<equiv>\n    case acap of\n      FrameCap ref cR sz dev as \\<Rightarrow> FrameCap ref (validate_vm_rights R) sz dev as\n    | _ \\<Rightarrow> acap\"", "property": "RISCV64-Specific Data Types and Sizes: Define architecture-specific object types, including ASID pools, page tables, and data pages, and specify their sizes. Additionally, define the sizes and properties of various architectural capabilities, such as frame caps, ASID pool caps, and page table caps, and provide functions to determine the size and device nature of these capabilities.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " produce discriminators and selectors even though no field names are mentioned "}
{"spec": "lemma \"LENGTH(pte_ppn_len) = word_bits - pt_bits\"\n  by (simp add: pte_bits_def ptTranslationBits_def word_size_bits_def word_bits_def\n                pt_bits_def table_size_def)", "property": "Length of PTE Physical Page Number: The length of the physical page number in a page table entry is defined as the difference between the total word bits and the bits used for the page table.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": "Sanity check:"}
{"spec": "datatype aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | HugePageObj\n  | PageTableObj\n  | ASIDPoolObj\n\ndefinition arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\"\n  where\n  \"arch_is_frame_type aobj \\<equiv> aobj \\<noteq> PageTableObj\"\n\ndefinition arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\"\n  where\n  \"arch_default_cap tp r n dev \\<equiv> case tp of\n     SmallPageObj \\<Rightarrow> FrameCap r vm_read_write RISCVSmallPage dev None\n   | LargePageObj \\<Rightarrow> FrameCap r vm_read_write RISCVLargePage dev None\n   | HugePageObj  \\<Rightarrow> FrameCap r vm_read_write RISCVHugePage dev None\n   | PageTableObj \\<Rightarrow> PageTableCap r None\n   | ASIDPoolObj  \\<Rightarrow> ASIDPoolCap r 0\" (* unused, but nicer properties when defined *)\n\ndefinition default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\"\n  where\n  \"default_arch_object tp dev n \\<equiv> case tp of\n     SmallPageObj \\<Rightarrow> DataPage dev RISCVSmallPage\n   | LargePageObj \\<Rightarrow> DataPage dev RISCVLargePage\n   | HugePageObj  \\<Rightarrow> DataPage dev RISCVHugePage\n   | PageTableObj \\<Rightarrow> PageTable (\\<lambda>_. InvalidPTE)\n   | ASIDPoolObj  \\<Rightarrow> ASIDPool Map.empty\"\n\ntype_synonym riscv_vspace_region_uses = \"vspace_ref \\<Rightarrow> riscvvspace_region_use\"", "property": "RISCV64-Specific Data Types: Defines architecture-specific object types including small, large, and huge page objects, page table objects, and ASID pool objects. These types are used to create default architectural capabilities and objects with specific properties, such as read-write permissions and page sizes, ensuring that the system can manage memory and address spaces effectively.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "type_synonym vm_level = 4\n\ndefinition asid_pool_level :: vm_level\n  where\n  \"asid_pool_level = maxBound\"\n\ndefinition max_pt_level :: vm_level\n  where\n  \"max_pt_level = asid_pool_level - 1\"\n\nend\n\nqualify RISCV64_A (in Arch)", "property": "Virtual Memory Levels: The architecture defines four levels of virtual memory, with the highest level containing ASID pools and the lower levels containing page tables. The top level is designated for ASID pools, followed by three levels of page tables, where the bottom level (level 0) contains only InvalidPTEs or PagePTEs.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific state", "comment": "\n  The number of levels over all virtual memory tables.\n  For RISC-V, we have three page table levels plus the ASID pool level.\n\n  The top level (with the highest number) contains ASID pools, the next levels contain the\n  top-level page tables, and level 1 page tables. The bottom-level page tables (level 0)\n  contains only InvalidPTEs or PagePTEs.\n"}
{"spec": "record arch_state =\n  riscv_asid_table :: \"asid_high_index \\<rightharpoonup> obj_ref\"\n  riscv_global_pts :: \"RISCV64_A.vm_level \\<Rightarrow> obj_ref set\"\n  riscv_kernel_vspace :: \"obj_ref \\<Rightarrow> RISCV64_H.riscvvspace_region_use\"", "property": "RISCV64 Architecture State: Maintains architecture-specific state including an ASID table, global page table sets for different VM levels, and a kernel virtual space mapping.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "end_qualify\n\ncontext Arch begin arch_global_naming (A)", "property": "RISCV64 Global Page Tables: The architecture-specific state includes generalized global page tables, with constraints that limit the set of tables at the maximum page table level to a singleton and ensure that the ASID pool level contains no tables. Other levels may have multiple or no tables, depending on kernel initialization.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Architecture-specific state", "comment": "\n  The @{const riscv_global_pts} generalise the concept of global page tables.\n  The invariants will constrain the set of tables for @{term max_pt_level} to a\n  singleton, and for @{term asid_pool_level} to empty. All other levels may contain\n  multiple or no tables, depending on how kernel initialisation sets up the kernel window.\n"}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\"\n  where\n  \"aa_type ao \\<equiv> case ao of\n     PageTable pt    \\<Rightarrow> APageTable\n   | DataPage dev sz \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n   | ASIDPool f      \\<Rightarrow> AASIDPool\"\n\ndefinition badge_bits :: nat\n  where\n  \"badge_bits \\<equiv> 64\"\n\nend", "property": "Architectural Object Types: Define the types of architectural objects, including AASIDPool, APageTable, AUserData with a specified virtual page size, and ADeviceData with a specified virtual page size. These types categorize different kinds of memory and control structures in the system. \n\nBadge Bits: Specify the number of bits used for badges, which is set to 64 bits.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "qualify RISCV64_A (in Arch)", "property": "RISCV64-Specific TCB: Defines architecture-specific data types and structures for the TCB, tailored to the RISCV64 architecture, ensuring that the thread control block is optimized for the specific features and requirements of the RISCV64 platform.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Arch-specific TCB", "comment": ""}
{"spec": "record arch_tcb =\n  tcb_context :: user_context\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition default_arch_tcb :: arch_tcb\n  where\n  \"default_arch_tcb \\<equiv> \\<lparr>tcb_context = new_context\\<rparr>\"", "property": "Arch-specific TCB: Contains a field for user context, ensuring that the architecture-specific part of the TCB is properly initialized with a default user context.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Arch-specific TCB", "comment": " Arch-specific part of a TCB: this must have at least a field for user context. "}
{"spec": "definition arch_tcb_context_set :: \"user_context \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\n  where\n  \"arch_tcb_context_set uc a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := uc \\<rparr>\"\n\ndefinition arch_tcb_context_get :: \"arch_tcb \\<Rightarrow> user_context\"\n  where\n  \"arch_tcb_context_get a_tcb \\<equiv> tcb_context a_tcb\"", "property": "Arch TCB Context Management: Provides functions to set and get the user context within the architecture-specific TCB, ensuring compatibility with user-level operations.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n  Accessors for @{text \"tcb_context\"} inside @{text \"arch_tcb\"}. These are later used to\n  implement @{text as_user}, i.e.\\ need to be compatible with @{text user_monad}.\n"}
{"spec": "definition arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\n  where\n  \"arch_tcb_set_registers regs a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := UserContext regs \\<rparr>\"\n\ndefinition arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\"\n  where\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\nend", "property": "Arch-specific TCB Register Management: Provides accessor functions to set and get user registers in the architecture-specific part of the TCB, ensuring that the register context is correctly updated and retrieved.", "title": "./spec/abstract/RISCV64/Arch_Structs_A.thy", "chapter": "RISCV64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n  Accessors for the user register part of the @{text \"arch_tcb\"}.\n  (Because @{typ \"register \\<Rightarrow> machine_word\"} might not be equal to @{typ user_context}).\n"}
{"spec": "chapter \\<open>Architecture-specific Fault-handling Functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\n  where\n  \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData)\n   od\"\n\ndefinition handle_arch_fault_reply ::\n  \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\n  where\n  \"handle_arch_fault_reply vmf thread x y \\<equiv> return True\"\n\nend\nend", "property": "Architecture-specific Fault Handling: Generate and handle architecture-specific fault messages. The system creates a fault message containing the program counter, virtual pointer, and architecture-specific data, and processes the fault reply, returning a boolean indicating successful handling.", "title": "./spec/abstract/RISCV64/ArchFault_A.thy", "chapter": "Architecture-specific Fault-handling Functions", "section": "", "comment": ""}
{"spec": "chapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\n  where\n  \"sanitise_register t r v \\<equiv> v\"\n\ndefinition arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\n  where\n  \"arch_get_sanitise_register_info t \\<equiv> return False\"\n\ndefinition arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\n  where\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "Architecture-specific TCB Functions: Provide architecture-specific operations for sanitizing register values, retrieving sanitization information, and performing post-modification actions on registers. These functions ensure that register modifications are handled in an architecture-appropriate manner, maintaining the integrity and consistency of the system state.", "title": "./spec/abstract/RISCV64/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "definition update_cnode_cap_data :: \"data \\<Rightarrow> nat \\<times> data\"\n  where\n  \"update_cnode_cap_data w \\<equiv>\n    let\n      guard_bits = 58;\n      guard_size' = unat ((w >> cnode_padding_bits) && mask cnode_guard_size_bits);\n      guard'' = (w >> (cnode_padding_bits + cnode_guard_size_bits)) && mask guard_bits\n    in (guard_size', guard'')\"", "property": "Update CNode Capability Data: Extract new guard size and guard bits from the provided data, ensuring that the CNode capability is updated with the specified guard parameters.", "title": "./spec/abstract/RISCV64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "On a user request to modify a CNode capability, extract new guard bits and guard."}
{"spec": "definition arch_is_physical :: \"arch_cap \\<Rightarrow> bool\"\n  where\n  \"arch_is_physical cap \\<equiv> case cap of ASIDControlCap \\<Rightarrow> False | _ \\<Rightarrow> True\"", "property": "Architectural Capability Physicality: Distinguish between physical and non-physical architectural capabilities, where ASIDControlCap is considered non-physical, and all other types of architectural capabilities are considered physical.", "title": "./spec/abstract/RISCV64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "For some purposes capabilities to physical objects are treated differently to others."}
{"spec": "fun arch_same_region_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\"\n  where\n  \"arch_same_region_as (FrameCap r _ sz _ _) c' =\n   (is_FrameCap c' \\<and>\n     (let\n        r' = acap_obj c';\n        sz' = acap_fsize c';\n        topA = r + (1 << pageBitsForSize sz) - 1;\n        topB = r' + (1 << pageBitsForSize sz') - 1\n      in r \\<le> r' \\<and> topA \\<ge> topB \\<and> r' \\<le> topB))\"\n| \"arch_same_region_as (PageTableCap r _) c' = (\\<exists>r' d'. c' = PageTableCap r' d' \\<and> r = r')\"\n| \"arch_same_region_as ASIDControlCap c' = (c' = ASIDControlCap)\"\n| \"arch_same_region_as (ASIDPoolCap r _) c' = (\\<exists>r' d'. c' = ASIDPoolCap r' d' \\<and> r = r')\"", "property": "Check Same Region: Determine if two architecture capabilities refer to the same object or if the second capability is contained within the region of the first. This ensures that the capabilities are consistent and correctly aligned, maintaining the integrity of memory regions.", "title": "./spec/abstract/RISCV64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Check whether the second capability is to the same object or an object\n  contained in the region of the first one.\n"}
{"spec": "definition same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\"\n  where\n  \"same_aobject_as cap cap' \\<equiv>\n     case (cap, cap') of\n       (FrameCap ref _ sz dev _, FrameCap ref' _ sz' dev' _) \\<Rightarrow>\n         (dev, ref, sz) = (dev', ref', sz') \\<and> ref \\<le> ref + 2 ^ pageBitsForSize sz - 1\n     | _ \\<Rightarrow> arch_same_region_as cap cap'\"\n\ndeclare same_aobject_as_def[simp]\n\ndefinition arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\n  where\n  \"arch_is_cap_revocable new_cap src_cap \\<equiv> False\"\n\nend\nend", "property": "Check Capabilities for Same Object: Determine if two architecture capabilities refer to the same object by comparing their device, reference, and size. If both are frame capabilities, they must have matching device, reference, and size, and the reference must be within the bounds of the frame. For other types of capabilities, a different comparison function is used.", "title": "./spec/abstract/RISCV64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "type_synonym obj_ref         = machine_word\ntype_synonym vspace_ref      = machine_word\n\ntype_synonym data            = machine_word\ntype_synonym cap_ref         = \"bool list\"\ntype_synonym length_type     = machine_word\n\ntype_synonym asid_low_len    = 9\ntype_synonym asid_low_index  = \"asid_low_len word\"\n\ntype_synonym asid_high_len   = 7\ntype_synonym asid_high_index = \"asid_high_len word\"\n\ntype_synonym asid_len        = 16\ntype_synonym asid_rep_len    = asid_len\ntype_synonym asid            = \"asid_rep_len word\"", "property": "Type Instantiation for RISCV64 Architecture: Defines concrete types for abstract type names, including object references, virtual space references, data, capability references, and length types, as well as specific bit lengths and indices for ASID (Address Space Identifier) components.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object references, user pointers,\n  word-based data, cap references, and so on. This theory provides an instantiation of these names\n  to concrete types for the RISCV64 architecture. Other architectures may have slightly different\n  instantiations.\n"}
{"spec": "definition oref_to_data :: \"obj_ref \\<Rightarrow> data\"\n  where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition data_to_oref :: \"data \\<Rightarrow> obj_ref\"\n  where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition vref_to_data :: \"vspace_ref \\<Rightarrow> data\"\n  where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition data_to_vref :: \"data \\<Rightarrow> vspace_ref\"\n  where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition nat_to_len :: \"nat \\<Rightarrow> length_type\"\n  where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition data_to_nat :: \"data \\<Rightarrow> nat\"\n  where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition data_to_16 :: \"data \\<Rightarrow> 16 word\"\n  where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition data_to_cptr :: \"data \\<Rightarrow> cap_ref\"\n  where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\"\n  where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\"\n  where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Define conversions between different data types, including object references, virtual space references, natural numbers, lengths, and various word sizes. These conversions ensure seamless data manipulation and interoperability within the system.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  With the definitions above, most conversions between abstract type names boil down to just\n  the identity function, some convert from @{text word} to @{typ nat} and others between different\n  word sizes using @{const ucast}.\n"}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversion Simplifications: Define and simplify conversions between different data types, including object references, virtual references, natural numbers, 16-bit data, and capability pointers. These simplifications facilitate automatic unfolding in proofs, ensuring consistent and efficient data handling.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition slot_bits :: nat\n  where\n  \"slot_bits \\<equiv> 5\"\n\ndefinition msg_label_bits :: nat\n  where\n  [simp]: \"msg_label_bits \\<equiv> 52\"\n\ndefinition new_context :: \"user_context\"\n  where\n  \"new_context \\<equiv> UserContext ((\\<lambda>_. 0) (SSTATUS := sstatusSPIE))\"", "property": "Architecture-Dependent Sizes: Define the standard sizes for slots and message labels, as well as the initial state for a new user context.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The following definitions provide architecture-dependent sizes such as the standard page\n  size and capability size of the underlying machine.\n"}
{"spec": "definition pptr_base :: \"machine_word\"\n  where\n  \"pptr_base = Platform.RISCV64.pptrBase\"\n\ntext \"Virtual address space available to users.\"\ndefinition user_vtop :: \"machine_word\"\n  where\n  \"user_vtop = Platform.RISCV64.pptrUserTop\"", "property": "Kernel Virtual Address Reservation: The kernel reserves a range of virtual addresses starting from the lowest virtual address in the kernel window, ensuring that this space is not available for user processes.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The lowest virtual address in the kernel window. The kernel reserves the virtual addresses\n  from here up in every virtual address space.\n"}
{"spec": "definition kdev_base :: \"machine_word\"\n  where\n  \"kdev_base = Platform.RISCV64.kdevBase\"", "property": "Kernel Device Mapping Base: Defines the virtual address for the start of the kernel device mapping region, which is located in the highest 1GiB of memory.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  Virtual address for start of kernel device mapping region in highest 1GiB of memory.\n"}
{"spec": "definition kernel_elf_base :: \"vspace_ref\"\n  where\n  \"kernel_elf_base \\<equiv> Platform.RISCV64.kernelELFBase\"", "property": "Kernel ELF Base: Specifies the virtual address at which the kernel code is mapped in the virtual address space.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The virtual address the kernel code is mapped.\n"}
{"spec": "definition idle_thread_ptr :: vspace_ref\n  where\n  \"idle_thread_ptr = pptr_base + 0x1000\"\n\n\ndefinition nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\"\n  where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len) (to_bl (of_nat n :: machine_word))\"\n\ndefinition msg_info_register :: register\n  where\n  \"msg_info_register \\<equiv> msgInfoRegister\"\n\ndefinition msg_registers :: \"register list\"\n  where\n  \"msg_registers \\<equiv> msgRegisters\"\n\ndefinition cap_register :: register\n  where\n  \"cap_register \\<equiv> capRegister\"\n\ndefinition badge_register :: register\n  where\n  \"badge_register \\<equiv> badgeRegister\"\n\ndefinition frame_registers :: \"register list\"\n  where\n  \"frame_registers \\<equiv> frameRegisters\"\n\ndefinition gp_registers :: \"register list\"\n  where\n  \"gp_registers \\<equiv> gpRegisters\"\n\ndefinition exception_message :: \"register list\"\n  where\n  \"exception_message \\<equiv> exceptionMessage\"\n\ndefinition syscall_message :: \"register list\"\n  where\n  \"syscall_message \\<equiv> syscallMessage\"\n\ndatatype arch_fault\n  = VMFault (vm_fault_address : vspace_ref) (vm_fault_arch_data : \"machine_word list\")\n\nend\n\narch_requalify_consts (A) idle_thread_ptr\n\nend", "property": "Idle Thread Pointer Definition: The idle thread pointer is defined as an arbitrary aligned address, ensuring the existence of a designated location for the idle thread in the virtual space.", "title": "./spec/abstract/RISCV64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  Currently an arbitrary aligned address for the idle thread.\n  Only has to exists, does not have to match up with the concrete value in C.\n"}
{"spec": "text \\<open>This is used by some decode functions. VCPU decode functions are the first that need to bounds\n  check IRQs from the user.\\<close>\ndefinition arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"arch_check_irq irq \\<equiv> whenE (irq > maxIRQ \\<or> irq < ucast minIRQ)\n                          $ throwError (RangeError (ucast minIRQ) maxIRQ)\"", "property": "Validate IRQ Range: Ensure that the provided IRQ number is within the valid range, throwing a `RangeError` if the IRQ is out of bounds.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "definition decode_vcpu_set_tcb ::\n  \"arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_set_tcb cap extras \\<equiv> case (cap, extras) of\n     (VCPUCap v, fs#_) \\<Rightarrow> (case fs of\n           (ThreadCap t, _) \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUSetTCB v t\n         | _ \\<Rightarrow> throwError IllegalOperation)\n   | (VCPUCap v, _) \\<Rightarrow> throwError TruncatedMessage\n   | _ \\<Rightarrow> throwError IllegalOperation\"", "property": "VCPU Set TCB: Decodes the capability and extra slots to set the TCB for a VCPU. Ensures that the operation is only valid if the first extra slot contains a ThreadCap, otherwise it throws an error.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "definition read_vcpu_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (machine_word,'z::state_ext) s_monad\" where\n  \"read_vcpu_register vcpu_ptr reg \\<equiv> do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     (on_cur_vcpu, active) \\<leftarrow> return (case cur_vcpu of\n         Some (vcpu_ptr', a) \\<Rightarrow> (vcpu_ptr' = vcpu_ptr, a)\n       | _ \\<Rightarrow> (False, False));\n\n     if on_cur_vcpu\n       then if vcpuRegSavedWhenDisabled reg \\<and> \\<not>active\n              then vcpu_read_reg vcpu_ptr reg\n              else do_machine_op $ readVCPUHardwareReg reg\n       else vcpu_read_reg vcpu_ptr reg\n  od\"\n\ndefinition\n  write_vcpu_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"write_vcpu_register vcpu_ptr reg val \\<equiv>\n  do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu o arch_state);\n     (on_cur_vcpu, active) \\<leftarrow> return (case cur_vcpu of\n         Some (cv, a) \\<Rightarrow> (cv = vcpu_ptr, a)\n       | _ \\<Rightarrow> (False, False));\n\n     if on_cur_vcpu\n       then if vcpuRegSavedWhenDisabled reg \\<and> \\<not>active\n         then vcpu_write_reg vcpu_ptr reg val\n         else do_machine_op $ writeVCPUHardwareReg reg val\n       else vcpu_write_reg vcpu_ptr reg val\n  od\"\n\ndefinition decode_vcpu_read_register ::\n  \"machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_read_register args cap \\<equiv> case (args, cap) of\n      (reg#_, VCPUCap p) \\<Rightarrow> if fromEnum (maxBound::vcpureg) < unat reg\n                           then throwError (InvalidArgument 1)\n                           else returnOk $ InvokeVCPU $ VCPUReadRegister p $ toEnum (unat reg)\n    | (_, _) \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition decode_vcpu_write_register :: \"machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_write_register args cap \\<equiv> case (args, cap) of\n    (reg#val#_, VCPUCap p) \\<Rightarrow> if fromEnum (maxBound::vcpureg) < unat reg\n                              then throwError (InvalidArgument 1)\n                              else returnOk $ InvokeVCPU $ VCPUWriteRegister p (toEnum (unat reg)) val\n  | (_, _) \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_read_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\n  where\n  \"invoke_vcpu_read_register v reg \\<equiv> do\n     val \\<leftarrow> read_vcpu_register v reg;\n     return [val]\n   od\"\n\ndefinition\n  invoke_vcpu_write_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"invoke_vcpu_write_register v reg val \\<equiv>  write_vcpu_register v reg val\"", "property": "VCPU Register Access: Enables reading and writing of VCPU registers, with the method of access (direct or through hardware) determined by whether the VCPU is the current one and its active state. If the VCPU is the current one and the register is saved when disabled, direct access is used; otherwise, hardware access is performed.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": ""}
{"spec": "definition make_virq :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> virq\" where\n  \"make_virq grp prio irq \\<equiv>\n    let\n      groupShift = 30;\n      prioShift = 23;\n      irqPending = 1 << 28;\n      eoiirqen = 1 << 19\n    in ((grp && 1) << groupShift) || ((prio && 0x1F) << prioShift) || (irq && 0x3FF)\n       || irqPending || eoiirqen\"\n\ndefinition virq_type :: \"virq \\<Rightarrow> nat\" where\n  \"virq_type virq \\<equiv> unat ((virq >> 28) && 3)\"\n\ndefinition is_virq_active :: \"virq \\<Rightarrow> bool\" where\n  \"is_virq_active virq \\<equiv> virq_type virq = 2\"\n\ndefinition decode_vcpu_inject_irq ::\n  \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_inject_irq ptrs cap \\<equiv> case (ptrs, cap) of\n  (mr0 # _, VCPUCap p) \\<Rightarrow> doE\n     vid \\<leftarrow> returnOk (mr0 && 0xFFFF);\n     priority \\<leftarrow> returnOk ((mr0 >> 16) && 0xFF);\n     group \\<leftarrow> returnOk ((mr0 >> 24) && 0xFF);\n     index \\<leftarrow> returnOk ((mr0 >> 32) && 0xFF);\n     range_check vid 0 ((1 << 10) - 1);\n     range_check priority 0 31;\n     range_check group 0 1;\n     num_list_regs \\<leftarrow> liftE $ gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     whenE (index \\<ge> of_nat num_list_regs) $\n        (throwError $ RangeError 0 (of_nat num_list_regs - 1));\n\n     vcpu \\<leftarrow> liftE $ get_vcpu p;\n     vcpuLR \\<leftarrow> returnOk (vgic_lr $ vcpu_vgic $ vcpu);\n\n     whenE (is_virq_active (vcpuLR (unat index))) $ throwError DeleteFirst;\n\n     virq \\<leftarrow> returnOk (make_virq group priority vid);\n     returnOk $ InvokeVCPU $ VCPUInjectIRQ p (unat index) virq\n  odE\n| _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_inject_irq :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> virq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invoke_vcpu_inject_irq vr index virq \\<equiv> do\n    cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n    if (cur_v \\<noteq> None \\<and> fst (the cur_v) = vr)\n    then do_machine_op $ set_gic_vcpu_ctrl_lr (of_nat index) virq\n    else vgic_update_lr vr index virq\n   od\"", "property": "VCPU Interrupt Injection: Allows the injection of a virtual interrupt into a VCPU by constructing a virtual interrupt (virq) with specified parameters (group, priority, and ID), validating the input values, and updating the VCPU's state. The function ensures that the virq is not already active before injecting it, maintaining the integrity of the VCPU's interrupt state.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": " This following function does not correspond to exactly what the C does, but\n   it is the value that is stored inside of lr in the vgic  "}
{"spec": "definition decode_vcpu_ack_vppi ::\n  \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_ack_vppi mrs cap \\<equiv>\n     case (mrs, cap)\n       of (mr0 # _, VCPUCap vcpu_ptr) \\<Rightarrow> doE\n           arch_check_irq mr0;\n           (case irq_vppi_event_index (ucast mr0)\n            of None \\<Rightarrow> throwError $ InvalidArgument 0\n             | Some vppi \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUAckVPPI vcpu_ptr vppi)\n         odE\n       | _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_ack_vppi :: \"obj_ref \\<Rightarrow> vppievent_irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invoke_vcpu_ack_vppi vcpu_ptr vppi =\n     vcpu_update vcpu_ptr\n                 (\\<lambda>vcpu. vcpu\\<lparr> vcpu_vppi_masked := (vcpu_vppi_masked vcpu)(vppi := False) \\<rparr>)\"", "property": "VCPU Acknowledge VPPI: Acknowledge a Virtual Posted-Interrupt (VPPI) event for a VCPU. This action updates the VCPU's VPPI mask to unmask the specified VPPI event, allowing the VCPU to handle the interrupt.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": "VCPU : acknowledge VPPI"}
{"spec": "definition\n  perform_vcpu_invocation :: \"vcpu_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"perform_vcpu_invocation iv \\<equiv> case iv of\n     VCPUSetTCB vcpu tcb \\<Rightarrow> do associate_vcpu_tcb vcpu tcb; return [] od\n   | VCPUReadRegister vcpu reg \\<Rightarrow> invoke_vcpu_read_register vcpu reg\n   | VCPUWriteRegister vcpu reg val \\<Rightarrow> do invoke_vcpu_write_register vcpu reg val; return [] od\n   | VCPUInjectIRQ vcpu index vir \\<Rightarrow> do invoke_vcpu_inject_irq vcpu index vir; return [] od\n   | VCPUAckVPPI vcpu vppi \\<Rightarrow> do invoke_vcpu_ack_vppi vcpu vppi; return [] od\"\n\ndefinition decode_vcpu_invocation ::\n  \"machine_word \\<Rightarrow> machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_invocation label args cap extras \\<equiv> case cap of\n  VCPUCap _ \\<Rightarrow> (case invocation_type label of\n      ArchInvocationLabel ARMVCPUSetTCB \\<Rightarrow> decode_vcpu_set_tcb cap extras\n    | ArchInvocationLabel ARMVCPUReadReg \\<Rightarrow> decode_vcpu_read_register args cap\n    | ArchInvocationLabel ARMVCPUWriteReg \\<Rightarrow> decode_vcpu_write_register args cap\n    | ArchInvocationLabel ARMVCPUInjectIRQ \\<Rightarrow> decode_vcpu_inject_irq args cap\n    | ArchInvocationLabel ARMVCPUAckVPPI \\<Rightarrow> decode_vcpu_ack_vppi args cap\n    |  _ \\<Rightarrow> throwError IllegalOperation)\n  | _ \\<Rightarrow> throwError IllegalOperation\"\n\nend\n\nend", "property": "VCPU Invocation and Decoding: VCPU can perform various operations including setting the associated TCB, reading and writing registers, injecting IRQs, and acknowledging VPPIs. These operations are decoded from invocation labels and arguments, ensuring that the correct VCPU actions are executed based on the provided parameters.", "title": "./spec/abstract/AARCH64/VCPU_A.thy", "chapter": "VCPU", "section": "", "comment": "VCPU perform and decode main functions"}
{"spec": "chapter \"Arch-specific Interrupts\"\n\ntheory ArchInterrupt_A\nimports Ipc_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition virqSetEOIIRQEN :: \"virq \\<Rightarrow> machine_word \\<Rightarrow> virq\" where\n  \"virqSetEOIIRQEN virq v \\<equiv>\n     if virq_type virq = 3\n     then virq\n     else (virq && ~~0x80000) || ((v << 19) && 0x80000)\"\n\ndefinition vgic_maintenance :: \"(unit,'z::state_ext) s_monad\" where\n  \"vgic_maintenance = do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     case cur_vcpu\n       of Some (vcpu_ptr, True) \\<Rightarrow> do\n            eisr0 \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_eisr0;\n            eisr1 \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_eisr1;\n            flags \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_misr;\n            vgic_misr_eoi \\<leftarrow> return $ vgicHCREN;\n            irq_idx \\<leftarrow> return (if eisr0 \\<noteq> 0 then word_ctz eisr0 else word_ctz eisr1 + 32);\n            gic_vcpu_num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs o arch_state);\n            fault \\<leftarrow> if flags && vgic_misr_eoi \\<noteq> 0\n                    then\n                      if eisr0 = 0 \\<and> eisr1 = 0 \\<or> irq_idx \\<ge> gic_vcpu_num_list_regs\n                      then return $ VGICMaintenance None\n                      else do\n                        virq <- do_machine_op $ get_gic_vcpu_ctrl_lr (of_nat irq_idx);\n                        virqen <- return $ virqSetEOIIRQEN virq 0;\n                        do_machine_op $ set_gic_vcpu_ctrl_lr (of_nat irq_idx) virqen;\n                        vgic_update_lr vcpu_ptr irq_idx virqen;\n                        return $ VGICMaintenance $ Some $ of_nat irq_idx\n                      od\n                    else return $ VGICMaintenance None;\n\n            ct \\<leftarrow> gets cur_thread;\n            st \\<leftarrow> get_thread_state ct;\n            \\<comment> \\<open>until a proof links active current vcpu to runnable current thread, we need this\n               check: @{term handle_fault} needs a runnable current thread\\<close>\n            when (runnable st) $ handle_fault ct $ ArchFault fault\n          od\n        | _ \\<Rightarrow> return ()\n   od\"\n\ndefinition vppi_event :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vppi_event irq = do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     case cur_vcpu\n       of Some (vcpu_ptr, True) \\<Rightarrow> do\n            do_machine_op $ maskInterrupt True irq;\n            vppi \\<leftarrow> return $ the $ irq_vppi_event_index irq;\n            vcpu_update vcpu_ptr\n                        (\\<lambda>vcpu. vcpu\\<lparr> vcpu_vppi_masked := (vcpu_vppi_masked vcpu)(vppi := True) \\<rparr>);\n            ct \\<leftarrow> gets cur_thread;\n            st \\<leftarrow> get_thread_state ct;\n            \\<comment> \\<open>until a proof links active current vcpu to runnable current thread, we need this\n               check: @{term handle_fault} needs a runnable current thread\\<close>\n            when (runnable st) $ handle_fault ct $ ArchFault $ VPPIEvent irq\n          od\n        | _ \\<Rightarrow> return ()\n   od\"\n\ndefinition handle_reserved_irq :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"handle_reserved_irq irq \\<equiv> do\n     when (irq = irqVGICMaintenance) vgic_maintenance;\n     when (irq_vppi_event_index irq \\<noteq> None) $ vppi_event irq\n   od\"\n\nfun arch_invoke_irq_handler :: \"irq_handler_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_invoke_irq_handler (ACKIrq irq) = (do_machine_op $ maskInterrupt False irq)\"\n| \"arch_invoke_irq_handler _ = return ()\"\n\ndefinition arch_mask_irq_signal :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_mask_irq_signal irq \\<equiv> do_machine_op $ maskInterrupt True irq\"\n\nend\n\nend", "property": "Arch-specific Interrupt Handling: Manages virtual and physical interrupts, including handling maintenance interrupts, masking interrupts, and updating the state of the current virtual CPU. Ensures that interrupt-related faults are handled only when the current thread is in a runnable state.", "title": "./spec/abstract/AARCH64/ArchInterrupt_A.thy", "chapter": "Arch-specific Interrupts", "section": "", "comment": ""}
{"spec": "definition perform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_asid_control_invocation iv \\<equiv> case iv of\n     MakePool frame slot parent base \\<Rightarrow> do\n       delete_objects frame pageBits;\n       pcap \\<leftarrow> get_cap parent;\n       set_cap (max_free_index_update pcap) parent;\n       retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n       cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n       assert (asid_low_bits_of base = 0);\n       asid_table \\<leftarrow> gets asid_table;\n       asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n       modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>arm_asid_table := asid_table'\\<rparr>\\<rparr>)\n     od\"", "property": "ASID Control Invocation: Creates a new ASID pool object, provides a capability to it, and connects it to the global virtual ASID table. This ensures that the ASID pool is properly initialized and integrated into the system's memory management.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "\n  The ASIDControl capability confers the authority to create a new ASID pool object. This\n  operation creates the new ASID pool, provides a capability to it and connects it to the global\n  virtual ASID table.\n"}
{"spec": "definition perform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_asid_pool_invocation iv \\<equiv> case iv of\n     Assign asid pool_ptr ct_slot \\<Rightarrow> do\n       pt_cap \\<leftarrow> get_cap ct_slot;\n       assert $ is_ArchObjectCap pt_cap;\n       acap \\<leftarrow> return $ the_arch_cap pt_cap;\n       assert $ is_PageTableCap acap;\n       set_cap (ArchObjectCap $ update_map_data acap $ Some (asid,0)) ct_slot;\n       pt_base \\<leftarrow> return $ acap_obj acap;\n       store_asid_pool_entry pool_ptr asid (Some (ASIDPoolVSpace None pt_base))\n     od\"\n\ndefinition perform_pg_inv_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_pg_inv_unmap cap ct_slot \\<equiv> do\n     assert $ is_FrameCap cap;\n     case acap_map_data cap of\n       Some (asid, vaddr) \\<Rightarrow> unmap_page (acap_fsize cap) asid vaddr (acap_obj cap)\n     | _ \\<Rightarrow> return ();\n     old_cap \\<leftarrow> get_cap ct_slot;\n     set_cap (ArchObjectCap $ update_map_data (the_arch_cap old_cap) None) ct_slot\n   od\"\n\ndefinition perform_pg_inv_map ::\n  \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> pte \\<Rightarrow> obj_ref \\<Rightarrow> vm_level \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_pg_inv_map cap ct_slot pte slot level \\<equiv> do\n     old_pte \\<leftarrow> get_pte level slot;\n     set_cap (ArchObjectCap cap) ct_slot;\n     store_pte level slot pte;\n     do_machine_op $ cleanByVA_PoU slot (addrFromPPtr slot);\n     when (old_pte \\<noteq> InvalidPTE) $ do\n        (asid, vaddr) \\<leftarrow> assert_opt $ acap_map_data cap;\n        invalidate_tlb_by_asid_va asid vaddr\n     od\n   od\"\n\ndefinition perform_pg_inv_get_addr ::\n  \"obj_ref \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"perform_pg_inv_get_addr ptr \\<equiv> return [addrFromPPtr ptr]\"\n\ndefinition do_flush :: \"flush_type \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\" where\n  \"do_flush type vstart vend pstart \\<equiv>\n     case type of\n       Clean \\<Rightarrow> cleanCacheRange_RAM vstart vend pstart\n     | Invalidate \\<Rightarrow> invalidateCacheRange_RAM vstart vend pstart\n     | CleanInvalidate \\<Rightarrow> cleanInvalidateCacheRange_RAM vstart vend pstart\n     | Unify \\<Rightarrow> do\n         cleanCacheRange_PoU vstart vend pstart;\n         dsb;\n         invalidateCacheRange_I vstart vend pstart;\n         isb\n       od\"", "property": "ASID Pool Management: Assign an ASID to a top-level page table, updating the corresponding capability and storing the ASID pool entry. This ensures that the ASID is correctly associated with the page table, enabling proper memory management and virtual address translation.\n\nPage Table Operations: Perform operations such as mapping and unmapping pages, updating the page table entries, and invalidating TLB entries. These operations ensure that the page tables are correctly managed, maintaining the integrity of the virtual memory system.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign an ASID to a top-level page table."}
{"spec": "definition perform_flush ::\n  \"flush_type \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> paddr \\<Rightarrow> obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_flush type vstart vend pstart space asid \\<equiv> do\n     start \\<leftarrow> return $ ptrFromPAddr pstart;\n     end \\<leftarrow> return $ start + (vend - vstart);\n     when (start < end) $ do_machine_op $ do_flush type start end pstart\n   od\"", "property": "Memory Flush Operation: Perform a memory flush operation on a specified range of virtual and physical addresses. The type of flush (vspace or page) determines the specific behavior, ensuring that the memory is correctly updated and synchronized.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": " Used for both, vspace and page invocation; distinction is in the flush type "}
{"spec": "definition perform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n  \"perform_page_invocation iv \\<equiv> case iv of\n     PageMap cap ct_slot (pte,slot,level) \\<Rightarrow> do\n       perform_pg_inv_map cap ct_slot pte slot level;\n       return []\n     od\n   | PageUnmap cap ct_slot \\<Rightarrow> do perform_pg_inv_unmap cap ct_slot; return [] od\n   | PageGetAddr ptr \\<Rightarrow> perform_pg_inv_get_addr ptr\n   | PageFlush type start end pstart space asid \\<Rightarrow> do\n       perform_flush type start end pstart space asid;\n       return []\n     od\"\n\n\ndefinition perform_pt_inv_map ::\n  \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> pte \\<Rightarrow> obj_ref \\<Rightarrow> vm_level \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_pt_inv_map cap ct_slot pte slot level = do\n     set_cap (ArchObjectCap cap) ct_slot;\n     store_pte level slot pte;\n     do_machine_op $ cleanByVA_PoU slot (addrFromPPtr slot)\n   od\"\n\ndefinition perform_pt_inv_unmap :: \"arch_cap \\<Rightarrow> cslot_ptr \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_pt_inv_unmap cap ct_slot = do\n     assert $ is_PageTableCap cap;\n     case acap_map_data cap of\n       Some (asid, vaddr) \\<Rightarrow> do\n         p \\<leftarrow> return $ acap_obj cap;\n         unmap_page_table asid vaddr p;\n         slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + mask (pt_bits (acap_pt_type cap))];\n         mapM_x (swp (store_pte (acap_pt_type cap)) InvalidPTE) slots;\n         do_machine_op $ cleanCacheRange_PoU p (p + mask (pt_bits (acap_pt_type cap)))\n                                             (addrFromPPtr p)\n       od\n     | _ \\<Rightarrow> return ();\n     old_cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n     set_cap (ArchObjectCap $ update_map_data old_cap None) ct_slot\n   od\"", "property": "Frame Capability Operations: Authorize the mapping and unmapping of memory, querying the physical address of a page, and flushing specific memory ranges. These operations ensure that memory management is secure and efficient, maintaining the integrity and performance of the system.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "\n  The Frame capability confers the authority to map and unmap memory, to query the physical\n  address of a page and to flush.\n"}
{"spec": "definition perform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"perform_page_table_invocation iv \\<equiv> case iv of\n     PageTableMap cap ct_slot pte slot level \\<Rightarrow> perform_pt_inv_map cap ct_slot pte slot level\n   | PageTableUnmap cap ct_slot \\<Rightarrow> perform_pt_inv_unmap cap ct_slot\"", "property": "PageTable Invocation: Allows the mapping and unmapping of page tables. This ensures that memory management operations are performed with the appropriate authority, maintaining the integrity and security of the system's memory.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page tables."}
{"spec": "definition perform_vspace_invocation :: \"vspace_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"perform_vspace_invocation iv \\<equiv> case iv of\n     VSpaceNothing \\<Rightarrow> return ()\n   | VSpaceFlush type start end pstart space asid \\<Rightarrow> perform_flush type start end pstart space asid\"\n\nlocale_abbrev arch_no_return :: \"(unit, 'z::state_ext) s_monad \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\n  where\n  \"arch_no_return oper \\<equiv> do oper; return [] od\"", "property": "VSpace Invocation: VSpace capabilities allow for the flushing of memory regions. The invocation can either do nothing or perform a flush operation, which involves specifying the type, start and end addresses, physical start address, space, and ASID to ensure the memory is correctly managed and updated.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "VSpace capabilities confer the authority to flush."}
{"spec": "definition arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\"\n  where\n  \"arch_perform_invocation i \\<equiv> liftE $ case i of\n     InvokeVSpace oper \\<Rightarrow> arch_no_return $ perform_vspace_invocation oper\n   | InvokePageTable oper \\<Rightarrow> arch_no_return $ perform_page_table_invocation oper\n   | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n   | InvokeASIDControl oper \\<Rightarrow> arch_no_return $ perform_asid_control_invocation oper\n   | InvokeASIDPool oper \\<Rightarrow> arch_no_return $ perform_asid_pool_invocation oper\n   | InvokeVCPU oper \\<Rightarrow> perform_vcpu_invocation oper\"\n\nend\nend", "property": "Architectural Invocation Handling: Dispatches AARCH64-specific system calls to the appropriate handlers for operations on virtual spaces, page tables, pages, ASID control, ASID pools, and VCPUs. Ensures that each invocation is processed by the corresponding architectural function, maintaining the integrity and functionality of the system's memory and virtualization components.", "title": "./spec/abstract/AARCH64/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call dispatcher for all AARCH64-specific system calls."}
{"spec": "chapter \\<open>Handle Hypervisor Fault Events\\<close>\n\ntheory Hypervisor_A\nimports Ipc_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"machine_word \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\n  where\n  \"handle_hypervisor_fault thread (ARMVCPUFault hsr) = do\n     fpu_enabled \\<leftarrow> do_machine_op isFpuEnable;\n     if \\<not>fpu_enabled\n     then fail\n     else if hsr = 0x2000000 \\<comment> \\<open>@{text UNKNOWN_FAULT}\\<close>\n          then do\n            esr \\<leftarrow> do_machine_op getESR;\n            handle_fault thread (UserException (esr && mask 32) 0)\n          od\n          else handle_fault thread (ArchFault $ VCPUFault (ucast hsr))\n   od\"\n\nend\nend", "property": "Handle Hypervisor Faults: Process hypervisor fault events by checking if the FPU is enabled, and based on the fault type, either handle a specific user exception or an architectural fault. If the FPU is not enabled, the fault handling fails.", "title": "./spec/abstract/AARCH64/Hypervisor_A.thy", "chapter": "Handle Hypervisor Fault Events", "section": "", "comment": ""}
{"spec": "definition reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Reserve Memory Region: Reserve a specified number of bytes in memory, optionally tagging the region as kernel data. This function currently acts as a placeholder and does not perform any actual reservation or tagging.", "title": "./spec/abstract/AARCH64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "\n  This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory.\n"}
{"spec": "definition vs_apiobj_size where\n  \"vs_apiobj_size ty \\<equiv>\n     case ty of\n       ArchObject SmallPageObj \\<Rightarrow> pageBitsForSize ARMSmallPage\n     | ArchObject LargePageObj \\<Rightarrow> pageBitsForSize ARMLargePage\n     | ArchObject HugePageObj \\<Rightarrow> pageBitsForSize ARMHugePage\n     | ArchObject PageTableObj \\<Rightarrow> table_size NormalPT_T\n     | ArchObject VSpaceObj \\<Rightarrow> table_size VSRootPT_T\"\n\ndefinition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv>\n     if \\<not>is_device \\<and>\n        new_type \\<in> {ArchObject SmallPageObj, ArchObject LargePageObj, ArchObject HugePageObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_RAM ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else if new_type \\<in> {ArchObject PageTableObj, ArchObject VSpaceObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_PoU ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else\n       return ()\"\n\ndefinition empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (FPUState (\\<lambda>_. 0) 0 0) (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context, tcb_vcpu = None \\<rparr>\"\n\nend\nend", "property": "Initialization of Architecture-Specific Objects: Initialize architecture-specific objects based on their type, including cleaning cache ranges for page and table objects. For non-device page objects, clean the cache range as RAM, and for page table and virtual space objects, clean the cache range with PoU (Preserve on Update).", "title": "./spec/abstract/AARCH64/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\" where\n  \"arch_post_cap_deletion ac \\<equiv> return ()\"", "property": "Post-Capability Deletion Action: Perform any necessary architectural actions after a capability is deleted. In this case, no specific action is required.", "title": "./spec/abstract/AARCH64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = unit\n\ndefinition arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\" where\n  \"arch_gen_obj_refs ac \\<equiv> {}\"\n\ndefinition arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\" where\n  \"arch_cap_cleanup_opt ac \\<equiv> NullCap\"\n\nend\nend", "property": "Arch-Specific Generic Object References: The system defines arch-specific generic object references, but they are not covered by the generic references. The set of arch-specific generic object references for any arch_cap is empty, and the cleanup operation for any arch_cap results in a NullCap.", "title": "./spec/abstract/AARCH64/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition arm_global_pt_ptr :: obj_ref where\n  \"arm_global_pt_ptr = pptr_base + 0x2000\"", "property": "Global Page Table Pointer Alignment: The global page table pointer is set to a memory address that is sufficiently aligned for one page, ensuring proper alignment for page table operations.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " Some address sufficiently aligned for one page "}
{"spec": "definition init_irq_node_ptr :: obj_ref where\n  \"init_irq_node_ptr = pptr_base + 0xc000\"", "property": "Initialization of IRQ Node Pointer: The IRQ node pointer is initialized to a memory address that is sufficiently aligned for the IRQ type and CTE level bits, ensuring proper alignment and access for interrupt handling.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " Sufficiently aligned for irq type + cte_level_bits "}
{"spec": "definition canonical_user :: \"vspace_ref\" where\n  \"canonical_user \\<equiv> mask ipa_size\"", "property": "Canonical User-Virtual Address: Defines the highest user-virtual address that is still considered canonical, which may exceed the maximum mappable user address. For AArch64-hyp, this value represents the top of the entire IPA address space, ensuring that all user-virtual addresses are within a valid and usable range.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " The highest user-virtual address that is still canonical.\n   It can be larger than user_vtop, which is the highest address we allow to be mapped.\n   For AArch64-hyp, user-virtual addresses are IPAs and since there is no sign extension,\n   the value is the top of the entire IPA address space. "}
{"spec": "definition init_vspace_uses :: \"vspace_ref \\<Rightarrow> arm_vspace_region_use\" where\n  \"init_vspace_uses p \\<equiv>\n     if p \\<in> {pptr_base ..< pptr_base + (1 << 30)} then ArmVSpaceKernelWindow\n     else ArmVSpaceInvalidRegion\"\n\n\ndefinition init_arch_state :: arch_state where\n  \"init_arch_state \\<equiv> \\<lparr>\n     arm_asid_table = Map.empty,\n     arm_kernel_vspace = init_vspace_uses,\n     arm_vmid_table = Map.empty,\n     arm_next_vmid = 0,\n     arm_us_global_vspace = arm_global_pt_ptr,\n     arm_current_vcpu = None,\n     arm_gicvcpu_numlistregs = undefined\n   \\<rparr>\"", "property": "Initialization of Virtual Space Regions: Define the initial state of the architecture, including an empty ASID table, a function to initialize virtual space regions based on their addresses, an empty VMID table, and other necessary components. The virtual space regions are categorized as either part of the kernel window or invalid, ensuring that the invariants for the kernel-level page table mappings are consistent.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " This is not the layout the real kernel uses, but we are only trying to show that\n   the invariants are consistent. These apply to the mappings of the (separate) kernel-level\n   page table in hyp mode, not the user-level page tables, which have no kernel mappings. "}
{"spec": "definition global_pt_obj :: arch_kernel_obj where\n  \"global_pt_obj \\<equiv> PageTable (VSRootPT (\\<lambda>_. InvalidPTE))\"\n\ndefinition init_kheap :: kheap where\n  \"init_kheap \\<equiv>\n    (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n           then Some (CNode 0 (empty_cnode 0))\n           else None)\n    (idle_thread_ptr \\<mapsto>\n       TCB \\<lparr>\n         tcb_ctable = NullCap,\n         tcb_vtable = NullCap,\n         tcb_reply = NullCap,\n         tcb_caller = NullCap,\n         tcb_ipcframe = NullCap,\n         tcb_state = IdleThreadState,\n         tcb_fault_handler = replicate word_bits False,\n         tcb_ipc_buffer = 0,\n         tcb_fault = None,\n         tcb_bound_notification = None,\n         tcb_mcpriority = minBound,\n         tcb_arch = init_arch_tcb\n         \\<rparr>,\n     arm_global_pt_ptr \\<mapsto> ArchObj global_pt_obj\n    )\"\n\ndefinition init_cdt :: cdt where\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition init_ioc :: \"cslot_ptr \\<Rightarrow> bool\" where\n  \"init_ioc \\<equiv>\n     \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                    (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition init_A_st :: \"'z::state_ext state\"\n  where\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n \nend\nend", "property": "Initialization of Kernel State: The kernel state is initialized with an empty global page table, an idle thread in the idle state, and an interrupt controller with initial mappings. The kernel heap is set up with specific capabilities for the idle thread and a global page table object, while the capability derivation tree and original capabilities are initially empty.", "title": "./spec/abstract/AARCH64/Init_A.thy", "chapter": "", "section": "", "comment": " The user-level global table in hyp mode is entirely empty.\n   Kernel-level mappings are in a separate kernel page table, which is not modeled here. "}
{"spec": "definition lookup_ipc_buffer :: \"bool \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\" where\n  \"lookup_ipc_buffer is_receiver thread \\<equiv> do\n     buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n     buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n     buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n     case buffer_cap of\n       ArchObjectCap (FrameCap p R vms False _) \\<Rightarrow>\n         if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n         then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n         else return None\n     | _ \\<Rightarrow> return None\n   od\"\n\ndefinition pool_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> obj_ref option\" where\n  \"pool_for_asid asid \\<equiv> \\<lambda>s. asid_table s (asid_high_bits_of asid)\"\n\ndefinition entry_for_pool :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (obj_ref \\<rightharpoonup> asid_pool) \\<Rightarrow> asid_pool_entry option\"\n  where\n  \"entry_for_pool pool_ptr asid \\<equiv> do {\n     pool \\<leftarrow> oapply pool_ptr;\n     K $ pool (asid_low_bits_of asid)\n   }\"\n\ndefinition vspace_for_pool :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (obj_ref \\<rightharpoonup> asid_pool) \\<Rightarrow> obj_ref option\" where\n  \"vspace_for_pool pool_ptr asid \\<equiv> do {\n     entry \\<leftarrow> entry_for_pool pool_ptr asid;\n     oreturn $ ap_vspace entry\n   }\"", "property": "Lookup IPC Buffer Authority: Verify that a thread has the necessary authority to read from or write to its IPC buffer. The function checks the buffer's capabilities and ensures that the thread's access rights are appropriate for the operation, either reading or writing, based on whether the thread is a receiver or not.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up a thread's IPC buffer and check that the thread has the authority to read or (in the\n  receiver case) write to it."}
{"spec": "definition entry_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> asid_pool_entry option\" where\n  \"entry_for_asid asid = do {\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     entry_for_pool pool_ptr asid \\<circ> asid_pools_of\n   }\"", "property": "ASID Mapping: Retrieve the ASID pool entry corresponding to a given ASID. This involves finding the appropriate pool for the ASID and then locating the specific entry within that pool.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": " this is what asid_map encodes in ARM/ARM_HYP; getASIDPoolEntry in Haskell "}
{"spec": "definition update_asid_pool_entry ::\n  \"(asid_pool_entry \\<rightharpoonup> asid_pool_entry) \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\" where\n  \"update_asid_pool_entry f asid \\<equiv> do\n     pool_ptr \\<leftarrow> gets_the $ pool_for_asid asid;\n     pool \\<leftarrow> get_asid_pool pool_ptr;\n     idx \\<leftarrow> return $ asid_low_bits_of asid;\n     entry \\<leftarrow> assert_opt $ pool idx;\n     set_asid_pool pool_ptr (pool (idx := f entry))\n   od\"\n\ndefinition vspace_for_asid :: \"asid \\<Rightarrow> 'z::state_ext state \\<Rightarrow> obj_ref option\" where\n  \"vspace_for_asid asid = do {\n     oassert (0 < asid);\n     entry \\<leftarrow> entry_for_asid asid;\n     oreturn $ ap_vspace entry\n   }\"", "property": "Update ASID Pool Entry: Modify an entry in the ASID pool by applying a function to the current entry and updating the pool with the new value. This ensures that the ASID map is correctly updated, reflecting changes in the virtual address space.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": " update an entry in the asid map "}
{"spec": "definition find_vspace_for_asid :: \"asid \\<Rightarrow> (obj_ref,'z::state_ext) lf_monad\" where\n  \"find_vspace_for_asid asid \\<equiv> doE\n     vspace_opt \\<leftarrow> liftE $ gets $ vspace_for_asid asid;\n     throw_opt InvalidRoot vspace_opt\n   odE\"\n\ndefinition load_vmid :: \"asid \\<Rightarrow> (vmid option, 'z::state_ext) s_monad\" where\n  \"load_vmid asid \\<equiv> do\n     entry \\<leftarrow> gets_the $ entry_for_asid asid;\n     return $ ap_vmid entry\n   od\"", "property": "Locate VSpace for ASID: Find the top-level page table associated with a given virtual ASID, ensuring that the ASID is valid and returning an error if it is not. Load VMID: Retrieve the VMID associated with a given ASID by accessing the corresponding entry in the system state.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the top-level page table associated with a given virtual ASID."}
{"spec": "definition store_vmid :: \"asid \\<Rightarrow> vmid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_vmid asid hw_asid \\<equiv> do\n     update_asid_pool_entry (\\<lambda>entry. Some $ ASIDPoolVSpace (Some hw_asid) (ap_vspace entry)) asid;\n     vmid_table \\<leftarrow> gets (arm_vmid_table \\<circ> arch_state);\n     vmid_table' \\<leftarrow> return $ vmid_table (hw_asid \\<mapsto> asid);\n     modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_vmid_table := vmid_table' \\<rparr>\\<rparr>)\n   od\"", "property": "Associate VMID with ASID: Store a VMID in the ASID pool and update the VMID table to map the VMID to the ASID, ensuring that the association is maintained in the system.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associate a VMID with an ASID."}
{"spec": "definition invalidate_tlb_by_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_tlb_by_asid asid \\<equiv> do\n     maybe_vmid \\<leftarrow> load_vmid asid;\n     case maybe_vmid of\n       None \\<Rightarrow> return ()\n     | Some vmid \\<Rightarrow> do_machine_op $ invalidateTranslationASID (ucast vmid)\n   od\"", "property": "Invalidate TLB by ASID: Clear all TLB mappings associated with a given ASID. If the ASID is associated with a VMID, perform a machine operation to invalidate the translation for that VMID.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Clear all TLB mappings associated with this ASID."}
{"spec": "definition invalidate_tlb_by_asid_va :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_tlb_by_asid_va asid vaddr \\<equiv> do\n     maybe_vmid \\<leftarrow> load_vmid asid;\n     case maybe_vmid of\n       None \\<Rightarrow> return ()\n     | Some vmid \\<Rightarrow>\n         do_machine_op $\n           invalidateTranslationSingle $ (ucast vmid << word_bits-asid_bits) || (vaddr >> pageBits)\n   od\"", "property": "Invalidate TLB by ASID and VA: Clear all TLB mappings associated with the given ASID and virtual address. If a valid VMID is found for the ASID, it performs the TLB invalidation using the combined VMID and virtual address.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Clear all TLB mappings associated with this ASID and virtual address."}
{"spec": "definition invalidate_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_asid asid \\<equiv>\n     update_asid_pool_entry (\\<lambda>entry. Some $ ASIDPoolVSpace None (ap_vspace entry)) asid\"", "property": "Invalidate ASID: Removes the mapping from a given virtual ASID to its associated VMID, ensuring that the ASID is no longer linked to any virtual memory space.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this virtual ASID to a VMID."}
{"spec": "definition invalidate_vmid_entry :: \"vmid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_vmid_entry vmid \\<equiv> do\n     vmid_table \\<leftarrow> gets (arm_vmid_table \\<circ> arch_state);\n     vmid_table' \\<leftarrow> return (vmid_table (vmid := None));\n     modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_vmid_table := vmid_table' \\<rparr>\\<rparr>)\n  od\"", "property": "Invalidate VMID Entry: Remove the mapping from a specified VMID to its associated ASID in the VMID table, ensuring that the VMID is no longer linked to any ASID.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this VMID to an ASID."}
{"spec": "definition invalidate_asid_entry :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"invalidate_asid_entry asid \\<equiv> do\n     maybe_vmid \\<leftarrow> load_vmid asid;\n     when (maybe_vmid \\<noteq> None) $ invalidate_vmid_entry (the maybe_vmid);\n     invalidate_asid asid\n  od\"", "property": "Invalidate ASID Entry: Remove mappings associated with the specified ASID, including invalidating the corresponding VMID entry if it exists.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove mappings in either direction involving this ASID."}
{"spec": "definition find_free_vmid :: \"(vmid,'z::state_ext) s_monad\" where\n  \"find_free_vmid \\<equiv> do\n     vmid_table \\<leftarrow> gets (arm_vmid_table \\<circ> arch_state);\n     next_vmid \\<leftarrow> gets (arm_next_vmid \\<circ> arch_state);\n     maybe_vmid \\<leftarrow> return $ find (\\<lambda>a. vmid_table a = None)\n                                 (take (length [minBound :: vmid .e. maxBound])\n                                       ([next_vmid .e. maxBound] @ [minBound .e. next_vmid]));\n     case maybe_vmid of\n       Some vmid \\<Rightarrow> return vmid\n     | None \\<Rightarrow> do\n         invalidate_asid $ the $ vmid_table next_vmid;\n         do_machine_op $ invalidateTranslationASID (ucast next_vmid);\n         invalidate_vmid_entry next_vmid;\n         modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_next_vmid := next_vmid + 1 \\<rparr>\\<rparr>);\n         return next_vmid\n       od\n   od\"", "property": "Find Free VMID: Locate an unused VMID, either by finding an available one in the VMID table or, if none are available, by reclaiming and invalidating the VMID currently assigned to the next ASID.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate a VMID that is not in use, if necessary by reclaiming one already assigned to an ASID."}
{"spec": "definition get_vmid :: \"asid \\<Rightarrow> (vmid, 'z::state_ext) s_monad\" where\n  \"get_vmid asid \\<equiv> do\n     maybe_vmid \\<leftarrow> load_vmid asid;\n     case maybe_vmid of\n       Some vmid \\<Rightarrow> return vmid\n     | None \\<Rightarrow>  do\n         new_hw_asid \\<leftarrow> find_free_vmid;\n         store_vmid asid new_hw_asid;\n         return new_hw_asid\n       od\n   od\"", "property": "VMID Retrieval and Assignment: Retrieve the VMID associated with an ASID, and if no VMID is assigned, allocate a new one and associate it with the ASID.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get the VMID associated with an ASID, assigning one if none is already assigned."}
{"spec": "definition handle_vm_fault :: \"obj_ref \\<Rightarrow> vmfault_type \\<Rightarrow> (unit, 'z::state_ext) f_monad\" where\n  \"handle_vm_fault thread fault \\<equiv> case fault of\n     ARMDataAbort \\<Rightarrow> doE\n       addr \\<leftarrow> liftE $ do_machine_op getFAR;\n       fault \\<leftarrow> liftE $ do_machine_op getESR;\n       cur_v \\<leftarrow> liftE $ gets (arm_current_vcpu \\<circ> arch_state);\n       addr \\<leftarrow> if (\\<exists>v. cur_v = Some (v, True)) \\<comment> \\<open>VCPU active\\<close>\n              then doE\n                  \\<comment> \\<open>address bits of PAR register after S1 translation\\<close>\n                  par_el1_mask \\<leftarrow> returnOk $ 0xfffffffff000;\n                  addr' \\<leftarrow> liftE $ do_machine_op $ addressTranslateS1 addr;\n                  returnOk $ (addr' && par_el1_mask) || (addr && mask pageBits)\n                odE\n              else returnOk addr;\n       \\<comment> \\<open>32 is the width of the FSR field in the C VMFault structure\\<close>\n       throwError $ ArchFault $ VMFault addr [0, fault && mask 32]\n     odE\n   | ARMPrefetchAbort \\<Rightarrow> doE\n       pc \\<leftarrow> liftE $ as_user thread $ getRestartPC;\n       fault \\<leftarrow> liftE $ do_machine_op getESR;\n       cur_v \\<leftarrow> liftE $ gets (arm_current_vcpu \\<circ> arch_state);\n       pc \\<leftarrow> if (\\<exists>v. cur_v = Some (v, True)) \\<comment> \\<open>VCPU active\\<close>\n            then doE\n                \\<comment> \\<open>address bits of PAR register after S1 translation\\<close>\n                par_el1_mask \\<leftarrow> returnOk $ 0xfffffffff000;\n                pc' \\<leftarrow> liftE $ do_machine_op $ addressTranslateS1 pc;\n                returnOk $ (pc' && par_el1_mask) || (pc && mask pageBits)\n              odE\n            else returnOk pc;\n       \\<comment> \\<open>32 is the width of the FSR field in the C VMFault structure\\<close>\n       throwError $ ArchFault $ VMFault pc [1, fault && mask 32]\n     odE\"", "property": "Handle VM Fault: Format and propagate a VM fault message to the thread's supervisor after encountering a page fault. The fault message includes the fault address and type, with address translation if a VCPU is active.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Format a VM fault message to be passed to a thread's supervisor after it encounters a page fault."}
{"spec": "definition arm_context_switch :: \"obj_ref \\<Rightarrow> asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arm_context_switch vspace asid = do\n     vmid <- get_vmid asid;\n     do_machine_op $ setVSpaceRoot (addrFromPPtr vspace) (ucast vmid)\n   od\"", "property": "Switch Address Space: Switch the current address space to the one associated with the provided ASID, using the corresponding VMID. This ensures that the virtual memory context is correctly updated for the specified address space.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch to given address space, using VMID associated with provided ASID."}
{"spec": "definition set_global_user_vspace :: \"(unit,'z::state_ext) s_monad\" where\n  \"set_global_user_vspace = do\n     global <- gets (arm_us_global_vspace \\<circ> arch_state);\n     do_machine_op $ setVSpaceRoot (addrFromKPPtr global) 0\n   od\"", "property": "Set Global User VSpace: Switch the system to use the global user address space by setting the virtual space root to the global user virtual space with VMID 0.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch to global user address space, using VMID 0."}
{"spec": "definition set_vm_root :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_vm_root tcb \\<equiv> do\n     thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n     thread_root \\<leftarrow> get_cap thread_root_slot;\n     (case thread_root of\n        ArchObjectCap (PageTableCap pt VSRootPT_T (Some (asid, _))) \\<Rightarrow> doE\n          pt' \\<leftarrow> find_vspace_for_asid asid;\n          whenE (pt \\<noteq> pt') $ throwError InvalidRoot;\n          liftE $ arm_context_switch pt asid\n        odE\n      | _ \\<Rightarrow> throwError InvalidRoot) <catch> (\\<lambda>_. set_global_user_vspace)\n  od\"\n\n\ndefinition delete_asid_pool :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"delete_asid_pool base ptr \\<equiv> do\n     assert (asid_low_bits_of base = 0);\n     asid_table \\<leftarrow> gets asid_table;\n     when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n       pool \\<leftarrow> get_asid_pool ptr;\n       mapM (\\<lambda>offset. when (pool (ucast offset) \\<noteq> None) $ do\n                            invalidate_tlb_by_asid $ base + offset;\n                            invalidate_asid_entry $ base + offset\n                      od) [0  .e.  mask asid_low_bits];\n       asid_table' \\<leftarrow> return $ asid_table (asid_high_bits_of base:= None);\n       modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_table := asid_table' \\<rparr>\\<rparr>);\n       tcb \\<leftarrow> gets cur_thread;\n       set_vm_root tcb\n     od\n   od\"\n\n\ndefinition delete_asid :: \"asid \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"delete_asid asid pt \\<equiv> do\n     pool_ptr_op \\<leftarrow> gets (pool_for_asid asid);\n     case pool_ptr_op of\n       None \\<Rightarrow> return ()\n     | Some pool_ptr \\<Rightarrow> do\n         pool \\<leftarrow> get_asid_pool pool_ptr;\n         when (\\<exists>vmid. pool (asid_low_bits_of asid) = Some (ASIDPoolVSpace vmid pt)) $ do\n           invalidate_tlb_by_asid asid;\n           invalidate_asid_entry asid;\n           \\<comment> \\<open>re-read here, because @{text invalidate_asid_entry} changes the ASID pool:\\<close>\n           pool \\<leftarrow> get_asid_pool pool_ptr;\n           pool' \\<leftarrow> return $ pool (asid_low_bits_of asid := None);\n           set_asid_pool pool_ptr pool';\n           tcb \\<leftarrow> gets cur_thread;\n           set_vm_root tcb\n         od\n       od\n   od\"\n\n\ndefinition unmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"unmap_page_table asid vaddr pt \\<equiv> doE\n     top_level_pt \\<leftarrow> find_vspace_for_asid asid;\n     (pt_slot, level) \\<leftarrow> pt_lookup_from_level max_pt_level top_level_pt vaddr pt;\n     liftE $ store_pte (level_type level) pt_slot InvalidPTE;\n     liftE $ do_machine_op $ cleanByVA_PoU pt_slot (addrFromPPtr pt_slot);\n     liftE $ invalidate_tlb_by_asid asid\n   odE <catch> (K $ return ())\"", "property": "Address Space Management: Switch the current address space to that of a specified thread or to the global address space if the thread's configuration is invalid. Ensure that the page table and ASID are correctly validated and updated, and handle invalid configurations by setting the global user address space.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Switch into the address space of a given thread or the global address space if none is correctly\n  configured."}
{"spec": "definition vs_lookup_table ::\n  \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\" where\n  \"vs_lookup_table bot_level asid vptr \\<equiv> do {\n     pool_ptr \\<leftarrow> pool_for_asid asid;\n     if bot_level = asid_pool_level\n     then oreturn (asid_pool_level, pool_ptr)\n     else do {\n       top_level_pt \\<leftarrow> vspace_for_pool pool_ptr asid \\<circ> asid_pools_of;\n       pt_walk max_pt_level bot_level top_level_pt vptr \\<circ> ptes_of\n     }\n   }\"", "property": "Virtual Memory Lookup: Perform a lookup in the page table for a given ASID and virtual space reference down to a specified level, returning the level and corresponding object reference. If the lookup reaches the bottom level or encounters a page or invalid entry, it terminates early.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Look up an @{text \"asid+vspace_ref\"} down to the provided level in the page table.\n  For level @{term bot_level}, return a pointer to a table at the returned level.\n  The level can be higher than @{term bot_level} if the lookup terminates early because\n  it hit a page or an invalid entry."}
{"spec": "definition vs_lookup_slot ::\n  \"vm_level \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> (vm_level \\<times> obj_ref) option\" where\n  \"vs_lookup_slot bot_level asid vref \\<equiv> do {\n     (level', table) \\<leftarrow> vs_lookup_table bot_level asid vref;\n     if level' = asid_pool_level then\n       oreturn (level', table)\n     else\n       oreturn (level', pt_slot_offset level' table vref)\n   }\"", "property": "VSpace Lookup Slot: Retrieve a pointer to a slot in the virtual space table at the specified level. If the lookup reaches the ASID pool level, return the pointer to the ASID pool itself, otherwise, return the pointer to the specific slot within the table.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Same as @{const vs_lookup_table}, but return a pointer to a slot in a table at the returned level.\n  For @{prop \"bot_level = asid_pool_level\"}, still return the pointer to the ASID pool (not a slot\n  inside it, since there are no slot functions for ASID pools)."}
{"spec": "definition unmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"unmap_page pgsz asid vptr pptr \\<equiv> doE\n     top_level_pt \\<leftarrow> find_vspace_for_asid asid;\n     (lev, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot top_level_pt vptr \\<circ> ptes_of;\n     unlessE (pt_bits_left lev = pageBitsForSize pgsz) $ throwError InvalidRoot;\n     pte \\<leftarrow> liftE $ get_pte lev slot;\n     unlessE (is_PagePTE pte \\<and> pptr_from_pte pte = pptr) $ throwError InvalidRoot;\n     liftE $ store_pte lev slot InvalidPTE;\n     liftE $ do_machine_op $ cleanByVA_PoU slot (addrFromPPtr slot);\n     liftE $ invalidate_tlb_by_asid_va asid vptr\n   odE <catch> (K $ return ())\"", "property": "Unmap Page: Unmaps a page from the virtual address space if the given mapping details are still current. This involves finding the top-level page table, locating the correct slot, validating the page table entry, and then invalidating the page table entry and cleaning the cache.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\" where\n  \"arch_derive_cap c \\<equiv>\n     case c of\n       PageTableCap _ _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n     | PageTableCap _ _ None \\<Rightarrow> throwError IllegalOperation\n     | FrameCap r R sz dev mp \\<Rightarrow> returnOk $ ArchObjectCap (FrameCap r R sz dev None)\n     | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n     | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\n     | VCPUCap _ \\<Rightarrow> returnOk (ArchObjectCap c)\"", "property": "Arch Derive Capabilities: Ensures that page table capabilities are only derived if they have an ASID and location assigned, preventing them from having multiple current ASIDs or being shared between address spaces. Other architecture-specific capabilities are derived without additional checks.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Page table structure capabilities cannot be copied until they have an ASID and location\n  assigned. This is because they cannot have multiple current ASIDs and cannot be shared between\n  address spaces or virtual locations."}
{"spec": "definition arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\" where\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "Arch Update Cap Data: Ensures that no user-modifiable data is stored in AARCH64-specific capabilities, maintaining the integrity and security of the system.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in AARCH64-specific capabilities."}
{"spec": "definition arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\" where\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n     (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n       delete_asid_pool b ptr;\n       return (NullCap, NullCap)\n     od\n   | (PageTableCap ptr VSRootPT_T (Some (a, v)), True) \\<Rightarrow> do\n       delete_asid a ptr;\n       return (NullCap, NullCap)\n     od\n   | (PageTableCap ptr NormalPT_T (Some (a, v)), True) \\<Rightarrow> do\n       unmap_page_table a v ptr;\n       return (NullCap, NullCap)\n     od\n   | (FrameCap ptr _ sz _ (Some (a, v)), _) \\<Rightarrow> do\n       unmap_page sz a v ptr;\n       return (NullCap, NullCap)\n     od\n   | (VCPUCap vcpu_ref, True) \\<Rightarrow> do\n      vcpu_finalise vcpu_ref;\n      return (NullCap, NullCap)\n     od\n   | _ \\<Rightarrow> return (NullCap, NullCap)\"", "property": "Finalize AARCH64-Specific Capabilities: Perform specific actions to finalize AARCH64-specific capabilities, such as deleting ASID pools, unmapping page tables, and finalizing VCPUs. Upon finalization, the capabilities are converted to NullCap.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of AARCH64-specific capabilities."}
{"spec": "definition is_valid_vtable_root :: \"cap \\<Rightarrow> bool\" where\n  \"is_valid_vtable_root c \\<equiv>\n     case c of ArchObjectCap (PageTableCap _ VSRootPT_T (Some _)) \\<Rightarrow> True | _ \\<Rightarrow> False\"", "property": "Virtual Address Space Validity: A virtual address space capability is valid if and only if it points to a mapped page table, ensuring the integrity and correctness of the virtual memory management on the AARCH64 architecture.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A thread's virtual address space capability must be to a mapped page table to be valid on\n  the AARCH64 architecture."}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\ndefinition check_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"check_valid_ipc_buffer vptr c \\<equiv>\n     case c of\n       ArchObjectCap (FrameCap _ _ _ False _) \\<Rightarrow>\n         whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError\n     | _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Check Valid IPC Buffer: Validate the alignment of the virtual pointer for an IPC buffer. If the virtual pointer is not aligned according to the specified `msg_align_bits`, an `AlignmentError` is thrown. For any other type of capability, an `IllegalOperation` error is thrown.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "definition in_user_frame :: \"obj_ref \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n  \"in_user_frame p s \\<equiv>\n     \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) = Some (ArchObj (DataPage False sz))\"\n\ndefinition fpu_thread_delete :: \"obj_ref \\<Rightarrow> (unit, 'z::state_ext) s_monad\" where\n  \"fpu_thread_delete thread_ptr \\<equiv> do_machine_op (fpuThreadDeleteOp thread_ptr)\"\n\ndefinition prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"prepare_thread_delete thread_ptr \\<equiv> do\n     fpu_thread_delete thread_ptr;\n     t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu thread_ptr;\n     case t_vcpu of\n       Some v \\<Rightarrow> dissociate_vcpu_tcb v thread_ptr\n     | None \\<Rightarrow> return ()\n   od\"\n\nend\nend", "property": "Pointer in User Frame: A pointer is considered to be inside a user frame if its top bits correspond to a DataPage in the kernel heap. \n\nThread Deletion Preparation: Prepares a thread for deletion by removing its FPU state and dissociating its VCPU, if present, ensuring that all associated resources are properly cleaned up.", "title": "./spec/abstract/AARCH64/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A pointer is inside a user frame if its top bits point to a @{const DataPage}."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition asid_high_bits_of :: \"asid \\<Rightarrow> asid_high_index\" where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"", "property": "Extract High ASID Bits: Extract the high bits of a virtual ASID to form an ASID high index, which is used for accessing the kernel heap.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "definition asid_low_bits_of :: \"asid \\<Rightarrow> asid_low_index\" where\n  \"asid_low_bits_of asid \\<equiv> ucast asid\"\n\nlemmas asid_bits_of_defs = asid_high_bits_of_def asid_low_bits_of_def\n\nlocale_abbrev asid_table :: \"'z::state_ext state \\<Rightarrow> asid_high_index \\<rightharpoonup> obj_ref\" where\n  \"asid_table \\<equiv> \\<lambda>s. arm_asid_table (arch_state s)\"", "property": "ASID Low Bits Extraction: Extract the low bits of a given ASID and convert them to an ASID low index.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The low bits of a virtual ASID."}
{"spec": "(* declared in Arch as workaround for VER-1099 *)\nlocale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\" where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"", "property": "Accessing AARCH64 VSpace: Provides a mechanism to access and manipulate the architecture-specific kernel objects (aobjs) in the kernel heap, enabling the management and interaction with the virtual space.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev asid_pools_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> asid_pool\" where\n  \"asid_pools_of \\<equiv> \\<lambda>s. aobjs_of s |> asid_pool_of\"\n\nlocale_abbrev get_asid_pool :: \"obj_ref \\<Rightarrow> (asid_pool, 'z::state_ext) s_monad\" where\n  \"get_asid_pool \\<equiv> gets_map asid_pools_of\"\n\ndefinition set_asid_pool :: \"obj_ref \\<Rightarrow> asid_pool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_asid_pool ptr pool \\<equiv> do\n     get_asid_pool ptr;\n     set_object ptr (ArchObj (ASIDPool pool))\n   od\"\n\nlocale_abbrev pts_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> pt\" where\n  \"pts_of \\<equiv> \\<lambda>s. aobjs_of s |> pt_of\"\n\nlocale_abbrev get_pt :: \"obj_ref \\<Rightarrow> (pt,'z::state_ext) s_monad\" where\n  \"get_pt \\<equiv> gets_map pts_of\"\n\ndefinition set_pt :: \"obj_ref \\<Rightarrow> pt \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pt ptr pt \\<equiv> do\n     get_pt ptr;\n     set_object ptr (ArchObj (PageTable pt))\n   od\"", "property": "VSpace Management: Manipulate ASID pools and page tables in the kernel heap, allowing for the retrieval and updating of ASID pools and page tables to maintain the virtual memory structure.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "Manipulate ASID pools, page directories and page tables in the kernel heap."}
{"spec": "locale_abbrev table_base :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref\" where\n  \"table_base pt_t p \\<equiv> p && ~~mask (pt_bits pt_t)\"", "property": "Table Base Calculation: Compute the base address of the table that a page table entry at a given address belongs to, assuming proper alignment. This ensures that the correct table is accessed for further operations in the virtual address space.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The base address of the table a page table entry at p is in (assuming alignment)"}
{"spec": "locale_abbrev table_index :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> machine_word\" where\n  \"table_index pt_t p \\<equiv> p && mask (pt_bits pt_t) >> pte_bits\"", "property": "Table Index Calculation: Compute the index within a page table that a given page table entry addresses, based on the provided address and the specified table type. This ensures accurate mapping and access to the relevant entries in the AARCH64 VSpace.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The index within the page table that a page table entry at p addresses. We return a\n  @{typ machine_word}, which is the slice of the provided address that represents the index in the\n  table of the specified table type."}
{"spec": "definition pt_apply :: \"pt \\<Rightarrow> machine_word \\<Rightarrow> pte\" where\n  \"pt_apply pt idx \\<equiv> case pt of NormalPT npt \\<Rightarrow> npt (ucast idx) | VSRootPT vs \\<Rightarrow> vs (ucast idx)\"", "property": "Apply Page Table: Access a specific entry in a page table using an index. The index is applied to either a normal page table or a virtual space root page table, with higher-order bits of the index being ignored.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "Use an index computed by @{const table_index} and apply it to a page table. Bits higher than\n  the table index width will be ignored."}
{"spec": "definition level_pte_of :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref \\<rightharpoonup> pt) \\<rightharpoonup> pte\" where\n  \"level_pte_of pt_t p \\<equiv> do {\n      oassert (is_aligned p pte_bits);\n      pt \\<leftarrow> oapply (table_base pt_t p);\n      oassert (pt_type pt = pt_t);\n      oreturn $ pt_apply pt (table_index pt_t p)\n   }\"\n\ntype_synonym ptes_of = \"pt_type \\<Rightarrow> obj_ref \\<rightharpoonup> pte\"\n\nlocale_abbrev ptes_of :: \"'z::state_ext state \\<Rightarrow> ptes_of\" where\n  \"ptes_of s pt_t p \\<equiv> level_pte_of pt_t p (pts_of s)\"\n\nlemmas ptes_of_def = level_pte_of_def", "property": "Extract Page Table Entry: Retrieve a specific PTE from the page table at a given level, ensuring that the provided address is properly aligned and the page table type matches.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "Extract a PTE from the page table of a specific level"}
{"spec": "locale_abbrev get_pte :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\" where\n  \"get_pte pt_t \\<equiv> gets_map (swp ptes_of pt_t)\"", "property": "Retrieve Page Table Entry: Given a pointer to a PTE in kernel memory, the function retrieves and returns the corresponding page table entry.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory and returns the PTE."}
{"spec": "definition pt_upd :: \"pt \\<Rightarrow> machine_word \\<Rightarrow> pte \\<Rightarrow> pt\" where\n  \"pt_upd pt idx pte \\<equiv> case pt of\n                         VSRootPT vs \\<Rightarrow> VSRootPT (vs(ucast idx := pte))\n                       | NormalPT pt \\<Rightarrow> NormalPT (pt(ucast idx := pte))\"\n\ndefinition store_pte :: \"pt_type \\<Rightarrow> obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pte pt_t p pte \\<equiv> do\n     assert (is_aligned p pte_bits);\n     base \\<leftarrow> return $ table_base pt_t p;\n     pt \\<leftarrow> get_pt base;\n     assert (pt_type pt = pt_t);\n     set_pt base (pt_upd pt (table_index pt_t p) pte)\n   od\"", "property": "Update Page Table Entries: Modify the page table entries in the virtual space by updating the specified index with a new page table entry. This ensures that the page table is correctly updated, maintaining the integrity of the virtual address space.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Kernel Heap Accessors", "comment": "The update function that corresponds to @{const pt_apply}. Also expects an index computed\n  with @{const table_index} for the correct page table type."}
{"spec": "(* During pt_walk, we will only call this with level \\<le> max_pt_level, but in the invariants we\n   also make use of this function for level = asid_pool_level. *)\ndefinition pt_bits_left :: \"vm_level \\<Rightarrow> nat\" where\n  \"pt_bits_left level =\n    (if level = asid_pool_level\n     then ptTranslationBits VSRootPT_T + ptTranslationBits NormalPT_T * size max_pt_level\n     else ptTranslationBits NormalPT_T * size level)\n    + pageBits\"\n\ndefinition pt_index :: \"vm_level \\<Rightarrow> vspace_ref \\<Rightarrow> machine_word\" where\n  \"pt_index level vptr \\<equiv>\n     (vptr >> pt_bits_left level) && mask (ptTranslationBits level)\"\n\n\nlocale_abbrev global_pt :: \"'z state \\<Rightarrow> obj_ref\" where\n  \"global_pt s \\<equiv> arm_us_global_vspace (arch_state s)\"", "property": "Page Table Index Calculation: Computes the index for a given virtual space reference at a specific page table level, using bitwise operations to extract the relevant bits based on the level and the virtual space reference.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition pptr_from_pte :: \"pte \\<Rightarrow> vspace_ref\" where\n  \"pptr_from_pte pte \\<equiv> ptrFromPAddr (pte_base_addr pte)\"\n\ndefinition pt_slot_offset :: \"vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref\" where\n  \"pt_slot_offset level pt_ptr vptr = pt_ptr + (pt_index level vptr << pte_bits)\"", "property": "VSpace Access: Convert a page table entry (PTE) to a physical pointer and calculate the offset of a specific slot in a page table based on the virtual address, allowing for precise manipulation and access within the AARCH64 virtual address space.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "fun pt_walk ::\n  \"vm_level \\<Rightarrow> vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> ptes_of \\<Rightarrow> (vm_level \\<times> obj_ref) option\"\n  where\n  \"pt_walk level bot_level pt_ptr vptr = do {\n     if bot_level < level\n     then do {\n       pte \\<leftarrow> oapply2 (level_type level) (pt_slot_offset level pt_ptr vptr);\n       if is_PageTablePTE pte\n         then pt_walk (level - 1) bot_level (pptr_from_pte pte) vptr\n         else oreturn (level, pt_ptr)\n     }\n     else oreturn (level, pt_ptr)\n   }\"\n\ndeclare pt_walk.simps[simp del]", "property": "Page Table Walk: Recursively traverses the page table structure from a specified level down to a base level or until a page is reached, returning the level and pointer of the final page table.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": "\n  This is the base function for walking a page table structure.\n  The walk proceeds from higher-level tables at the provided @{term level} (e.g. 2) to lower\n  level tables, down to @{term bot_level} (e.g. 0). It returns a pointer to the page table where\n  the walk stopped and the level of that table. The lookup stops when @{term bot_level} or a\n  page is reached.\n"}
{"spec": "definition pt_lookup_slot_from_level ::\n  \"vm_level \\<Rightarrow> vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> ptes_of \\<Rightarrow> (vm_level \\<times> obj_ref) option\" where\n  \"pt_lookup_slot_from_level level bot_level pt_ptr vptr = do {\n     (level', pt_ptr') \\<leftarrow> pt_walk level bot_level pt_ptr vptr;\n     oreturn (level', pt_slot_offset level' pt_ptr' vptr)\n   }\"\n\ndefinition pt_lookup_slot :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> ptes_of \\<Rightarrow> (vm_level \\<times> obj_ref) option\" where\n  \"pt_lookup_slot = pt_lookup_slot_from_level max_pt_level 0\"", "property": "Page Table Slot Lookup: Retrieve a slot in the page table structure, returning the level and an object pointer to the slot. The slot is located at the returned level, and its type depends on the level, being either an InvalidPTE, PagePTE, or PageTablePTE.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": "\n  Looking up a slot in a page table structure. The function returns a level and an object\n  pointer. The pointer is to a slot in a table at the returned level. If the returned level is 0,\n  this slot is either an @{const InvalidPTE} or a @{const PagePTE}. If the returned level is higher\n  the slot may also be a @{const PageTablePTE}.\n"}
{"spec": "fun pt_lookup_from_level ::\n  \"vm_level \\<Rightarrow> obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (machine_word \\<times> vm_level, 'z::state_ext) lf_monad\"\n  where\n  \"pt_lookup_from_level level pt_ptr vptr target_pt_ptr s = (doE\n     unlessE (0 < level) $ throwError InvalidRoot;\n     slot <- returnOk $ pt_slot_offset level pt_ptr vptr;\n     pte <- liftE $ gets_the $ oapply slot o swp ptes_of level;\n     unlessE (is_PageTablePTE pte) $ throwError InvalidRoot;\n     ptr <- returnOk (pptr_from_pte pte);\n     if ptr = target_pt_ptr\n       then returnOk (slot, level)\n       else pt_lookup_from_level (level - 1) ptr vptr target_pt_ptr\n   odE) s\"", "property": "Page Table Lookup: Recursively searches the page table hierarchy starting from a specified level, using the provided virtual address to find the slot that points to the target page table pointer. Ensures that the search is valid by checking the level and verifying that each PTE encountered is a valid page table entry.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": "Returns the slot that points to @{text target_pt_ptr}"}
{"spec": "declare pt_lookup_from_level.simps[simp del]", "property": "VSpace Access: Perform basic operations on the AARCH64 VSpace, including managing the global free index counter to avoid type variable warnings.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": " We apply \"s\" to avoid a type variable warning, and increase in global freeindex counter,\n   which we would get without the application "}
{"spec": "schematic_goal pt_lookup_from_level_simps:\n  \"pt_lookup_from_level level pt_ptr vptr target_pt_ptr = ?rhs\"\n  by (rule ext, rule pt_lookup_from_level.simps)\n\nend\nend", "property": "Page Table Lookup from Level: Provides a simplified rule for looking up a page table entry at a specified level, given a page table pointer, virtual address, and target page table pointer.", "title": "./spec/abstract/AARCH64/ArchVSpaceAcc_A.thy", "chapter": "Accessing the AARCH64 VSpace", "section": "Basic Operations", "comment": " Recover simp rule without state applied: "}
{"spec": "definition check_vp_alignment :: \"vmpage_size \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) se_monad\"\n  where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $ throwError AlignmentError\"\n\ndefinition page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\" where\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"", "property": "Check Virtual Page Alignment: Ensure that the virtual page address is properly aligned for the given page size, throwing an alignment error if the condition is not met.", "title": "./spec/abstract/AARCH64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture-specific Decode Functions", "comment": ""}
{"spec": "definition arch_decode_irq_control_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list \\<Rightarrow> (arch_irq_control_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_irq_control_invocation label args src_slot cps \\<equiv>\n     (if invocation_type label = ArchInvocationLabel ARMIRQIssueIRQHandlerTrigger\n      then if length args \\<ge> 4 \\<and> length cps \\<ge> 1\n        then let irq_word = args ! 0;\n                 trigger = args ! 1;\n                 index = args ! 2;\n                 depth = args ! 3;\n                 cnode = cps ! 0;\n                 irq = ucast irq_word\n        in doE\n          arch_check_irq irq_word;\n          irq_active \\<leftarrow> liftE $ is_irq_active irq;\n          whenE irq_active $ throwError RevokeFirst;\n          dest_slot \\<leftarrow> lookup_target_slot cnode (data_to_cptr index) (unat depth);\n          ensure_empty dest_slot;\n          returnOk $ ARMIRQControlInvocation irq dest_slot src_slot (trigger \\<noteq> 0)\n        odE\n      else throwError TruncatedMessage\n    else throwError IllegalOperation)\"\n\ndefinition attribs_from_word :: \"machine_word \\<Rightarrow> vm_attributes\" where\n  \"attribs_from_word w \\<equiv> {attr.  \\<not>w!!0 \\<and> attr = Device \\<or> \\<not>w !! 2 \\<and> attr = Execute}\"\n\ndefinition make_user_pte :: \"paddr \\<Rightarrow> vm_attributes \\<Rightarrow> vm_rights \\<Rightarrow> vmpage_size \\<Rightarrow> pte\" where\n  \"make_user_pte addr attr rights vm_size \\<equiv>\n     PagePTE addr (vm_size = ARMSmallPage) (attr - {Global}) rights\"\n\ndefinition check_vspace_root :: \"cap \\<Rightarrow> nat \\<Rightarrow> (obj_ref \\<times> asid, 'z) se_monad\" where\n  \"check_vspace_root cap arg_no \\<equiv>\n     case cap of\n       ArchObjectCap (PageTableCap pt VSRootPT_T (Some (asid, _))) \\<Rightarrow> returnOk (pt, asid)\n     | _ \\<Rightarrow> throwError $ InvalidCapability arg_no\"\n\ntype_synonym 'z arch_decoder =\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    (arch_invocation,'z) se_monad\"\n\ndefinition decode_fr_inv_map :: \"'z::state_ext arch_decoder\" where\n  \"decode_fr_inv_map label args cte cap extra_caps \\<equiv> case cap of\n     FrameCap p R pgsz dev mapped_address \\<Rightarrow>\n       if length args > 2 \\<and> length extra_caps > 0\n       then let\n           vaddr = args ! 0;\n           rights_mask = args ! 1;\n           attr = args ! 2;\n           vspace_cap = fst (extra_caps ! 0)\n         in doE\n           (pt, asid) \\<leftarrow> check_vspace_root vspace_cap 1;\n           pt' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n           whenE (pt' \\<noteq> pt) $ throwError $ InvalidCapability 1;\n           check_vp_alignment pgsz vaddr;\n           pg_bits \\<leftarrow> returnOk $ pageBitsForSize pgsz;\n           case mapped_address of\n             Some (asid', vaddr') \\<Rightarrow> doE\n               whenE (asid' \\<noteq> asid) $ throwError $ InvalidCapability 1;\n               whenE (vaddr' \\<noteq> vaddr) $ throwError $ InvalidArgument 0\n             odE\n           | None \\<Rightarrow> doE\n               vtop \\<leftarrow> returnOk $ vaddr + mask (pageBitsForSize pgsz);\n               whenE (vtop > user_vtop) $ throwError $ InvalidArgument 0\n             odE;\n           (level, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot pt vaddr \\<circ> ptes_of;\n           unlessE (pt_bits_left level = pg_bits) $\n             throwError $ FailedLookup False $ MissingCapability $ pt_bits_left level;\n           vm_rights \\<leftarrow> returnOk $ mask_vm_rights R (data_to_rights rights_mask);\n           attribs \\<leftarrow> returnOk $ attribs_from_word attr;\n           pte \\<leftarrow> returnOk $ make_user_pte (addrFromPPtr p) attribs vm_rights pgsz;\n           returnOk $ InvokePage $ PageMap (FrameCap p R pgsz dev (Some (asid,vaddr))) cte\n                                           (pte,slot,level)\n         odE\n       else throwError TruncatedMessage\n     | _ \\<Rightarrow> fail\"\n\ndefinition label_to_flush_type :: \"data \\<Rightarrow> flush_type\" where\n  \"label_to_flush_type label \\<equiv>\n     case invocation_type label of\n       ArchInvocationLabel ARMVSpaceClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPageClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMVSpaceInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPageInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMVSpaceCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPageCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMVSpaceUnify_Instruction \\<Rightarrow> Unify\n     | ArchInvocationLabel ARMPageUnify_Instruction \\<Rightarrow> Unify\"\n\ndefinition decode_fr_inv_flush :: \"'z::state_ext arch_decoder\" where\n  \"decode_fr_inv_flush label args cte cap extra_caps \\<equiv> case cap of\n     FrameCap p R pgsz dev mapped_address \\<Rightarrow>\n        if length args > 1\n        then let\n          start = args ! 0;\n          end = args ! 1\n        in doE\n          (asid, vaddr) \\<leftarrow> case mapped_address of\n                             Some a \\<Rightarrow> returnOk a\n                           | _ \\<Rightarrow> throwError IllegalOperation;\n          vspace \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n          whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n          page_size \\<leftarrow> returnOk $ 1 << pageBitsForSize pgsz;\n          whenE (start \\<ge> page_size \\<or> end > page_size) $ throwError $ InvalidArgument 0;\n          pstart \\<leftarrow> returnOk $ addrFromPPtr p + start;\n          \\<comment> \\<open>flush only inside the kernel window:\\<close>\n          whenE (pstart < paddrBase \\<or> ((end - start) + pstart > paddrTop)) $\n            throwError IllegalOperation;\n          returnOk $ InvokePage $\n            PageFlush (label_to_flush_type label)\n                      (vaddr + start) (vaddr + end - 1)\n                      pstart vspace asid\n        odE\n        else throwError TruncatedMessage\n   | _ \\<Rightarrow> fail\"\n\n\ndefinition decode_frame_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_frame_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel ARMPageMap\n     then decode_fr_inv_map label args cte cap extra_caps\n     else if invocation_type label = ArchInvocationLabel ARMPageUnmap\n     then returnOk $ InvokePage $ PageUnmap cap cte\n     else if invocation_type label = ArchInvocationLabel ARMPageGetAddress\n     then returnOk $ InvokePage $ PageGetAddr (acap_obj cap)\n     else if isPageFlushLabel (invocation_type label)\n     then decode_fr_inv_flush label args cte cap extra_caps\n     else throwError IllegalOperation\"\n\ndefinition decode_pt_inv_map :: \"'z::state_ext arch_decoder\" where\n  \"decode_pt_inv_map label args cte cap extra_caps \\<equiv> case cap of\n     PageTableCap p t mapped_address \\<Rightarrow>\n       if length args > 1 \\<and> length extra_caps > 0\n       then let\n           vaddr = args ! 0;\n           attr = args ! 1;\n           vspace_cap = fst (extra_caps ! 0)\n         in doE\n           whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n           (pt, asid) \\<leftarrow> check_vspace_root vspace_cap 1;\n           whenE (user_vtop < vaddr) $ throwError $ InvalidArgument 0;\n           pt' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n           whenE (pt' \\<noteq> pt) $ throwError $ InvalidCapability 1;\n           (level, slot) \\<leftarrow> liftE $ gets_the $ pt_lookup_slot pt vaddr \\<circ> ptes_of;\n           old_pte \\<leftarrow> liftE $ get_pte (level_type level) slot;\n           whenE (pt_bits_left level = pageBits \\<or> old_pte \\<noteq> InvalidPTE) $ throwError DeleteFirst;\n           pte \\<leftarrow> returnOk $ PageTablePTE (ppn_from_pptr p);\n           cap' <- returnOk $ PageTableCap p t $ Some (asid, vaddr && ~~mask (pt_bits_left level));\n           returnOk $ InvokePageTable $ PageTableMap cap' cte pte slot level\n         odE\n       else throwError TruncatedMessage\n     | _ \\<Rightarrow> fail\"\n\ndefinition decode_page_table_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_page_table_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel ARMPageTableMap\n     then decode_pt_inv_map label args cte cap extra_caps\n     else if invocation_type label = ArchInvocationLabel ARMPageTableUnmap\n     then doE\n       final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n       unlessE final $ throwError RevokeFirst;\n       returnOk $ InvokePageTable $ PageTableUnmap cap cte\n     odE\n     else throwError IllegalOperation\"\n\ndefinition level_of_vmsize :: \"vmpage_size \\<Rightarrow> vm_level\" where\n  \"level_of_vmsize vmsz \\<equiv>\n     case vmsz of\n       ARMSmallPage \\<Rightarrow> 0\n     | ARMLargePage \\<Rightarrow> 1\n     | ARMHugePage \\<Rightarrow> 2\"\n\ndefinition vmsize_of_level :: \"vm_level \\<Rightarrow> vmpage_size\" where\n  \"vmsize_of_level level \\<equiv>\n     if level = 0 then ARMSmallPage\n     else if level = 1 then ARMLargePage\n     else ARMHugePage\"\n\ndefinition lookup_frame :: \"obj_ref \\<Rightarrow> vspace_ref \\<Rightarrow> ptes_of \\<Rightarrow> (vmpage_size \\<times> paddr) option\" where\n  \"lookup_frame vspace vaddr = do {\n     (level, slot) \\<leftarrow> pt_lookup_slot vspace vaddr;\n     pte \\<leftarrow> oapply2 (level_type level) slot;\n     oassert (is_PagePTE pte);\n     oassert (level \\<le> 2);\n     oreturn (vmsize_of_level level, pte_base_addr pte)\n   }\"\n\ndefinition decode_vs_inv_flush :: \"'z::state_ext arch_decoder\" where\n  \"decode_vs_inv_flush label args cte cap extra_caps \\<equiv> case cap of\n     PageTableCap p VSRootPT_T mapped_address \\<Rightarrow>\n        if length args > 1\n        then let\n          start = args ! 0;\n          end = args ! 1\n        in doE\n          whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n          whenE (end > pptrUserTop) $ throwError $ IllegalOperation;\n          (vspace, asid) \\<leftarrow> check_vspace_root (ArchObjectCap cap) 0;\n          vspace' \\<leftarrow> lookup_error_on_failure False $ find_vspace_for_asid asid;\n          whenE (vspace' \\<noteq> vspace) $ throwError $ InvalidCapability 0;\n          frame_info \\<leftarrow> liftE $ gets $ lookup_frame p start \\<circ> ptes_of;\n          case frame_info of\n            None \\<Rightarrow> returnOk $ InvokeVSpace VSpaceNothing\n          | Some (pgsz, paddr) \\<Rightarrow> doE\n              bits_left  \\<leftarrow> returnOk $ pt_bits_left (level_of_vmsize pgsz);\n              base_start \\<leftarrow> returnOk $ page_base start pgsz;\n              base_end \\<leftarrow> returnOk $ page_base (end - 1) pgsz;\n              whenE (base_start \\<noteq> base_end) $\n                throwError $ RangeError start (base_start + mask bits_left);\n              pstart \\<leftarrow> returnOk $ paddr + (start && mask bits_left);\n              returnOk $ InvokeVSpace $\n                VSpaceFlush (label_to_flush_type label) start (end - 1) pstart vspace asid\n            odE\n        odE\n        else throwError TruncatedMessage\n   | _ \\<Rightarrow> fail\"\n\ndefinition decode_vspace_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_vspace_invocation label args cte cap extra_caps \\<equiv>\n     if isVSpaceFlushLabel (invocation_type label)\n     then decode_vs_inv_flush label args cte cap extra_caps\n     else throwError IllegalOperation\"\n\ndefinition decode_asid_control_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_asid_control_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel ARMASIDControlMakePool\n     then if length args > 1 \\<and> length extra_caps > 1\n     then let\n         index = args ! 0;\n         depth = args ! 1;\n         (untyped, parent_slot) = extra_caps ! 0;\n         root = fst (extra_caps ! 1)\n       in doE\n         asid_table \\<leftarrow> liftE $ gets asid_table;\n         free_set \\<leftarrow> returnOk (- dom asid_table);\n         whenE (free_set = {}) $ throwError DeleteFirst;\n         free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n         base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n         (p,n) \\<leftarrow> case untyped of\n                    UntypedCap False p n _ \\<Rightarrow> returnOk (p,n)\n                  | _ \\<Rightarrow> throwError $ InvalidCapability 1;\n         frame \\<leftarrow> if n = pageBits then doE\n                    ensure_no_children parent_slot;\n                    returnOk p\n                  odE\n                  else throwError $ InvalidCapability 1;\n         dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n         ensure_empty dest_slot;\n         returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n       odE\n     else throwError TruncatedMessage\n     else throwError IllegalOperation\"\n\ndefinition decode_asid_pool_invocation :: \"'z::state_ext arch_decoder\" where\n  \"decode_asid_pool_invocation label args cte cap extra_caps \\<equiv>\n     if invocation_type label = ArchInvocationLabel ARMASIDPoolAssign\n     then if length extra_caps > 0\n     then let\n         (pt_cap, pt_cap_slot) = extra_caps ! 0;\n         p = acap_obj cap;\n         base = acap_asid_base cap\n       in case pt_cap of\n         ArchObjectCap (PageTableCap _ VSRootPT_T None) \\<Rightarrow> doE\n           asid_table \\<leftarrow> liftE $ gets asid_table;\n           pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n           whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n           whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n           pool \\<leftarrow> liftE $ get_asid_pool p;\n           free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n           whenE (free_set = {}) $ throwError DeleteFirst;\n           offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n           returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pt_cap_slot\n         odE\n       | _ \\<Rightarrow> throwError $ InvalidCapability 1\n     else throwError TruncatedMessage\n     else throwError IllegalOperation\"\n\ndefinition arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n    (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n     PageTableCap _ VSRootPT_T _ \\<Rightarrow> decode_vspace_invocation label args cte cap extra_caps\n   | PageTableCap _ NormalPT_T _ \\<Rightarrow> decode_page_table_invocation label args cte cap extra_caps\n   | FrameCap _ _ _ _ _        \\<Rightarrow> decode_frame_invocation label args cte cap extra_caps\n   | ASIDControlCap            \\<Rightarrow> decode_asid_control_invocation label args cte cap extra_caps\n   | ASIDPoolCap _ _           \\<Rightarrow> decode_asid_pool_invocation label args cte cap extra_caps\n   | VCPUCap _                 \\<Rightarrow> decode_vcpu_invocation label args cap extra_caps\"", "property": "Architecture-specific System Call Decoding: Decodes architecture-specific system calls by interpreting the invocation label and arguments, validating the provided capabilities, and performing the corresponding actions such as managing IRQs, mapping and unmapping pages, flushing memory, and controlling ASID pools. This ensures that the system calls are correctly interpreted and executed, maintaining the integrity and security of the system.", "title": "./spec/abstract/AARCH64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Interface Functions used in Decode", "comment": ""}
{"spec": "definition arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\" where\n  \"arch_data_to_obj_type n \\<equiv>\n     if      n = 0 then Some HugePageObj\n     else if n = 1 then Some VSpaceObj\n     else if n = 2 then Some SmallPageObj\n     else if n = 3 then Some LargePageObj\n     else if n = 4 then Some PageTableObj\n     else if n = 5 then Some VCPUObj\n     else None\"\n\nend\nend", "property": "Architectural Data to Object Type Mapping: Convert a numerical value to a corresponding architecture-specific object type, such as HugePage, VSpace, SmallPage, LargePage, PageTable, or VCPU. If the numerical value does not match any of these, it returns None.", "title": "./spec/abstract/AARCH64/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Interface Functions used in Decode", "comment": ""}
{"spec": "locale_abbrev vcpus_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> vcpu\" where\n  \"vcpus_of \\<equiv> \\<lambda>s. aobjs_of s |> vcpu_of\"\n\ndefinition get_vcpu :: \"obj_ref \\<Rightarrow> (vcpu,'z::state_ext) s_monad\" where\n  \"get_vcpu \\<equiv> gets_map vcpus_of\"\n\ndefinition set_vcpu :: \"obj_ref \\<Rightarrow> vcpu \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_vcpu ptr vcpu \\<equiv> set_object ptr (ArchObj (VCPU vcpu))\"", "property": "VCPU State Management: Retrieve and update the VCPU state associated with a given object reference. This ensures that the VCPU-related state and registers can be manipulated effectively, maintaining the integrity and performance of the system.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": ""}
{"spec": "definition vcpu_update :: \"obj_ref \\<Rightarrow> (vcpu \\<Rightarrow> vcpu) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_update vr f \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    set_vcpu vr (f vcpu)\n  od\"\n\ndefinition vgic_update ::\n  \"obj_ref \\<Rightarrow> (gic_vcpu_interface \\<Rightarrow> gic_vcpu_interface) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vgic_update vr f \\<equiv> vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_vgic := f (vcpu_vgic vcpu) \\<rparr> )\"\n\ndefinition vgic_update_lr :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> virq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vgic_update_lr vr irq_idx virq \\<equiv>\n    vgic_update vr (\\<lambda>vgic. vgic \\<lparr> vgic_lr := (vgic_lr vgic)(irq_idx := virq) \\<rparr>)\"\n\ndefinition vcpu_save_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_save_reg vr reg \\<equiv> do\n    rval \\<leftarrow> do_machine_op (readVCPUHardwareReg reg);\n    vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_regs := (vcpu_regs vcpu)(reg := rval) \\<rparr> )\n  od\"\n\ndefinition vcpu_save_reg_range :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_save_reg_range vr from to \\<equiv> mapM_x (\\<lambda>reg. vcpu_save_reg vr reg) [from .e. to]\"\n\ndefinition vcpu_restore_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_restore_reg vr reg \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    do_machine_op (writeVCPUHardwareReg reg (vcpu_regs vcpu reg))\n  od\"\n\ndefinition vcpu_restore_reg_range :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"vcpu_restore_reg_range vr from to \\<equiv> mapM_x (\\<lambda>reg. vcpu_restore_reg vr reg) [from .e. to]\"\n\ndefinition vcpu_read_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (machine_word, 'z::state_ext) s_monad\" where\n  \"vcpu_read_reg vr reg \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    return (vcpu_regs vcpu reg)\n  od\"\n\ndefinition vcpu_write_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"vcpu_write_reg vr reg val \\<equiv>\n    vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_regs := (vcpu_regs vcpu)(reg := val) \\<rparr> )\"\n\ndefinition save_virt_timer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"save_virt_timer vcpu_ptr \\<equiv> do\n     vcpu_save_reg vcpu_ptr VCPURegCNTV_CTL;\n     do_machine_op $ writeVCPUHardwareReg VCPURegCNTV_CTL 0;\n     vcpu_save_reg vcpu_ptr VCPURegCNTV_CVAL;\n     vcpu_save_reg vcpu_ptr VCPURegCNTVOFF;\n     vcpu_save_reg vcpu_ptr VCPURegCNTKCTL_EL1;\n     do_machine_op check_export_arch_timer;\n     cntpct \\<leftarrow> do_machine_op read_cntpct;\n     vcpu_update vcpu_ptr (\\<lambda>vcpu. vcpu\\<lparr>vcpu_vtimer := VirtTimer cntpct \\<rparr>)\n   od\"\n\ndefinition irq_vppi_event_index :: \"irq \\<rightharpoonup> vppievent_irq\" where\n  \"irq_vppi_event_index irq \\<equiv>\n     if irq = irqVTimerEvent\n     then Some VPPIEventIRQ_VTimer\n     else None\"\n\ndefinition restore_virt_timer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"restore_virt_timer vcpu_ptr \\<equiv> do\n     vcpu_restore_reg vcpu_ptr VCPURegCNTV_CVAL;\n     vcpu_restore_reg vcpu_ptr VCPURegCNTKCTL_EL1;\n     current_cntpct \\<leftarrow> do_machine_op read_cntpct;\n     vcpu \\<leftarrow> get_vcpu vcpu_ptr;\n     last_pcount \\<leftarrow> return $ vtimerLastPCount $ vcpu_vtimer vcpu;\n     delta \\<leftarrow> return $ current_cntpct - last_pcount;\n     cntvoff \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTVOFF;\n     offset \\<leftarrow> return $ cntvoff + ucast delta;\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFF offset;\n     vcpu_restore_reg vcpu_ptr VCPURegCNTVOFF;\n     \\<comment> \\<open>read again, so we don't have to reason about @{const vcpu_write_reg} changes in CRefine\\<close>\n     vcpu \\<leftarrow> get_vcpu vcpu_ptr;\n     masked \\<leftarrow> return $ (vcpu_vppi_masked vcpu (the $ irq_vppi_event_index irqVTimerEvent));\n     \\<comment> \\<open>we do not know here that irqVTimerEvent is IRQReserved, therefore not IRQInactive,\n        so the only way to prove we don't unmask an inactive interrupt is to check\\<close>\n     safe_to_unmask \\<leftarrow> is_irq_active irqVTimerEvent;\n     when safe_to_unmask $ do_machine_op $ maskInterrupt masked irqVTimerEvent;\n     vcpu_restore_reg vcpu_ptr VCPURegCNTV_CTL\n   od\"", "property": "VCPU State and Register Manipulation: Provides functions to update, save, and restore VCPU-related state and registers. This includes updating the VCPU and VGIC state, saving and restoring individual or ranges of VCPU registers, and managing the virtual timer by saving and restoring its control and counter values. These operations ensure that the VCPU's state is accurately maintained and can be effectively managed during context switches and other critical operations.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": ""}
{"spec": "definition vcpu_disable :: \"obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_disable vo \\<equiv> do\n    do_machine_op dsb;\n    case vo of\n      Some vr \\<Rightarrow> do\n        hcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_hcr;\n        vgic_update vr (\\<lambda>vgic. vgic\\<lparr> vgic_hcr := hcr \\<rparr>);\n        vcpu_save_reg vr VCPURegSCTLR;\n        vcpu_save_reg vr VCPURegCPACR; \\<comment> \\<open>since FPU enabled\\<close>\n        do_machine_op isb\n      od\n    | _ \\<Rightarrow> return ();\n    do_machine_op $ do\n        set_gic_vcpu_ctrl_hcr 0; \\<comment> \\<open>turn VGIC off\\<close>\n        isb;\n        setSCTLR sctlrDefault; \\<comment> \\<open>turn S1 MMU off\\<close>\n        isb;\n        setHCR hcrNative;\n        isb;\n        \\<comment> \\<open>allow FPU instructions in EL0 and EL1 for native threads\\<close>\n        enableFpuEL01\n      od;\n    case vo of\n      Some vr \\<Rightarrow> do\n          save_virt_timer vr;\n          do_machine_op $ maskInterrupt True irqVTimerEvent\n        od\n    | _ \\<Rightarrow> return ()\n    od\"", "property": "VCPU Disable: Disables the VCPU mode on the hardware level by turning off the VGIC, saving relevant VCPU registers, and adjusting system control settings to ensure proper state transition. This includes saving the SCTLR and CPACR registers, disabling the S1 MMU, setting the HCR to native mode, enabling FPU instructions in EL0 and EL1, and masking the virtual timer interrupt.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Turn VPCU mode off on the hardware level."}
{"spec": "definition vcpu_enable :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_enable vr \\<equiv> do\n     vcpu_restore_reg vr VCPURegSCTLR;\n     vcpu \\<leftarrow> get_vcpu vr;\n     do_machine_op $ do\n        setHCR hcrVCPU;\n        isb;\n        set_gic_vcpu_ctrl_hcr (vgic_hcr $ vcpu_vgic vcpu)\n     od;\n     vcpu_restore_reg vr VCPURegCPACR; \\<comment> \\<open>FPU\\<close>\n     restore_virt_timer vr\n   od\"", "property": "Enable VCPU Mode: Activate the VCPU mode on the hardware level by restoring specific VCPU registers, setting the HCR (Hypervisor Configuration Register) to enable VCPU, and configuring the GIC (Generic Interrupt Controller) for VCPU operation. This ensures that the VCPU is properly initialized and ready for virtualized execution.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Turn VCPU mode on, on the hardware level."}
{"spec": "definition vcpu_invalidate_active :: \"(unit,'z::state_ext) s_monad\" where\n  \"vcpu_invalidate_active \\<equiv> do\n    cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n    case cur_v of\n      Some (vr, True) \\<Rightarrow> vcpu_disable None\n    | _ \\<Rightarrow> return ();\n    modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := None \\<rparr>\\<rparr>)\n  od\"", "property": "VCPU Invalidation: Invalidate the active VCPU by disabling it and updating the system state to remove the current VCPU reference. This ensures that the VCPU is properly prepared for removal, maintaining the integrity of the system's virtualization state.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Prepare the current VCPU for removal."}
{"spec": "definition vcpu_save :: \"(obj_ref \\<times> bool) option \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_save vb \\<equiv>\n     case vb\n     of Some (vr, active) \\<Rightarrow> do\n          do_machine_op dsb;\n\n          when active $ do\n            vcpu_save_reg vr VCPURegSCTLR;\n            hcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_hcr;\n            vgic_update vr (\\<lambda>vgic. vgic\\<lparr> vgic_hcr := hcr \\<rparr>);\n            save_virt_timer vr\n          od;\n\n          vmcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_vmcr;\n          vgic_update vr (\\<lambda>vgic. vgic \\<lparr>vgic_vmcr := vmcr\\<rparr>);\n\n          apr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_apr;\n          vgic_update vr (\\<lambda>vgic. vgic \\<lparr>vgic_apr := apr\\<rparr>);\n\n          num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n          gicIndices \\<leftarrow> return [0..<num_list_regs];\n\n          mapM (\\<lambda>vreg. do\n                    val \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_lr (of_nat vreg);\n                    vgic_update_lr vr vreg val\n                  od)\n            gicIndices;\n\n          \\<comment> \\<open>armvVCPUSave\\<close>\n          vcpu_save_reg_range vr VCPURegTTBR0 VCPURegSPSR_EL1\n       od\n     | _ \\<Rightarrow> fail\"", "property": "VCPU State and Register Save: Saves the state and registers of a VCPU, including SCTLR, HCR, VMCR, APR, and GIC list registers, and updates the VGIC state. The function ensures that the VCPU's context is properly saved, maintaining the integrity of the virtualized environment.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Register + context save for VCPUs"}
{"spec": "definition vcpu_restore :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_restore vr \\<equiv> do\n     do_machine_op $ set_gic_vcpu_ctrl_hcr 0;  \\<comment> \\<open>turn off VGIC\\<close>\n     do_machine_op $ isb;\n     vcpu \\<leftarrow> get_vcpu vr;  \\<comment> \\<open>restore GIC VCPU control state\\<close>\n     vgic \\<leftarrow> return (vcpu_vgic vcpu);\n     num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     gicIndices \\<leftarrow> return [0..<num_list_regs];\n     do_machine_op $ do\n         set_gic_vcpu_ctrl_vmcr (vgic_vmcr vgic);\n         set_gic_vcpu_ctrl_apr (vgic_apr vgic);\n         mapM (\\<lambda>p. set_gic_vcpu_ctrl_lr (of_nat (fst p)) (snd p))\n              (map (\\<lambda>i. (i, (vgic_lr vgic) i)) gicIndices)\n     od;\n    \\<comment> \\<open>restore banked VCPU registers except SCTLR (that's in VCPUEnable)\\<close>\n     vcpu_restore_reg_range vr VCPURegTTBR0 VCPURegSPSR_EL1;\n     vcpu_enable vr\n  od\"", "property": "VCPU Restore: Restores the state and registers of a VCPU, including turning off the VGIC, restoring GIC VCPU control state, setting specific GIC VCPU control registers, and restoring banked VCPU registers. The process ensures that the VCPU is correctly reinitialized and ready for execution.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Register + context restore for VCPUs"}
{"spec": "definition vcpu_switch :: \"obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_switch v \\<equiv> case v of\n     None \\<Rightarrow> do\n       cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n       (case cur_v of\n          None \\<Rightarrow> return () \\<comment> \\<open>both null, current cannot be active\\<close>\n        | Some (vr, active) \\<Rightarrow> do \\<comment> \\<open>switch to thread without vcpu\\<close>\n            when active $ do  \\<comment> \\<open> save state if not saved already\\<close>\n              vcpu_disable (Some vr);\n              modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (vr, False) \\<rparr>\\<rparr>)\n            od;\n            return ()\n          od)\n       od\n   | Some new \\<Rightarrow> do\n       cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n       (case cur_v of\n          None \\<Rightarrow> do \\<comment> \\<open>switch to the new vcpu with no current one\\<close>\n            vcpu_restore new;\n            modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n          od\n        | Some (vr, active) \\<Rightarrow> \\<comment> \\<open>switch from an existing vcpu\\<close>\n            (if vr \\<noteq> new\n            then do \\<comment> \\<open>different vcpu\\<close>\n              vcpu_save cur_v;\n              vcpu_restore new;\n              modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n            od\n            else \\<comment> \\<open>same vcpu\\<close>\n              when (\\<not> active) $ do\n                do_machine_op isb;\n                vcpu_enable new;\n                modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n              od))\n     od\"", "property": "VCPU Switching: Manages the activation and deactivation of a VCPU. If a new VCPU is specified, it saves the state of the current VCPU (if active) and restores the state of the new VCPU, marking it as active. If no VCPU is specified, it deactivates the current VCPU and disables VCPU mode, preserving the state for potential future reactivation.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "\n  Make a new VCPU the active/current VCPU. If passed None, will mark the current VCPU as\n  not active, and disable VCPU mode, but leave the rest intact caching for the case where\n  we switch back to the same VCPU soon."}
{"spec": "definition dissociate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"dissociate_vcpu_tcb vr t \\<equiv> do\n     t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n     v \\<leftarrow> get_vcpu vr;\n     assert (t_vcpu = Some vr \\<and> vcpu_tcb v = Some t); \\<comment> \\<open>make sure they were associated\\<close>\n     cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     when (\\<exists>a. cur_v = Some (vr,a)) vcpu_invalidate_active;\n     arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := None \\<rparr>) t;\n     set_vcpu vr (v\\<lparr> vcpu_tcb := None \\<rparr>);\n     as_user t $ do\n       sr \\<leftarrow> getRegister SPSR_EL1;\n       setRegister SPSR_EL1 $ sanitise_register False SPSR_EL1 sr\n     od\n   od\"", "property": "Dissociate VCPU and TCB: Safely remove the association between a VCPU and a TCB, ensuring that they were previously associated. Invalidate the active VCPU if it is the one being dissociated, update the TCB to remove the VCPU reference, and sanitize the SPSR_EL1 register of the TCB.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Removing the connection between a TCB and VCPU:"}
{"spec": "definition associate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"associate_vcpu_tcb vcpu_ptr t \\<equiv> do\n     t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n     case t_vcpu of\n       Some p \\<Rightarrow> dissociate_vcpu_tcb p t\n     | _ \\<Rightarrow> return ();\n     v \\<leftarrow> get_vcpu vcpu_ptr;\n     case vcpu_tcb v of\n       Some p \\<Rightarrow> dissociate_vcpu_tcb vcpu_ptr p\n     | _ \\<Rightarrow> return ();\n     arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := Some vcpu_ptr \\<rparr>) t;\n     set_vcpu vcpu_ptr (v\\<lparr> vcpu_tcb := Some t \\<rparr>);\n     ct \\<leftarrow> gets cur_thread;\n     when (t = ct) $ vcpu_switch (Some vcpu_ptr)\n  od\"", "property": "Associate VCPU and TCB: Ensures a VCPU is associated with a TCB, removing any existing associations. If the TCB or VCPU is already associated, it first dissociates them before establishing the new association. If the TCB being associated is the current thread, it performs a VCPU switch to the new VCPU.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "Associating a TCB and VCPU, removing any potentially existing associations:"}
{"spec": "definition vcpu_finalise :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vcpu_finalise vr \\<equiv> do\n    v \\<leftarrow> get_vcpu vr;\n    case vcpu_tcb v of\n      Some t \\<Rightarrow> dissociate_vcpu_tcb vr t\n    | None \\<Rightarrow> return ()\n   od\"\n\nend\nend", "property": "VCPU Finalization: Prepare a VCPU for removal by dissociating it from its associated TCB and cleaning up the current VCPU state.", "title": "./spec/abstract/AARCH64/VCPUAcc_A.thy", "chapter": "AARCH64 VCPU Accessor Functions", "section": "Manipulation of VCPU-related state and registers", "comment": "\n  Prepare a given VCPU for removal: dissociate it, and clean up current VCPU state\n  if necessary."}
{"spec": "datatype vspace_invocation =\n    VSpaceNothing\n  | VSpaceFlush\n      (vs_flush_type : flush_type)\n      (vs_flush_start : vspace_ref)\n      (vs_flush_end : vspace_ref)\n      (vs_flush_pstart : paddr)\n      (vs_flush_space : obj_ref)\n      (vs_flush_asid : asid)\n\ndatatype page_table_invocation =\n    PageTableMap\n      (pt_inv_cap : arch_cap)\n      (pt_inv_cslot : cslot_ptr)\n      (pt_map_pte : pte)\n      (pt_map_slot : obj_ref)\n      (pt_map_level : vm_level)\n  | PageTableUnmap\n      (pt_inv_cap : arch_cap)\n      (pt_inv_cslot : cslot_ptr)\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation =\n    PageMap\n      (pg_inv_cap : arch_cap)\n      (pg_inv_cslot : cslot_ptr)\n      (pg_inv_entries : \"pte \\<times> obj_ref \\<times> vm_level\")\n  | PageUnmap\n      (pg_inv_cap : arch_cap)\n      (pg_inv_cslot : cslot_ptr)\n  | PageGetAddr\n      (pg_get_paddr : obj_ref)\n  | PageFlush\n      (pg_flush_type : flush_type)\n      (pg_flush_start : vspace_ref)\n      (pg_flush_end : vspace_ref)\n      (pg_flush_pStart : paddr)\n      (pg_flush_space : obj_ref)\n      (pg_flush_asid : asid)\n\ndatatype vcpu_invocation =\n    VCPUSetTCB\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_tcb : obj_ref)\n  | VCPUInjectIRQ\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_idx : nat)\n      (vcpu_inv_irq : virq)\n  | VCPUReadRegister\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_reg : vcpureg)\n  | VCPUWriteRegister\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_reg : vcpureg)\n      (vcpu_inv_val : machine_word)\n  | VCPUAckVPPI\n      (vcpu_inv_vcpu : obj_ref)\n      (vcpu_inv_eirq : vppievent_irq)\n\ndatatype arch_invocation =\n    InvokeVSpace vspace_invocation\n  | InvokePageTable page_table_invocation\n  | InvokePage page_invocation\n  | InvokeASIDControl asid_control_invocation\n  | InvokeASIDPool asid_pool_invocation\n  | InvokeVCPU vcpu_invocation\n\ndatatype arch_copy_register_sets =\n    ARMNoExtraRegisters\n\ndefinition ArchDefaultExtraRegisters :: arch_copy_register_sets where\n  \"ArchDefaultExtraRegisters = ARMNoExtraRegisters\"\n\ndatatype arch_irq_control_invocation =\n    ARMIRQControlInvocation irq cslot_ptr cslot_ptr bool\n\nend\nend", "property": "Architectural Invocation Types: Define the various AARCH64-specific system call arguments, including operations for managing virtual space, page tables, ASID pools, pages, and VCPUs. These datatypes provide a structured way to handle different types of architectural invocations, ensuring that the system can perform specific actions such as flushing virtual spaces, mapping and unmapping page tables, assigning ASIDs, and controlling VCPUs.", "title": "./spec/abstract/AARCH64/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "\n  These datatypes encode the arguments to the various possible AARCH64-specific system calls.\n  Selectors are defined for various fields for convenience elsewhere.\n"}
{"spec": "text \\<open>\n  The AARCH64 kernel supports capabilities for ASID pools and an ASID controller capability,\n  along with capabilities for virtual memory mappings.\n\\<close>\n\ndatatype arch_cap =\n    ASIDPoolCap\n      (acap_obj : obj_ref)\n      (acap_asid_base : asid)\n  | ASIDControlCap\n  | FrameCap\n      (acap_obj : obj_ref)\n      (acap_rights : cap_rights)\n      (acap_fsize : vmpage_size)\n      (acap_is_device : bool)\n      (acap_map_data : \"(asid \\<times> vspace_ref) option\")\n  | PageTableCap\n      (acap_obj : obj_ref)\n      (acap_pt_type : pt_type)\n      (acap_map_data : \"(asid \\<times> vspace_ref) option\")\n  | VCPUCap\n      (acap_obj : obj_ref)", "property": "AARCH64-Specific Capabilities: Define architecture-specific capabilities including ASID pools, ASID controller, frame, page table, and VCPU. These capabilities encapsulate specific properties such as object references, ASID bases, rights, sizes, device flags, and mapping data, enabling fine-grained control over memory and virtualization resources.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "definition update_map_data :: \"arch_cap \\<Rightarrow> (asid \\<times> vspace_ref) option \\<Rightarrow> arch_cap\" where\n  \"update_map_data cap m \\<equiv> case cap of\n     FrameCap p R sz dev _  \\<Rightarrow> FrameCap p R sz dev m\n   | PageTableCap p t _ \\<Rightarrow> PageTableCap p t m\"", "property": "Update Mapping Data: Modify the mapping data in a frame or page table capability, updating the ASID and virtual space reference.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific objects", "comment": "Update the mapping data saved in a frame or page table capability."}
{"spec": "(* This datatype does not match up with the executable spec directly:\n   This one here models all \"things\" one can set on a page entry.\n   The attributes accessible to users are the ones returned by attribs_from_word. *)\ndatatype vm_attribute = Global | Execute | Device\ntype_synonym vm_attributes = \"vm_attribute set\"", "property": "VM Attributes: Define a set of attributes that can be applied to virtual memory, including global, execute, and device-specific attributes. These attributes allow for fine-grained control over the properties and behavior of memory pages in the system.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "value_type ppn_len = \"ipa_size - pageBits\"\ntype_synonym ppn = \"ppn_len word\"", "property": "Physical Page Number Encoding: The base address for next-level tables of PagePTEs is encoded as a 36-bit field, with the bottom 12 bits always set to 0, ensuring alignment. This encoding ensures that the significant bits of the physical address are stored from the top of the intermediate physical address size down to the page bits, providing both size and alignment invariants.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": "\n  The C field @{text base_addr} for next-level tables of @{text PagePTE}s is a 36 bit field-high\n  value, i.e., a 48-bit word with the bottom 12 bits always set to 0. (They must be 0 due to\n  alignment). Since Arm does not specify a name, we are re-using the RISC-V name @{text ppn}\n  (physical page number) for the concept of encoding only the significant bits of this address.\n\n  In addition to the bottom 12 bits being 0 (where 12 = @{const pageBits}), we also know that\n  the base address of the next level table is a physical address and therefore has the same width\n  as intermediate physical addresses (@{const ipa_size}). We can therefore be more precise in the\n  encoding here: the significant bits of the next-level page table address go from @{const ipa_size}\n  at the top to @{const pageBits} at the bottom. Similar to the ppn on RISC-V we store a word\n  of that size, and shift by @{const pageBits} to get the address. This encodes both a size invariant\n  and an alignment invariant in the type, which functions like @{text pt_walk} rely on.\n\n  To provide the same field name as in C, we define @{text pte_base_addr} as the main accessor\n  function."}
{"spec": "lemma ppn_len_def':\n  \"ppn_len = ipa_size - pageBits\"\n  by (simp add: ppn_len_val pageBits_def ipa_size_def Kernel_Config.config_ARM_PA_SIZE_BITS_40_def)\n\ndatatype pte =\n    InvalidPTE\n  | PagePTE\n      (pte_page_addr : paddr)\n      (pte_is_small_page : bool)\n      (pte_attr : vm_attributes)\n      (pte_rights : vm_rights)\n  | PageTablePTE\n      (pte_ppn : ppn)\n\ndefinition paddr_from_ppn :: \"ppn \\<Rightarrow> paddr\" where\n  \"paddr_from_ppn addr \\<equiv> ucast addr << pageBits\"\n\ndefinition pte_base_addr :: \"pte \\<Rightarrow> paddr\" where\n  \"pte_base_addr pte \\<equiv>\n    if is_PageTablePTE pte then paddr_from_ppn (pte_ppn pte) else pte_page_addr pte\"\n\ndefinition ppn_from_pptr :: \"obj_ref \\<Rightarrow> ppn\" where\n  \"ppn_from_pptr p = ucast (addrFromPPtr p >> pageBits)\"", "property": "Page Table Entry (PTE) Structure: Defines the structure of a page table entry, which can represent an invalid entry, a small or large page with associated attributes and rights, or a page table. The base address of a PTE is determined based on its type, either from the page address for a page entry or from the page table physical number for a page table entry.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": "This lemma encodes @{typ ppn_len} value above as a term, so we can use it generically:"}
{"spec": "lemma vs_index_ptTranslationBits:\n  \"ptTranslationBits VSRootPT_T = LENGTH(vs_index_len)\"\n  by (simp add: ptTranslationBits_def vs_index_bits_def)\n\nlemma pt_index_ptTranslationBits:\n  \"ptTranslationBits NormalPT_T = LENGTH(pt_index_len)\"\n  by (simp add: ptTranslationBits_def)", "property": "Page Table Translation Bits: The number of translation bits for the VSpace root page table (VSRootPT_T) and the normal page table (NormalPT_T) are defined to match the length of their respective index types, ensuring proper alignment and addressing within the architecture.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " Sanity check for page table type sizes -- ptTranslationBits not yet available at definition site "}
{"spec": "datatype asid_pool_entry = ASIDPoolVSpace (ap_vmid : \"vmid option\") (ap_vspace : obj_ref)\n\ntype_synonym asid_pool = \"asid_low_index \\<rightharpoonup> asid_pool_entry\"\n\ndatatype pt =\n    VSRootPT (the_vs : \"vs_index \\<Rightarrow> pte\")\n  | NormalPT (the_pt : \"pt_index \\<Rightarrow> pte\")\n\ndefinition pt_type :: \"pt \\<Rightarrow> pt_type\" where\n  \"pt_type pt \\<equiv> case pt of VSRootPT _ \\<Rightarrow> VSRootPT_T | NormalPT _ \\<Rightarrow> NormalPT_T\"", "property": "Architecture-Specific Data Types: Define AARCH64-specific data types for ASID pools and page tables. ASID pools are represented as a mapping from ASID low indices to entries, where each entry contains an optional VMID and a reference to a virtual space. Page tables can be either VSRootPT, which maps virtual space indices to page table entries, or NormalPT, which maps page table indices to page table entries. The type of a page table is determined by its structure, distinguishing between VSRootPT and NormalPT.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " This could also be a record, but we expect further alternatives to be added for SMMU "}
{"spec": "type_synonym virq = machine_word\n\nend\n\nqualify AARCH64_A (in Arch)\n\nrecord  gic_vcpu_interface =\n  vgic_hcr  :: word32\n  vgic_vmcr :: word32\n  vgic_apr  :: word32\n  vgic_lr   :: \"nat \\<Rightarrow> AARCH64_A.virq\"\n\nrecord vcpu =\n  vcpu_tcb  :: \"obj_ref option\"\n  vcpu_vgic :: \"gic_vcpu_interface\"\n  vcpu_regs :: \"vcpureg \\<Rightarrow> machine_word\"\n  vcpu_vppi_masked :: \"vppievent_irq \\<Rightarrow> bool\"\n  vcpu_vtimer :: virt_timer\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition \"vcpu_sctlr vcpu \\<equiv> vcpu_regs vcpu VCPURegSCTLR\"\n\ndefinition default_gic_vcpu_interface :: gic_vcpu_interface where\n  \"default_gic_vcpu_interface \\<equiv> \\<lparr>\n      vgic_hcr  = vgicHCREN,\n      vgic_vmcr = 0,\n      vgic_apr  = 0,\n      vgic_lr   = \\<lambda>_. 0\n   \\<rparr>\"\n\ndefinition\n  default_vcpu :: vcpu where\n  \"default_vcpu \\<equiv> \\<lparr>\n      vcpu_tcb    = None,\n      vcpu_vgic   = default_gic_vcpu_interface,\n      vcpu_regs   = (\\<lambda>_. 0) (VCPURegSCTLR := sctlrEL1VM),\n      vcpu_vppi_masked = (\\<lambda>_. False),\n      vcpu_vtimer = VirtTimer 0\n   \\<rparr>\"", "property": "AARCH64 VCPU Structure: Defines a virtual CPU (vCPU) with fields for TCB reference, GIC vCPU interface, registers, VPII event masking, and a virtual timer. The default vCPU is initialized with specific values for the GIC interface, registers, and other components, ensuring a consistent and predictable initial state for vCPUs in the system.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "datatype (discs_sels) arch_kernel_obj =\n    ASIDPool asid_pool\n  | PageTable pt\n  | DataPage bool vmpage_size\n  | VCPU vcpu\n\ndefinition asid_pool_of :: \"arch_kernel_obj \\<rightharpoonup> asid_pool\" where\n  \"asid_pool_of ko \\<equiv> case ko of ASIDPool pool \\<Rightarrow> Some pool | _ \\<Rightarrow> None\"\n\ndefinition pt_of :: \"arch_kernel_obj \\<rightharpoonup> pt\" where\n  \"pt_of ko \\<equiv> case ko of PageTable pt \\<Rightarrow> Some pt | _ \\<Rightarrow> None\"\n\ndefinition vcpu_of :: \"arch_kernel_obj \\<rightharpoonup> vcpu\" where\n  \"vcpu_of ko \\<equiv> case ko of VCPU vcpu \\<Rightarrow> Some vcpu | _ \\<Rightarrow> None\"\n\ndefinition pte_bits :: nat where\n  \"pte_bits = word_size_bits\"\n\ndefinition table_size :: \"pt_type \\<Rightarrow> nat\" where\n  \"table_size pt_t = ptTranslationBits pt_t + pte_bits\"\n\ndefinition pt_bits :: \"pt_type \\<Rightarrow> nat\" where\n  \"pt_bits pt_t \\<equiv> table_size pt_t\"", "property": "Architecture-Specific Kernel Objects: Define and categorize architecture-specific kernel objects, including ASID pools, page tables, data pages, and VCPUs. Discriminators and selectors are provided for each type, allowing for the extraction of specific components such as ASID pools, page tables, and VCPUs from the kernel object.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " produce discriminators and selectors even though no field names are mentioned "}
{"spec": "lemma ppn_len:\n  \"LENGTH(ppn_len) = ipa_size - pt_bits NormalPT_T\"\n  by (simp add: pt_bits_def table_size_def ptTranslationBits_def pte_bits_def word_size_bits_def\n                ipa_size_def Kernel_Config.config_ARM_PA_SIZE_BITS_40_def)\n\nprimrec arch_obj_size :: \"arch_cap \\<Rightarrow> nat\" where\n  \"arch_obj_size (ASIDPoolCap _ _) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (FrameCap _ _ sz _ _) = pageBitsForSize sz\"\n| \"arch_obj_size (PageTableCap _ pt_t _ ) = table_size pt_t\"\n| \"arch_obj_size (VCPUCap _) = vcpuBits\"\n\nfun arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_cap_is_device (FrameCap _ _ _ is_dev _) = is_dev\"\n| \"arch_cap_is_device _ = False\"\n\ndefinition cte_level_bits :: nat where\n  \"cte_level_bits \\<equiv> 5\"\n\ndefinition tcb_bits :: nat where\n  \"tcb_bits \\<equiv> 11\"\n\ndefinition endpoint_bits :: nat where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat where\n  \"ntfn_bits \\<equiv> 5\"\n\ndefinition untyped_min_bits :: nat where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat where\n  \"untyped_max_bits \\<equiv> 47\"\n\nprimrec arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\" where\n  \"arch_kobj_size (ASIDPool _) = pageBits\"\n| \"arch_kobj_size (PageTable pt) = table_size (pt_type pt)\"\n| \"arch_kobj_size (DataPage _ sz) = pageBitsForSize sz\"\n| \"arch_kobj_size (VCPU _) = vcpuBits\"\n\nfun aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\" where\n  \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref c = Some (acap_obj c)\"\n\ndefinition acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\" where\n  \"acap_rights_update R acap \\<equiv>\n    case acap of\n      FrameCap ref cR sz dev as \\<Rightarrow> FrameCap ref (validate_vm_rights R) sz dev as\n    | _ \\<Rightarrow> acap\"", "property": "Architecture-Specific Object Sizes and Properties: Defines the sizes of architecture-specific objects such as ASID pools, frame caps, page tables, and VCPUs. Additionally, it specifies whether a frame cap is a device and provides a method to update the rights of a frame cap.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": " sanity check "}
{"spec": "datatype aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | HugePageObj\n  | PageTableObj\n  | VSpaceObj\n  | ASIDPoolObj (* used internally, not on API level *)\n  | VCPUObj\n\ndefinition arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\" where\n  \"arch_is_frame_type aobj \\<equiv> case aobj of\n     SmallPageObj \\<Rightarrow> True\n   | LargePageObj \\<Rightarrow> True\n   | HugePageObj \\<Rightarrow> True\n   | _ \\<Rightarrow> False\"\n\ndefinition arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\" where\n  \"arch_default_cap tp r n dev \\<equiv> case tp of\n     SmallPageObj \\<Rightarrow> FrameCap r vm_read_write ARMSmallPage dev None\n   | LargePageObj \\<Rightarrow> FrameCap r vm_read_write ARMLargePage dev None\n   | HugePageObj  \\<Rightarrow> FrameCap r vm_read_write ARMHugePage dev None\n   | PageTableObj \\<Rightarrow> PageTableCap r NormalPT_T None\n   | VSpaceObj    \\<Rightarrow> PageTableCap r VSRootPT_T None\n   | VCPUObj      \\<Rightarrow> VCPUCap r\n   | ASIDPoolObj  \\<Rightarrow> ASIDPoolCap r 0\" (* unused, but nicer properties when defined *)\n\ndefinition default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\" where\n  \"default_arch_object tp dev n \\<equiv> case tp of\n     SmallPageObj \\<Rightarrow> DataPage dev ARMSmallPage\n   | LargePageObj \\<Rightarrow> DataPage dev ARMLargePage\n   | HugePageObj  \\<Rightarrow> DataPage dev ARMHugePage\n   | PageTableObj \\<Rightarrow> PageTable (NormalPT (\\<lambda>_. InvalidPTE))\n   | VSpaceObj    \\<Rightarrow> PageTable (VSRootPT (\\<lambda>_. InvalidPTE))\n   | VCPUObj \\<Rightarrow> VCPU default_vcpu\n   | ASIDPoolObj  \\<Rightarrow> ASIDPool Map.empty\"\n\ntype_synonym arm_vspace_region_uses = \"vspace_ref \\<Rightarrow> arm_vspace_region_use\"", "property": "AARCH64-Specific Data Types: Defines architecture-specific object types and their default capabilities, including small, large, and huge page objects, page table objects, virtual space objects, ASID pool objects, and VCPU objects. These definitions ensure that the system can correctly manage and allocate different types of memory and virtualization resources.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "value_type vm_level = \"if config_ARM_PA_SIZE_BITS_40 then 4 else (5::int)\"\n\ndefinition asid_pool_level :: vm_level where\n  \"asid_pool_level = maxBound\"\n\ndefinition max_pt_level :: vm_level where\n  \"max_pt_level = asid_pool_level - 1\"\n\ndefinition level_type :: \"vm_level \\<Rightarrow> pt_type\" where\n  \"level_type level \\<equiv> if level = max_pt_level then VSRootPT_T else NormalPT_T\"\n\ndeclare [[coercion_enabled]]\ndeclare [[coercion level_type]]\n\nend\n\nqualify AARCH64_A (in Arch)", "property": "VM Level Configuration: The number of virtual memory levels is determined by the configuration, with 4 levels if `config_ARM_PA_SIZE_BITS_40` is set, and 5 levels otherwise. The top level contains ASID pools, and the subsequent levels contain page tables, with the bottom level (level 0) containing only InvalidPTEs or PagePTEs.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific state", "comment": "\n  The number of levels over all virtual memory tables.\n  For AARCH64 in hyp without @{const config_ARM_PA_SIZE_BITS_40}, we have four page table\n  levels plus the ASID pool level.\n\n  The top level (with the highest number) contains ASID pools, the next levels contain the\n  top-level page tables, and level 1 page tables. The bottom-level page tables (level 0)\n  contains only InvalidPTEs or PagePTEs.\n"}
{"spec": "record arch_state =\n  arm_asid_table :: \"asid_high_index \\<rightharpoonup> obj_ref\"\n  arm_kernel_vspace :: \"AARCH64_A.arm_vspace_region_uses\"\n  arm_vmid_table :: \"AARCH64_A.vmid \\<rightharpoonup> asid\"\n  arm_next_vmid :: AARCH64_A.vmid\n  arm_us_global_vspace :: \"obj_ref\"\n  arm_current_vcpu    :: \"(obj_ref \\<times> bool) option\"\n  arm_gicvcpu_numlistregs :: nat\n\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)", "property": "Architecture-Specific State: The `arch_state` record maintains architecture-specific data for the AARCH64 system, including ASID tables, kernel virtual space, VMID tables, the next VMID, a global user-space virtual space, the current VCPU (with an active flag), and the number of GICvCPU list registers. This ensures that the system can manage and track the state of virtual memory, virtual CPUs, and interrupt handling effectively.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable (a_pt_t : pt_type)\n  | AVCPU\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\" where\n  \"aa_type ao \\<equiv> case ao of\n     PageTable pt    \\<Rightarrow> APageTable (pt_type pt)\n   | DataPage dev sz \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n   | ASIDPool _      \\<Rightarrow> AASIDPool\n   | VCPU _          \\<Rightarrow> AVCPU\"\n\ndefinition badge_bits :: nat where\n  \"badge_bits \\<equiv> 64\"\n\nend", "property": "AARCH64-Specific Data Types: Defines a set of data types specific to the AARCH64 architecture, including AASIDPool, APageTable, AVCPU, AUserData, and ADeviceData, each with specific attributes. The `aa_type` function maps an architectural kernel object to its corresponding AARCH64-specific type, ensuring that the object's properties are correctly represented.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "qualify AARCH64_A (in Arch)", "property": "AARCH64-Specific TCB Data Types: Define and qualify AARCH64-specific data types for the TCB, including VCPU, to ensure proper handling and representation of architecture-specific thread control block information.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Arch-specific TCB", "comment": ""}
{"spec": "record arch_tcb =\n  tcb_context :: user_context\n  tcb_vcpu    :: \"obj_ref option\"\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition default_arch_tcb :: arch_tcb where\n  \"default_arch_tcb \\<equiv> \\<lparr>tcb_context = new_context, tcb_vcpu = None\\<rparr>\"", "property": "Arch-specific TCB: The architecture-specific part of a TCB includes a user context and an optional VCPU reference, ensuring that the TCB can manage both the user-level state and virtual CPU associations.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Arch-specific TCB", "comment": " Arch-specific part of a TCB: this must have at least a field for user context. "}
{"spec": "definition arch_tcb_context_set :: \"user_context \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\" where\n  \"arch_tcb_context_set uc a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := uc \\<rparr>\"\n\ndefinition arch_tcb_context_get :: \"arch_tcb \\<Rightarrow> user_context\" where\n  \"arch_tcb_context_get a_tcb \\<equiv> tcb_context a_tcb\"", "property": "Access and Modify TCB Context: Provides functions to set and get the user context within the architecture-specific TCB, ensuring compatibility with the user monad for operations that need to be performed on behalf of a user.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n  Accessors for @{text \"tcb_context\"} inside @{text \"arch_tcb\"}. These are later used to\n  implement @{text as_user}, i.e.\\ need to be compatible with @{text user_monad}.\n"}
{"spec": "definition arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\" where\n  \"arch_tcb_set_registers regs a_tcb \\<equiv>\n    a_tcb \\<lparr> tcb_context := UserContext (fpu_state (tcb_context a_tcb)) regs \\<rparr>\"\n\ndefinition arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\" where\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\nend", "property": "Access and Modify User Registers: Provides functions to set and get the user registers in the architecture-specific TCB, ensuring that the FPU state is preserved when updating the register values.", "title": "./spec/abstract/AARCH64/Arch_Structs_A.thy", "chapter": "AARCH64-Specific Data Types", "section": "Arch-specific TCB", "comment": "\n  Accessors for the user register part of the @{text \"arch_tcb\"}.\n  (Because @{typ \"register \\<Rightarrow> machine_word\"} might not be equal to @{typ user_context}).\n"}
{"spec": "chapter \\<open>Architecture-specific Fault-handling Functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\" where\n  \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData)\n   od\"\n| \"make_arch_fault_msg (VCPUFault hsr) thread = return (7, [hsr])\"\n| \"make_arch_fault_msg (VPPIEvent irq) thread = return (8, [ucast irq])\"\n| \"make_arch_fault_msg (VGICMaintenance archData) thread = do\n      msg \\<leftarrow> return $ (case archData of None \\<Rightarrow> [-1] | Some idx \\<Rightarrow> [idx]);\n      return (6, msg)\n   od\"\n\ndefinition handle_arch_fault_reply ::\n  \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\n  where\n  \"handle_arch_fault_reply vmf thread x y \\<equiv> return True\"\n\nend\nend", "property": "Generate Architecture-specific Fault Messages: Construct messages for different types of architecture-specific faults, including VMFault, VCPUFault, VPPIEvent, and VGICMaintenance. These messages contain relevant fault data and are formatted according to the specific fault type.", "title": "./spec/abstract/AARCH64/ArchFault_A.thy", "chapter": "Architecture-specific Fault-handling Functions", "section": "", "comment": ""}
{"spec": "chapter \\<open>Architecture-specific TCB functions\\<close>\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\" where\n  \"sanitise_register b r v \\<equiv> case r of\n     SPSR_EL1 \\<Rightarrow> if b \\<and> v && 0x1f \\<in> {0,4,5} then v else v && 0xf0000000 || 0x140\n   | _ \\<Rightarrow> v\"\n\ndefinition arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\" where\n  \"arch_get_sanitise_register_info t \\<equiv> do\n     vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n     return (vcpu \\<noteq> None)\n   od\"\n\ndefinition arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\" where\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "Architecture-specific TCB Functions: Sanitize and manage thread control block (TCB) registers based on architecture-specific rules. The sanitization process ensures that specific register values are modified to maintain system integrity, and the post-modification process updates the state accordingly.", "title": "./spec/abstract/AARCH64/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "definition update_cnode_cap_data :: \"data \\<Rightarrow> nat \\<times> data\" where\n  \"update_cnode_cap_data w \\<equiv>\n     let\n       guard_bits = 58;\n       guard_size' = unat ((w >> cnode_padding_bits) && mask cnode_guard_size_bits);\n       guard'' = (w >> (cnode_padding_bits + cnode_guard_size_bits)) && mask guard_bits\n     in (guard_size', guard'')\"", "property": "Update CNode Capability Data: Extract new guard size and guard bits from the provided data, ensuring that the CNode capability is modified according to the user's request.", "title": "./spec/abstract/AARCH64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "On a user request to modify a CNode capability, extract new guard bits and guard."}
{"spec": "definition arch_is_physical :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_is_physical cap \\<equiv> case cap of ASIDControlCap \\<Rightarrow> False | _ \\<Rightarrow> True\"", "property": "Architectural Capability Physicality: Distinguish between physical and non-physical architectural capabilities, where an ASIDControlCap is considered non-physical, and all other architectural capabilities are considered physical.", "title": "./spec/abstract/AARCH64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "For some purposes capabilities to physical objects are treated differently to others."}
{"spec": "fun arch_same_region_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n  \"arch_same_region_as (FrameCap r _ sz _ _) c' =\n   (is_FrameCap c' \\<and>\n     (let\n        r' = acap_obj c';\n        sz' = acap_fsize c';\n        topA = r + (1 << pageBitsForSize sz) - 1;\n        topB = r' + (1 << pageBitsForSize sz') - 1\n      in r \\<le> r' \\<and> topA \\<ge> topB \\<and> r' \\<le> topB))\"\n| \"arch_same_region_as (PageTableCap r pt_t _) c' = (\\<exists>r' d'. c' = PageTableCap r' pt_t d' \\<and> r = r')\"\n| \"arch_same_region_as ASIDControlCap c' = (c' = ASIDControlCap)\"\n| \"arch_same_region_as (ASIDPoolCap r _) c' = (\\<exists>r' d'. c' = ASIDPoolCap r' d' \\<and> r = r')\"\n| \"arch_same_region_as (VCPUCap r) c' = (\\<exists>r'. c' = VCPUCap r' \\<and> r = r')\"", "property": "Check Capabilities for Same Region: Determine if two architecture capabilities refer to the same memory region or object. This involves comparing their base addresses and sizes for frame capabilities, and checking for exact matches for other types of capabilities such as page table, ASID control, ASID pool, and VCPU.", "title": "./spec/abstract/AARCH64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Check whether the second capability is to the same object or an object\n  contained in the region of the first one.\n"}
{"spec": "definition same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n  \"same_aobject_as cap cap' \\<equiv>\n     case (cap, cap') of\n       (FrameCap ref _ sz dev _, FrameCap ref' _ sz' dev' _) \\<Rightarrow>\n         (dev, ref, sz) = (dev', ref', sz') \\<and> ref \\<le> ref + 2 ^ pageBitsForSize sz - 1\n     | _ \\<Rightarrow> arch_same_region_as cap cap'\"\n\ndeclare same_aobject_as_def[simp]\n\ndefinition arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\" where\n  \"arch_is_cap_revocable new_cap src_cap \\<equiv> False\"\n\nend\nend", "property": "Check Arch Capabilities for Same Object: Determine if two architecture capabilities refer to the same object by comparing their references, sizes, and device identifiers. If they are frame capabilities, ensure that the references and sizes match and that the reference is within the valid range; otherwise, use a general region comparison.", "title": "./spec/abstract/AARCH64/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "type_synonym obj_ref         = machine_word\ntype_synonym vspace_ref      = machine_word\n\ntype_synonym data            = machine_word\ntype_synonym cap_ref         = \"bool list\"\ntype_synonym length_type     = machine_word\n\ntype_synonym asid_low_len    = 9\ntype_synonym asid_low_index  = \"asid_low_len word\"\n\ntype_synonym asid_high_len   = 7\ntype_synonym asid_high_index = \"asid_high_len word\"\n\ntype_synonym asid_len        = 16\ntype_synonym asid_rep_len    = asid_len\ntype_synonym asid            = \"asid_rep_len word\"\n\ntype_synonym vmid            = \"8 word\"", "property": "Type Instantiation for AARCH64: Defines concrete types for abstract type names such as object references, virtual space references, data, capability references, and length types, specific to the AARCH64 architecture. This includes detailed bit-length specifications for ASID (Address Space Identifier) components and VMID (Virtual Machine Identifier).", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object references, user pointers,\n  word-based data, cap references, and so on. This theory provides an instantiation of these names\n  to concrete types for the AARCH64 architecture. Other architectures may have slightly different\n  instantiations.\n"}
{"spec": "definition oref_to_data :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition data_to_oref :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition vref_to_data :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition data_to_vref :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition nat_to_len :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition data_to_nat :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition data_to_16 :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Convert between different data types, including object references, virtual space references, natural numbers, lengths, and various word sizes, using identity functions, type casting, and bitwise operations.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  With the definitions above, most conversions between abstract type names boil down to just\n  the identity function, some convert from @{text word} to @{typ nat} and others between different\n  word sizes using @{const ucast}.\n"}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversion Simplifications: Define and simplify conversions between data representations, including object references, virtual references, natural numbers, 16-bit values, and capability pointers. These simplifications facilitate automatic unfolding in proofs, ensuring consistent and efficient data handling.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition slot_bits :: nat where\n  \"slot_bits \\<equiv> 5\"\n\ndefinition msg_label_bits :: nat where\n  [simp]: \"msg_label_bits \\<equiv> 52\"\n\ndefinition new_context :: \"user_context\" where\n  \"new_context \\<equiv> UserContext (FPUState (\\<lambda>_. 0) 0 0) ((\\<lambda>_. 0) (SPSR_EL1 := pstateUser))\"", "property": "Architecture-Dependent Sizes: Define the standard sizes for slots and message labels, as well as the initial state for a new user context. These definitions ensure that the system adheres to the specific architectural constraints of the underlying machine.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The following definitions provide architecture-dependent sizes such as the standard page\n  size and capability size of the underlying machine.\n"}
{"spec": "definition pptr_base :: \"machine_word\" where\n  \"pptr_base = Platform.AARCH64.pptrBase\"\n\ntext \"Virtual address space available to users.\"\ndefinition user_vtop :: \"machine_word\" where\n  \"user_vtop = Platform.AARCH64.pptrUserTop\"", "property": "Kernel Virtual Address Reservation: The kernel reserves a range of virtual addresses starting from the lowest virtual address in the kernel window, ensuring that these addresses are not available for user processes.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The lowest virtual address in the kernel window. The kernel reserves the virtual addresses\n  from here up in every virtual address space.\n"}
{"spec": "definition kdev_base :: \"machine_word\" where\n  \"kdev_base = Platform.AARCH64.kdevBase\"", "property": "Virtual Address for Kernel Device Mapping: The `kdev_base` is defined as the starting virtual address for the kernel device mapping region, located in the highest 1GiB of memory.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  Virtual address for start of kernel device mapping region in highest 1GiB of memory.\n"}
{"spec": "definition kernel_elf_base :: \"vspace_ref\" where\n  \"kernel_elf_base \\<equiv> Platform.AARCH64.kernelELFBase\"", "property": "Kernel ELF Base: Defines the virtual address at which the kernel code is mapped in the virtual address space.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The virtual address the kernel code is mapped.\n"}
{"spec": "definition idle_thread_ptr :: vspace_ref where\n  \"idle_thread_ptr = pptr_base + 0x1000\"\n\n\ndefinition nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\" where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len) (to_bl (of_nat n :: machine_word))\"\n\ndefinition msg_info_register :: register where\n  \"msg_info_register \\<equiv> msgInfoRegister\"\n\ndefinition msg_registers :: \"register list\" where\n  \"msg_registers \\<equiv> msgRegisters\"\n\ndefinition cap_register :: register where\n  \"cap_register \\<equiv> capRegister\"\n\ndefinition badge_register :: register where\n  \"badge_register \\<equiv> badgeRegister\"\n\ndefinition frame_registers :: \"register list\" where\n  \"frame_registers \\<equiv> frameRegisters\"\n\ndefinition gp_registers :: \"register list\" where\n  \"gp_registers \\<equiv> gpRegisters\"\n\ndefinition exception_message :: \"register list\" where\n  \"exception_message \\<equiv> exceptionMessage\"\n\ndefinition syscall_message :: \"register list\" where\n  \"syscall_message \\<equiv> syscallMessage\"\n\ndatatype arch_fault\n  = VMFault (vm_fault_address : vspace_ref) (vm_fault_arch_data : \"machine_word list\")\n  | VCPUFault (vcpu_hsr : data)\n  | VPPIEvent (vppi_irq : irq)\n  | VGICMaintenance (vgic_maintenance_data : \"data option\")\n\n\nend\n\narch_requalify_consts (A) idle_thread_ptr\n\nend", "property": "Idle Thread Pointer Definition: Defines an arbitrary aligned address for the idle thread, which must exist but does not need to match a specific concrete value in the C implementation.", "title": "./spec/abstract/AARCH64/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  Currently an arbitrary aligned address for the idle thread.\n  Only has to exist, does not have to match up with the concrete value in C.\n"}
{"spec": "consts\n  register_mask :: \"machine_word option\" (* no need for option? *)\n\n\ncontext Arch begin arch_global_naming (A)", "property": "Register Masking: Ensures that certain bits in the registers are preserved and cannot be written by the user, maintaining the integrity of specific register parts.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": "\n  Some parts of some registers cannot be written by the user.\n  Bits set in the mask will be preserved (used in vcpu\\_write\\_register).\n"}
{"spec": "text \\<open>\n  This is used by some decode functions. VCPU decode functions are the first that need to bounds\n  check IRQs from the user.\n  \\<close>\n\ndefinition\n  arch_check_irq :: \"data \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n  \"arch_check_irq irq \\<equiv> whenE (irq > maxIRQ) $ throwError (RangeError 0 maxIRQ)\"", "property": "Architectural IRQ Validation: Ensures that the provided IRQ number is within the valid range, throwing a `RangeError` if the IRQ exceeds the maximum allowed value.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition decode_vcpu_set_tcb :: \"arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere \"decode_vcpu_set_tcb cap extras \\<equiv> case (cap, extras) of\n  (VCPUCap v, fs#_) \\<Rightarrow> (case fs of\n        (ThreadCap t, _) \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUSetTCB v t\n      | _ \\<Rightarrow> throwError IllegalOperation)\n |(VCPUCap v, _) \\<Rightarrow> throwError TruncatedMessage\n | _ \\<Rightarrow> throwError IllegalOperation\"", "property": "VCPU Set TCB: Decodes the VCPU capability and sets the TCB for a VCPU. Ensures that the operation is only valid if the provided capability is a VCPU capability and the extra slot contains a thread capability, otherwise it throws an error.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition\n  read_vcpu_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (machine_word,'z::state_ext) s_monad\"\nwhere\n  \"read_vcpu_register vcpu_ptr reg \\<equiv> do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     (on_cur_vcpu, active) \\<leftarrow> return (case cur_vcpu of\n         Some (vcpu_ptr', a) \\<Rightarrow> (vcpu_ptr' = vcpu_ptr, a)\n       | _ \\<Rightarrow> (False, False));\n\n     if on_cur_vcpu\n       then if vcpuRegSavedWhenDisabled reg \\<and> \\<not>active\n              then vcpu_read_reg vcpu_ptr reg\n              else do_machine_op $ readVCPUHardwareReg reg\n       else vcpu_read_reg vcpu_ptr reg\n  od\"\n\ndefinition\n  write_vcpu_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"write_vcpu_register vcpu_ptr reg val \\<equiv>\n  do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu o arch_state);\n     (on_cur_vcpu, active) \\<leftarrow> return (case cur_vcpu of\n         Some (cv, a) \\<Rightarrow> (cv = vcpu_ptr, a)\n       | _ \\<Rightarrow> (False, False));\n\n     if on_cur_vcpu\n       then if vcpuRegSavedWhenDisabled reg \\<and> \\<not>active\n         then vcpu_write_reg vcpu_ptr reg val\n         else do_machine_op $ writeVCPUHardwareReg reg val\n       else vcpu_write_reg vcpu_ptr reg val\n  od\"\n\ndefinition decode_vcpu_read_register :: \"machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_vcpu_read_register args cap \\<equiv> case (args, cap) of\n      (reg#_, VCPUCap p) \\<Rightarrow> if fromEnum (maxBound::vcpureg) < unat reg\n                           then throwError (InvalidArgument 1)\n                           else returnOk $ InvokeVCPU $ VCPUReadRegister p $ toEnum (unat reg)\n    | (_, _) \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition decode_vcpu_write_register :: \"machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_vcpu_write_register args cap \\<equiv> case (args, cap) of\n    (reg#val#_, VCPUCap p) \\<Rightarrow> if fromEnum (maxBound::vcpureg) < unat reg\n                              then throwError (InvalidArgument 1)\n                              else returnOk $ InvokeVCPU $ VCPUWriteRegister p (toEnum (unat reg)) val\n  | (_, _) \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_read_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (data list, 'z::state_ext) s_monad\"\nwhere \"invoke_vcpu_read_register v reg \\<equiv> do\n   val \\<leftarrow> read_vcpu_register v reg;\n   return [val]\nod\"\n\ndefinition\n  invoke_vcpu_write_register :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"invoke_vcpu_write_register v reg val \\<equiv>  write_vcpu_register v reg val\"", "property": "VCPU Register Access: Provides mechanisms to read and write VCPU registers, ensuring that the appropriate method is used based on whether the VCPU is the current one and its active state. If the VCPU is the current one and the register is saved when disabled, it uses specific read/write functions; otherwise, it accesses the hardware directly.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "definition make_virq :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> virq\" where\n  \"make_virq grp prio irq \\<equiv>\n  let\n    groupShift = 30;\n    prioShift = 23;\n    irqPending = 1 << 28;\n    eoiirqen = 1 << 19\n  in ((grp && 1) << groupShift) || ((prio && 0x1F) << prioShift) || (irq && 0x3FF) || irqPending || eoiirqen\"\n\n\ndefinition decode_vcpu_inject_irq :: \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_vcpu_inject_irq ptrs cap \\<equiv> case (ptrs, cap) of\n  (mr0 # mr1 # _, VCPUCap p) \\<Rightarrow> doE\n     vid \\<leftarrow> returnOk (mr0 && 0xFFFF);\n     priority \\<leftarrow> returnOk ((mr0 >> 16) && 0xFF);\n     group \\<leftarrow> returnOk ((mr0 >> 24) && 0xFF);\n     index \\<leftarrow> returnOk (mr1 && 0xFF);\n     range_check vid 0 ((1 << 10) - 1);\n     range_check priority 0 31;\n     range_check group 0 1;\n     num_list_regs \\<leftarrow> liftE $ gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     whenE (index \\<ge> of_nat num_list_regs) $\n        (throwError $ RangeError 0 (of_nat num_list_regs - 1));\n\n     vcpu \\<leftarrow> liftE $ get_vcpu p;\n     vcpuLR \\<leftarrow> returnOk (vgic_lr $ vcpu_vgic $ vcpu);\n\n     whenE (vcpuLR (unat index) && vgic_irq_mask = vgic_irq_active) $ throwError DeleteFirst;\n\n     virq \\<leftarrow> returnOk (make_virq group priority vid);\n     returnOk $ InvokeVCPU $ VCPUInjectIRQ p (unat index) virq\n  odE\n| _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition\n  invoke_vcpu_inject_irq :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> virq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"invoke_vcpu_inject_irq vr index virq \\<equiv> do\n    cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n    if (cur_v \\<noteq> None \\<and> fst (the cur_v) = vr)\n    then do_machine_op $ set_gic_vcpu_ctrl_lr (of_nat index) virq\n    else vgic_update_lr vr index virq\n   od\"", "property": "VCPU Interrupt Injection: Decode and inject a virtual interrupt into a VCPU. The function extracts the virtual interrupt ID, priority, group, and index from the provided parameters, performs range checks, and constructs a virtual interrupt (virq) to be injected. If the VCPU is the current VCPU, it sets the GIC VCPU control register; otherwise, it updates the VCPU's local register.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": " This following function does not correspond to exactly what the C does, but\nit is the value that is stored inside of lr in the vgic  "}
{"spec": "definition decode_vcpu_ack_vppi ::\n  \"obj_ref list \\<Rightarrow> arch_cap \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\n  where\n  \"decode_vcpu_ack_vppi mrs cap \\<equiv>\n     case (mrs, cap)\n       of (mr0 # _, VCPUCap vcpu_ptr) \\<Rightarrow> doE\n           arch_check_irq mr0;\n           (case irq_vppi_event_index (ucast mr0)\n            of None \\<Rightarrow> throwError $ InvalidArgument 0\n             | Some vppi \\<Rightarrow> returnOk $ InvokeVCPU $ VCPUAckVPPI vcpu_ptr vppi)\n         odE\n       | _ \\<Rightarrow> throwError TruncatedMessage\"\n\ndefinition invoke_vcpu_ack_vppi :: \"obj_ref \\<Rightarrow> vppievent_irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"invoke_vcpu_ack_vppi vcpu_ptr vppi =\n     vcpu_update vcpu_ptr\n                 (\\<lambda>vcpu. vcpu\\<lparr> vcpu_vppi_masked := (vcpu_vppi_masked vcpu)(vppi := False) \\<rparr>)\"", "property": "Acknowledge VCPU VPPI: The system acknowledges a VPPI (Virtual Platform Performance Interrupt) event for a VCPU by unmasking the corresponding VPPI in the VCPU's state, allowing the VCPU to handle the interrupt.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": "VCPU : acknowledge VPPI"}
{"spec": "definition\nperform_vcpu_invocation :: \"vcpu_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n\"perform_vcpu_invocation iv \\<equiv> case iv of\n    VCPUSetTCB vcpu tcb \\<Rightarrow> do associate_vcpu_tcb vcpu tcb; return [] od\n  | VCPUReadRegister vcpu reg \\<Rightarrow> invoke_vcpu_read_register vcpu reg\n  | VCPUWriteRegister vcpu reg val \\<Rightarrow> do invoke_vcpu_write_register vcpu reg val; return [] od\n  | VCPUInjectIRQ vcpu index vir \\<Rightarrow> do invoke_vcpu_inject_irq vcpu index vir; return [] od\n  | VCPUAckVPPI vcpu vppi \\<Rightarrow> do invoke_vcpu_ack_vppi vcpu vppi; return [] od\"\n\n\ndefinition decode_vcpu_invocation ::\n\"machine_word \\<Rightarrow> machine_word list \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow> (arch_invocation,'z::state_ext) se_monad\"\nwhere\n\"decode_vcpu_invocation label args cap extras \\<equiv> case cap of\nVCPUCap _ \\<Rightarrow> (case invocation_type label of\n    ArchInvocationLabel ARMVCPUSetTCB \\<Rightarrow> decode_vcpu_set_tcb cap extras\n  | ArchInvocationLabel ARMVCPUReadReg \\<Rightarrow> decode_vcpu_read_register args cap\n  | ArchInvocationLabel ARMVCPUWriteReg \\<Rightarrow> decode_vcpu_write_register args cap\n  | ArchInvocationLabel ARMVCPUInjectIRQ \\<Rightarrow> decode_vcpu_inject_irq args cap\n  | ArchInvocationLabel ARMVCPUAckVPPI \\<Rightarrow> decode_vcpu_ack_vppi args cap\n  |  _ \\<Rightarrow> throwError IllegalOperation)\n| _ \\<Rightarrow> throwError IllegalOperation\"\n\nend\n\nend", "property": "VCPU Invocation and Decoding: Supports VCPU operations including setting the associated TCB, reading and writing registers, injecting IRQs, and acknowledging VPPIs. These operations are decoded from the invocation type and arguments, ensuring that the VCPU can perform and manage its state effectively.", "title": "./spec/abstract/ARM_HYP/VCPU_A.thy", "chapter": "", "section": "", "comment": "VCPU perform and decode main functions"}
{"spec": "definition\n  virqSetEOIIRQEN :: \"virq \\<Rightarrow> 32 word \\<Rightarrow> virq\"\nwhere\n  \"virqSetEOIIRQEN virq v =\n    (if ((virq >> 28) && 3 = 3)\n    then virq\n    else (virq && ~~0x80000) || ((v << 19) && 0x80000))\"\n\ndefinition\n  vgic_maintenance :: \"(unit,'z::state_ext) s_monad\"\nwhere\n  \"vgic_maintenance = do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     case cur_vcpu\n       of Some (vcpu_ptr, True) \\<Rightarrow> do\n            eisr0 \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_eisr0;\n            eisr1 \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_eisr1;\n            flags \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_misr;\n            vgic_misr_eoi \\<leftarrow> return $ 1;\n            irq_idx \\<leftarrow> return (if eisr0 \\<noteq> 0 then word_ctz eisr0 else word_ctz eisr1 + 32);\n            gic_vcpu_num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs o arch_state);\n            fault \\<leftarrow> if flags && vgic_misr_eoi \\<noteq> 0\n                    then\n                      if eisr0 = 0 \\<and> eisr1 = 0 \\<or> irq_idx \\<ge> gic_vcpu_num_list_regs\n                      then return $ VGICMaintenance None\n                      else do\n                        virq <- do_machine_op $ get_gic_vcpu_ctrl_lr (of_nat irq_idx);\n                        virqen <- return $ virqSetEOIIRQEN virq 0;\n                        do_machine_op $ set_gic_vcpu_ctrl_lr (of_nat irq_idx) virqen;\n                        vgic_update_lr vcpu_ptr irq_idx virqen;\n                        return $ VGICMaintenance $ Some $ of_nat irq_idx\n                      od\n                    else return $ VGICMaintenance None;\n\n            ct \\<leftarrow> gets cur_thread;\n            st \\<leftarrow> get_thread_state ct;\n            \\<comment> \\<open>until a proof links active current vcpu to runnable current thread, we need this\n               check: @{term handle_fault} needs a runnable current thread\\<close>\n            when (runnable st) $ handle_fault ct $ ArchFault fault\n          od\n        | _ \\<Rightarrow> return ()\n   od\"\n\ndefinition vppi_event :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"vppi_event irq = do\n     cur_vcpu \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     case cur_vcpu\n       of Some (vcpu_ptr, True) \\<Rightarrow> do\n            do_machine_op $ maskInterrupt True irq;\n            vppi \\<leftarrow> return $ the $ irq_vppi_event_index irq;\n            vcpu_update vcpu_ptr\n                        (\\<lambda>vcpu. vcpu\\<lparr> vcpu_vppi_masked := (vcpu_vppi_masked vcpu)(vppi := True) \\<rparr>);\n            ct \\<leftarrow> gets cur_thread;\n            st \\<leftarrow> get_thread_state ct;\n            \\<comment> \\<open>until a proof links active current vcpu to runnable current thread, we need this\n               check: @{term handle_fault} needs a runnable current thread\\<close>\n            when (runnable st) $ handle_fault ct $ ArchFault $ VPPIEvent irq\n          od\n        | _ \\<Rightarrow> return ()\n   od\"\n\ndefinition\n  handle_reserved_irq :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"handle_reserved_irq irq \\<equiv>\n     if irq = irqVGICMaintenance then vgic_maintenance\n     else if irq_vppi_event_index irq \\<noteq> None then vppi_event irq\n     else return ()\"\n\nfun arch_invoke_irq_handler :: \"irq_handler_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"arch_invoke_irq_handler (ACKIrq irq) = (do_machine_op $ maskInterrupt False irq)\"\n| \"arch_invoke_irq_handler _ = return ()\"\n\ndefinition arch_mask_irq_signal :: \"irq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"arch_mask_irq_signal irq \\<equiv> do_machine_op $ maskInterrupt True irq\"\n\nend\n\nend", "property": "VGIC Maintenance: Manages the VGIC (Virtual Generic Interrupt Controller) by handling maintenance interrupts, updating the EOI (End of Interrupt) status, and managing virtual IRQs. It ensures that the current vCPU's state is updated and any faults are handled if the current thread is runnable. Additionally, it processes VPPIs (Virtual Physical Peripheral Interrupts) by masking the interrupt and updating the vCPU's VPPi masked state.", "title": "./spec/abstract/ARM_HYP/ArchInterrupt_A.thy", "chapter": "", "section": "", "comment": "VGIC Maintenance"}
{"spec": "definition\n  arch_switch_to_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_switch_to_thread t \\<equiv> do\n     t' \\<leftarrow> gets_the $ get_tcb t;\n     vcpu_switch $ tcb_vcpu $ tcb_arch t';\n     set_vm_root t;\n     do_machine_op $ clearExMonitor\n   od\"", "property": "Switch to Thread's Virtual Address Space: Switch the virtual address space context to the specified thread, update the VCPU state, and clear the load-exclusive monitor.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "Switch to a thread's virtual address space context. Clear the load-exclusive monitor."}
{"spec": "definition\n   arch_switch_to_idle_thread :: \"(unit,'z::state_ext) s_monad\" where\n   \"arch_switch_to_idle_thread \\<equiv> do\n     vcpu_switch None;\n     t \\<leftarrow> gets idle_thread;\n     set_vm_root t\n   od\"\n\ndefinition\n  arch_activate_idle_thread :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"arch_activate_idle_thread t \\<equiv> return ()\"", "property": "Idle Thread Management: The system switches to the idle thread by updating the virtual machine root, and no special handling is required for activating the idle thread.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The idle thread does not need to be handled specially on ARM."}
{"spec": "definition\nperform_asid_control_invocation :: \"asid_control_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_control_invocation iv \\<equiv> case iv of\n  MakePool frame slot parent base \\<Rightarrow> do\n    delete_objects frame page_bits;\n    pcap \\<leftarrow> get_cap parent;\n    set_cap (max_free_index_update pcap) parent;\n    retype_region frame 1 0 (ArchObject ASIDPoolObj) False;\n    cap_insert (ArchObjectCap $ ASIDPoolCap frame base) parent slot;\n    assert (base && mask asid_low_bits = 0);\n    asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base \\<mapsto> frame));\n    modify (\\<lambda>s. s \\<lparr>arch_state := (arch_state s) \\<lparr>arm_asid_table := asid_table'\\<rparr>\\<rparr>)\nod\"", "property": "ASID Control: Create a new ASID pool object, provide a capability to it, and connect it to the global virtual ASID table. This ensures that the new ASID pool is properly initialized and integrated into the system's memory management.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDControl capability confers the authority to create a new ASID\npool object. This operation creates the new ASID pool, provides a capability\nto it and connects it to the global virtual ASID table."}
{"spec": "definition\nperform_asid_pool_invocation :: \"asid_pool_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_asid_pool_invocation iv \\<equiv> case iv of Assign asid pool_ptr ct_slot \\<Rightarrow>\ndo\n    pd_cap \\<leftarrow> get_cap ct_slot;\n    case pd_cap of\n      ArchObjectCap (PageDirectoryCap pd_base _) \\<Rightarrow> do\n        pool \\<leftarrow> get_asid_pool pool_ptr;\n        pool' \\<leftarrow> return (pool (ucast asid \\<mapsto> pd_base));\n        set_cap (ArchObjectCap $ PageDirectoryCap pd_base (Some asid)) ct_slot;\n        set_asid_pool pool_ptr pool'\n      od\n    | _ \\<Rightarrow> fail\nod\"", "property": "Assign ASID to Page Directory: The ASIDPool capability allows the assignment of a virtual ASID to a page directory. This involves updating the page directory's ASID and the ASID pool with the new mapping, ensuring that the page directory is correctly associated with the specified ASID.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The ASIDPool capability confers the authority to assign a virtual ASID\nto a page directory."}
{"spec": "definition\n  perform_page_directory_invocation :: \"page_directory_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"perform_page_directory_invocation iv \\<equiv> case iv of\n       PageDirectoryFlush typ start end pstart pd asid \\<Rightarrow>\n         when (start < end) $ do\n           root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n           do_machine_op $ do_flush typ start end pstart;\n           when root_switched $ do\n             tcb \\<leftarrow> gets cur_thread;\n             set_vm_root tcb\n           od\n        od\n     | PageDirectoryNothing \\<Rightarrow> return ()\"\n\ndefinition\n  pte_check_if_mapped :: \"32 word \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pte_check_if_mapped slot \\<equiv> do\n     pt \\<leftarrow> get_master_pte slot;\n     return (pt \\<noteq> InvalidPTE)\n  od\"\n\ndefinition\n  pde_check_if_mapped :: \"32 word \\<Rightarrow> (bool, 'z::state_ext) s_monad\"\nwhere\n  \"pde_check_if_mapped slot \\<equiv> do\n     pd \\<leftarrow> get_master_pde slot;\n     return (pd \\<noteq> InvalidPDE)\n  od\"", "property": "Page Directory Invocation: Allows the invocation of operations on a page directory, such as flushing cache entries within a specified range. The operation ensures that the virtual machine root is correctly set and restored if necessary, maintaining the integrity and consistency of the memory management system.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The PageDirectory capability confers the authority to flush cache entries\nassociated with that PD"}
{"spec": "definition\nperform_page_invocation :: \"page_invocation \\<Rightarrow> (data list,'z::state_ext) s_monad\" where\n\"perform_page_invocation iv \\<equiv> case iv of\n  PageMap asid cap ct_slot entries \\<Rightarrow> do\n    set_cap cap ct_slot;\n    case entries of\n          Inl (pte, slots) \\<Rightarrow> do\n            flush \\<leftarrow> pte_check_if_mapped (hd slots);\n            store_pte (hd slots) pte;\n            mapM (swp store_pte InvalidPTE) (tl slots);\n            do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pte (last slots))\n                                                (addrFromPPtr (hd slots));\n            if flush then (invalidate_tlb_by_asid asid) else return ()\n          od\n        | Inr (pde, slots) \\<Rightarrow> do\n            flush \\<leftarrow> pde_check_if_mapped (hd slots);\n            store_pde (hd slots) pde;\n            mapM (swp store_pde InvalidPDE) (tl slots);\n            do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pde (last slots))\n                                                (addrFromPPtr (hd slots));\n            if flush then (invalidate_tlb_by_asid asid) else return ()\n          od;\n    return []\n  od\n| PageUnmap cap ct_slot \\<Rightarrow>\n    (case cap of\n      PageCap dev p R vp_size vp_mapped_addr \\<Rightarrow> do\n        case vp_mapped_addr of\n            Some (asid, vaddr) \\<Rightarrow> unmap_page vp_size asid vaddr p\n          | None \\<Rightarrow> return ();\n        cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n        set_cap (ArchObjectCap $ update_map_data cap None) ct_slot;\n        return []\n      od\n    | _ \\<Rightarrow> fail)\n| PageFlush typ start end pstart pd asid \\<Rightarrow> do\n    when (start < end) $ do\n      root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n      do_machine_op $ do_flush typ start end pstart;\n      when root_switched $ do\n        tcb \\<leftarrow> gets cur_thread;\n        set_vm_root tcb\n      od\n    od;\n    return []\n  od\n| PageGetAddr ptr \\<Rightarrow>\n    return [addrFromPPtr ptr]\n  \"", "property": "Page Capability Operations: Authorize the mapping, unmapping, and flushing of memory pages. Mapping involves setting the page table entries or page directory entries and updating the cache, while unmapping removes the page from the address space and updates the capability. Flushing ensures that the specified memory range is cleaned and the translation lookaside buffer (TLB) is invalidated if necessary.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "The Page capability confers the authority to map, unmap and flush the\n  memory page."}
{"spec": "definition\nperform_page_table_invocation :: \"page_table_invocation \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"perform_page_table_invocation iv \\<equiv>\ncase iv of PageTableMap cap ct_slot pde pd_slot \\<Rightarrow> do\n    set_cap cap ct_slot;\n    store_pde pd_slot pde;\n    do_machine_op $ cleanByVA_PoU pd_slot (addrFromPPtr pd_slot)\n  od\n  | PageTableUnmap (ArchObjectCap (PageTableCap p mapped_address)) ct_slot \\<Rightarrow> do\n    case mapped_address of Some (asid, vaddr) \\<Rightarrow> do\n      unmap_page_table asid vaddr p;\n      slots \\<leftarrow> return [p, p + (1 << pte_bits) .e. p + (1 << pt_bits) - 1];\n      mapM_x (swp store_pte InvalidPTE) slots;\n      do_machine_op $ cleanCacheRange_PoU p (p + (1 << pt_bits) - 1)\n                                          (addrFromPPtr p)\n    od | None \\<Rightarrow> return ();\n    cap \\<leftarrow> liftM the_arch_cap $ get_cap ct_slot;\n    set_cap (ArchObjectCap $ update_map_data cap None) ct_slot\n  od\n  | _ \\<Rightarrow> fail\"", "property": "PageTable Capabilities: Allow the mapping and unmapping of page tables. This includes setting and storing page directory entries, cleaning the cache by virtual address, unmaping page tables, invalidating page table entries, and updating the capability's mapping data.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "PageTable capabilities confer the authority to map and unmap page\ntables."}
{"spec": "definition\n  arch_perform_invocation :: \"arch_invocation \\<Rightarrow> (data list,'z::state_ext) p_monad\" where\n  \"arch_perform_invocation i \\<equiv> liftE $\n    case i of\n          InvokePageTable oper \\<Rightarrow> do perform_page_table_invocation oper; return [] od\n        | InvokePageDirectory oper \\<Rightarrow> do perform_page_directory_invocation oper; return [] od\n        | InvokePage oper \\<Rightarrow> perform_page_invocation oper\n        | InvokeASIDControl oper \\<Rightarrow> do perform_asid_control_invocation oper; return [] od\n        | InvokeASIDPool oper \\<Rightarrow> do perform_asid_pool_invocation oper; return [] od\n        | InvokeVCPU oper \\<Rightarrow> perform_vcpu_invocation oper\"\n\nend\n\nend", "property": "Architectural Invocation Dispatcher: Dispatches ARM-specific system calls to their respective handlers for page tables, page directories, pages, ASID control, ASID pools, and VCPUs. Ensures that each invocation is processed by the appropriate function, maintaining the integrity and functionality of the memory management and virtualization components.", "title": "./spec/abstract/ARM_HYP/Arch_A.thy", "chapter": "", "section": "", "comment": "Top level system call despatcher for all ARM-specific system calls."}
{"spec": "chapter \"Handle Hypervisor Fault Event\"\n\ntheory Hypervisor_A\nimports Ipc_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun handle_hypervisor_fault :: \"word32 \\<Rightarrow> hyp_fault_type \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n\"handle_hypervisor_fault thread (ARMVCPUFault hsr) =\n   handle_fault thread (ArchFault $ VCPUFault hsr)\"\n\n\nend\nend", "property": "Handle Hypervisor Fault: Processes hypervisor fault events by converting them into architecture-specific faults and handling them accordingly.", "title": "./spec/abstract/ARM_HYP/Hypervisor_A.thy", "chapter": "Handle Hypervisor Fault Event", "section": "", "comment": ""}
{"spec": "definition\n  reserve_region :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"reserve_region ptr byteLength is_kernel \\<equiv> return ()\"", "property": "Reserve Memory Region: Reserve a specified number of bytes in memory, potentially tagging the region as kernel data. The function currently acts as a placeholder and does not perform any actual reservation or tagging.", "title": "./spec/abstract/ARM_HYP/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "This is a placeholder function. We may wish to extend the specification\n  with explicitly tagging kernel data regions in memory."}
{"spec": "definition vs_apiobj_size where\n  \"vs_apiobj_size ty \\<equiv>\n     case ty of\n       ArchObject SmallPageObj \\<Rightarrow> pageBitsForSize ARMSmallPage\n     | ArchObject LargePageObj \\<Rightarrow> pageBitsForSize ARMLargePage\n     | ArchObject SectionObj \\<Rightarrow> pageBitsForSize ARMSection\n     | ArchObject SuperSectionObj \\<Rightarrow> pageBitsForSize ARMSuperSection\n     | ArchObject PageTableObj \\<Rightarrow> pt_bits\n     | ArchObject PageDirectoryObj \\<Rightarrow> pd_bits\"\n\ndefinition init_arch_objects ::\n  \"apiobject_type \\<Rightarrow> bool \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> obj_ref list \\<Rightarrow> (unit,'z::state_ext) s_monad\"\n  where\n  \"init_arch_objects new_type is_device ptr num_objects obj_sz refs \\<equiv> do\n     when (new_type = ArchObject PageDirectoryObj) $ mapM_x copy_global_mappings refs;\n     if \\<not>is_device \\<and>\n        new_type \\<in> {ArchObject SmallPageObj, ArchObject LargePageObj,\n                    ArchObject SectionObj, ArchObject SuperSectionObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_RAM ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else if new_type \\<in> {ArchObject PageTableObj, ArchObject PageDirectoryObj}\n     then\n       mapM_x (\\<lambda>ref. do_machine_op $\n                       cleanCacheRange_PoU ref (ref + mask (vs_apiobj_size new_type))\n                                           (addrFromPPtr ref))\n              refs\n     else\n       return ()\n   od\"\n\ndefinition\n  empty_context :: user_context where\n  \"empty_context \\<equiv> UserContext (\\<lambda>_. 0)\"\n\ndefinition init_arch_tcb :: arch_tcb where\n  \"init_arch_tcb \\<equiv> \\<lparr> tcb_context = empty_context, tcb_vcpu = None \\<rparr>\"\n\nend\n\nend", "property": "Initialise Architecture-Specific Objects: Initialize architecture-specific objects based on their type, including page directories, page tables, and various page sizes. The initialization process involves copying global mappings for page directories, and cleaning cache ranges for different object types to ensure proper memory management and device handling.", "title": "./spec/abstract/ARM_HYP/ArchRetype_A.thy", "chapter": "", "section": "", "comment": "Initialise architecture-specific objects."}
{"spec": "definition\n  arch_post_cap_deletion :: \"arch_cap \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arch_post_cap_deletion _ \\<equiv> return ()\"", "property": "Arch Post Cap Deletion: No specific actions are taken after a capability is deleted.", "title": "./spec/abstract/ARM_HYP/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Actions to be taken after a cap is deleted"}
{"spec": "datatype arch_gen_obj_ref = unit\n\ndefinition\n  arch_gen_obj_refs :: \"arch_cap \\<Rightarrow> arch_gen_obj_ref set\"\nwhere\n  \"arch_gen_obj_refs _ = {}\"\n\ndefinition\n  arch_cap_cleanup_opt :: \"arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_cap_cleanup_opt ac \\<equiv> NullCap\"\n\nend\nend", "property": "Arch-Specific Generic Object References: The system defines arch-specific generic object references, but they are not used in the current context, as the set of such references for any arch_cap is empty. Additionally, the cleanup operation for arch_caps results in a NullCap, indicating no specific cleanup action is defined.", "title": "./spec/abstract/ARM_HYP/ArchIpcCancel_A.thy", "chapter": "", "section": "", "comment": "Arch specific generic object references not covered by generic references"}
{"spec": "definition\n  init_tcb_ptr :: word32 where\n  \"init_tcb_ptr = kernel_base + 0x2000\"\n\ndefinition\n  init_irq_node_ptr :: word32 where\n  \"init_irq_node_ptr = kernel_base + 0x8000\"\n\ndefinition\n  init_globals_frame :: word32 where\n  \"init_globals_frame = kernel_base + 0x5000\"\n\ndefinition\n  \"us_global_pd_ptr = kernel_base + 0x60000\"\n\ndefinition\n  \"init_arch_state \\<equiv> \\<lparr>\n    arm_asid_table = Map.empty,\n    arm_hwasid_table = Map.empty,\n    arm_next_asid = 0,\n    arm_asid_map = Map.empty,\n    arm_current_vcpu = None,\n    arm_gicvcpu_numlistregs = undefined,\n    arm_kernel_vspace = (\\<lambda>ref.\n      if ref \\<in> {kernel_base .. kernel_base + mask 20}\n      then ArmVSpaceKernelWindow\n      else ArmVSpaceInvalidRegion),\n    arm_us_global_pd = us_global_pd_ptr\n  \\<rparr>\"\n\ndefinition [simp]: \"us_global_pd \\<equiv> ArchObj (PageDirectory (\\<lambda>_. InvalidPDE))\"\n\ndefinition\n  \"init_kheap \\<equiv>\n  (\\<lambda>x. if \\<exists>irq :: irq. init_irq_node_ptr + (ucast irq << cte_level_bits) = x\n       then Some (CNode 0 (empty_cnode 0)) else None)\n  (idle_thread_ptr \\<mapsto> TCB \\<lparr>\n    tcb_ctable = NullCap,\n    tcb_vtable = NullCap,\n    tcb_reply = NullCap,\n    tcb_caller = NullCap,\n    tcb_ipcframe = NullCap,\n    tcb_state = IdleThreadState,\n    tcb_fault_handler = replicate word_bits False,\n    tcb_ipc_buffer = 0,\n    tcb_fault = None,\n    tcb_bound_notification = None,\n    tcb_mcpriority = minBound,\n    tcb_arch = init_arch_tcb\n  \\<rparr>,\n  us_global_pd_ptr \\<mapsto> us_global_pd)\"\n\ndefinition\n  \"init_cdt \\<equiv> Map.empty\"\n\ndefinition\n  \"init_ioc \\<equiv>\n   \\<lambda>(a,b). (\\<exists>obj. init_kheap a = Some obj \\<and>\n                  (\\<exists>cap. cap_of obj b = Some cap \\<and> cap \\<noteq> cap.NullCap))\"\n\ndefinition\n  \"init_A_st \\<equiv> \\<lparr>\n    kheap = init_kheap,\n    cdt = init_cdt,\n    is_original_cap = init_ioc,\n    cur_thread = idle_thread_ptr,\n    idle_thread = idle_thread_ptr,\n    machine_state = init_machine_state,\n    interrupt_irq_node = \\<lambda>irq. init_irq_node_ptr + (ucast irq << cte_level_bits),\n    interrupt_states = \\<lambda>_. Structures_A.IRQInactive,\n    arch_state = init_arch_state,\n    exst = ext_init\n  \\<rparr>\"\n\nend\n\n\nend", "property": "Initialization of Kernel State: The kernel initializes various components, including the idle thread, initial TCB, interrupt node, global frame, and architecture state. This setup ensures that the kernel has a well-defined starting point, with specific memory regions and data structures allocated and configured to support system operations.", "title": "./spec/abstract/ARM_HYP/Init_A.thy", "chapter": "", "section": "", "comment": " Moved to Deterministic_A\ndefinition\n  idle_thread_ptr :: word32 where\n  \"idle_thread_ptr = kernel_base + 0x1000\"\n"}
{"spec": "definition largePagePTE_offsets :: \"obj_ref list\"\n  where\n  \"largePagePTE_offsets \\<equiv>\n    let pts = of_nat pte_bits\n    in [0, 2 ^ pts  .e.  (15 << pte_bits)]\"\n\ndefinition superSectionPDE_offsets :: \"obj_ref list\"\n  where\n  \"superSectionPDE_offsets \\<equiv>\n    let pts = of_nat pde_bits\n    in [0, 2 ^ pts  .e.  (15 << pde_bits)]\"\n\nfun create_mapping_entries ::\n  \"paddr \\<Rightarrow> vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vm_rights \\<Rightarrow> vm_attributes \\<Rightarrow> word32 \\<Rightarrow>\n  ((pte * word32 list) + (pde * word32 list),'z::state_ext) se_monad\"\nwhere\n  \"create_mapping_entries base vptr ARMSmallPage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (SmallPagePTE base attrib vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMLargePage vm_rights attrib pd =\n  doE\n    p \\<leftarrow> lookup_error_on_failure False $ lookup_pt_slot pd vptr;\n    returnOk $ Inl (LargePagePTE base attrib vm_rights, map (\\<lambda>x. x + p) largePagePTE_offsets)\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SectionPDE base attrib vm_rights, [p])\n  odE\"\n\n| \"create_mapping_entries base vptr ARMSuperSection vm_rights attrib pd =\n  doE\n    p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    returnOk $ Inr (SuperSectionPDE base attrib vm_rights, map (\\<lambda>x. x + p) superSectionPDE_offsets)\n  odE\"\n\ndefinition get_master_pde :: \"word32 \\<Rightarrow> (pde,'z::state_ext)s_monad\"\n  where \"get_master_pde ptr \\<equiv> do\n    pde \\<leftarrow> (get_pde (ptr && ~~ mask 7));\n    (case pde of SuperSectionPDE _ _ _ \\<Rightarrow> return pde\n    | _ \\<Rightarrow> get_pde ptr)\n  od\"\n\ndefinition get_master_pte :: \"word32 \\<Rightarrow> (pte, 'z::state_ext)s_monad\"\n  where \"get_master_pte ptr \\<equiv> do\n    pte \\<leftarrow> (get_pte (ptr && ~~ mask 7));\n    (case pte of LargePagePTE _ _ _ \\<Rightarrow> return pte\n    | _ \\<Rightarrow> get_pte ptr)\n  od\"", "property": "Create Mapping Entries: Generate the necessary page table or page directory entries to map frames of different sizes at a given virtual address, ensuring that the correct offsets and attributes are applied for small pages, large pages, sections, and super sections.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Save the set of entries that would be inserted into a page table or\npage directory to map various different sizes of frame at a given virtual\naddress."}
{"spec": "fun ensure_safe_mapping ::\n  \"(pte * word32 list) + (pde * word32 list) \\<Rightarrow> (unit,'z::state_ext) se_monad\"\nwhere\n\"ensure_safe_mapping (Inl (InvalidPTE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inl (SmallPagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda>slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | SmallPagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst)\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inl (LargePagePTE _ _ _, pt_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pte \\<leftarrow> liftE $ get_master_pte slot;\n        (case pte of\n              InvalidPTE \\<Rightarrow> returnOk ()\n            | LargePagePTE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pt_slots\"\n|\n\"ensure_safe_mapping (Inr (InvalidPDE, _)) = returnOk ()\"\n|\n\"ensure_safe_mapping (Inr (PageTablePDE _, _)) = fail\"\n|\n\"ensure_safe_mapping (Inr (SectionPDE _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SectionPDE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"\n|\n\"ensure_safe_mapping (Inr (SuperSectionPDE _ _ _, pd_slots)) =\n    mapME_x (\\<lambda> slot. (doE\n        pde \\<leftarrow> liftE $ get_master_pde slot;\n        (case pde of\n              InvalidPDE \\<Rightarrow> returnOk ()\n            | SuperSectionPDE _ _ _ \\<Rightarrow> returnOk ()\n            | _ \\<Rightarrow> throwError DeleteFirst\n            )\n    odE)) pd_slots\"", "property": "Ensure Safe Mapping: Verify that new page table or page directory entries replace either invalid entries or entries of the same granularity, preventing unsafe mappings.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Placing an entry which maps a frame within the set of entries that map a\nlarger frame is unsafe. This function checks that given entries replace either\ninvalid entries or entries of the same granularity."}
{"spec": "definition\nlookup_ipc_buffer :: \"bool \\<Rightarrow> word32 \\<Rightarrow> (word32 option,'z::state_ext) s_monad\" where\n\"lookup_ipc_buffer is_receiver thread \\<equiv> do\n    buffer_ptr \\<leftarrow> thread_get tcb_ipc_buffer thread;\n    buffer_frame_slot \\<leftarrow> return (thread, tcb_cnode_index 4);\n    buffer_cap \\<leftarrow> get_cap buffer_frame_slot;\n    (case buffer_cap of\n      ArchObjectCap (PageCap _ p R vms _) \\<Rightarrow>\n        if vm_read_write \\<subseteq> R \\<or> vm_read_only \\<subseteq> R \\<and> \\<not>is_receiver\n        then return $ Some $ p + (buffer_ptr && mask (pageBitsForSize vms))\n        else return None\n    | _ \\<Rightarrow> return None)\nod\"", "property": "Lookup IPC Buffer: Verify the thread's authority to access its IPC buffer. Check if the thread has the appropriate read or write permissions for the buffer, based on whether it is the receiver or not.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Look up a thread's IPC buffer and check that the thread has the right\nauthority to read or (in the receiver case) write to it."}
{"spec": "definition\nfind_pd_for_asid :: \"asid \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"find_pd_for_asid asid \\<equiv> doE\n    assertE (asid > 0);\n    asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n    pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of asid));\n    pool \\<leftarrow> (case pool_ptr of\n               Some ptr \\<Rightarrow> liftE $ get_asid_pool ptr\n             | None \\<Rightarrow> throwError InvalidRoot);\n    pd \\<leftarrow> returnOk (pool (ucast asid));\n    (case pd of\n          Some ptr \\<Rightarrow> returnOk ptr\n        | None \\<Rightarrow> throwError InvalidRoot)\nodE\"", "property": "Locate Page Directory: Find the page directory associated with a given virtual ASID by looking up the ASID in the ASID table and then in the corresponding ASID pool. If the ASID or the page directory is not found, an error is thrown.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory associated with a given virtual ASID."}
{"spec": "definition\nfind_pd_for_asid_assert :: \"asid \\<Rightarrow> (word32,'z::state_ext) s_monad\" where\n\"find_pd_for_asid_assert asid \\<equiv> do\n   pd \\<leftarrow> find_pd_for_asid asid <catch> K fail;\n   get_pde pd;\n   return pd\n od\"", "property": "Locate and Validate Page Directory: Locate the page directory for a given ASID and ensure it is valid by retrieving a page directory entry. If the page directory is not found, the operation fails.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate the page directory and check that this process succeeds and\nreturns a pointer to a real page directory."}
{"spec": "fun\nhandle_vm_fault :: \"word32 \\<Rightarrow> vmfault_type \\<Rightarrow> (unit,'z::state_ext) f_monad\"\nwhere\n\"handle_vm_fault thread ARMDataAbort = doE\n    addr \\<leftarrow> liftE $ do_machine_op getHDFAR;\n    uaddr \\<leftarrow> liftE $ do_machine_op (addressTranslateS1 addr);\n    fault \\<leftarrow> liftE $ do_machine_op getHSR;\n    let faddr = (uaddr && complement (mask pageBits)) || (addr && mask pageBits)\n    in\n    throwError $ ArchFault $ VMFault faddr [0, fault && 0x3ffffff]\nodE\"\n|\n\"handle_vm_fault thread ARMPrefetchAbort = doE\n    pc \\<leftarrow> liftE $ as_user thread $ getRestartPC;\n    upc \\<leftarrow> liftE $ do_machine_op (addressTranslateS1 pc);\n    fault \\<leftarrow> liftE $ do_machine_op getHSR;\n    let faddr = (upc && complement (mask pageBits)) || (pc && mask pageBits)\n    in\n    throwError $ ArchFault $ VMFault faddr [1, fault && 0x3ffffff]\nodE\"", "property": "Handle VM Fault: Generate a formatted VM fault message for a thread's supervisor after encountering a page fault. The message includes the fault address and relevant fault information, ensuring that the supervisor can appropriately handle the fault.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Format a VM fault message to be passed to a thread's supervisor after\nit encounters a page fault."}
{"spec": "definition\nload_hw_asid :: \"asid \\<Rightarrow> (hardware_asid option,'z::state_ext) s_monad\" where\n\"load_hw_asid asid \\<equiv> do\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    return $ option_map fst $ asid_map asid\nod\"", "property": "Load Hardware ASID: Retrieve the optional hardware ASID associated with a given virtual ASID from the ASID map.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Load the optional hardware ASID currently associated with this virtual\nASID."}
{"spec": "definition\nstore_hw_asid :: \"asid \\<Rightarrow> hardware_asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"store_hw_asid asid hw_asid \\<equiv> do\n    pd \\<leftarrow> find_pd_for_asid_assert asid;\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    asid_map' \\<leftarrow> return (asid_map (asid \\<mapsto> (hw_asid, pd)));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_map := asid_map' \\<rparr>\\<rparr>);\n    hw_asid_map \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n    hw_asid_map' \\<leftarrow> return (hw_asid_map (hw_asid \\<mapsto> asid));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_hwasid_table := hw_asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Associate a hardware ASID with a virtual ASID: Store the association between a virtual ASID and a hardware ASID in the system's ASID map, and update the hardware ASID table to reflect this mapping.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associate a hardware ASID with a virtual ASID."}
{"spec": "definition\ninvalidate_tlb_by_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_tlb_by_asid asid \\<equiv> do\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    (case maybe_hw_asid of\n          None \\<Rightarrow> return ()\n        | Some hw_asid \\<Rightarrow> do_machine_op $ invalidateLocalTLB_ASID hw_asid)\nod\"", "property": "Invalidate TLB by ASID: Clear all TLB mappings associated with a given virtual ASID. If the hardware ASID is found, it invalidates the corresponding TLB entries; otherwise, it does nothing.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Clear all TLB mappings associated with this virtual ASID."}
{"spec": "definition\nflush_space :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_space asid \\<equiv> do\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    do_machine_op cleanCaches_PoU;\n    (case maybe_hw_asid of\n          None \\<Rightarrow> return ()\n        | Some hw_asid \\<Rightarrow> do_machine_op $ invalidateLocalTLB_ASID hw_asid)\nod\"", "property": "Flush Virtual ASID: Flush all cache and TLB entries associated with a given virtual ASID. If the ASID is mapped to a hardware ASID, invalidate the local TLB for that hardware ASID; otherwise, perform a general cache clean operation.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush all cache and TLB entries associated with this virtual ASID."}
{"spec": "definition\ninvalidate_asid :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_asid asid \\<equiv> do\n    asid_map \\<leftarrow> gets (arm_asid_map \\<circ> arch_state);\n    asid_map' \\<leftarrow> return (asid_map (asid:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_map := asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Invalidate ASID: Remove the mapping from a specified virtual ASID to its corresponding hardware ASID, ensuring that the ASID is no longer associated with any hardware ASID in the system.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this virtual ASID to a hardware ASID."}
{"spec": "definition\ninvalidate_hw_asid_entry :: \"hardware_asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_hw_asid_entry hw_asid \\<equiv> do\n  hw_asid_map \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n  hw_asid_map' \\<leftarrow> return (hw_asid_map (hw_asid:= None));\n  modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_hwasid_table := hw_asid_map' \\<rparr>\\<rparr>)\nod\"", "property": "Invalidate Hardware ASID Entry: Remove the mapping from a specified hardware ASID to its corresponding virtual ASID, ensuring that the hardware ASID is no longer associated with any virtual ASID in the system.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove any mapping from this hardware ASID to a virtual ASID."}
{"spec": "definition\ninvalidate_asid_entry :: \"asid \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"invalidate_asid_entry asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  when (maybe_hw_asid \\<noteq> None) $ invalidate_hw_asid_entry (the maybe_hw_asid);\n  invalidate_asid asid\nod\"", "property": "Invalidate ASID Entry: Remove virtual to physical mappings for a given ASID by invalidating the hardware ASID entry if it exists, followed by invalidating the ASID itself.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Remove virtual to physical mappings in either direction involving this\nvirtual ASID."}
{"spec": "definition\nfind_free_hw_asid :: \"(hardware_asid,'z::state_ext) s_monad\" where\n\"find_free_hw_asid \\<equiv> do\n    hw_asid_table \\<leftarrow> gets (arm_hwasid_table \\<circ> arch_state);\n    next_asid \\<leftarrow> gets (arm_next_asid \\<circ> arch_state);\n    maybe_asid \\<leftarrow> return (find (\\<lambda>a. hw_asid_table a = None)\n                    (take (length [minBound :: hardware_asid .e. maxBound])\n                        ([next_asid .e. maxBound] @ [minBound .e. next_asid])));\n    (case maybe_asid of\n       Some hw_asid \\<Rightarrow> return hw_asid\n     | None \\<Rightarrow>  do\n            invalidate_asid $ the $ hw_asid_table next_asid;\n            do_machine_op $ invalidateLocalTLB_ASID next_asid;\n            invalidate_hw_asid_entry next_asid;\n            new_next_asid \\<leftarrow> return (next_asid + 1);\n            modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_next_asid := new_next_asid \\<rparr>\\<rparr>);\n            return next_asid\n       od)\nod\"", "property": "Find Free Hardware ASID: Locate an unused hardware ASID, and if none are available, reclaim one in a round-robin manner by invalidating the current next ASID and updating the next ASID to the next value.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Locate a hardware ASID that is not in use, if necessary by reclaiming\none from another virtual ASID in a round-robin manner."}
{"spec": "definition\nget_hw_asid :: \"asid \\<Rightarrow> (hardware_asid,'z::state_ext) s_monad\" where\n\"get_hw_asid asid \\<equiv> do\n  maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n  (case maybe_hw_asid of\n    Some hw_asid \\<Rightarrow> return hw_asid\n  | None \\<Rightarrow>  do\n      new_hw_asid \\<leftarrow> find_free_hw_asid;\n      store_hw_asid asid new_hw_asid;\n      return new_hw_asid\n  od)\nod\"\n\n\nabbreviation\n  \"arm_context_switch_hwasid pd hwasid \\<equiv> writeContextIDAndPD hwasid (addrFromPPtr pd)\"\n\ndefinition\n  arm_context_switch :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (unit, 'z::state_ext) s_monad\"\nwhere\n  \"arm_context_switch pd asid \\<equiv> do\n    hwasid \\<leftarrow> get_hw_asid asid;\n    do_machine_op $ arm_context_switch_hwasid pd hwasid\n   od\"", "property": "Hardware ASID Management: Retrieve the hardware ASID associated with a given virtual ASID, and if none is assigned, allocate a new hardware ASID and store it. This ensures that each virtual ASID is correctly mapped to a unique hardware ASID, facilitating efficient context switching.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get the hardware ASID associated with a virtual ASID, assigning one if\nnone is already assigned."}
{"spec": "definition\n  vcpu_update :: \"obj_ref \\<Rightarrow> (vcpu \\<Rightarrow> vcpu) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_update vr f \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    set_vcpu vr (f vcpu)\n  od\"\n\ndefinition\n  vgic_update :: \"obj_ref \\<Rightarrow> (gic_vcpu_interface \\<Rightarrow> gic_vcpu_interface) \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vgic_update vr f \\<equiv> vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_vgic := f (vcpu_vgic vcpu) \\<rparr> )\"\n\ndefinition\n  vgic_update_lr :: \"obj_ref \\<Rightarrow> nat \\<Rightarrow> virq \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vgic_update_lr vr irq_idx virq \\<equiv>\n    vgic_update vr (\\<lambda>vgic. vgic \\<lparr> vgic_lr := (vgic_lr vgic)(irq_idx := virq) \\<rparr>)\"\n\ndefinition\n  vcpu_save_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_save_reg vr reg \\<equiv> do\n    rval \\<leftarrow> do_machine_op (readVCPUHardwareReg reg);\n    vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_regs := (vcpu_regs vcpu)(reg := rval) \\<rparr> )\n  od\"\n\ndefinition\n  vcpu_save_reg_range :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_save_reg_range vr from to \\<equiv> mapM_x (\\<lambda>reg. vcpu_save_reg vr reg) [from .e. to]\"\n\ndefinition\n  vcpu_restore_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_restore_reg vr reg \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    do_machine_op (writeVCPUHardwareReg reg (vcpu_regs vcpu reg))\n  od\"\n\ndefinition\n  vcpu_restore_reg_range :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> vcpureg \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_restore_reg_range vr from to \\<equiv> mapM_x (\\<lambda>reg. vcpu_restore_reg vr reg) [from .e. to]\"\n\ndefinition\n  vcpu_read_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> (machine_word, 'z::state_ext) s_monad\"\nwhere\n  \"vcpu_read_reg vr reg \\<equiv> do\n    vcpu \\<leftarrow> get_vcpu vr;\n    return (vcpu_regs vcpu reg)\n  od\"\n\ndefinition\n  vcpu_write_reg :: \"obj_ref \\<Rightarrow> vcpureg \\<Rightarrow> machine_word \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_write_reg vr reg val \\<equiv>\n    vcpu_update vr (\\<lambda>vcpu. vcpu \\<lparr> vcpu_regs := (vcpu_regs vcpu)(reg := val) \\<rparr> )\"\n\ndefinition save_virt_timer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"save_virt_timer vcpu_ptr \\<equiv> do\n     vcpu_save_reg vcpu_ptr VCPURegCNTV_CTL;\n     do_machine_op $ writeVCPUHardwareReg VCPURegCNTV_CTL 0;\n     cval \\<leftarrow> do_machine_op get_cntv_cval_64;\n     cntvoff \\<leftarrow> do_machine_op get_cntv_off_64;\n     vcpu_write_reg vcpu_ptr VCPURegCNTV_CVALhigh (ucast (cval >> 32));\n     vcpu_write_reg vcpu_ptr VCPURegCNTV_CVALlow (ucast cval);\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFFhigh (ucast (cntvoff >> 32));\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFFlow (ucast cntvoff);\n     cntpct \\<leftarrow> do_machine_op read_cntpct;\n     vcpu_update vcpu_ptr (\\<lambda>vcpu. vcpu\\<lparr>vcpu_vtimer := VirtTimer cntpct \\<rparr>)\n   od\"\n\ndefinition irq_vppi_event_index :: \"irq \\<rightharpoonup> vppievent_irq\" where\n  \"irq_vppi_event_index irq \\<equiv>\n     if irq = irqVTimerEvent\n     then Some VPPIEventIRQ_VTimer\n     else None\"\n\ndefinition restore_virt_timer :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"restore_virt_timer vcpu_ptr \\<equiv> do\n     cval_high \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTV_CVALhigh;\n     cval_low \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTV_CVALlow;\n     (cval :: 64 word) \\<leftarrow> return $ ((ucast cval_high) << 32) || ucast cval_low;\n     do_machine_op $ set_cntv_cval_64 cval;\n     current_cntpct \\<leftarrow> do_machine_op read_cntpct;\n     vcpu \\<leftarrow> get_vcpu vcpu_ptr;\n     last_pcount \\<leftarrow> return $ vtimerLastPCount $ vcpu_vtimer vcpu;\n     delta \\<leftarrow> return $ current_cntpct - last_pcount;\n     offs_high \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTVOFFhigh;\n     offs_low \\<leftarrow> vcpu_read_reg vcpu_ptr VCPURegCNTVOFFlow;\n     (offset :: 64 word) \\<leftarrow> return $ (((ucast offs_high) << 32) || ucast offs_low) + delta;\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFFhigh (ucast (offset >> 32));\n     vcpu_write_reg vcpu_ptr VCPURegCNTVOFFlow (ucast offset);\n     do_machine_op $ set_cntv_off_64 offset;\n     masked \\<leftarrow> return $ (vcpu_vppi_masked vcpu (the $ irq_vppi_event_index irqVTimerEvent));\n     \\<comment> \\<open>we do not know here that irqVTimerEvent is IRQReserved, therefore not IRQInactive,\n        so the only way to prove we don't unmask an inactive interrupt is to check\\<close>\n     safe_to_unmask \\<leftarrow> is_irq_active irqVTimerEvent;\n     when safe_to_unmask $ do_machine_op $ maskInterrupt masked irqVTimerEvent;\n     vcpu_restore_reg vcpu_ptr VCPURegCNTV_CTL\n   od\"", "property": "VCPU State and Register Manipulation: Provides functions to update, save, and restore VCPU-related state and registers, including the virtual GIC (VGIC) interface, individual registers, and virtual timer values. These operations ensure that the VCPU's state is accurately maintained and can be effectively managed during context switches and other system events.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Manipulation of VCPU-related state and registers"}
{"spec": "definition\n  vcpu_disable :: \"obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_disable vo \\<equiv> do\n    do_machine_op dsb;\n    (case vo of\n      Some vr \\<Rightarrow> do\n        hcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_hcr;\n        vgic_update vr (\\<lambda>vgic. vgic\\<lparr> vgic_hcr := hcr \\<rparr>);\n        vcpu_save_reg vr VCPURegSCTLR;\n        do_machine_op isb\n      od\n    | _ \\<Rightarrow> return ());\n    do_machine_op $ do\n        set_gic_vcpu_ctrl_hcr 0; \\<comment> \\<open>turn VGIC off\\<close>\n        isb;\n        setSCTLR sctlrDefault; \\<comment> \\<open>turn SI MMU off\\<close>\n        setHCR hcrNative;\n        isb\n      od;\n    case vo of\n      Some vr \\<Rightarrow> do\n          save_virt_timer vr;\n          do_machine_op $ maskInterrupt True irqVTimerEvent\n        od\n      | _ \\<Rightarrow> return ()\n    od\"", "property": "VPCU Mode Disabling: Disables the VPCU mode on the hardware level by turning off the VGIC, SI MMU, and setting the HCR to its native state. Additionally, it saves the VCPU register and virtual timer, and masks the virtual timer interrupt if a VCPU reference is provided.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Turn VPCU mode off on the hardware level."}
{"spec": "definition\n  vcpu_enable :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_enable vr \\<equiv> do\n     vcpu_restore_reg vr VCPURegSCTLR;\n     vcpu \\<leftarrow> get_vcpu vr;\n     do_machine_op $ do\n        setHCR hcrVCPU;\n        isb;\n        set_gic_vcpu_ctrl_hcr (vgic_hcr $ vcpu_vgic vcpu)\n     od;\n     restore_virt_timer vr\n   od\"", "property": "Enable VCPU Mode: Activate the VCPU mode on the hardware level by restoring the VCPU register, setting the HCR for VCPU, updating the GIC VCPU control, and restoring the virtual timer.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Turn VCPU mode on, on the hardware level."}
{"spec": "definition\n  vcpu_invalidate_active :: \"(unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_invalidate_active \\<equiv> do\n    cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n    case cur_v of\n      Some (vr, True) \\<Rightarrow> vcpu_disable None\n    | _ \\<Rightarrow> return ();\n    modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := None \\<rparr>\\<rparr>)\n  od\"", "property": "Prepare VCPU for Removal: Invalidate the active VCPU by disabling it and clearing the current VCPU reference in the system state.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Prepare the current VCPU for removal.\n"}
{"spec": "definition dissociate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere \"dissociate_vcpu_tcb vr t \\<equiv> do\n  t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n  v \\<leftarrow> get_vcpu vr;\n  assert (t_vcpu = Some vr \\<and> vcpu_tcb v = Some t); \\<comment> \\<open>make sure they were associated\\<close>\n  cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n  when (\\<exists>a. cur_v = Some (vr,a)) vcpu_invalidate_active;\n  arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := None \\<rparr>) t;\n  set_vcpu vr (v\\<lparr> vcpu_tcb := None \\<rparr>);\n  as_user t $ do\n    cpsr \\<leftarrow> getRegister CPSR;\n    setRegister CPSR $ sanitise_register False CPSR cpsr\n  od\nod\"", "property": "Dissociate VCPU and TCB: Ensures the removal of the connection between a TCB and a VCPU, invalidating the active VCPU if it is the one being dissociated. It also sanitizes the CPSR register for the TCB to maintain system integrity.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Removing the connection between a TCB and VCPU:"}
{"spec": "definition\n  vcpu_save :: \"(obj_ref \\<times> bool) option \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_save vb \\<equiv>\n     case vb\n     of Some (vr, active) \\<Rightarrow> do\n          do_machine_op dsb;\n\n          when active $ do\n            vcpu_save_reg vr VCPURegSCTLR;\n            hcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_hcr;\n            vgic_update vr (\\<lambda>vgic. vgic\\<lparr> vgic_hcr := hcr \\<rparr>);\n            save_virt_timer vr\n          od;\n\n          vmcr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_vmcr;\n          vgic_update vr (\\<lambda>vgic. vgic \\<lparr>vgic_vmcr := vmcr\\<rparr>);\n\n          apr \\<leftarrow> do_machine_op get_gic_vcpu_ctrl_apr;\n          vgic_update vr (\\<lambda>vgic. vgic \\<lparr>vgic_apr := apr\\<rparr>);\n\n          num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n          gicIndices \\<leftarrow> return [0..<num_list_regs];\n\n          mapM (\\<lambda>vreg. do\n                    val \\<leftarrow> do_machine_op $ get_gic_vcpu_ctrl_lr (of_nat vreg);\n                    vgic_update_lr vr vreg val\n                  od)\n            gicIndices;\n\n          vcpu_save_reg_range vr VCPURegACTLR VCPURegSPSRfiq;\n          do_machine_op isb\n       od\n     | _ \\<Rightarrow> fail\"", "property": "VCPU Save: Saves the state of a VCPU, including its registers and context. It updates the VCPU's control registers, saves the virtual timer, and retrieves and updates the GIC (Generic Interrupt Controller) related registers. This ensures that the VCPU's state is preserved and can be restored accurately.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Register + context save for VCPUs"}
{"spec": "definition\n  vcpu_restore :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_restore vr \\<equiv> do\n     do_machine_op $ set_gic_vcpu_ctrl_hcr 0;  \\<comment> \\<open>turn off VGIC\\<close>\n     do_machine_op $ isb;\n     vcpu \\<leftarrow> get_vcpu vr;  \\<comment> \\<open>restore GIC VCPU control state\\<close>\n     vgic \\<leftarrow> return (vcpu_vgic vcpu);\n     num_list_regs \\<leftarrow> gets (arm_gicvcpu_numlistregs \\<circ> arch_state);\n     gicIndices \\<leftarrow> return [0..<num_list_regs];\n     do_machine_op $ do\n         set_gic_vcpu_ctrl_vmcr (vgic_vmcr vgic);\n         set_gic_vcpu_ctrl_apr (vgic_apr vgic);\n         mapM (\\<lambda>p. set_gic_vcpu_ctrl_lr (of_nat (fst p)) (snd p))\n              (map (\\<lambda>i. (i, (vgic_lr vgic) i)) gicIndices)\n     od;\n    \\<comment> \\<open>restore banked VCPU registers except SCTLR (that's in VCPUEnable)\\<close>\n     vcpu_restore_reg_range vr VCPURegACTLR VCPURegSPSRfiq;\n     vcpu_enable vr\n  od\"", "property": "Vcpu Restore: Restores the VCPU's state by turning off the VGIC, restoring GIC VCPU control state, setting specific GIC VCPU control registers, and restoring a range of banked VCPU registers, followed by enabling the VCPU.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Register + context restore for VCPUs"}
{"spec": "definition vcpu_switch :: \"obj_ref option \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_switch v \\<equiv> case v of\n   None \\<Rightarrow> do\n     cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     (case cur_v of\n        None \\<Rightarrow> return () \\<comment> \\<open>both null, current cannot be active\\<close>\n      | Some (vr, active) \\<Rightarrow> do \\<comment> \\<open>switch to thread without vcpu\\<close>\n          when active $ do  \\<comment> \\<open> save state if not saved already\\<close>\n            vcpu_disable (Some vr);\n            modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (vr, False) \\<rparr>\\<rparr>)\n          od;\n          return ()\n        od)\n     od\n | Some new \\<Rightarrow> do\n     cur_v \\<leftarrow> gets (arm_current_vcpu \\<circ> arch_state);\n     (case cur_v of\n        None \\<Rightarrow> do \\<comment> \\<open>switch to the new vcpu with no current one\\<close>\n          vcpu_restore new;\n          modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n        od\n      | Some (vr, active) \\<Rightarrow> \\<comment> \\<open>switch from an existing vcpu\\<close>\n          (if vr \\<noteq> new\n          then do \\<comment> \\<open>different vcpu\\<close>\n            vcpu_save cur_v;\n            vcpu_restore new;\n            modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n          od\n          else \\<comment> \\<open>same vcpu\\<close>\n            when (\\<not> active) $ do\n              do_machine_op isb;\n              vcpu_enable new;\n              modify (\\<lambda>s. s\\<lparr> arch_state := (arch_state s)\\<lparr> arm_current_vcpu := Some (new, True) \\<rparr>\\<rparr>)\n            od))\n   od\"", "property": "VCPU Switching: Switch the active VCPU to a new one, or mark the current VCPU as inactive and disable VCPU mode if no new VCPU is provided. If the new VCPU is different from the current one, save the state of the current VCPU and restore the state of the new VCPU. If the same VCPU is being reactivated, enable it and update its active status.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Make a new VCPU the active/current VCPU. If passed None, will mark the current VCPU as\n  not active, and disable VCPU mode, but leave the rest intact caching for the case where\n  we switch back to the same VCPU soon.\n"}
{"spec": "definition associate_vcpu_tcb :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"associate_vcpu_tcb vr t \\<equiv> do\n    t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n    case t_vcpu of Some p \\<Rightarrow> dissociate_vcpu_tcb p t\n                 | _ \\<Rightarrow> return ();\n    v \\<leftarrow> get_vcpu vr;\n    case vcpu_tcb v of Some p \\<Rightarrow> dissociate_vcpu_tcb vr p\n                     | _ \\<Rightarrow> return ();\n    arch_thread_set (\\<lambda>x. x \\<lparr> tcb_vcpu := Some vr \\<rparr>) t;\n    set_vcpu vr (v\\<lparr> vcpu_tcb := Some t \\<rparr>);\n    ct \\<leftarrow> gets cur_thread;\n    when (t = ct) $ vcpu_switch (Some vr)\n  od\"", "property": "Associate and Dissociate VCPU and TCB: Ensures a TCB is associated with a VCPU, and any existing associations are removed. This process maintains the integrity of the TCB-VCPU relationship, ensuring that each TCB is correctly linked to a single VCPU and vice versa. If the TCB being associated is the current thread, a VCPU switch is performed to reflect the new association.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Associating a TCB and VCPU, removing any potentially existing associations:"}
{"spec": "definition vcpu_finalise :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"vcpu_finalise vr \\<equiv> do\n    v \\<leftarrow> get_vcpu vr;\n    case vcpu_tcb v of\n      Some t \\<Rightarrow> dissociate_vcpu_tcb vr t\n    | None \\<Rightarrow> return ()\n   od\"", "property": "VCPU Finalization: Prepare a VCPU for removal by dissociating it from its associated TCB, if any, and cleaning up the current VCPU state.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  Prepare a given VCPU for removal: dissociate it, and clean up current VCPU state\n  if necessary.\n"}
{"spec": "definition\n  set_vm_root :: \"word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"set_vm_root tcb \\<equiv> do\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    (case thread_root of\n       ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow> doE\n           pd' \\<leftarrow> find_pd_for_asid asid;\n           whenE (pd \\<noteq> pd') $ throwError InvalidRoot;\n           liftE $ arm_context_switch pd asid\n       odE\n     | _ \\<Rightarrow> throwError InvalidRoot) <catch>\n    (\\<lambda>_. do\n       global_us_pd \\<leftarrow> gets (arm_us_global_pd o arch_state);\n       do_machine_op $ set_current_pd $ addrFromKPPtr global_us_pd\n    od)\nod\"", "property": "Set VM Root: Switch the address space to the one associated with a given thread, using its page directory and ASID. If the thread's root is invalid or not correctly configured, switch to the global address space. This ensures that the system operates within a valid and correctly configured address space, maintaining the integrity and security of memory access.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch into the address space of a given thread or the global address\nspace if none is correctly configured."}
{"spec": "definition\ndelete_asid_pool :: \"asid \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid_pool base ptr \\<equiv> do\n  assert (base && mask asid_low_bits = 0);\n  asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n  when (asid_table (asid_high_bits_of base) = Some ptr) $ do\n    pool \\<leftarrow> get_asid_pool ptr;\n    mapM (\\<lambda>offset. (when (pool (ucast offset) \\<noteq> None) $ do\n                          flush_space $ base + offset;\n                          invalidate_asid_entry $ base + offset\n                    od)) [0  .e.  (1 << asid_low_bits) - 1];\n    asid_table' \\<leftarrow> return (asid_table (asid_high_bits_of base:= None));\n    modify (\\<lambda>s. s \\<lparr> arch_state := (arch_state s) \\<lparr> arm_asid_table := asid_table' \\<rparr>\\<rparr>);\n    tcb \\<leftarrow> gets cur_thread;\n    set_vm_root tcb\n  od\nod\"", "property": "ASID Pool Deletion: Before deleting an ASID pool, deactivate all page directories installed in it by flushing and invalidating their entries. Update the ASID table to remove the reference to the deleted pool and set the VM root for the current thread.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Before deleting an ASID pool object we must deactivate all page\ndirectories that are installed in it."}
{"spec": "definition\ndelete_asid :: \"asid \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"delete_asid asid pd \\<equiv> do\n  asid_table \\<leftarrow> gets (arm_asid_table \\<circ> arch_state);\n  (case asid_table (asid_high_bits_of asid) of\n    None \\<Rightarrow> return ()\n  | Some pool_ptr \\<Rightarrow>  do\n     pool \\<leftarrow> get_asid_pool pool_ptr;\n     when (pool (ucast asid) = Some pd) $ do\n                flush_space asid;\n                invalidate_asid_entry asid;\n                pool' \\<leftarrow> return (pool (ucast asid := None));\n                set_asid_pool pool_ptr pool';\n                tcb \\<leftarrow> gets cur_thread;\n                set_vm_root tcb\n            od\n    od)\nod\"", "property": "Delete ASID: Deactivate and remove a page directory from an ASID pool. If the ASID is found in the pool, it flushes the space, invalidates the ASID entry, updates the pool to remove the page directory, and sets the VM root for the current thread.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "When deleting a page directory from an ASID pool we must deactivate\nit."}
{"spec": "definition\nset_vm_root_for_flush :: \"word32 \\<Rightarrow> asid \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n\"set_vm_root_for_flush pd asid \\<equiv> do\n    tcb \\<leftarrow> gets cur_thread;\n    thread_root_slot \\<leftarrow> return (tcb, tcb_cnode_index 1);\n    thread_root \\<leftarrow> get_cap thread_root_slot;\n    not_is_pd \\<leftarrow> (case thread_root of\n                    ArchObjectCap (PageDirectoryCap cur_pd (Some _)) \\<Rightarrow> return (cur_pd \\<noteq> pd)\n                  | _ \\<Rightarrow> return True);\n    (if not_is_pd then do\n        arm_context_switch pd asid;\n        return True\n    od\n    else return False)\nod\"\n\ndefinition\ndo_flush :: \"flush_type \\<Rightarrow> vspace_ref \\<Rightarrow> vspace_ref \\<Rightarrow> paddr \\<Rightarrow> unit machine_monad\" where\n\"do_flush flush_type vstart vend pstart \\<equiv>\n    let vstart' = ptrFromPAddr pstart;\n        vend'  = vstart' + (vend - vstart)\n    in\n    (case flush_type of\n       Clean \\<Rightarrow> cleanCacheRange_RAM vstart' vend' pstart\n     | Invalidate \\<Rightarrow> invalidateCacheRange_RAM vstart' vend' pstart\n     | CleanInvalidate \\<Rightarrow> cleanInvalidateCacheRange_RAM vstart' vend' pstart\n     | Unify \\<Rightarrow> do\n         cleanCacheRange_PoU vstart' vend' pstart;\n         dsb;\n         invalidateCacheRange_I vstart' vend' pstart;\n         branchFlushRange vstart' vend' pstart;\n         isb\n     od)\"", "property": "Address Space Switch for Flush: Switch to a specific address space to perform a flush operation. If the current page directory does not match the target, a context switch is performed, and the flush operation is executed. The type of flush (clean, invalidate, clean-invalidate, or unify) determines the specific cache operations to be carried out.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Switch to a particular address space in order to perform a flush\noperation."}
{"spec": "definition\nflush_table :: \"word32 \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_table pd asid vptr pt \\<equiv> do\n    assert (vptr && mask (pageBitsForSize ARMSection) = 0);\n    root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    when (maybe_hw_asid \\<noteq> None) $ do\n      hw_asid \\<leftarrow> return (the maybe_hw_asid);\n      do_machine_op $ invalidateLocalTLB_ASID hw_asid;\n      when root_switched $ do\n        tcb \\<leftarrow> gets cur_thread;\n        set_vm_root tcb\n      od\n    od\nod\"", "property": "Flush Page Table Mappings: Invalidate the local TLB for a given ASID and flush mappings associated with a page table. If the hardware ASID is present, perform the invalidation and, if the VM root was switched, reset it to the current thread's VM root.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a page table."}
{"spec": "definition\nflush_page :: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"flush_page page_size pd asid vptr\\<equiv> do\n    assert (vptr && mask pageBits = 0);\n    root_switched \\<leftarrow> set_vm_root_for_flush pd asid;\n    maybe_hw_asid \\<leftarrow> load_hw_asid asid;\n    when (maybe_hw_asid \\<noteq> None) $ do\n      hw_asid \\<leftarrow> return (the maybe_hw_asid);\n      do_machine_op $ invalidateLocalTLB_VAASID (vptr || ucast hw_asid);\n      when root_switched $ do\n          tcb \\<leftarrow> gets cur_thread;\n          set_vm_root tcb\n      od\n   od\nod\"", "property": "Flush Page Mappings: Invalidate the mappings associated with a given page in the virtual address space. This involves setting the virtual machine root for flushing, loading the hardware ASID, and invalidating the local TLB if the hardware ASID is present. If the root was switched during the process, it is reset to the current thread's virtual machine root.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Flush mappings associated with a given page."}
{"spec": "definition\npage_table_mapped :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (obj_ref option,'z::state_ext) s_monad\" where\n\"page_table_mapped asid vaddr pt \\<equiv> doE\n    pd \\<leftarrow> find_pd_for_asid asid;\n    pd_slot \\<leftarrow> returnOk $ lookup_pd_slot pd vaddr;\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    case pde of\n      PageTablePDE addr \\<Rightarrow> returnOk $\n             if addrFromPPtr pt = addr then Some pd else None\n    | _ \\<Rightarrow> returnOk None\nodE <catch> (K $ return None)\"", "property": "Page Table Mapping: Determine the page directory in which a given page table is mapped, if any. The function checks the page directory for the specified ASID and virtual address, and returns the page directory if the page table is found, otherwise it returns None.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Return the optional page directory a page table is mapped in."}
{"spec": "definition\nunmap_page_table :: \"asid \\<Rightarrow> vspace_ref \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page_table asid vaddr pt \\<equiv> do\n    pdOpt \\<leftarrow> page_table_mapped asid vaddr pt;\n    case pdOpt of\n      None \\<Rightarrow> return ()\n    | Some pd \\<Rightarrow> do\n        pd_slot \\<leftarrow> return $ lookup_pd_slot pd vaddr;\n        store_pde pd_slot InvalidPDE;\n        do_machine_op $ cleanByVA_PoU pd_slot (addrFromPPtr pd_slot);\n        flush_table pd asid vaddr pt\n    od\nod\"", "property": "Unmap Page Table: Unmaps a specified page table from its page directory. If the page table is found, it invalidates the corresponding page directory entry, cleans the cache, and flushes the table to ensure the changes are effective.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a page table from its page directory."}
{"spec": "definition\ncheck_mapping_pptr :: \"obj_ref \\<Rightarrow> vmpage_size \\<Rightarrow> (obj_ref + obj_ref) \\<Rightarrow> (bool,'z::state_ext) s_monad\" where\n\"check_mapping_pptr pptr pgsz tablePtr \\<equiv> case tablePtr of\n   Inl ptePtr \\<Rightarrow> do\n     pte \\<leftarrow> get_pte ptePtr;\n     return $ case pte of\n       SmallPagePTE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSmallPage\n     | LargePagePTE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMLargePage\n     | _ \\<Rightarrow> False\n   od\n | Inr pdePtr \\<Rightarrow> do\n     pde \\<leftarrow> get_pde pdePtr;\n     return $ case pde of\n       SectionPDE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSection\n     | SuperSectionPDE x _ _ \\<Rightarrow> x = addrFromPPtr pptr \\<and> pgsz = ARMSuperSection\n     | _ \\<Rightarrow> False\n   od\"\n\n\ndefinition\n  \"last_byte_pte x \\<equiv> x + ((1 << pte_bits) - 1)\"\n\ndefinition\n  \"last_byte_pde x \\<equiv> x + ((1 << pde_bits) - 1)\"", "property": "Check Mapping Validity: Verify that a given frame is correctly mapped by a specified mapping entry, ensuring the physical page address and page size match the expected values for the corresponding page table or page directory entry.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Check that a given frame is mapped by a given mapping entry."}
{"spec": "definition\nunmap_page :: \"vmpage_size \\<Rightarrow> asid \\<Rightarrow> vspace_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"unmap_page pgsz asid vptr pptr \\<equiv> doE\n    pd \\<leftarrow> find_pd_for_asid asid;\n    (case pgsz of\n          ARMSmallPage \\<Rightarrow> doE\n            p \\<leftarrow> lookup_pt_slot pd vptr;\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inl p);\n            liftE $ do\n                store_pte p InvalidPTE;\n                do_machine_op $ cleanByVA_PoU p (addrFromPPtr p)\n            od\n          odE\n        | ARMLargePage \\<Rightarrow> doE\n            p \\<leftarrow> lookup_pt_slot pd vptr;\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inl p);\n            liftE $ do\n                assert $ p && mask 7 = 0;\n                slots \\<leftarrow> return (map (\\<lambda>x. x + p) largePagePTE_offsets);\n                mapM (swp store_pte InvalidPTE) slots;\n                do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pte (last slots))\n                                                    (addrFromPPtr (hd slots))\n            od\n          odE\n        | ARMSection \\<Rightarrow> doE\n            p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inr p);\n            liftE $ do\n                store_pde p InvalidPDE;\n                do_machine_op $ cleanByVA_PoU p (addrFromPPtr p)\n            od\n          odE\n        | ARMSuperSection \\<Rightarrow> doE\n            p \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n            throw_on_false undefined $\n                check_mapping_pptr pptr pgsz (Inr p);\n            liftE $ do\n                assert $ p && mask 7 = 0;\n                slots \\<leftarrow> return (map (\\<lambda>x. x + p) superSectionPDE_offsets);\n                mapM (swp store_pde InvalidPDE) slots;\n                do_machine_op $ cleanCacheRange_PoU (hd slots) (last_byte_pde (last slots))\n                                                    (addrFromPPtr (hd slots))\n            od\n          odE);\n    liftE $ flush_page pgsz pd asid vptr\nodE <catch> (K $ return ())\"", "property": "Unmap Page: Unmaps a page from the virtual address space if the provided mapping details are still current. This involves finding the appropriate page directory, checking the mapping, invalidating the corresponding page table entry or page directory entry, and cleaning the cache. The operation ensures that the page is properly unmapped and the cache is updated to reflect the changes.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Unmap a mapped page if the given mapping details are still current."}
{"spec": "definition\n  arch_derive_cap :: \"arch_cap \\<Rightarrow> (cap,'z::state_ext) se_monad\"\nwhere\n  \"arch_derive_cap c \\<equiv> case c of\n     PageTableCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageTableCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageDirectoryCap _ (Some x) \\<Rightarrow> returnOk (ArchObjectCap c)\n   | PageDirectoryCap _ None \\<Rightarrow> throwError IllegalOperation\n   | PageCap dev r R pgs x \\<Rightarrow> returnOk (ArchObjectCap (PageCap dev r R pgs None))\n   | ASIDControlCap \\<Rightarrow> returnOk (ArchObjectCap c)\n   | ASIDPoolCap _ _ \\<Rightarrow> returnOk (ArchObjectCap c)\n   | VCPUCap _ \\<Rightarrow> returnOk (ArchObjectCap c)\"", "property": "Architectural Capability Derivation: Ensures that PageTable and PageDirectory capabilities can only be derived if they have a virtual ASID and location assigned. If these conditions are not met, an illegal operation error is thrown. Other architectural capabilities, such as Page, ASIDControl, ASIDPool, and VCPU, are derived without additional checks.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "PageDirectory and PageTable capabilities cannot be copied until they\nhave a virtual ASID and location assigned. This is because page directories\ncannot have multiple current virtual ASIDs and page tables cannot be shared\nbetween address spaces or virtual locations."}
{"spec": "definition\n  arch_update_cap_data :: \"bool \\<Rightarrow> data \\<Rightarrow> arch_cap \\<Rightarrow> cap\"\nwhere\n  \"arch_update_cap_data preserve data c \\<equiv> ArchObjectCap c\"", "property": "Arch Update Capability Data: Ensures that no user-modifiable data is stored in ARM-specific capabilities, maintaining the integrity and security of the system.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "No user-modifiable data is stored in ARM-specific capabilities."}
{"spec": "definition\n  arch_finalise_cap :: \"arch_cap \\<Rightarrow> bool \\<Rightarrow> (cap \\<times> cap,'z::state_ext) s_monad\"\nwhere\n  \"arch_finalise_cap c x \\<equiv> case (c, x) of\n    (ASIDPoolCap ptr b, True) \\<Rightarrow>  do\n    delete_asid_pool b ptr;\n    return (NullCap, NullCap)\n    od\n  | (PageDirectoryCap ptr (Some a), True) \\<Rightarrow> do\n    delete_asid a ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageTableCap ptr (Some (a, v)), True) \\<Rightarrow> do\n    unmap_page_table a v ptr;\n    return (NullCap, NullCap)\n  od\n  | (PageCap _ ptr _ s (Some (a, v)), _) \\<Rightarrow> do\n     unmap_page s a v ptr;\n     return (NullCap, NullCap)\n  od\n  | (VCPUCap vcpu_ref, True) \\<Rightarrow> do\n     vcpu_finalise vcpu_ref;\n     return (NullCap, NullCap)\n  od\n  | _ \\<Rightarrow> return (NullCap, NullCap)\"\n\ndefinition\n  prepare_thread_delete :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"prepare_thread_delete p \\<equiv> do\n   t_vcpu \\<leftarrow> arch_thread_get tcb_vcpu p;\n   case t_vcpu of\n   Some v \\<Rightarrow> dissociate_vcpu_tcb v p\n | None \\<Rightarrow> return ()\n od\"", "property": "Architectural Capability Finalization: Perform specific actions to finalize AR_MHYP-specific capabilities, such as deleting ASID pools, unmapping page directories, page tables, and pages, and finalizing VCPUs. These actions ensure that the resources associated with these capabilities are properly released and cleaned up. \n\nThread Deletion Preparation: Prepare a thread for deletion by dissociating its VCPU, if it exists, ensuring that the thread's resources are properly managed before it is removed.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Actions that must be taken on finalisation of AR\\_MHYP-specific\ncapabilities."}
{"spec": "definition\n  is_valid_vtable_root :: \"cap \\<Rightarrow> bool\" where\n  \"is_valid_vtable_root c \\<equiv> \\<exists>r a. c = ArchObjectCap (PageDirectoryCap r (Some a))\"\n\ndefinition\ncheck_valid_ipc_buffer :: \"vspace_ref \\<Rightarrow> cap \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n\"check_valid_ipc_buffer vptr c \\<equiv> case c of\n  (ArchObjectCap (PageCap False _ _ _ _)) \\<Rightarrow> doE\n    whenE (\\<not> is_aligned vptr msg_align_bits) $ throwError AlignmentError;\n    returnOk ()\n  odE\n| _ \\<Rightarrow> throwError IllegalOperation\"", "property": "Valid IPC Buffer: Ensures that the virtual address space capability for an IPC buffer is a valid page directory. If the capability is a non-page-directory, it throws an illegal operation error. For a page capability, it checks alignment and throws an alignment error if not properly aligned.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "A thread's virtual address space capability must be to a page directory\nto be valid on the ARM architecture."}
{"spec": "definition\nattribs_from_word :: \"word32 \\<Rightarrow> vm_attributes\" where\n\"attribs_from_word w \\<equiv>\n  let V = (if w !!0 then {PageCacheable} else {})\n  in if w!!2 then insert XNever V else V\"", "property": "Decode VM Attributes: Extract and decode the virtual memory attributes from a 32-bit word, determining if the mapping should be cacheable and if it should have the XNever attribute.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Decode a user argument word describing the kind of VM attributes a\nmapping is to have."}
{"spec": "definition\n  update_map_data :: \"arch_cap \\<Rightarrow> (word32 \\<times> word32) option \\<Rightarrow> arch_cap\" where\n  \"update_map_data cap m \\<equiv> case cap of PageCap dev p R sz _ \\<Rightarrow> PageCap dev p R sz m\n                                     | PageTableCap p _ \\<Rightarrow> PageTableCap p m\"", "property": "Update Mapping Data: Modify the mapping data associated with a page or page table capability. This ensures that the capability's mapping information is updated to reflect the new values, maintaining the integrity of the memory management system.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Update the mapping data saved in a page or page table capability."}
{"spec": "definition\n  resolve_vaddr :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> ((vmpage_size \\<times> obj_ref) option, 'z::state_ext) s_monad\"\nwhere\n  \"resolve_vaddr pd vaddr \\<equiv> do\n     pd_slot \\<leftarrow> return $ lookup_pd_slot pd vaddr;\n     pde \\<leftarrow> get_master_pde pd_slot;\n     case pde of\n         SectionPDE f _ _ \\<Rightarrow> return $ Some (ARMSection, f)\n       | SuperSectionPDE f _ _ \\<Rightarrow> return $ Some (ARMSuperSection, f)\n       | PageTablePDE t \\<Rightarrow> (do\n           pt \\<leftarrow> return $ ptrFromPAddr t;\n           pte_slot \\<leftarrow> return $ lookup_pt_slot_no_fail pt vaddr;\n           pte \\<leftarrow> get_master_pte pte_slot;\n           case pte of\n               LargePagePTE f _ _ \\<Rightarrow> return $ Some (ARMLargePage, f)\n             | SmallPagePTE f _ _ \\<Rightarrow> return $ Some (ARMSmallPage, f)\n             | _ \\<Rightarrow> return None\n         od)\n       | _ \\<Rightarrow> return None\n   od\"", "property": "Resolve Virtual Address: Determine the frame size and corresponding object reference for a given virtual address by traversing the page directory and page table entries. This process identifies the type of frame (section, super section, large page, or small page) and its associated frame object, enabling accurate memory management and access.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Get information about the frame of a given virtual address"}
{"spec": "definition\n  in_user_frame :: \"word32 \\<Rightarrow> 'z::state_ext state \\<Rightarrow> bool\" where\n  \"in_user_frame p s \\<equiv>\n   \\<exists>sz. kheap s (p && ~~ mask (pageBitsForSize sz)) =\n        Some (ArchObj (DataPage False sz))\"", "property": "Pointer in User Frame: A pointer is considered to be inside a user frame if its top bits, when masked, point to a data page in the kernel heap.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "\n  A pointer is inside a user frame if its top bits point to a @{text DataPage}.\n"}
{"spec": "lemmas msg_align_bits = msg_align_bits'[unfolded word_size_bits_def, simplified]\n\nend\n\nend", "property": "Numeric Value Visibility: Ensure the numeric value of `msg_align_bits` is explicitly visible for clarity and ease of use.", "title": "./spec/abstract/ARM_HYP/ArchVSpace_A.thy", "chapter": "", "section": "", "comment": "Make numeric value of @{const msg_align_bits} visible."}
{"spec": "text \\<open>The high bits of a virtual ASID.\\<close>\ndefinition\n  asid_high_bits_of :: \"asid \\<Rightarrow> 7 word\" where\n  \"asid_high_bits_of asid \\<equiv> ucast (asid >> asid_low_bits)\"", "property": "ASID High Bits Extraction: Extract the high 7 bits of a given ASID by right-shifting the ASID and converting it to a 7-bit word.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "text \\<open>Manipulate ASID pools, page directories and page tables in the kernel\nheap.\\<close>", "property": "Kernel Heap Access: Manipulate ASID pools, page directories, and page tables within the kernel heap to manage memory and address space effectively.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": ""}
{"spec": "locale_abbrev aobjs_of :: \"'z::state_ext state \\<Rightarrow> obj_ref \\<rightharpoonup> arch_kernel_obj\"\n  where\n  \"aobjs_of \\<equiv> \\<lambda>s. kheap s |> aobj_of\"\n\ndefinition\n  get_asid_pool :: \"obj_ref \\<Rightarrow> (10 word \\<rightharpoonup> obj_ref,'z::state_ext) s_monad\" where\n  \"get_asid_pool ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (ASIDPool pool) \\<Rightarrow> return pool\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_asid_pool :: \"obj_ref \\<Rightarrow> (10 word \\<rightharpoonup> obj_ref) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n \"set_asid_pool ptr pool \\<equiv> set_object ptr (ArchObj (arch_kernel_obj.ASIDPool pool))\"\n\ndefinition\n  get_vcpu :: \"obj_ref \\<Rightarrow> (vcpu,'z::state_ext) s_monad\" where\n  \"get_vcpu ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (VCPU v) \\<Rightarrow> return v\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_vcpu :: \"obj_ref \\<Rightarrow> vcpu \\<Rightarrow> (unit,'z::state_ext) s_monad\"\nwhere\n  \"set_vcpu ptr vcpu \\<equiv> set_object ptr (ArchObj (VCPU vcpu))\"\n\ndefinition\n  get_pd :: \"obj_ref \\<Rightarrow> (11 word \\<Rightarrow> pde,'z::state_ext) s_monad\" where\n  \"get_pd ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageDirectory pd) \\<Rightarrow> return pd\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pd :: \"obj_ref \\<Rightarrow> (11 word \\<Rightarrow> pde) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pd ptr pd \\<equiv> set_object ptr (ArchObj (PageDirectory pd))\"\n\ndefinition\n  set_current_pd :: \"paddr \\<Rightarrow> unit machine_monad\"\nwhere\n  \"set_current_pd pd \\<equiv> setCurrentPDPL2 pd\"", "property": "ARM VSpace Accessors: Provide functions to get and set ASID pools, VCPUs, and page directories in the kernel heap, enabling the management and manipulation of virtual address spaces.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": " declared in Arch as workaround for VER-1099 "}
{"spec": "definition\n  get_pde :: \"obj_ref \\<Rightarrow> (pde,'z::state_ext) s_monad\" where\n  \"get_pde ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pd_bits);\n     offset \\<leftarrow> return ((ptr && mask pd_bits) >> pde_bits);\n     pd \\<leftarrow> get_pd base;\n     return $ pd (ucast offset)\n   od\"\n\ndefinition\n  store_pde :: \"obj_ref \\<Rightarrow> pde \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pde p pde \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pd_bits);\n    offset \\<leftarrow> return ((p && mask pd_bits) >> pde_bits);\n    pd \\<leftarrow> get_pd base;\n    pd' \\<leftarrow> return $ pd (ucast offset := pde);\n    set_pd base pd'\n  od\"\n\n\ndefinition\n  get_pt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pte,'z::state_ext) s_monad\" where\n  \"get_pt ptr \\<equiv> do\n     kobj \\<leftarrow> get_object ptr;\n     (case kobj of ArchObj (PageTable pt) \\<Rightarrow> return pt\n                 | _ \\<Rightarrow> fail)\n   od\"\n\ndefinition\n  set_pt :: \"obj_ref \\<Rightarrow> (9 word \\<Rightarrow> pte) \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"set_pt ptr pt \\<equiv> set_object ptr (ArchObj (PageTable pt))\"", "property": "Page Table and Page Directory Access: Retrieve and modify the page table entries (PTEs) and page directory entries (PDEs) in the ARM VSpace. The functions allow for accessing and updating specific entries in the page tables and directories, ensuring that the memory mappings are correctly managed and maintained.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PDE in kernel memory\n  and returns the actual PDE."}
{"spec": "definition\n  get_pte :: \"obj_ref \\<Rightarrow> (pte,'z::state_ext) s_monad\" where\n  \"get_pte ptr \\<equiv> do\n     base \\<leftarrow> return (ptr && ~~mask pt_bits);\n     offset \\<leftarrow> return ((ptr && mask pt_bits) >> pte_bits);\n     pt \\<leftarrow> get_pt base;\n     return $ pt (ucast offset)\n   od\"\n\ndefinition\n  store_pte :: \"obj_ref \\<Rightarrow> pte \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n  \"store_pte p pte \\<equiv> do\n    base \\<leftarrow> return (p && ~~mask pt_bits);\n    offset \\<leftarrow> return ((p && mask pt_bits) >> pte_bits);\n    pt \\<leftarrow> get_pt base;\n    pt' \\<leftarrow> return $ pt (ucast offset := pte);\n    set_pt base pt'\n  od\"", "property": "Page Table Entry Access: Retrieve and store PTEs in the page table. The functions calculate the base address and offset of the PTE, access the page table, and either return or update the PTE at the specified location.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Kernel Heap Accessors", "comment": "The following function takes a pointer to a PTE in kernel memory\n  and returns the actual PTE."}
{"spec": "text \\<open>The kernel window is mapped into every virtual address space from the\n@{term kernel_base} pointer upwards. This function copies the mappings which\ncreate the kernel window into a new page directory object.\\<close>\ndefinition\ncopy_global_mappings :: \"obj_ref \\<Rightarrow> (unit,'z::state_ext) s_monad\" where\n\"copy_global_mappings new_pd \\<equiv> return ()\"", "property": "Copy Global Mappings: Copies the mappings that create the kernel window into a new page directory object, ensuring that the kernel window is accessible from the specified base pointer in every virtual address space.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": ""}
{"spec": "definition\nlookup_pd_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\" where\n\"lookup_pd_slot pd vptr \\<equiv>\n    let pd_index = vptr >> (pageBits + pt_bits - pte_bits) \\<comment> \\<open>ARMHYP\\<close>\n    in pd + (pd_index << pde_bits)\"", "property": "Compute Page Directory Entry Pointer: Given a page-directory reference and a virtual address, calculate the pointer to the corresponding page directory entry in kernel memory.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PDE in kernel memory"}
{"spec": "definition\nlookup_pt_slot :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> (word32,'z::state_ext) lf_monad\" where\n\"lookup_pt_slot pd vptr \\<equiv> doE\n    pd_slot \\<leftarrow> returnOk (lookup_pd_slot pd vptr);\n    pde \\<leftarrow> liftE $ get_pde pd_slot;\n    (case pde of\n          PageTablePDE ptab \\<Rightarrow>   (doE\n            pt \\<leftarrow> returnOk (ptrFromPAddr ptab);\n            pt_index \\<leftarrow> returnOk ((vptr >> pageBits) && mask (pt_bits - pte_bits));\n            pt_slot \\<leftarrow> returnOk (pt + (pt_index << pte_bits));\n            returnOk pt_slot\n          odE)\n        | _ \\<Rightarrow> throwError $ MissingCapability 21)\nodE\"", "property": "Lookup Page Table Slot: Computes a pointer to the PTE in kernel memory for a given page-directory reference and virtual address. The function fails if the virtual address is mapped on a section or super section, ensuring that only valid page table entries are accessed.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "The following function takes a page-directory reference as well as\n  a virtual address and then computes a pointer to the PTE in kernel memory.\n  Note that the function fails if the virtual address is mapped on a section or\n  super section."}
{"spec": "definition\n  lookup_pt_slot_no_fail :: \"word32 \\<Rightarrow> vspace_ref \\<Rightarrow> word32\"\nwhere\n  \"lookup_pt_slot_no_fail pt vptr \\<equiv>\n     let pt_index = ((vptr >> pageBits) && mask (pt_bits - pte_bits))\n     in pt + (pt_index << pte_bits)\"\n\nend\n\nend", "property": "Lookup Page Table Slot: Computes the address of a page table slot given a known page table and a virtual page number, ensuring that the operation does not fail.", "title": "./spec/abstract/ARM_HYP/ArchVSpaceAcc_A.thy", "chapter": "Accessing the ARM VSpace", "section": "Basic Operations", "comment": "A non-failing version of @{const lookup_pt_slot} when the pd is already known"}
{"spec": "text \\<open>This definition ensures that the given pointer is aligned\nto the given page size.\\<close>\n\ndefinition\n  check_vp_alignment :: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> (unit,'z::state_ext) se_monad\" where\n  \"check_vp_alignment sz vptr \\<equiv>\n     unlessE (is_aligned vptr (pageBitsForSize sz)) $\n       throwError AlignmentError\"", "property": "Check Virtual Page Alignment: Ensure that the given virtual page pointer is aligned to the specified page size, throwing an alignment error if the condition is not met.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "definition\n  label_to_flush_type :: \"invocation_label \\<Rightarrow> flush_type\"\nwhere\n  \"label_to_flush_type label \\<equiv> case label of\n       ArchInvocationLabel ARMPDClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPageClean_Data \\<Rightarrow> Clean\n     | ArchInvocationLabel ARMPDInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPageInvalidate_Data \\<Rightarrow> Invalidate\n     | ArchInvocationLabel ARMPDCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPageCleanInvalidate_Data \\<Rightarrow> CleanInvalidate\n     | ArchInvocationLabel ARMPDUnify_Instruction \\<Rightarrow> Unify\n     | ArchInvocationLabel ARMPageUnify_Instruction \\<Rightarrow> Unify\"", "property": "Convert Invocation Label to Flush Type: Maps architecture-specific invocation labels to corresponding flush types, enabling the system to determine the appropriate method for handling memory operations such as cleaning, invalidating, or unifying data and instructions.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": "This definition converts a user-supplied argument into an\ninvocation label, used to determine the method to invoke.\n"}
{"spec": "text \\<open>This definition decodes architecture-specific invocations.\n\\<close>\n\ndefinition\n  page_base :: \"vspace_ref \\<Rightarrow> vmpage_size \\<Rightarrow> vspace_ref\"\nwhere\n  \"page_base vaddr vmsize \\<equiv> vaddr && ~~ mask (pageBitsForSize vmsize)\"", "property": "Page Base Calculation: Compute the base address of a page given a virtual address and the size of the memory page. This ensures that the base address is aligned to the page boundary, facilitating efficient memory management and access.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": ""}
{"spec": "definition\n  isIOSpaceFrame :: \"arch_cap \\<Rightarrow> bool\"\n  where \"isIOSpaceFrame c \\<equiv> False\"\n\ndefinition\n  decode_mmu_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"decode_mmu_invocation label args x_slot cte cap extra_caps \\<equiv>\ncase cap of\n\n  PageDirectoryCap _ _ \\<Rightarrow>\n    if isPDFlushLabel (invocation_type label) then\n    if length args > 1\n    then let start = args ! 0;\n             end = args ! 1\n    in doE\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            whenE (start \\<ge> kernel_base \\<or> end > kernel_base) $ throwError IllegalOperation;\n            (pd,asid) \\<leftarrow> (case cap of\n                    PageDirectoryCap pd (Some asid) \\<Rightarrow> returnOk (pd,asid)\n                  | _ \\<Rightarrow> throwError $ InvalidCapability 0);\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 0;\n            frame_info \\<leftarrow> liftE $ resolve_vaddr pd start;\n            case frame_info of\n                None \\<Rightarrow> returnOk $ InvokePageDirectory PageDirectoryNothing\n              | Some (frame_size, frame_base) \\<Rightarrow>\n                    let base_start = page_base start frame_size;\n                        base_end = page_base (end - 1) frame_size;\n                        offset = start && mask (pageBitsForSize frame_size);\n                        pstart = frame_base + offset\n                    in doE\n                        whenE (base_start \\<noteq> base_end) $ throwError $\n                            RangeError start (base_start + mask (pageBitsForSize frame_size));\n                        returnOk $ InvokePageDirectory $\n                            PageDirectoryFlush (label_to_flush_type (invocation_type label))\n                            start (end - 1) pstart pd asid\n                    odE\n    odE\n    else throwError TruncatedMessage\n    else throwError IllegalOperation\n\n| PageTableCap p mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageTableMap then\n    if length args > 1 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             pd_cap = fst (extra_caps ! 0)\n    in doE\n            whenE (mapped_address \\<noteq> None) $ throwError $ InvalidCapability 0;\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            whenE (vaddr \\<ge> kernel_base) $ throwError $ InvalidArgument 0;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            pd_index \\<leftarrow> returnOk (shiftr vaddr (pageBits + pt_bits - pte_bits));\n            vaddr' \\<leftarrow> returnOk (vaddr && ~~ mask (pageBits + pt_bits - pte_bits));\n            pd_slot \\<leftarrow> returnOk (pd + (pd_index << pde_bits));\n            oldpde \\<leftarrow> liftE $ get_master_pde pd_slot;\n            unlessE (oldpde = InvalidPDE) $ throwError DeleteFirst;\n            pde \\<leftarrow> returnOk (PageTablePDE (addrFromPPtr p));\n            returnOk $ InvokePageTable $\n                PageTableMap\n                (ArchObjectCap $ PageTableCap p (Some (asid, vaddr')))\n                cte pde pd_slot\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageTableUnmap\n    then doE\n            final \\<leftarrow> liftE $ is_final_cap (ArchObjectCap cap);\n            unlessE final $ throwError RevokeFirst;\n            returnOk $ InvokePageTable $ PageTableUnmap (ArchObjectCap cap) cte\n    odE\n    else throwError IllegalOperation\n\n| PageCap dev p R pgsz mapped_address \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMPageMap then\n    if length args > 2 \\<and> length extra_caps > 0\n    then let vaddr = args ! 0;\n             rights_mask = args ! 1;\n             attr = args ! 2;\n             pd_cap = fst (extra_caps ! 0)\n        in doE\n            (pd,asid) \\<leftarrow> (case pd_cap of\n                            ArchObjectCap (PageDirectoryCap pd (Some asid)) \\<Rightarrow>\n                              returnOk (pd,asid)\n                         | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            case mapped_address of\n              Some (asid', vaddr') \\<Rightarrow> doE\n                whenE (asid' \\<noteq> asid) (throwError $ InvalidCapability 1);\n                whenE (vaddr' \\<noteq> vaddr) (throwError $ InvalidArgument 0)\n              odE\n            | None \\<Rightarrow> doE\n                vtop \\<leftarrow> returnOk (vaddr + (1 << (pageBitsForSize pgsz)) - 1);\n                whenE (vtop \\<ge> kernel_base) $ throwError $ InvalidArgument 0\n              odE;\n            pd' \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (pd' \\<noteq> pd) $ throwError $ InvalidCapability 1;\n            vm_rights \\<leftarrow> returnOk (mask_vm_rights R (data_to_rights rights_mask));\n            check_vp_alignment pgsz vaddr;\n            entries \\<leftarrow> create_mapping_entries (addrFromPPtr p)\n                                              vaddr pgsz vm_rights\n                                              (attribs_from_word attr) pd;\n            ensure_safe_mapping entries;\n            returnOk $ InvokePage $ PageMap asid\n                (ArchObjectCap $ PageCap dev p R pgsz (Some (asid, vaddr)))\n                cte entries\n        odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageUnmap\n    then  returnOk $ InvokePage $ PageUnmap cap cte\n    else if isPageFlushLabel (invocation_type label) then\n        if length args > 1\n        then let start = args ! 0;\n                 end = args ! 1;\n                 pstart = start + addrFromPPtr p\n        in doE\n            (asid, _) \\<leftarrow> (case mapped_address of\n                Some a \\<Rightarrow> returnOk a\n              | _ \\<Rightarrow> throwError IllegalOperation);\n            pd \\<leftarrow> lookup_error_on_failure False $ find_pd_for_asid asid;\n            whenE (end \\<le> start) $ throwError $ InvalidArgument 1;\n            page_size \\<leftarrow> returnOk $ 1 << pageBitsForSize pgsz;\n            whenE (start \\<ge> page_size \\<or> end > page_size) $ throwError $ InvalidArgument 0;\n            whenE (pstart < physBase \\<or> ((end - start) + pstart) > paddrTop) $ throwError IllegalOperation;\n            returnOk $ InvokePage $ PageFlush\n                (label_to_flush_type (invocation_type label)) (start + p) \\<comment> \\<open>check\\<close>\n                (end + p - 1) pstart pd asid\n    odE\n    else throwError TruncatedMessage\n    else if invocation_type label = ArchInvocationLabel ARMPageGetAddress\n    then returnOk $ InvokePage $ PageGetAddr p\n  else  throwError IllegalOperation\n\n| ASIDControlCap \\<Rightarrow>\n    if invocation_type label = ArchInvocationLabel ARMASIDControlMakePool then\n    if length args > 1 \\<and> length extra_caps > 1\n    then let index = args ! 0;\n             depth = args ! 1;\n             (untyped, parent_slot) = extra_caps ! 0;\n             root = fst (extra_caps ! 1)\n         in doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            free_set \\<leftarrow> returnOk (- dom asid_table \\<inter> {x. x \\<le> (1 << asid_high_bits) - 1});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            free \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_select asid_table) free_set;\n            base \\<leftarrow> returnOk (ucast free << asid_low_bits);\n            (p,n) \\<leftarrow> (case untyped of UntypedCap False p n f \\<Rightarrow> returnOk (p,n)\n                                    | _ \\<Rightarrow> throwError $ InvalidCapability 1);\n            frame \\<leftarrow> (if n = pageBits\n                      then doE\n                        ensure_no_children parent_slot;\n                        returnOk p\n                      odE\n                      else  throwError $ InvalidCapability 1);\n            dest_slot \\<leftarrow> lookup_target_slot root (to_bl index) (unat depth);\n            ensure_empty dest_slot;\n            returnOk $ InvokeASIDControl $ MakePool frame dest_slot parent_slot base\n        odE\n    else  throwError TruncatedMessage\n    else  throwError IllegalOperation\n\n| ASIDPoolCap p base \\<Rightarrow>\n  if invocation_type label = ArchInvocationLabel ARMASIDPoolAssign then\n  if length extra_caps > 0\n  then\n    let (pd_cap, pd_cap_slot) = extra_caps ! 0\n     in case pd_cap of\n          ArchObjectCap (PageDirectoryCap _ None) \\<Rightarrow> doE\n            asid_table \\<leftarrow> liftE $ gets (arm_asid_table \\<circ> arch_state);\n            pool_ptr \\<leftarrow> returnOk (asid_table (asid_high_bits_of base));\n            whenE (pool_ptr = None) $ throwError $ FailedLookup False InvalidRoot;\n            whenE (p \\<noteq> the pool_ptr) $ throwError $ InvalidCapability 0;\n            pool \\<leftarrow> liftE $ get_asid_pool p;\n            free_set \\<leftarrow> returnOk (- dom pool \\<inter> {x. ucast x + base \\<noteq> 0});\n            whenE (free_set = {}) $ throwError DeleteFirst;\n            offset \\<leftarrow> liftE $ select_ext (\\<lambda>_. free_asid_pool_select pool base) free_set;\n            returnOk $ InvokeASIDPool $ Assign (ucast offset + base) p pd_cap_slot\n          odE\n        | _ \\<Rightarrow>  throwError $ InvalidCapability 1\n  else  throwError TruncatedMessage\n  else  throwError IllegalOperation\n| VCPUCap p \\<Rightarrow> fail \\<comment> \\<open>not an MMU invocation\\<close>\"", "property": "Decode MMU Invocations: Decode architecture-specific system calls related to memory management, including operations on page directories, page tables, and pages. The decoding process validates the arguments, checks for valid capabilities, and performs specific actions such as mapping, unmapping, and flushing, ensuring the integrity and security of the memory management unit. \n\n- **Page Directory Operations**: Validate and decode operations for flushing page directories, ensuring that the provided addresses and ranges are valid and within the allowed limits.\n- **Page Table Operations**: Decode operations for mapping and unmapping page tables, validating the provided addresses, and ensuring the correct parent directory and ASID are used.\n- **Page Operations**: Decode operations for mapping, unmapping, and flushing pages, validating the provided addresses, rights, and attributes, and ensuring the correct parent directory and ASID are used.\n- **ASID Control Operations**: Decode operations for creating ASID pools, ensuring that the provided untyped capability is valid and the destination slot is empty.\n- **ASID Pool Operations**: Decode operations for assigning ASIDs to page directories, ensuring that the provided ASID pool and page directory capabilities are valid and the ASID is available.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": " decode mmu invocations "}
{"spec": "definition\n  arch_decode_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cap_ref \\<Rightarrow> cslot_ptr \\<Rightarrow> arch_cap \\<Rightarrow> (cap \\<times> cslot_ptr) list \\<Rightarrow>\n   (arch_invocation,'z::state_ext) se_monad\"\nwhere\n  \"arch_decode_invocation label args x_slot cte cap extra_caps \\<equiv> case cap of\n VCPUCap _ \\<Rightarrow> decode_vcpu_invocation label args cap extra_caps\n\\<comment> \\<open>arm-hyp: add cases for iommu\\<close>\n| _ \\<Rightarrow> decode_mmu_invocation label args x_slot cte cap extra_caps\"\n\ndefinition\n  arch_data_to_obj_type :: \"nat \\<Rightarrow> aobject_type option\" where\n \"arch_data_to_obj_type n \\<equiv>\n  if n = 0 then Some PageDirectoryObj\n  else if n = 1 then Some SmallPageObj\n  else if n = 2 then Some LargePageObj\n  else if n = 3 then Some SectionObj\n  else if n = 4 then Some SuperSectionObj\n  else if n = 5 then Some PageTableObj\n  else if n = 6 then Some VCPUObj\n  else None\"\n\ndefinition arch_decode_irq_control_invocation ::\n  \"data \\<Rightarrow> data list \\<Rightarrow> cslot_ptr \\<Rightarrow> cap list \\<Rightarrow> (arch_irq_control_invocation,'z::state_ext) se_monad\"\n  where\n  \"arch_decode_irq_control_invocation label args src_slot cps \\<equiv>\n    (if invocation_type label = ArchInvocationLabel ARMIRQIssueIRQHandler\n      then if length args \\<ge> 4 \\<and> length cps \\<ge> 1\n        then let irq_word = args ! 0;\n                 trigger = args ! 1;\n                 index = args ! 2;\n                 depth = args ! 3;\n                 cnode = cps ! 0;\n                 irq = ucast irq_word\n        in doE\n          arch_check_irq irq_word;\n          irq_active \\<leftarrow> liftE $ is_irq_active irq;\n          whenE irq_active $ throwError RevokeFirst;\n\n          dest_slot \\<leftarrow> lookup_target_slot cnode (data_to_cptr index) (unat depth);\n          ensure_empty dest_slot;\n\n          returnOk $ ArchIRQControlIssue irq dest_slot src_slot (trigger \\<noteq> 0)\n        odE\n      else throwError TruncatedMessage\n    else throwError IllegalOperation)\"\n\nend\n\nend", "property": "Decode Architecture-specific System Calls: Decode architecture-specific system call invocations based on the provided label, arguments, and capabilities. It handles different types of invocations, such as VCPU and MMU, and decodes IRQ control invocations, ensuring that the correct parameters are present and valid.", "title": "./spec/abstract/ARM_HYP/ArchDecode_A.thy", "chapter": "Decoding Architecture-specific System Calls", "section": "Architecture calls", "comment": " arch decode invocations "}
{"spec": "datatype flush_type = Clean | Invalidate | CleanInvalidate | Unify\n\ndatatype page_directory_invocation =\n    PageDirectoryFlush (pd_flush_type: flush_type) (pd_flush_start: vspace_ref)\n                       (pd_flush_end: vspace_ref) (pd_flush_pstart: word32)\n                       (pd_flush_pd: obj_ref) (pd_flush_asid: asid)\n  | PageDirectoryNothing\n\ndatatype page_table_invocation =\n    PageTableMap cap cslot_ptr pde obj_ref\n  | PageTableUnmap cap cslot_ptr\n\ndatatype asid_control_invocation =\n    MakePool obj_ref cslot_ptr cslot_ptr asid\n\ndatatype asid_pool_invocation =\n    Assign asid obj_ref cslot_ptr\n\ndatatype page_invocation\n     = PageMap\n         (page_map_asid: asid)\n         (page_map_cap: cap)\n         (page_map_ct_slot: cslot_ptr)\n         (page_map_entries: \"pte \\<times> (obj_ref list) + pde \\<times> (obj_ref list)\")\n     | PageUnmap\n         (page_unmap_cap: arch_cap)\n         (page_unmap_cap_slot: cslot_ptr)\n     | PageFlush\n         (page_flush_type: flush_type)\n         (page_flush_start: vspace_ref)\n         (page_flush_end: vspace_ref)\n         (page_flush_pstart: word32)\n         (page_flush_pd: obj_ref)\n         (page_flush_asid: asid)\n     | PageGetAddr\n         (page_get_paddr: obj_ref)\n\ndatatype vcpu_invocation =\n       VCPUSetTCB obj_ref (*vcpu*) obj_ref (*tcb*)\n     | VCPUInjectIRQ obj_ref nat virq\n     | VCPUReadRegister obj_ref vcpureg\n     | VCPUWriteRegister obj_ref vcpureg machine_word\n     | VCPUAckVPPI obj_ref (* vcpu *) vppievent_irq\n\ndatatype arch_invocation\n     = InvokePageTable page_table_invocation\n     | InvokePageDirectory page_directory_invocation\n     | InvokePage page_invocation\n     | InvokeASIDControl asid_control_invocation\n     | InvokeASIDPool asid_pool_invocation\n     | InvokeVCPU vcpu_invocation", "property": "ARM System Call Arguments: Define the arguments for ARM-specific system calls, including operations on page directories, page tables, ASID control, ASID pools, and VCPUs. These datatypes provide a structured way to handle various memory management and virtualization tasks, ensuring that the system calls can be invoked with the necessary parameters.", "title": "./spec/abstract/ARM_HYP/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": "These datatypes encode the arguments to the various possible\nARM-specific system calls. Selectors are defined for various fields\nfor convenience elsewhere."}
{"spec": "datatype arch_copy_register_sets = ARMNoExtraRegisters\n\ndefinition \"ArchDefaultExtraRegisters \\<equiv> ARMNoExtraRegisters\"\n\ndatatype arch_irq_control_invocation =\n    ArchIRQControlIssue irq cslot_ptr cslot_ptr bool\n\nend\n\nend", "property": "ARM Copy Registers: The ARM platform does not currently support additional register sets for the \"CopyRegisters\" operation, limiting it to the standard register sets. Future updates may introduce support for a floating point unit.", "title": "./spec/abstract/ARM_HYP/ArchInvocation_A.thy", "chapter": "", "section": "", "comment": " The ARM platform currently does not define any additional register sets for\nthe \"CopyRegisters\" operation. This may be changed in future to support a floating point unit. "}
{"spec": "text \\<open>An ASID is simply a word.\\<close>\ntype_synonym asid = \"word32\"\n\ndatatype vm_attribute = PageCacheable | XNever\ntype_synonym vm_attributes = \"vm_attribute set\"", "property": "Define ASID and VM Attributes: An ASID is represented as a 32-bit word, and VM attributes are defined as a set of possible values including PageCacheable and XNever.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific capabilities", "comment": ""}
{"spec": "text \\<open>The ARM kernel supports capabilities for ASID pools and an ASID controller capability,\nalong with capabilities for page directories, page tables, and page mappings.\\<close>\n\ndatatype arch_cap =\n   ASIDPoolCap obj_ref asid\n | ASIDControlCap\n | PageCap bool obj_ref cap_rights vmpage_size \"(asid * vspace_ref) option\"\n | PageTableCap obj_ref \"(asid * vspace_ref) option\"\n | PageDirectoryCap obj_ref \"asid option\"\n | VCPUCap obj_ref\n\nlemmas arch_cap_cases =\n  arch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P, simplified, rule_format]\n\nlemmas arch_cap_cases_asm =\narch_cap.induct[where arch_cap=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n  simplified, rule_format, rotated -1]\n\ndefinition\n  is_page_cap :: \"arch_cap \\<Rightarrow> bool\" where\n  \"is_page_cap c \\<equiv> \\<exists>x0 x1 x2 x3 x4. c = PageCap x0 x1 x2 x3 x4\"", "property": "ARM-Specific Capabilities: The ARM kernel supports a variety of architecture-specific capabilities, including ASID pools, ASID controller, page directories, page tables, page mappings, and VCPU. These capabilities are used to manage memory and virtualization in the ARM architecture.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "text \\<open>This section gives the types and auxiliary definitions for the\narchitecture-specific objects: a page directory entry (@{text \"pde\"})\ncontains either an invalid entry, a page table reference, a section\nreference, or a super-section reference; a page table entry contains\neither an invalid entry, a large page, or a small page mapping;\nfinally, an architecture-specific object is either an ASID pool, a\npage table, a page directory, or a data page used to model user\nmemory.\n\\<close>", "property": "Architecture-Specific Objects: Define the types for architecture-specific objects, including page directory entries (PDEs) that can contain invalid entries, page table references, section references, or super-section references; page table entries that can contain invalid entries, large page mappings, or small page mappings; and architecture-specific objects that can be ASID pools, page tables, page directories, or data pages used to model user memory.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": ""}
{"spec": "datatype pde =\n   InvalidPDE\n | PageTablePDE obj_ref\n | SectionPDE obj_ref vm_attributes cap_rights\n | SuperSectionPDE obj_ref vm_attributes cap_rights\n\ndatatype pte =\n   InvalidPTE\n | LargePagePTE obj_ref vm_attributes cap_rights\n | SmallPagePTE obj_ref vm_attributes cap_rights\n\ntype_synonym hyper_reg_context = machine_word", "property": "Page Table and Page Entry Descriptors: Define the structure of page table and page entry descriptors, including invalid entries, page table pointers, section and super-section mappings, and large and small page mappings. These descriptors support the three-level table system for stage 2 translation, with the flexibility to omit the first level if second levels are stored contiguously.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": "\nHypervisor extensions use long page table descriptors (64-bit) for the stage 2\ntranslation (host-to-hypervisor). This is a three-level table system, but the\nhardware can be configured to omit the first level entirely if all second\nlevels are stored contiguously. We use this configuration to preserve the usual\npage table/directory nomenclature.\nseL4 does not use hardware domains or parity on ARM hypervisor systems.\n"}
{"spec": "definition\n  pde_bits :: \"nat\" where\n  \"pde_bits \\<equiv> 3\"\n\ndefinition\n  pte_bits :: \"nat\" where\n  \"pte_bits \\<equiv> 3\"\n\ndefinition\n  pd_bits :: \"nat\" where\n  \"pd_bits \\<equiv> 11 + pde_bits\"\n\ndefinition\n  pt_bits :: \"nat\" where\n  \"pt_bits \\<equiv> 9 + pte_bits\"\n\ndefinition\n  vcpu_bits :: \"nat\" where\n  \"vcpu_bits \\<equiv> pageBits\"", "property": "Page Table and Directory Sizes: Define the sizes of page table and directory entries, where each entry occupies 8 bytes. Page directories span four frames, and page tables span a single frame, with specific bit allocations for page directory (11 + 3 bits) and page table (9 + 3 bits) entries.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": "With hypervisor extensions enabled, page table and page directory entries occupy\n8 bytes. Page directories occupy four frames, and page tables occupy a frame."}
{"spec": "type_synonym virq = machine_word\n\nend\n\nqualify ARM_HYP_A (in Arch)\n\nrecord  gic_vcpu_interface =\n  vgic_hcr  :: machine_word\n  vgic_vmcr :: machine_word\n  vgic_apr  :: machine_word\n  vgic_lr   :: \"nat \\<Rightarrow> ARM_HYP_A.virq\"\n\nrecord vcpu =\n  vcpu_tcb   :: \"obj_ref option\"\n  vcpu_vgic  :: gic_vcpu_interface\n  vcpu_regs :: \"vcpureg \\<Rightarrow> machine_word\"\n  vcpu_vppi_masked :: \"vppievent_irq \\<Rightarrow> bool\"\n  vcpu_vtimer :: virt_timer\n\nend_qualify\n\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition \"vcpu_sctlr vcpu \\<equiv> vcpu_regs vcpu VCPURegSCTLR\"\n\ndefinition\n  default_gic_vcpu_interface :: gic_vcpu_interface\nwhere\n  \"default_gic_vcpu_interface \\<equiv> \\<lparr>\n      vgic_hcr  = vgicHCREN,\n      vgic_vmcr = 0,\n      vgic_apr  = 0,\n      vgic_lr   = \\<lambda>_. 0 \\<rparr>\"\n\ndefinition\n  default_vcpu :: vcpu where\n  \"default_vcpu \\<equiv> \\<lparr>\n      vcpu_tcb    = None,\n      vcpu_vgic   = default_gic_vcpu_interface,\n      vcpu_regs   = (\\<lambda>_. 0) (VCPURegSCTLR := sctlrDefault\n                             , VCPURegACTLR := actlrDefault),\n      vcpu_vppi_masked = (\\<lambda>_. False),\n      vcpu_vtimer = VirtTimer 0\n      \\<rparr>\"", "property": "Virtual CPU (vCPU) Definition: Defines a virtual CPU structure that includes a reference to a thread control block, a GIC vCPU interface, register values, vPPI masking, and a virtual timer. The GIC vCPU interface contains fields for handling virtual interrupt control, and the vCPU structure is initialized with default values for these components.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": "vcpu"}
{"spec": "datatype arch_kernel_obj =\n   ASIDPool \"10 word \\<rightharpoonup> obj_ref\"\n | PageTable \"9 word \\<Rightarrow> pte\"  (* ARMHYP *)\n | PageDirectory \"11 word \\<Rightarrow> pde\"  (* ARMHYP *)\n | DataPage bool vmpage_size\n | VCPU vcpu\n\nlemmas arch_kernel_obj_cases =\n  arch_kernel_obj.induct[where arch_kernel_obj=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x'\" for x P,\n                         simplified, rule_format]\n\nlemmas arch_kernel_obj_cases_asm =\n  arch_kernel_obj.induct[where arch_kernel_obj=x and P=\"\\<lambda>x'. x = x' \\<longrightarrow> P x' \\<longrightarrow> R\" for P R x,\n                         simplified, rule_format, rotated -1]\n\ndefinition cte_level_bits :: nat where\n  \"cte_level_bits \\<equiv> 4\"\n\nprimrec\n  arch_obj_size :: \"arch_cap \\<Rightarrow> nat\"\nwhere\n  \"arch_obj_size (ASIDPoolCap p as) = pageBits\"\n| \"arch_obj_size ASIDControlCap = 0\"\n| \"arch_obj_size (PageCap dev x rs sz as4) = pageBitsForSize sz\"\n| \"arch_obj_size (PageDirectoryCap x as2) = pd_bits\"\n| \"arch_obj_size (PageTableCap x as3) = pt_bits\"\n| \"arch_obj_size (VCPUCap _) = vcpu_bits\"\n\nprimrec\n  arch_cap_is_device :: \"arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_cap_is_device (PageCap dev x rs sz as4) = dev\"\n| \"arch_cap_is_device ASIDControlCap = False\"\n| \"arch_cap_is_device (ASIDPoolCap p as) = False\"\n| \"arch_cap_is_device (PageTableCap x as3) = False\"\n| \"arch_cap_is_device (PageDirectoryCap x as2) = False\"\n| \"arch_cap_is_device (VCPUCap _) = False\"\n\ndefinition tcb_bits :: nat where\n  \"tcb_bits \\<equiv> 9\"\n\ndefinition endpoint_bits :: nat where\n  \"endpoint_bits \\<equiv> 4\"\n\ndefinition ntfn_bits :: nat where\n  \"ntfn_bits \\<equiv> 4\"\n\ndefinition untyped_min_bits :: nat where\n  \"untyped_min_bits \\<equiv> 4\"\n\ndefinition untyped_max_bits :: nat where\n  \"untyped_max_bits \\<equiv> 29\"\n\nprimrec\n  arch_kobj_size :: \"arch_kernel_obj \\<Rightarrow> nat\"\nwhere\n  \"arch_kobj_size (ASIDPool p) = pageBits\"\n| \"arch_kobj_size (PageTable pte) = pt_bits\"\n| \"arch_kobj_size (PageDirectory pde) = pd_bits\"\n| \"arch_kobj_size (DataPage dev sz) = pageBitsForSize sz\"\n| \"arch_kobj_size (VCPU _) = vcpu_bits\"\n\nprimrec\n  aobj_ref :: \"arch_cap \\<rightharpoonup> obj_ref\"\nwhere\n  \"aobj_ref (ASIDPoolCap p as) = Some p\"\n| \"aobj_ref ASIDControlCap = None\"\n| \"aobj_ref (PageCap dev x rs sz as4) = Some x\"\n| \"aobj_ref (PageDirectoryCap x as2) = Some x\"\n| \"aobj_ref (PageTableCap x as3) = Some x\"\n| \"aobj_ref (VCPUCap x) = Some x\"\n\nprimrec (nonexhaustive)\n  acap_rights :: \"arch_cap \\<Rightarrow> cap_rights\"\nwhere\n \"acap_rights (PageCap dev x rs sz as) = rs\"\n\ndefinition\n  acap_rights_update :: \"cap_rights \\<Rightarrow> arch_cap \\<Rightarrow> arch_cap\" where\n \"acap_rights_update rs ac \\<equiv> case ac of\n    PageCap dev x rs' sz as \\<Rightarrow> PageCap dev x (validate_vm_rights rs) sz as\n  | _                   \\<Rightarrow> ac\"", "property": "Architecture-Specific Kernel Objects: Define and categorize ARM-specific kernel objects, including ASID pools, page tables, page directories, data pages, and VCPUs. Each object type has a specific size and structure, with ASID pools translating 10 bits, page tables having 512 entries, and data pages recording their size. VCPUs store a potential association to a TCB and an extended register context.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific objects", "comment": "\n  ASID pools translate 10 bits, VCPUs store a potential association to a TCB as well as\n  an extended register context. Page tables have 512 entries (cf B3.6.5, pg 1348). For data pages,\n  we record their size.\n"}
{"spec": "datatype\n  aobject_type =\n    SmallPageObj\n  | LargePageObj\n  | SectionObj\n  | SuperSectionObj\n  | PageTableObj\n  | PageDirectoryObj\n  | ASIDPoolObj\n  | VCPUObj\n\ndefinition\n  arch_is_frame_type :: \"aobject_type \\<Rightarrow> bool\"\n  where\n    \"arch_is_frame_type aobj \\<equiv> case aobj of\n         SmallPageObj \\<Rightarrow> True\n       | LargePageObj \\<Rightarrow> True\n       | SectionObj \\<Rightarrow> True\n       | SuperSectionObj \\<Rightarrow> True\n       | _ \\<Rightarrow> False\"\n\ndefinition  arch_default_cap :: \"aobject_type \\<Rightarrow> obj_ref \\<Rightarrow> nat \\<Rightarrow> bool \\<Rightarrow> arch_cap\" where\n \"arch_default_cap tp r n dev \\<equiv> case tp of\n  SmallPageObj \\<Rightarrow> PageCap dev r vm_read_write ARMSmallPage None\n  | LargePageObj \\<Rightarrow> PageCap dev r vm_read_write ARMLargePage None\n  | SectionObj \\<Rightarrow> PageCap dev r vm_read_write ARMSection None\n  | SuperSectionObj \\<Rightarrow> PageCap dev r vm_read_write ARMSuperSection None\n  | PageTableObj \\<Rightarrow> PageTableCap r None\n  | PageDirectoryObj \\<Rightarrow> PageDirectoryCap r None\n  | VCPUObj \\<Rightarrow> VCPUCap r\n  | ASIDPoolObj \\<Rightarrow> ASIDPoolCap r 0\" (* unused *)\n\ndefinition\n  default_arch_object :: \"aobject_type \\<Rightarrow> bool \\<Rightarrow> nat \\<Rightarrow> arch_kernel_obj\" where\n \"default_arch_object tp dev n \\<equiv> case tp of\n    SmallPageObj \\<Rightarrow> DataPage dev ARMSmallPage\n  | LargePageObj \\<Rightarrow> DataPage dev ARMLargePage\n  | SectionObj \\<Rightarrow> DataPage dev ARMSection\n  | SuperSectionObj \\<Rightarrow> DataPage dev ARMSuperSection\n  | PageTableObj \\<Rightarrow> PageTable (\\<lambda>x. InvalidPTE)\n  | PageDirectoryObj \\<Rightarrow> PageDirectory (\\<lambda>x. InvalidPDE)\n  | VCPUObj \\<Rightarrow> VCPU default_vcpu\n  | ASIDPoolObj \\<Rightarrow> ASIDPool (\\<lambda>_. None)\"\n\ntype_synonym hw_asid = word8\n\ntype_synonym arm_vspace_region_uses = \"vspace_ref \\<Rightarrow> arm_vspace_region_use\"", "property": "Architecture-Specific Object Types: Defines a set of ARM-specific object types, including various page sizes, page tables, page directories, ASID pools, and VCPU objects. Each object type can be checked for whether it is a frame type, and default capabilities and objects can be generated based on the type, device status, and other parameters.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific object types and default objects", "comment": ""}
{"spec": "text \\<open>The architecture-specific state for the ARM model\nconsists of the first level of the ASID table (@{text \"arm_asid_table\"}), a\nmap from hardware ASIDs to seL4 ASIDs (@{text \"arm_hwasid_table\"}),\nthe next hardware ASID to preempt (@{text \"arm_next_asid\"}), the\ninverse map from seL4 ASIDs to hardware ASIDs (first component of\n@{text \"arm_asid_map\"}), and the address of the page directory and\npage tables mapping the shared address space, along with a description\nof this space (@{text \"arm_global_pd\"}, @{text \"arm_global_pts\"}, and\n@{text \"arm_kernel_vspace\"} respectively).\n\nHardware ASIDs are only ever associated with seL4 ASIDs that have a\ncurrently active page directory. The second component of\n@{text \"arm_asid_map\"} values is the address of that page directory.\n\\<close>\n\nend\n\nqualify ARM_HYP_A (in Arch)", "property": "Architecture-Specific State: The ARM model maintains a set of architecture-specific state components, including the first level of the ASID table, a mapping from hardware ASIDs to seL4 ASIDs, the next hardware ASID to be preempted, an inverse map from seL4 ASIDs to hardware ASIDs, and the address and description of the page directory and page tables for the shared address space. These components ensure that the ARM architecture's memory management and virtualization are correctly managed and synchronized.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific state", "comment": ""}
{"spec": "record arch_state =\n  arm_asid_table    :: \"7 word \\<rightharpoonup> obj_ref\"\n  arm_hwasid_table  :: \"ARM_HYP_A.hw_asid \\<rightharpoonup> ARM_HYP_A.asid\"\n  arm_next_asid     :: ARM_HYP_A.hw_asid\n  arm_asid_map      :: \"ARM_HYP_A.asid \\<rightharpoonup> (ARM_HYP_A.hw_asid \\<times> obj_ref)\"\n  arm_current_vcpu    :: \"(obj_ref \\<times> bool) option\"\n  arm_gicvcpu_numlistregs :: nat\n  arm_kernel_vspace :: ARM_HYP_A.arm_vspace_region_uses\n  arm_us_global_pd  :: obj_ref\n\nend_qualify\n\ncontext Arch begin arch_global_naming (A)", "property": "Architecture-Specific State: The `arch_state` record encapsulates various architecture-specific components, including ASID tables, the next available ASID, mappings between ASIDs and virtual CPUs, the current virtual CPU, the number of GICvCPU list registers, the kernel's virtual space, and the global page directory. This structure ensures that the system maintains the necessary state for managing memory and virtualization on ARM architectures.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Architecture-specific state", "comment": "arch\\_state"}
{"spec": "datatype aa_type =\n    AASIDPool\n  | APageTable\n  | APageDirectory\n  | AVCPU\n  | AUserData vmpage_size\n  | ADeviceData vmpage_size\n\n\ndefinition aa_type :: \"arch_kernel_obj \\<Rightarrow> aa_type\"\nwhere\n \"aa_type ao \\<equiv> (case ao of\n           PageTable pt             \\<Rightarrow> APageTable\n         | PageDirectory pd         \\<Rightarrow> APageDirectory\n         | DataPage dev sz          \\<Rightarrow> if dev then ADeviceData sz else AUserData sz\n         | ASIDPool f               \\<Rightarrow> AASIDPool\n         | VCPU v                   \\<Rightarrow> AVCPU)\"", "property": "ARM-Specific Architecture Object Types: Defines a set of types for ARM-specific architecture objects, including AASIDPool, APageTable, APageDirectory, AVCPU, and data pages (AUserData or ADeviceData) with varying sizes. These types categorize different kinds of architectural objects, ensuring they are correctly identified and managed within the system.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": ""}
{"spec": "definition\n  badge_bits :: nat where\n  badge_bits_def [simp]: \"badge_bits \\<equiv> 28\"\nend", "property": "Badge Bits Definition: The badge word is defined to have 28 bits.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Type declarations for invariant definitions", "comment": "For implementation reasons the badge word has differing amounts of bits"}
{"spec": "qualify ARM_HYP_A (in Arch)", "property": "ARM-Specific TCB: Defines architecture-specific data types and configurations for the Thread Control Block (TCB) in an ARM hypervisor environment, ensuring that the TCB is tailored to the specific requirements and capabilities of ARM architecture.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Arch-specific tcb", "comment": ""}
{"spec": "definition\n  arch_tcb_set_registers :: \"(register \\<Rightarrow> machine_word) \\<Rightarrow> arch_tcb \\<Rightarrow> arch_tcb\"\nwhere\n  \"arch_tcb_set_registers regs a_tcb \\<equiv> a_tcb \\<lparr> tcb_context := UserContext regs \\<rparr>\"\n\ndefinition\n  arch_tcb_get_registers :: \"arch_tcb \\<Rightarrow> register \\<Rightarrow> machine_word\"\nwhere\n  \"arch_tcb_get_registers a_tcb \\<equiv> user_regs (tcb_context a_tcb)\"\n\nend\n\n\nend", "property": "Register Management: Allows setting and retrieving user registers in the architecture-specific TCB. Setting updates the TCB context with the provided register values, while retrieving fetches the value of a specific register from the TCB context.", "title": "./spec/abstract/ARM_HYP/Arch_Structs_A.thy", "chapter": "ARM-Specific Data Types", "section": "Arch-specific tcb", "comment": "\n  Accessors for the user register part of the @{text \"arch_tcb\"}.\n  (Because @{typ \"register \\<Rightarrow> machine_word\"} might not be equal to @{typ user_context})."}
{"spec": "(*\nFunctions for fault handling.\n*)\n\nchapter \\<open>arch fault related functions\\<close>\n\ntheory ArchFault_A\nimports Structures_A Tcb_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\nfun make_arch_fault_msg :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> (data \\<times> data list,'z::state_ext) s_monad\"\nwhere\n  \"make_arch_fault_msg (VMFault vptr archData) thread = do\n     pc \\<leftarrow> as_user thread getRestartPC;\n     return (5, pc # vptr # archData) od\"\n| \"make_arch_fault_msg (VCPUFault hsr) thread = return (7, [hsr])\"\n| \"make_arch_fault_msg (VPPIEvent irq) thread = return (8, [ucast irq])\"\n| \"make_arch_fault_msg (VGICMaintenance archData) thread = do\n      msg \\<leftarrow> return $ (case archData of None \\<Rightarrow> [-1] | Some idx \\<Rightarrow> [idx]);\n      return (6, msg)\n   od\"\n\ndefinition\n  handle_arch_fault_reply :: \"arch_fault \\<Rightarrow> obj_ref \\<Rightarrow> data \\<Rightarrow> data list \\<Rightarrow> (bool,'z::state_ext) s_monad\"\nwhere\n  \"handle_arch_fault_reply af thread x y = return True\"\n\n\nend\n\nend", "property": "Arch Fault Message Generation: Generates a message for different types of architectural faults, including VM faults, VCPU faults, VPPI events, and VGIC maintenance. The message includes specific data relevant to the fault type, such as the restart PC, virtual pointer, and additional fault-specific data.", "title": "./spec/abstract/ARM_HYP/ArchFault_A.thy", "chapter": "arch fault related functions", "section": "", "comment": ""}
{"spec": "(*\nArch-specific functions for the abstract model of CSpace.\n*)\n\nchapter \"Architecture-specific TCB functions\"\n\ntheory ArchTcb_A\nimports KHeap_A\nbegin\n\ncontext Arch begin arch_global_naming (A)\n\ndefinition\n  sanitise_register :: \"bool \\<Rightarrow> register \\<Rightarrow> machine_word \\<Rightarrow> machine_word\"\nwhere\n  \"sanitise_register t r v \\<equiv> case r of\n      CPSR \\<Rightarrow>\n       if t \\<and>\n          v && 0x1f \\<in> {0x10, 0x11, 0x12, 0x13, 0x17, 0x1b, 0x1f}\n            \\<comment> \\<open>@{text \\<open>PMODE_(USER/FIQ/IRQ/SUPERVISOR/ABORT/UNDEFINED/SYSTEM)\\<close>}\\<close>\n       then v\n       else (v && 0xf8000000) || 0x150\n    | _    \\<Rightarrow> v\"\n\ndefinition\n  arch_get_sanitise_register_info :: \"obj_ref \\<Rightarrow> (bool, 'a::state_ext) s_monad\"\nwhere\n  \"arch_get_sanitise_register_info t \\<equiv> do\n          vcpu \\<leftarrow> arch_thread_get tcb_vcpu t;\n          return (vcpu \\<noteq> None)\n   od\"\n\ndefinition\n  arch_post_modify_registers :: \"obj_ref \\<Rightarrow> obj_ref \\<Rightarrow> (unit, 'a::state_ext) s_monad\"\nwhere\n  \"arch_post_modify_registers cur t \\<equiv> return ()\"\n\nend\nend", "property": "Sanitise Register: Modifies the value of a register based on specific conditions, ensuring that certain bits are preserved or altered to maintain the integrity and security of the system. The sanitization process is particularly focused on the CPSR register, where it enforces specific bit patterns, while other registers remain unchanged.", "title": "./spec/abstract/ARM_HYP/ArchTcb_A.thy", "chapter": "Architecture-specific TCB functions", "section": "", "comment": ""}
{"spec": "definition\n  update_cnode_cap_data :: \"data \\<Rightarrow> nat \\<times> data\" where\n \"update_cnode_cap_data w \\<equiv>\n    let\n      guard_bits = 18;\n      guard_size' = unat ((w >> cnode_padding_bits) && mask cnode_guard_size_bits);\n      guard'' = (w >> (cnode_padding_bits + cnode_guard_size_bits)) && mask guard_bits\n    in (guard_size', guard'')\"", "property": "Update CNode Capability Data: Extract new guard size and guard bits from the provided data, using specific bit masking and shifting operations to isolate the relevant information.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "On a user request to modify a cnode capability, extract new guard bits and guard."}
{"spec": "definition\n  arch_is_physical :: \"arch_cap \\<Rightarrow> bool\" where\n  \"arch_is_physical cap \\<equiv> case cap of ASIDControlCap \\<Rightarrow> False | _ \\<Rightarrow> True\"", "property": "Architectural Capability Physicality: Distinguish between physical and non-physical architectural capabilities, where ASIDControlCap is treated as non-physical, and all other types of capabilities are treated as physical.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "For some purposes capabilities to physical objects are treated\ndifferently to others."}
{"spec": "fun\n  arch_same_region_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\"\nwhere\n  \"arch_same_region_as (PageCap dev r R s x) (PageCap dev' r' R' s' x') =\n   (let\n     topA = r + (1 << pageBitsForSize s) - 1;\n     topB = r' + (1 << pageBitsForSize s') - 1\n   in r \\<le> r' \\<and> topA \\<ge> topB \\<and> r' \\<le> topB)\"\n| \"arch_same_region_as (PageTableCap r x) (PageTableCap r' x') = (r' = r)\"\n| \"arch_same_region_as (PageDirectoryCap r x) (PageDirectoryCap r' x') = (r' = r)\"\n| \"arch_same_region_as ASIDControlCap ASIDControlCap = True\"\n| \"arch_same_region_as (ASIDPoolCap r a) (ASIDPoolCap r' a') = (r' = r)\"\n| \"arch_same_region_as (VCPUCap r) (VCPUCap r') = (r' = r)\"\n| \"arch_same_region_as _ _ = False\"", "property": "Check Same Region: Determine if two architectural capabilities refer to the same object or if one is contained within the region of the other. This includes comparing page, page table, page directory, ASID control, ASID pool, and VCPU capabilities.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether the second capability is to the same object or an object\ncontained in the region of the first one."}
{"spec": "definition\n  same_aobject_as :: \"arch_cap \\<Rightarrow> arch_cap \\<Rightarrow> bool\" where\n \"same_aobject_as cp cp' \\<equiv>\n   (case (cp, cp') of\n      (PageCap dev ref _ pgsz _,PageCap dev' ref' _ pgsz' _)\n          \\<Rightarrow> (dev, ref, pgsz) = (dev', ref', pgsz')\n              \\<and> ref \\<le> ref + 2 ^ pageBitsForSize pgsz - 1\n    | _ \\<Rightarrow> arch_same_region_as cp cp')\"", "property": "Check if Two Arch Capabilities Point to the Same Object: Determine if two architecture capabilities refer to the same object by comparing their device, reference, and page size. If they are both page capabilities, ensure that the references fall within the same range. For other types of capabilities, use a general region comparison.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": "Check whether two arch capabilities are to the same object."}
{"spec": "declare same_aobject_as_def[simp]\n\ndefinition\n  arch_is_cap_revocable :: \"cap \\<Rightarrow> cap \\<Rightarrow> bool\"\nwhere\n  \"arch_is_cap_revocable c c' \\<equiv> False\"\n\nend\nend", "property": "Architectural Capability Revocation: Specifies that no capability is revocable by another, as defined by the function `arch_is_cap_revocable` which always returns `False`.", "title": "./spec/abstract/ARM_HYP/ArchCSpace_A.thy", "chapter": "", "section": "", "comment": " Proofs don't want to see this definition "}
{"spec": "type_synonym obj_ref            = machine_word\ntype_synonym vspace_ref         = machine_word\n\ntype_synonym data               = machine_word\ntype_synonym cap_ref            = \"bool list\"\ntype_synonym length_type        = machine_word\n\ntype_synonym asid_low_len       = 10\ntype_synonym asid_low_index     = \"asid_low_len word\"\n\ntype_synonym asid_high_len      = 7\ntype_synonym asid_high_index    = \"asid_high_len word\"", "property": "Type Instantiation for ARM Architecture: Defines concrete types for abstract type names, including object references, virtual space references, data, capability references, and length types, as well as specific lengths and indices for ASID (Address Space Identifier) components.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "\n  The specification is written with abstract type names for object\n  references, user pointers, word-based data, cap references, and so\n  on. This theory provides an instantiation of these names to concrete\n  types for the ARM architecture. Other architectures may have slightly\n  different instantiations.\n"}
{"spec": "type_synonym asid_len           = 17\ntype_synonym asid_rep_len       = machine_word_len\ntype_synonym asid               = \"asid_rep_len word\"", "property": "ASID Representation: The ASID is represented as a machine word with a length of 17 bits, requiring invariants to ensure that any extra bits beyond the 17-bit length are zero.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": " Making asid a machine_word means that we need invariants that the extra bits are zero. "}
{"spec": "definition\n  oref_to_data   :: \"obj_ref \\<Rightarrow> data\" where\n  \"oref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_oref   :: \"data \\<Rightarrow> obj_ref\" where\n  \"data_to_oref \\<equiv> id\"\n\ndefinition\n  vref_to_data   :: \"vspace_ref \\<Rightarrow> data\" where\n  \"vref_to_data \\<equiv> id\"\n\ndefinition\n  data_to_vref   :: \"data \\<Rightarrow> vspace_ref\" where\n  \"data_to_vref \\<equiv> id\"\n\ndefinition\n  nat_to_len     :: \"nat \\<Rightarrow> length_type\" where\n  \"nat_to_len \\<equiv> of_nat\"\n\ndefinition\n  data_to_nat    :: \"data \\<Rightarrow> nat\" where\n  \"data_to_nat \\<equiv> unat\"\n\ndefinition\n  data_to_16     :: \"data \\<Rightarrow> 16 word\" where\n  \"data_to_16 \\<equiv> ucast\"\n\ndefinition\n  data_to_cptr :: \"data \\<Rightarrow> cap_ref\" where\n  \"data_to_cptr \\<equiv> to_bl\"\n\ndefinition\n  combine_ntfn_badges :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_badges \\<equiv> semiring_bit_operations_class.or\"\n\ndefinition\n  combine_ntfn_msgs :: \"data \\<Rightarrow> data \\<Rightarrow> data\" where\n  \"combine_ntfn_msgs \\<equiv> semiring_bit_operations_class.or\"", "property": "Type Conversions: Convert between different data types, including object references, virtual space references, natural numbers, lengths, and various word sizes, using identity functions, type casting, and bitwise operations. These conversions ensure seamless data manipulation and interoperability within the system.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "With the definitions above, most conversions between abstract\ntype names boil down to just the identity function, some convert from\n@{text word} to @{typ nat} and others between different word sizes\nusing @{const ucast}."}
{"spec": "lemmas data_convs [simp] =\n  oref_to_data_def data_to_oref_def vref_to_data_def data_to_vref_def\n  nat_to_len_def data_to_nat_def data_to_16_def data_to_cptr_def", "property": "Data Conversion Simplifications: Provide simplification rules for converting between different data types, including object references, virtual references, natural numbers, and capability pointers, to facilitate automatic unfolding in proofs.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "These definitions will be unfolded automatically in proofs."}
{"spec": "definition\n  slot_bits :: nat where\n  \"slot_bits \\<equiv> 4\"\n\ndefinition\n  msg_label_bits :: nat where\n  [simp]: \"msg_label_bits \\<equiv> 20\"\n\ndefinition\n  new_context :: \"user_context\" where\n  \"new_context \\<equiv> UserContext ((\\<lambda>r. 0) (CPSR := 0x150))\"", "property": "Architecture-Dependent Sizes: Define the standard sizes for slots and message labels, which are specific to the underlying machine architecture. These sizes ensure consistent and predictable behavior in memory management and communication.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "The following definitions provide architecture-dependent sizes\n  such as the standard page size and capability size of the underlying\n  machine.\n"}
{"spec": "definition\n  kernel_base :: \"vspace_ref\" where\n  \"kernel_base \\<equiv> 0xe0000000\"\n\ndefinition\n  idle_thread_ptr :: vspace_ref where\n  \"idle_thread_ptr = kernel_base + 0x1000\"\n\nend\n\narch_requalify_consts (A) kernel_base idle_thread_ptr\n\ncontext Arch begin arch_global_naming (A)", "property": "Kernel Virtual Address Space: The kernel reserves a specific range of virtual addresses starting from a defined base address, ensuring that this space is available for kernel use in every virtual address space.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "The lowest virtual address in the kernel window. The kernel reserves the\nvirtual addresses from here up in every virtual address space."}
{"spec": "definition\n  nat_to_cref :: \"nat \\<Rightarrow> nat \\<Rightarrow> cap_ref\" where\n  \"nat_to_cref len n \\<equiv> drop (word_bits - len)\n                           (to_bl (of_nat n :: machine_word))\"\n\ndefinition\n \"msg_info_register \\<equiv> msgInfoRegister\"\ndefinition\n \"msg_registers \\<equiv> msgRegisters\"\ndefinition\n \"cap_register \\<equiv> capRegister\"\ndefinition\n \"badge_register \\<equiv> badgeRegister\"\ndefinition\n \"frame_registers \\<equiv> frameRegisters\"\ndefinition\n \"gp_registers \\<equiv> gpRegisters\"\ndefinition\n \"exception_message \\<equiv> exceptionMessage\"\ndefinition\n \"syscall_message \\<equiv> syscallMessage\"\n\n\ndatatype arch_fault =\n    VMFault vspace_ref \"machine_word list\"\n  | VGICMaintenance \"data option\" (* idx *)\n  | VCPUFault data (* hsr *)\n  | VPPIEvent irq (* vppi IRQ *)\n\n\nend\n\nend", "property": "Machine Operation Constants: Define constants for various machine operations, including message information, general-purpose and frame registers, capability and badge registers, and different types of architectural faults. These constants provide a standardized way to reference specific elements in the system, ensuring consistency and clarity in the implementation of machine operations.", "title": "./spec/abstract/ARM_HYP/Machine_A.thy", "chapter": "", "section": "", "comment": "Miscellaneous definitions of constants used in modelling machine\noperations."}
{"spec": "theory TypHeapLimits\n  imports CParser.TypHeapLib\nbegin\n\ndefinition\n  states_all_but_typs_eq :: \"char list set \\<Rightarrow> heap_raw_state \\<Rightarrow> heap_raw_state \\<Rightarrow> bool\"\nwhere\n \"states_all_but_typs_eq names hrs hrs'\n    = (hrs_htd hrs = hrs_htd hrs'\n        \\<and> (\\<forall>x. hrs_mem hrs x = hrs_mem hrs' x\n             \\<or> (\\<exists>p td. x \\<in> {p ..+ size_td td} \\<and> td_names td \\<subseteq> names\n                    \\<and> typ_name td \\<noteq> pad_typ_name\n                    \\<and> valid_footprint (hrs_htd hrs) p td)))\"\n\nlemma heap_list_eq_from_region_eq:\n  \"\\<forall>x \\<in> {p ..+ n}. hp x = hp' x\n    \\<Longrightarrow> heap_list hp n p = heap_list hp' n p\"\n  apply (induct n arbitrary: p)\n   apply simp\n  apply (simp add: intvl_def)\n  apply (frule_tac x=p in spec, drule mp, rule_tac x=0 in exI,\n         simp+)\n  apply (erule meta_allE, erule meta_mp)\n  apply clarsimp\n  apply (drule spec, erule mp)\n  apply (rule_tac x=\"Suc k\" in exI)\n  apply simp\n  done\n\nlemma states_all_but_typs_eq_clift:\n  \"\\<lbrakk> states_all_but_typs_eq names hrs hrs';\n      \\<forall>x \\<in> td_names (typ_info_t TYPE('a)). x \\<notin> names;\n      typ_name (typ_info_t TYPE('a)) \\<noteq> pad_typ_name \\<rbrakk>\n     \\<Longrightarrow> (clift hrs :: (_ \\<rightharpoonup> ('a :: c_type))) = clift hrs'\"\n  apply (rule ext, simp add: lift_t_def)\n  apply (cases hrs, cases hrs', clarsimp)\n  apply (simp add: lift_typ_heap_def restrict_map_def)\n  apply (simp add: s_valid_def proj_d_lift_state\n                   states_all_but_typs_eq_def hrs_htd_def\n                   hrs_mem_def)\n  apply clarsimp\n  apply (simp add: heap_list_s_heap_list h_t_valid_def)\n  apply (subst heap_list_eq_from_region_eq, simp_all)\n  apply clarsimp\n  apply (drule spec, erule disjE, assumption)\n  apply clarsimp\n  apply (drule(1) valid_footprint_neq_disjoint)\n    apply (clarsimp simp: typ_uinfo_t_def typ_tag_lt_def\n                          typ_tag_le_def)\n    apply (force dest: td_set_td_names\n                intro: td_set_td_names[OF td_set_self])\n   apply (clarsimp simp: field_of_def typ_uinfo_t_def)\n   apply (force dest: td_set_td_names\n               intro: td_set_td_names[OF td_set_self])\n  apply (simp add: size_of_def)\n  apply blast\n  done\n\nlemma states_all_but_typs_eq_refl:\n  \"states_all_but_typs_eq names hrs hrs\"\n  by (simp add: states_all_but_typs_eq_def)\n\nlemma states_all_but_typs_eq_trans:\n  \"states_all_but_typs_eq names hrs hrs'\n     \\<Longrightarrow> states_all_but_typs_eq names hrs' hrs''\n     \\<Longrightarrow> states_all_but_typs_eq names hrs hrs''\"\n  apply (clarsimp simp add: states_all_but_typs_eq_def\n                  del: disjCI)\n  apply (drule_tac x=x in spec)+\n  apply clarsimp\n  done\n\nlemma states_all_but_typs_eq_update:\n  \"\\<lbrakk> hrs_htd hrs \\<Turnstile>\\<^sub>t (ptr :: ('a :: c_type) ptr);\n      td_names (typ_info_t TYPE('a)) \\<subseteq> names;\n      typ_name (typ_info_t TYPE('a)) \\<noteq> pad_typ_name;\n      wf_fd (typ_info_t TYPE('a)) \\<rbrakk>\n        \\<Longrightarrow>\n   states_all_but_typs_eq names hrs\n    (hrs_mem_update (heap_update ptr v) hrs)\"\n  apply (clarsimp simp: states_all_but_typs_eq_def hrs_mem_update\n                   del: disjCI)\n  apply (subst disj_commute, rule disjCI)\n  apply (rule_tac x=\"ptr_val ptr\" in exI)\n  apply (rule_tac x=\"typ_uinfo_t TYPE('a)\" in exI)\n  apply (simp add: typ_uinfo_t_def h_t_valid_def heap_update_def)\n  apply (rule ccontr)\n  apply (subst(asm) heap_update_nmem_same)\n   apply (simp add: to_bytes_def length_fa_ti)\n   apply (subst length_fa_ti, simp_all add: size_of_def)\n  done\n\nend", "property": "Heap State Equivalence: Two heap states are considered equivalent if they have the same heap type dictionary and the same memory contents, except for regions that correspond to specific types. The equivalence holds even if the memory contents differ in regions associated with types whose names are in a specified set, as long as the footprints of these types are valid. \n\nSubproperties:\n- Reflexivity: A heap state is always equivalent to itself.\n- Transitivity: If one heap state is equivalent to a second, and the second is equivalent to a third, then the first is equivalent to the third.\n- Update Preservation: Updating a memory region corresponding to a type with a valid footprint preserves the equivalence, provided the type's name is in the specified set.", "title": "./spec/cspec/TypHeapLimits.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "(* The base theory for generated bitfield proofs about the kernel *)\n\ntheory KernelState_C\nimports\n  \"Word_Lib.WordSetup\"\n  \"CLib.BitFieldProofsLib\"\n  \"Substitute\"\nbegin\n\ntype_synonym c_ptr_name = int\ntype_synonym 't c_com = \"('t, c_ptr_name, strictc_errortype) com\"\ntype_synonym 't c_body = \"('t, c_ptr_name, strictc_errortype) body\"\ntype_synonym 't c_xstate = \"('t, strictc_errortype) xstate\"\n\ntype_synonym cstate = \"globals myvars\"\ntype_synonym rf_com = \"cstate c_com\"\n\nabbreviation\n  \"cslift (s :: cstate) \\<equiv> clift (t_hrs_' (globals s))\"\n\nlemma cslift_def: \"is_an_abbreviation\" by (simp add: is_an_abbreviation_def)", "property": "Type Definitions and Abbreviations: Defines types for C pointers, commands, bodies, and states, and provides an abbreviation for lifting a C state to a higher-level representation. This ensures that the system can handle and manipulate C-level data structures in a type-safe and consistent manner.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "abbreviation\n  \"c_h_t_valid\" :: \"cstate \\<Rightarrow> 'a::c_type ptr \\<Rightarrow> bool\"  (\"_ \\<Turnstile>\\<^sub>c _\" [99,99] 100)\nwhere\n  \"s \\<Turnstile>\\<^sub>c p == hrs_htd (t_hrs_' (globals s)),c_guard \\<Turnstile>\\<^sub>t p\"", "property": "Memory Access Validity: Ensures that a given pointer is valid within the context of the current state, according to the combined constraints of the hardware and capability guard.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": " Add an abbreviation for the common case of hrs_htd (t_hrs_' (globals s)) \\<Turnstile>\\<^sub>t p "}
{"spec": "lemmas conseqPre = HoarePartialDef.conseqPre\nlemmas conseqPost = HoarePartialDef.conseqPost", "property": "Hoare Logic Theorems: Utilize the HoarePartialDef theorems, particularly `conseqPre` and `conseqPost`, for reasoning about partial correctness in the system. These theorems are extensively used to establish the correctness of program segments under various preconditions and postconditions.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": " The HoarePartialDef theorems are used extensively\n   (as opposed to their HoareTotalDef counterparts, which aren't used much).\n   We can give most their long names, but conseqPre is used over 400 times,\n   so for these cases we override the namespaces "}
{"spec": "lemmas conj_cong = HOL.conj_cong", "property": "Conjunction Congruence: Establishes a congruence rule for conjunction, allowing the substitution of equivalent propositions within a conjunction.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": " Likewise, we'd prefer to get HOL.conj_cong over StateFun.conj_cong "}
{"spec": "declare bit_shiftr_eq[simp del]\ndeclare shiftl_of_Suc[simp del]\n\nend", "property": "Remove Eager Bitfield Proof Rules: Eliminate specific simplification rules for bit shifting operations to prevent over-eager simplification during bitfield proofs.", "title": "./spec/cspec/KernelState_C.thy", "chapter": "", "section": "", "comment": " Removes two rules that are too eager for the bitfield proofs. "}
{"spec": "theory KernelInc_C\nimports\n  \"Substitute\"\n  \"structures_defs\"\n  \"structures_proofs\"\n  \"shared_types_defs\"\n  \"shared_types_proofs\"\nbegin\n\nend", "property": "No specific properties can be derived from the provided code, as it only contains theory imports and no actual definitions or specifications.", "title": "./spec/cspec/KernelInc_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "theory Substitute\n\nimports\n  \"CKernel.Kernel_C\"\n  \"AsmRefine.GlobalsSwap\"\nbegin\n\nML \\<open>\n\nstructure SubstituteSpecs = struct\n\nval list_abs = uncurry (fold_rev (fn (x, T) => fn t => Abs (x, T, t)));\n\nfun get_rhs thm =\n    snd (Logic.dest_equals (Thm.concl_of thm))\n    handle TYPE _ =>\n      snd (HOLogic.dest_eq (Thm.concl_of thm));\n\nfun get_lhs thm =\n    fst (Logic.dest_equals (Thm.concl_of thm))\n    handle TYPE _ =>\n      fst (HOLogic.dest_eq (Thm.concl_of thm));\n\nfun term_convert prefix convs (tm as Const (name, _)) =\n    if not (String.isPrefix prefix name) then tm\n    else the (Termtab.lookup convs tm)\n  | term_convert _ _ tm = tm;\n\nfun suspicious_term ctxt s t = if Term.add_var_names t [] = [] then ()\n  else (tracing (\"suspicious \" ^ s);\n    Syntax.pretty_term ctxt t |> Pretty.string_of |> tracing;\n    ())\n\nval debug_trace = ref (Bound 0);\n\nfun convert prefix src_ctxt proc (tm as Const (name, _)) (convs, ctxt) =\n  ((term_convert prefix convs tm; (convs, ctxt))\n  handle Option =>\n let\n    val cname = unprefix prefix name;\n    val def_thm = Proof_Context.get_thm src_ctxt (cname ^ \"_def\")\n    val rhs = get_rhs def_thm;\n    val _ = suspicious_term ctxt \"init rhs\" rhs;\n    val consts = Term.add_consts rhs [];\n    val (convs, ctxt) = fold (convert prefix src_ctxt proc o Const)\n        consts (convs, ctxt);\n    val rhs' = map_aterms (term_convert prefix convs) rhs;\n    val rhs'' = proc ctxt cname rhs';\n    val _ = suspicious_term ctxt \"adjusted rhs\" rhs'';\n\n  in if rhs'' aconv rhs\n    then (Termtab.insert (K true) (tm, tm) convs,\n        ctxt\n        |> Local_Theory.begin_nested |> snd\n        |> Local_Theory.abbrev Syntax.mode_default ((Binding.name cname, NoSyn), get_lhs def_thm)\n        |> snd |> Local_Theory.note ((Binding.name (cname ^ \"_def\"), []), [def_thm])\n        |> snd |> Local_Theory.end_nested\n    )\n\n  else let\n      val _ = tracing (\"Defining \" ^ cname);\n\n      val pre_def_ctxt = ctxt\n      val b = Binding.name cname\n      val ctxt = Local_Theory.begin_nested ctxt |> snd\n      val ((tm', _), ctxt) = Local_Theory.define\n          ((b, NoSyn), ((Thm.def_binding b, []), rhs'')) ctxt\n      val tm'' = Morphism.term (Proof_Context.export_morphism ctxt pre_def_ctxt) tm'\n      val ctxt = Local_Theory.end_nested ctxt\n\n      val lhs_argTs = get_lhs def_thm |> strip_comb |> snd |> map fastype_of;\n      val abs_tm = list_abs (map (pair \"_\") lhs_argTs, tm'')\n\n    in (Termtab.insert (K true) (tm, abs_tm) convs, ctxt) end\n  end)\n  | convert _ _ _ (tm) _ = raise TERM (\"convert: not Const\", [tm])\n\n\nfun prove_impl_tac ctxt ss =\n    SUBGOAL (fn (t, n) => let\n        val lhs = t |> HOLogic.dest_Trueprop |> HOLogic.dest_eq |> fst;\n        val cnames = Term.add_const_names lhs []\n          |> filter (String.isSuffix \"_'proc\");\n        val unfolds = map (Proof_Context.get_thm ctxt o suffix \"_def\"\n          o Long_Name.base_name) cnames;\n      in simp_tac (put_simpset ss ctxt addsimps unfolds) n\n      end);\n\nfun convert_impls ctxt = let\n\n    val thm = Proof_Context.get_thm ctxt \"\\<Gamma>_def\"\n\n    val proc_defs = (Term.add_const_names (Thm.concl_of thm) [])\n      |> filter (String.isSuffix Hoare.proc_deco)\n      |> map (suffix \"_def\" #> Proof_Context.get_thm ctxt)\n\n    val tree_lemmata = StaticFun.prove_partial_map_thms thm\n        (ctxt addsimps proc_defs)\n\n    fun impl_name_from_proc (Const (s, _)) = s\n            |> Long_Name.base_name\n            |> unsuffix Hoare.proc_deco\n            |> suffix HoarePackage.implementationN\n      | impl_name_from_proc t = raise TERM (\"impl_name_from_proc\", [t])\n\n    val saves = tree_lemmata |> map (apfst (fst #> impl_name_from_proc))\n\n  in Local_Theory.notes (map (fn (n, t) => ((Binding.name n, []), [([t], [])])) saves)\n    ctxt |> snd end\n\nfun take_all_actions prefix src_ctxt proc tm csenv\n      styargs ctxt = let\n    val (_, ctxt) = convert prefix src_ctxt proc tm (Termtab.empty, ctxt);\n  in ctxt\n    |> convert_impls\n    |> Modifies_Proofs.prove_all_modifies_goals_local csenv (fn _ => true) styargs\n  end\n\nend\n\n\\<close>\n\nML \\<open>\nfun com_rewrite f t = case fastype_of t of\n    (comT as Type (@{type_name com}, [s, _, ft]))\n      => let\n    val gd = Const (@{const_name Guard},\n                ft --> (HOLogic.mk_setT s) --> comT --> comT)\n    fun add_guard ((f, gd_s), c) = gd $ f $ gd_s $ c;\n\n    val seq = Const (@{const_name Seq}, comT --> comT --> comT);\n    val skip = Const (@{const_name Skip}, comT);\n    fun add_guards_to_seq gs (Const (@{const_name Seq}, _) $ a $ b)\n        = seq $ add_guards_to_seq gs a $ b\n      | add_guards_to_seq gs c\n        = seq $ foldr add_guard skip gs $ c;\n\n    fun add_guards c [] = c\n      | add_guards ((w as Const (@{const_name While}, _)) $ S $ c) gs\n        = seq $ (w $ S $ add_guards_to_seq gs c) $ foldr add_guard skip gs\n      | add_guards (call as (Const (@{const_name call}, _) $ _ $ _ $ _ $ _)) gs\n        = foldr add_guard (seq $ call $ foldr add_guard skip gs) gs\n      | add_guards c gs = foldr add_guard c gs;\n\n    fun inner t = case t of\n      (Const (@{const_name \"switch\"}, T) $ v $ set_com_list) => let\n        val (ss, cs) = map_split HOLogic.dest_prod\n          (HOLogic.dest_list set_com_list);\n        val cs' = map inner cs;\n        val (v', gs) = f v;\n        val (ss', gss) = map_split f ss;\n        val listT = HOLogic.mk_prodT\n          (HOLogic.mk_setT (range_type (domain_type T)), comT);\n      in foldr add_guard (head_of t $ v' $ HOLogic.mk_list listT\n            (map HOLogic.mk_prod (ss' ~~ cs')))\n          (gs @ flat gss)\n      end\n      | _ => let\n        val (h, xs) = strip_comb t;", "property": "Term Conversion and Guard Addition: The code defines a mechanism for converting terms and adding guards to commands. It processes constant terms, retrieves their definitions, and recursively converts sub-terms. Additionally, it adds guards to sequences, while loops, and calls, ensuring that the modified commands are properly guarded and sequenced.", "title": "./spec/cspec/Substitute.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "val xTs = xs ~~ (fastype_of h |> strip_type |> fst);\n        fun upd_arg (x, T) = if T = comT then (inner x, []) else f x;\n        val (ys, gss) = map_split upd_arg xTs;\n      in add_guards (list_comb (h, ys)) (flat gss) end\n  in inner (Envir.beta_eta_contract t) end\n  | _ => t;\n\n\\<close>\n\nsetup \\<open>DefineGlobalsList.define_globals_list_i\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\" @{typ globals}\\<close>\n\n\nlocale substitute_pre\n  = fixes symbol_table :: \"string \\<Rightarrow> addr\"\n      and domain :: \"addr set\"\n\nbegin\n\nabbreviation\n \"globals_list \\<equiv> kernel_all_global_addresses.global_data_list\"\n\nend\n\nlocale kernel_all_substitute = substitute_pre\nbegin\n\nML \\<open>\nfun mk_rew (t as Abs (s, T, _)) = mk_rew (betapply (t, Var ((s, 0), T)))\n  | mk_rew t = HOLogic.dest_eq t\n\nval mk_varifyT = Term.map_types Logic.varifyT_global\n\nlocal\nval c_guard_rew =\n  @{term \"\\<lambda>p b. Guard C_Guard {s. c_guard (p s)} b\n     = Guard C_Guard {s. h_t_valid (hrs_htd (t_hrs_' (globals s))) c_guard (p s)} b\"}\n  |> mk_varifyT |> mk_rew\n\nval c_guard_rew_weak =\n  @{term \"\\<lambda>p b. Guard C_Guard {s. c_guard (p s)} b\n         = Guard C_Guard {s. ptr_safe (p s) (hrs_htd (t_hrs_' (globals s)))\n            \\<and> c_guard (p s)} b\"}\n      |> mk_varifyT |> mk_rew\n\nin\nfun strengthen_c_guards ss thy s =\n  if (exists (curry (=) s) ss)\n  then Pattern.rewrite_term thy [c_guard_rew_weak] []\n  else Pattern.rewrite_term thy [c_guard_rew] []\nend;\n\\<close>\n\nlemmas global_data_defs\n    = kernel_all_global_addresses.global_data_defs\n\nlemmas globals_list_def\n    = kernel_all_global_addresses.global_data_list_def\n\nML \\<open>", "property": "Strengthen C Guards: Modify the guards in the term by rewriting them to include additional conditions. The rewrite rules ensure that the guards are strengthened with `h_t_valid` or `ptr_safe` and `c_guard` conditions, depending on the specified set of symbols.", "title": "./spec/cspec/Substitute.thy", "chapter": "", "section": "", "comment": " assumption: we can only get into the com type with one of the\n           constructors or pseudo-constructors, which don't need rewriting,\n           so we can ignore h "}
{"spec": "val global_datas = @{thms global_data_defs}\n  |> map (Thm.concl_of #> Logic.unvarify_global\n        #> Logic.dest_equals #> snd #> Envir.beta_eta_contract)\n\nval const_globals = map_filter\n    (fn (Const (@{const_name const_global_data}, _) $ nm $ t)\n        => SOME (HOLogic.dest_string nm, t)\n        | _ => NONE) global_datas\n\nlocal\n\nval hrs_htd_update_guard_rew1 =\n    @{term \"\\<lambda>u. Basic (\\<lambda>s. globals_update (t_hrs_'_update (hrs_htd_update (u s))) s)\n         = Guard C_Guard {s. globals_list_distinct (fst ` dom_s (u s (hrs_htd (t_hrs_' (globals s)))))\n                         symbol_table globals_list}\n           (Basic (\\<lambda>s. globals_update (t_hrs_'_update (id hrs_htd_update (u s))) s))\"}\n        |> mk_rew\n\nval hrs_htd_update_guard_rew2 =\n  @{term \"t_hrs_'_update (id hrs_htd_update f) = t_hrs_'_update (hrs_htd_update f)\"}\n  |> Logic.varify_global |> HOLogic.dest_eq;\n\nval consts = map snd const_globals\n\nval index_eq_set_helper\n  = Syntax.parse_term @{context} (String.concat\n    [\"\\<lambda>str t n c. {s :: globals myvars. c \\<longrightarrow>\",\n        \"h_val (hrs_mem (t_hrs_' (globals s)))\",\n        \" (CTypesDefs.ptr_add (Ptr (symbol_table str)) (of_nat (n s)))\",\n        \" = t s}\"])\n\nval eq_set_helper\n  = Syntax.parse_term @{context} (String.concat\n    [\"\\<lambda>str t c. {s :: globals myvars. c \\<longrightarrow>\",\n        \"h_val (hrs_mem (t_hrs_' (globals s)))\",\n        \" (Ptr (symbol_table str)) = t}\"])\n\nval s = @{term \"s :: globals myvars\"}\n\nval grab_name_str = head_of #> dest_Const #> fst #> Long_Name.base_name\n    #> HOLogic.mk_string\n\nin\n\nfun const_global_asserts ctxt cond\n  (t as (Const (@{const_name index}, _) $ arr $ n)) = if member (=) consts arr\n    then [(index_eq_set_helper $ grab_name_str arr\n        $ lambda s t $ lambda s n $ cond) |> Syntax.check_term ctxt]\n    else []\n  | const_global_asserts ctxt cond (Const c) = if member (=) consts (Const c)\n    then [(eq_set_helper $ grab_name_str (Const c) $ Const c $ cond)\n        |> Syntax.check_term ctxt]\n    else []\n  | const_global_asserts ctxt cond (f $ x) = if member (=) consts (f $ x)\n    then [(eq_set_helper $ grab_name_str (f $ x) $ (f $ x) $ cond)\n        |> Syntax.check_term ctxt]\n    else const_global_asserts ctxt cond f @ const_global_asserts ctxt cond x\n  | const_global_asserts ctxt cond (a as Abs (_, @{typ \"globals myvars\"}, _))\n    = const_global_asserts ctxt cond (betapply (a, s))\n  | const_global_asserts ctxt cond (Abs (_, _, t))\n    = const_global_asserts ctxt cond t\n  | const_global_asserts _ _ _ = []\n\nfun guard_rewritable_globals const_cond ctxt =\n  Pattern.rewrite_term @{theory} [hrs_htd_update_guard_rew2] []\n  o Pattern.rewrite_term @{theory} [hrs_htd_update_guard_rew1] []\n  o com_rewrite (fn t =>\n     (t, map (pair @{term C_Guard})\n        (case const_cond of SOME cond => const_global_asserts ctxt cond t\n                | NONE => [])))\n\nval guard_htd_updates_with_domain = com_rewrite\n  (fn t => if fastype_of t = @{typ \"globals myvars \\<Rightarrow> globals myvars\"}\n        andalso Term.exists_Const (fn (s, _) => s = @{const_name \"hrs_htd_update\"}) t\n        then (t, [(@{term MemorySafety}, betapply (@{term \"\\<lambda>f :: globals myvars \\<Rightarrow> globals myvars.\n                {s. htd_safe domain (hrs_htd (t_hrs_' (globals s)))\n              \\<and> htd_safe domain (hrs_htd (t_hrs_' (globals (f s))))}\"}, t))])\n        else (t, []))\n\nval guard_halt = com_rewrite\n  (fn t => if t = @{term \"halt_'proc\"}\n    then (t, [(@{term DontReach}, @{term \"{} :: globals myvars set\"})])\n    else (t, []))\n\nfun acc_ptr_adds (Const (@{const_name h_val}, _) $ m $ (Const (@{const_name ptr_add}, _) $ p $ n))\n    = [(p, n, true)] @ maps acc_ptr_adds [m, p, n]\n  | acc_ptr_adds (Const (@{const_name heap_update}, _) $ (Const (@{const_name ptr_add}, _) $ p $ n))\n    = [(p, n, true)] @ maps acc_ptr_adds [p, n]\n  | acc_ptr_adds (Const (@{const_name ptr_add}, _) $ p $ n)\n    = [(p, n, false)] @ maps acc_ptr_adds [p, n]\n  | acc_ptr_adds (f $ x) = maps acc_ptr_adds [f, x]\n  | acc_ptr_adds (abs as Abs (_, T, t)) = if T = @{typ \"globals myvars\"}\n    then acc_ptr_adds (betapply (abs, @{term \"s :: globals myvars\"}))\n    else acc_ptr_adds t\n  | acc_ptr_adds _ = []\n\nfun mk_bool true = @{term True} | mk_bool false = @{term False}\n\nval guard_acc_ptr_adds = com_rewrite\n  (fn t => (t, acc_ptr_adds t |> map (fn (p, n, strong) => let\n    val assn = Const (@{const_name ptr_add_assertion'},\n            fastype_of p --> @{typ \"int \\<Rightarrow> bool \\<Rightarrow> heap_typ_desc \\<Rightarrow> bool\"})\n        $ p $ n $ mk_bool strong\n        $ @{term \"hrs_htd (t_hrs_' (globals (s :: globals myvars)))\"}\n    val gd = HOLogic.mk_Collect (\"s\", @{typ \"globals myvars\"}, assn)\n  in (@{term MemorySafety}, gd) end)))\n\nend\n\n\\<close>\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\nML \\<open>\n  Feedback.verbosity_level := ~1;\n\\<close>\n\nlocal_setup \\<open>\nSubstituteSpecs.take_all_actions\n  \"Kernel_C.kernel_all_global_addresses.\"\n  (Locale.init \"Kernel_C.kernel_all_global_addresses\" @{theory})\n  (fn ctxt => fn s => guard_rewritable_globals NONE ctxt\n    o (strengthen_c_guards [\"memset_body\", \"memcpy_body\", \"memzero_body\"]\n          (Proof_Context.theory_of ctxt) s)\n    o guard_halt\n    o guard_htd_updates_with_domain\n    o guard_acc_ptr_adds)\n  @{term kernel_all_global_addresses.\\<Gamma>}\n  (CalculateState.get_csenv @{theory} \"../c/build/$L4V_ARCH/kernel_all.c_pp\" |> the)\n  [@{typ \"globals myvars\"}, @{typ int}, @{typ strictc_errortype}]\n\\<close>\n\nend\n\nend", "property": "Guarded Memory and State Updates: Ensures that memory and state updates, such as those involving the heap and global variables, are performed safely by applying guards and assertions. This includes verifying the safety of heap table descriptor (HTD) updates, handling pointer arithmetic, and ensuring that certain operations do not reach a halt state.", "title": "./spec/cspec/Substitute.thy", "chapter": "", "section": "", "comment": " the unvarify sets ?symbol_table back to symbol_table. be careful "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> word32\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> word32 \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: Manipulates the ghost state to manage memory regions, virtual memory frames, and capability node (cnode) allocations. It allows for clearing regions, setting up new frames, and creating new cnodes, ensuring that the ghost state accurately reflects the system's memory and capability structure.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\n\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\n\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 8\"\n\ndefinition\n  ctcb_offset :: \"32 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Qualified Aliases: Define and qualify constants for ARM page sizes and TCB-related values, ensuring that they are appropriately named and accessible within the context.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "hide_const (open)\n  numDomains", "property": "Hide Unqualified Names: Ensures that unqualified names conflicting with Kernel_Config names are hidden, requiring the use of the Kernel_C prefix to access these names.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "ThreadState Definitions: Provides a collection of definitions for various thread states, making them more accessible and usable within the system.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n vmpage_size.ARMSmallPage\n vmpage_size.ARMLargePage\n vmpage_size.ARMSection\n vmpage_size.ARMSuperSection", "property": "Hide VMPage Sizes: Conceal the specific constants related to different ARM virtual memory page sizes, ensuring they are not directly accessible or visible in the specification.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\n\nglobal_naming \"ARM.vmpage_size\"\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\n\nglobal_naming ARM\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\nend\n\n\nend", "property": "Re-allow Fully Qualified Accesses: Ensure that fully qualified accesses are re-enabled for consistency, allowing the use of specific constants such as ARMSmallPage, ARMLargePage, ARMSection, and ARMSuperSection.", "title": "./spec/cspec/ARM/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> machine_word\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> machine_word \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: Manages the ghost state by clearing regions, adding new frames, and creating new capability nodes. It ensures that specific memory regions are updated or cleared based on the provided parameters, maintaining the integrity of the ghost state for tracking and verification purposes.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "setup \\<open>Context.theory_map (ASM_Ignore_Hooks.add_hook (fn _ => true))\\<close>", "property": "Ignore x86-64 Assembly Statements: The system is configured to ignore x86-64 assembly statements, ensuring that they do not affect the parsing and processing of the code.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " x86-64 asm statements are not yet supported by the c-parser "}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\nrequalify_consts X64SmallPage X64LargePage X64HugePage\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 10\"\n\ndefinition\n  ctcb_offset :: \"64 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Qualified Aliases: Define and qualify constants for different page sizes and calculate the size and offset for the control thread control block (CTCB). This ensures that the system uses consistent and appropriately sized memory allocations for thread control blocks.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "hide_const (open)\n  numDomains", "property": "Hide Unqualified Names: Ensures that unqualified names conflicting with Kernel_Config names are hidden, requiring the use of the Kernel_C prefix to avoid naming conflicts.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "Thread State Definitions: Consolidates the definitions related to thread states, providing a more usable and accessible name for referencing these definitions.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n  vmpage_size.X64SmallPage\n  vmpage_size.X64LargePage\n  vmpage_size.X64HugePage", "property": "Hide VMPage Sizes: Conceal the specific sizes of different types of virtual memory pages (small, large, and huge) to prevent direct access or manipulation.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\nglobal_naming \"X64.vmpage_size\" requalify_consts X64SmallPage X64LargePage X64HugePage\nglobal_naming \"X64\" requalify_consts X64SmallPage X64LargePage X64HugePage\nend\n\nend", "property": "Requalification of Constants: Re-allow fully qualified accesses to constants related to page sizes (X64SmallPage, X64LargePage, X64HugePage) for consistency, ensuring that these constants can be referenced with their full qualification.", "title": "./spec/cspec/X64/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> machine_word\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> machine_word \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: Manipulates the ghost state to manage memory regions, including clearing regions, adding new frames, and adding new capability nodes. These operations ensure that the ghost state accurately reflects the system's memory layout and capabilities, supporting verification and analysis.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\nrequalify_consts RISCVSmallPage RISCVLargePage RISCVHugePage\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 9\"\n\ndefinition\n  ctcb_offset :: \"64 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Qualified Aliases: Define and qualify constants for different page sizes and TCB-related values, ensuring consistent and appropriately scoped naming within the architecture context.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "hide_const (open)\n  numDomains", "property": "Hide Conflicting Names: Conceal unqualified names that conflict with those in Kernel_Config, enforcing the use of the Kernel_C prefix for these names to avoid naming conflicts and ensure clarity.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "ThreadState Definitions: Consolidates the definitions related to thread states, providing a more usable and accessible name for referencing these definitions.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n  vmpage_size.RISCVSmallPage\n  vmpage_size.RISCVLargePage\n  vmpage_size.RISCVHugePage", "property": "Hide VM Page Sizes: Conceal the definitions of RISCV small, large, and huge page sizes to prevent direct access and manipulation.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\nglobal_naming \"RISCV.vmpage_size\" requalify_consts RISCVSmallPage RISCVLargePage RISCVHugePage\nglobal_naming \"RISCV\" requalify_consts RISCVSmallPage RISCVLargePage RISCVHugePage\nend\n\nend", "property": "Re-allow Fully Qualified Accesses: Re-enable fully qualified accesses for consistency, allowing the use of specific constants (RISCVSmallPage, RISCVLargePage, RISCVHugePage) in the context of the RISCV architecture.", "title": "./spec/cspec/RISCV64/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n  pt_array_len\n  vs_array_len\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\n\nlemma ptTranslationBits_vs_array_len':\n  \"2 ^ ptTranslationBits VSRootPT_T = vs_array_len\"\n  by (simp add: vs_array_len_val ptTranslationBits_vs_index_bits vs_index_bits_def\n                Kernel_Config.config_ARM_PA_SIZE_BITS_40_def)\n\nlemmas ptTranslationBits_vs_array_len = ptTranslationBits_vs_array_len'[unfolded vs_array_len_val]\n\ntype_synonym cghost_state =\n  \"(machine_word \\<rightharpoonup> vmpage_size) \\<times>   \\<comment> \\<open>Frame sizes\\<close>\n   (machine_word \\<rightharpoonup> nat) \\<times>           \\<comment> \\<open>CNode sizes\\<close>\n   (machine_word \\<rightharpoonup> pt_type) \\<times>       \\<comment> \\<open>PT types\\<close>\n   ghost_assertions\"                 \\<comment> \\<open>ASMRefine assertions\\<close>\n\ndefinition gs_clear_region :: \"addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n     (\\<lambda>x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n      \\<lambda>x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x,\n      \\<lambda>x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd (snd gs)) x,\n      snd (snd (snd gs)))\"\n\ndefinition gs_new_frames:: \"vmpage_size \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n     if bits < pageBitsForSize sz then gs\n     else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                    x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n               else fst gs x, snd gs)\"\n\ndefinition gs_new_cnodes:: \"nat \\<Rightarrow> addr \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n     if bits < sz + 4 then gs\n     else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                       then Some sz\n                       else fst (snd gs) x, snd (snd gs))\"\n\ndefinition gs_new_pt_t:: \"pt_type \\<Rightarrow> addr \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_new_pt_t pt_t ptr \\<equiv>\n     \\<lambda>gs. (fst gs, fst (snd gs), (fst (snd (snd gs))) (ptr \\<mapsto> pt_t), snd (snd (snd gs)))\"\n\nabbreviation gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> machine_word\" where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd \\<circ> snd \\<circ> snd)\"\n\nabbreviation gs_set_assn :: \"int \\<Rightarrow> machine_word \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd \\<circ> apsnd \\<circ> apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: Manages the ghost state, including frame sizes, CNode sizes, PT types, and assertions. It provides operations to clear regions, add new frames, add new CNodes, and set PT types, ensuring that the ghost state accurately reflects the system's memory and capability configurations.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\nrequalify_consts ARMSmallPage ARMLargePage ARMHugePage\nend", "property": "Create Qualified Aliases: Generate appropriately qualified aliases for specific constants, ensuring they are correctly scoped and accessible within the current context.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "context begin interpretation Arch .\nrequalify_consts NormalPT_T VSRootPT_T\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 10\"\n\ndefinition\n  ctcb_offset :: \"64 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Page Table Type Constructors: Define constructors for retype annotations, specifically for normal page tables and virtual space root page tables, to be used globally in the C code.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": " Also need pt_type constructors for retype annotations. We leave them available globally for C. "}
{"spec": "hide_const (open)\n  numDomains", "property": "Hide Conflicting Names: Conceal unqualified names that conflict with those in Kernel_Config, ensuring the use of the Kernel_C prefix for these names to avoid naming conflicts.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "ThreadState Definitions: Consolidates the definitions related to thread states, providing a more usable and accessible name for referencing these definitions.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n  vmpage_size.ARMSmallPage\n  vmpage_size.ARMLargePage\n  vmpage_size.ARMHugePage", "property": "Hide VMPage Sizes: Conceal the specific constants for ARM small, large, and huge page sizes.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\nglobal_naming \"AARCH64.vmpage_size\" requalify_consts ARMSmallPage ARMLargePage ARMHugePage\nglobal_naming \"AARCH64\" requalify_consts ARMSmallPage ARMLargePage ARMHugePage\nend\n\nend", "property": "Re-allow Fully Qualified Accesses: Re-enables fully qualified accesses for consistency, specifically for ARM page sizes (small, large, and huge) and the AARCH64 architecture.", "title": "./spec/cspec/AARCH64/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "theory Kernel_C\nimports\n  \"ExecSpec.MachineTypes\"\n  \"CLib.CTranslationNICTA\"\n  \"AsmRefine.CommonOps\"\nbegin\n\nexternal_file\n  \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n\ncontext begin interpretation Arch .\n\nrequalify_types\n  machine_state\n\nend\n\ndeclare [[populate_globals=true]]\n\ncontext begin interpretation Arch . \n\ntype_synonym cghost_state = \"(machine_word \\<rightharpoonup> vmpage_size) * (machine_word \\<rightharpoonup> nat)\n    * ghost_assertions\"\n\ndefinition\n  gs_clear_region :: \"word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\" where\n  \"gs_clear_region ptr bits gs \\<equiv>\n   (%x. if x \\<in> {ptr..+2 ^ bits} then None else fst gs x,\n    %x. if x \\<in> {ptr..+2 ^ bits} then None else fst (snd gs) x, snd (snd gs))\"\n\ndefinition\n  gs_new_frames:: \"vmpage_size \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_frames sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < pageBitsForSize sz then gs\n   else (\\<lambda>x. if \\<exists>n\\<le>mask (bits - pageBitsForSize sz).\n                  x = ptr + n * 2 ^ pageBitsForSize sz then Some sz\n             else fst gs x, snd gs)\"\n\ndefinition\n  gs_new_cnodes:: \"nat \\<Rightarrow> word32 \\<Rightarrow> nat \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_new_cnodes sz ptr bits \\<equiv> \\<lambda>gs.\n   if bits < sz + 4 then gs\n   else (fst gs, \\<lambda>x. if \\<exists>n\\<le>mask (bits - sz - 4). x = ptr + n * 2 ^ (sz + 4)\n                     then Some sz\n                     else fst (snd gs) x, snd (snd gs))\"\n\nabbreviation\n  gs_get_assn :: \"int \\<Rightarrow> cghost_state \\<Rightarrow> word32\"\n  where\n  \"gs_get_assn k \\<equiv> ghost_assertion_data_get k (snd o snd)\"\n\nabbreviation\n  gs_set_assn :: \"int \\<Rightarrow> word32 \\<Rightarrow> cghost_state \\<Rightarrow> cghost_state\"\n  where\n  \"gs_set_assn k v \\<equiv> ghost_assertion_data_set k v (apsnd o apsnd)\"\n\ndeclare [[record_codegen = false]]\ndeclare [[allow_underscore_idents = true]]\n\nend", "property": "Ghost State Management: Manipulate the ghost state to manage memory regions, frames, and capability nodes. Clear specific regions, allocate new frames, and create new capability nodes within the ghost state, ensuring that the system maintains a consistent and accurate representation of memory and capabilities.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": ""}
{"spec": "context begin interpretation Arch . global_naming vmpage_size\n\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\n\nend\n\ndefinition\n  ctcb_size_bits :: nat\nwhere\n  \"ctcb_size_bits \\<equiv> 8\"\n\ndefinition\n  ctcb_offset :: \"32 word\"\nwhere\n  \"ctcb_offset \\<equiv> 2 ^ ctcb_size_bits\"\n\nlemmas ctcb_offset_defs = ctcb_offset_def ctcb_size_bits_def\n\ncond_sorry_modifies_proofs SORRY_MODIFIES_PROOFS\n\ninstall_C_file \"../c/build/$L4V_ARCH/kernel_all.c_pp\"\n  [machinety=machine_state, ghostty=cghost_state]", "property": "Create Qualified Aliases: Define and qualify constants for specific architecture page sizes and TCB-related values, ensuring consistent and accessible naming within the system.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": " create appropriately qualified aliases "}
{"spec": "hide_const (open)\n  numDomains", "property": "Hide Unqualified Names: Ensures that unqualified names conflicting with Kernel_Config names are hidden, requiring the use of the Kernel_C prefix for these names to avoid conflicts and maintain clarity.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": "Hide unqualified names conflicting with Kernel_Config names. Force use of Kernel_C prefix\n  for these:"}
{"spec": "lemmas ThreadState_defs = StrictC'_thread_state_defs", "property": "Thread State Definitions: Consolidates the definitions related to thread states, providing a more usable and accessible reference for thread state management.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": "Add a more usable name for the collection of ThreadState definitions"}
{"spec": "hide_const\n vmpage_size.ARMSmallPage\n vmpage_size.ARMLargePage\n vmpage_size.ARMSection\n vmpage_size.ARMSuperSection", "property": "Hide VMPage Sizes: Conceal the specific constants related to various virtual memory page sizes, ensuring they are not directly accessible or visible in the code.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": " hide vmpage sizes again "}
{"spec": "context Arch begin\n\nglobal_naming \"ARM.vmpage_size\"\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\n\nglobal_naming ARM\nrequalify_consts ARMSmallPage ARMLargePage ARMSection ARMSuperSection\nend\n\n\nend", "property": "Re-allow Fully Qualified Accesses: Enable fully qualified accesses for consistency, allowing the use of specific constants such as ARMSmallPage, ARMLargePage, ARMSection, and ARMSuperSection in the context.", "title": "./spec/cspec/ARM_HYP/Kernel_C.thy", "chapter": "", "section": "", "comment": " re-allow fully qualified accesses (for consistency). Slightly clunky "}
{"spec": "text \\<open>\n  The basic type of the nondeterministic state monad with failure is\n  very similar to the normal state monad. Instead of a pair consisting\n  of result and new state, we return a set of these pairs coupled with\n  a failure flag. Each element in the set is a potential result of the\n  computation. The flag is @{const True} if there is an execution path\n  in the computation that may have failed. Conversely, if the flag is\n  @{const False}, none of the computations resulting in the returned\n  set can have failed.\\<close>\ntype_synonym ('s, 'a) nondet_monad = \"'s \\<Rightarrow> ('a \\<times> 's) set \\<times> bool\"", "property": "Nondeterministic State Monad with Failure: Represents a computation that can produce a set of possible results and states, along with a failure flag. The failure flag indicates whether any execution path in the computation may have failed. If the flag is false, all potential results are guaranteed to be successful.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "print_ast_translation \\<open>\n  let\n    fun monad_tr _ [t1, Ast.Appl [Ast.Constant @{type_syntax prod},\n                          Ast.Appl [Ast.Constant @{type_syntax set},\n                            Ast.Appl [Ast.Constant @{type_syntax prod}, t2, t3]],\n                          Ast.Constant @{type_syntax bool}]] =\n      if t3 = t1\n      then Ast.Appl [Ast.Constant @{type_syntax \"nondet_monad\"}, t1, t2]\n      else raise Match\n  in [(@{type_syntax \"fun\"}, monad_tr)] end\n\\<close>", "property": "Type Abbreviation for Nondeterministic State Monad with Failure: Provides a more readable and concise type syntax for the nondeterministic state monad with failure, ensuring that the state variable occurs twice in the type.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Print the type @{typ \"('s,'a) nondet_monad\"} instead of its unwieldy expansion.\n  Needs an AST translation in code, because it needs to check that the state variable\n  @{typ 's} occurs twice. This comparison is not guaranteed to always work as expected\n  (AST instances might have different decoration), but it does seem to work here."}
{"spec": "definition return :: \"'a \\<Rightarrow> ('s,'a) nondet_monad\" where\n  \"return a \\<equiv> \\<lambda>s. ({(a,s)},False)\"", "property": "Return Function: The return function in the nondeterministic state monad with failure does not alter the state, does not fail, and returns the specified value.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  The definition of fundamental monad functions @{text return} and\n  @{text bind}. The monad function @{text \"return x\"} does not change\n  the  state, does not fail, and returns @{text \"x\"}."}
{"spec": "definition bind ::\n  \"('s, 'a) nondet_monad \\<Rightarrow> ('a \\<Rightarrow> ('s, 'b) nondet_monad) \\<Rightarrow> ('s, 'b) nondet_monad\" (infixl \">>=\" 60)\n  where\n  \"bind f g \\<equiv> \\<lambda>s. (\\<Union>(fst ` case_prod g ` fst (f s)),\n                   True \\<in> snd ` case_prod g ` fst (f s) \\<or> snd (f s))\"", "property": "Nondeterministic Binding with Failure: The bind operation combines two monadic actions, where the second action is dependent on the result of the first. The combined operation's result is the union of all possible outcomes from applying the second action to each outcome of the first. The combined operation may fail if either the first action fails or the second action fails for any of the results of the first.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  The monad function @{text \"bind f g\"}, also written @{text \"f >>= g\"},\n  is the execution of @{term f} followed by the execution of @{text g}.\n  The function @{text g} takes the result value \\emph{and} the result\n  state of @{text f} as parameter. The definition says that the result of\n  the combined operation is the union of the set of sets that is created\n  by @{text g} applied to the result sets of @{text f}. The combined\n  operation may have failed, if @{text f} may have failed or @{text g} may\n  have failed on any of the results of @{text f}."}
{"spec": "abbreviation (input) bind_rev ::\n  \"('c \\<Rightarrow> ('a, 'b) nondet_monad) \\<Rightarrow> ('a, 'c) nondet_monad \\<Rightarrow> ('a, 'b) nondet_monad\" (infixl \"=<<\" 60)\n  where\n  \"g =<< f \\<equiv> f >>= g\"", "property": "Reversed Bind Operation: Allows the composition of monadic actions in a reversed order, providing flexibility in writing and understanding monadic bindings.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Sometimes it is convenient to write @{text bind} in reverse order."}
{"spec": "definition get :: \"('s,'s) nondet_monad\" where\n  \"get \\<equiv> \\<lambda>s. ({(s,s)}, False)\"\n\ndefinition put :: \"'s \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"put s \\<equiv> \\<lambda>_. ({((),s)}, False)\"", "property": "State Access and Modification: The `get` function retrieves the current state without modifying it or causing failure, while the `put` function updates the state to a specified value without returning any result and without causing failure.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  The basic accessor functions of the state monad. @{text get} returns\n  the current state as result, does not fail, and does not change the state.\n  @{text \"put s\"} returns nothing (@{typ unit}), changes the current state\n  to @{text s} and does not fail."}
{"spec": "text \\<open>\n  Basic nondeterministic functions. @{text \"select A\"} chooses an element\n  of the set @{text A}, does not change the state, and does not fail\n  (even if the set is empty). @{text \"f \\<sqinter> g\"} executes @{text f} or\n  executes @{text g}. It retuns the union of results of @{text f} and\n  @{text g}, and may have failed if either may have failed.\\<close>\ndefinition select :: \"'a set \\<Rightarrow> ('s,'a) nondet_monad\" where\n  \"select A \\<equiv> \\<lambda>s. (A \\<times> {s}, False)\"\n\ndefinition alternative ::\n  \"('s, 'a) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad\" (infixl \"\\<sqinter>\" 20)\n  where\n  \"f \\<sqinter> g \\<equiv> \\<lambda>s. (fst (f s) \\<union> fst (g s), snd (f s) \\<or> snd (g s))\"", "property": "Nondeterministic Choice with Failure: The system allows for the selection of an element from a set and the nondeterministic choice between two operations. The selection does not change the state and does not fail, even if the set is empty. The alternative operation returns the union of the results of the two operations and may fail if either operation can fail.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "definition select_f :: \"'a set \\<times> bool  \\<Rightarrow> ('s,'a) nondet_monad\" where\n  \"select_f S \\<equiv> \\<lambda>s. (fst S \\<times> {s}, snd S)\"", "property": "Nondeterministic Selection with Failure: Allows the selection of a value from a set, paired with a boolean indicating whether the execution has failed. This enables the lifting of monads between different state spaces while preserving failure information.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  A variant of @{text select} that takes a pair. The first component is a set\n  as in normal @{text select}, the second component indicates whether the\n  execution failed. This is useful to lift monads between different state\n  spaces."}
{"spec": "definition state_select :: \"('s \\<times> 's) set \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"state_select r \\<equiv> \\<lambda>s. ((\\<lambda>x. ((), x)) ` {s'. (s, s') \\<in> r}, \\<not> (\\<exists>s'. (s, s') \\<in> r))\"", "property": "Nondeterministic State Selection: Selects a state nondeterministically from a set of states related to the input state according to a given relationship. Fails if no such related state exists.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  @{text state_select} takes a relationship between states, and outputs\n  nondeterministically a state related to the input state. Fails if no such\n  state exists."}
{"spec": "text \\<open>\n  The monad function that always fails. Returns an empty set of results and sets the failure flag.\\<close>\ndefinition fail :: \"('s, 'a) nondet_monad\" where\n  \"fail \\<equiv> \\<lambda>s. ({}, True)\"", "property": "Failure Handling: The monad function `fail` always results in an empty set of outcomes and sets the failure flag, indicating an unsuccessful computation.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "definition assert :: \"bool \\<Rightarrow> ('a, unit) nondet_monad\" where\n  \"assert P \\<equiv> if P then return () else fail\"", "property": "Property: Assertion Validation: Ensures that a given property \\( P \\) holds, failing the computation if \\( P \\) is not true.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Assertions: fail if the property @{text P} is not true"}
{"spec": "definition assert_opt :: \"'a option \\<Rightarrow> ('b, 'a) nondet_monad\" where\n  \"assert_opt v \\<equiv> case v of None \\<Rightarrow> fail | Some v \\<Rightarrow> return v\"", "property": "Assertion with Optional Values: Ensures that the computation fails if the value is `None`, and returns the result `v` if the value is `Some v`.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Fail if the value is @{const None}, return result @{text v} for @{term \"Some v\"}"}
{"spec": "definition state_assert :: \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"state_assert P \\<equiv> get >>= (\\<lambda>s. assert (P s))\"", "property": "State Assertion with Introspection: Allows for the introspection of the current state and asserts a condition based on that state.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "An assertion that also can introspect the current state."}
{"spec": "text \\<open>Apply a function to the current state and return the result without changing the state.\\<close>\ndefinition gets :: \"('s \\<Rightarrow> 'a) \\<Rightarrow> ('s, 'a) nondet_monad\" where\n  \"gets f \\<equiv> get >>= (\\<lambda>s. return (f s))\"", "property": "State Retrieval: Retrieve the current state and apply a function to it, returning the result without modifying the state.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "definition modify :: \"('s \\<Rightarrow> 's) \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"modify f \\<equiv> get >>= (\\<lambda>s. put (f s))\"\n\nlemma simpler_gets_def:\n  \"gets f = (\\<lambda>s. ({(f s, s)}, False))\"\n  by (simp add: gets_def return_def bind_def get_def)\n\nlemma simpler_modify_def:\n  \"modify f = (\\<lambda>s. ({((), f s)}, False))\"\n  by (simp add: modify_def bind_def get_def put_def)", "property": "State Modification: Allows the current state to be updated using a provided function, ensuring that the state transformation is encapsulated and applied atomically.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Modify the current state using the function passed in."}
{"spec": "definition \"when\" :: \"bool \\<Rightarrow> ('s, unit) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"when P m \\<equiv> if P then m else return ()\"", "property": "Conditional Execution: Execute the given monadic action only if the specified condition is true, otherwise return a unit value.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Execute the given monad when the condition is true, return @{text \"()\"} otherwise."}
{"spec": "definition unless :: \"bool \\<Rightarrow> ('s, unit) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"unless P m \\<equiv> when (\\<not>P) m\"", "property": "Conditional Execution: Execute the given monadic action only if the specified condition is false, otherwise return a unit value.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Execute the given monad unless the condition is true, return @{text \"()\"} otherwise."}
{"spec": "definition condition ::\n  \"('s \\<Rightarrow> bool) \\<Rightarrow> ('s, 'r) nondet_monad \\<Rightarrow> ('s, 'r) nondet_monad \\<Rightarrow> ('s, 'r) nondet_monad\"\n  where\n  \"condition P L R \\<equiv> \\<lambda>s. if (P s) then (L s) else (R s)\"\n\nnotation (output)\n  condition  (\"(condition (_)//  (_)//  (_))\" [1000,1000,1000] 1000)", "property": "Conditional Execution: Execute one of two monadic actions based on a condition. If the condition is true, the left action is performed; otherwise, the right action is executed.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Perform a test on the current state, performing the left monad if\n  the result is true or the right monad if the result is false. "}
{"spec": "definition gets_the :: \"('s \\<Rightarrow> 'a option) \\<Rightarrow> ('s, 'a) nondet_monad\" where\n  \"gets_the f \\<equiv> gets f >>= assert_opt\"", "property": "Apply Option-Valued Function: Execute an option-valued function on the current state, failing if the result is `None` and returning the value `v` if the result is `Some v`.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Apply an option valued function to the current state, fail if it returns @{const None},\n  return @{text v} if it returns @{term \"Some v\"}."}
{"spec": "definition gets_map :: \"('s \\<Rightarrow> 'a \\<Rightarrow> 'b option) \\<Rightarrow> 'a \\<Rightarrow> ('s, 'b) nondet_monad\" where\n  \"gets_map f p \\<equiv> gets f >>= (\\<lambda>m. assert_opt (m p))\"", "property": "Retrieve Map Value: Access a map from the current state and apply a given argument to retrieve a value. If the map returns `None`, the operation fails; otherwise, it returns the retrieved value.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Get a map (such as a heap) from the current state and apply an argument to the map.\n  Fail if the map returns @{const None}, otherwise return the value."}
{"spec": "text \\<open>An alternative definition of @{term bind}, sometimes more convenient.\\<close>\nlemma bind_def':\n  \"(f >>= g) \\<equiv>\n       \\<lambda>s. ({(r'', s''). \\<exists>(r', s') \\<in> fst (f s). (r'', s'') \\<in> fst (g r' s') },\n                     snd (f s) \\<or> (\\<exists>(r', s') \\<in> fst (f s). snd (g r' s')))\"\n  by (rule eq_reflection)\n     (auto simp add: bind_def split_def Let_def)", "property": "Nondeterministic State Monad with Failure: The bind operation for the monad is defined in a way that it combines the results and failures of two monadic actions, ensuring that the overall computation reflects both the possible outcomes and the potential for failure.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "lemma return_bind[simp]:\n  \"(return x >>= f) = f x\"\n  by (simp add: return_def bind_def)", "property": "Return Absorption: The `return` function, when bound to another function `f`, directly applies the return value to `f`, effectively absorbing the `return` operation.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "@{term return} is absorbed at the left of a @{term bind}, applying the return value directly:"}
{"spec": "lemma bind_return[simp]:\n  \"(m >>= return) = m\"\n  by (simp add: bind_def return_def split_def)", "property": "Monad Absorption: The bind operation with the return function on the right is equivalent to the original monad value, ensuring that the monad's structure is preserved.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "@{term return} is absorbed on the right of a @{term bind}"}
{"spec": "lemma bind_assoc:\n  fixes m :: \"('a,'b) nondet_monad\"\n  fixes f :: \"'b \\<Rightarrow> ('a,'c) nondet_monad\"\n  fixes g :: \"'c \\<Rightarrow> ('a,'d) nondet_monad\"\n  shows \"(m >>= f) >>= g  =  m >>= (\\<lambda>x. f x >>= g)\"\n  unfolding bind_def Let_def split_def\n  by (auto intro: rev_image_eqI)", "property": "Bind Associativity: The bind operation in the nondeterministic state monad with failure is associative, ensuring that the order of operations does not affect the final result.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "@{term bind} is associative"}
{"spec": "text \\<open>\n  The type @{typ \"('s,'a) nondet_monad\"} gives us nondeterminism and\n  failure. We now extend this monad with exceptional return values\n  that abort normal execution, but can be handled explicitly.\n  We use the sum type to indicate exceptions.\n\n  In @{typ \"('s, 'e + 'a) nondet_monad\"}, @{typ \"'s\"} is the state,\n  @{typ 'e} is an exception, and @{typ 'a} is a normal return value.\n\n  This new type itself forms a monad again. Since type classes in\n  Isabelle are not powerful enough to express the class of monads,\n  we provide new names for the @{term return} and @{term bind} functions\n  in this monad. We call them @{text returnOk} (for normal return values)\n  and @{text bindE} (for composition). We also define @{text throwError}\n  to return an exceptional value.\\<close>\ndefinition returnOk :: \"'a \\<Rightarrow> ('s, 'e + 'a) nondet_monad\" where\n  \"returnOk \\<equiv> return o Inr\"\n\ndefinition throwError :: \"'e \\<Rightarrow> ('s, 'e + 'a) nondet_monad\" where\n  \"throwError \\<equiv> return o Inl\"", "property": "Exception Handling in Nondeterministic State Monad: The monad supports both normal and exceptional return values, allowing for explicit handling of exceptions. Normal return values are wrapped using `returnOk`, while exceptions are thrown using `throwError`.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "definition lift :: \"('a \\<Rightarrow> ('s, 'e + 'b) nondet_monad) \\<Rightarrow> 'e +'a \\<Rightarrow> ('s, 'e + 'b) nondet_monad\" where\n  \"lift f v \\<equiv> case v of Inl e \\<Rightarrow> throwError e | Inr v' \\<Rightarrow> f v'\"", "property": "Lifting with Exception Handling: Lifts a function to handle exceptions, where if the input is an exception, it returns that exception; otherwise, it continues with the function execution.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Lifting a function over the exception type: if the input is an\n  exception, return that exception; otherwise continue execution."}
{"spec": "definition bindE ::\n  \"('s, 'e + 'a) nondet_monad \\<Rightarrow> ('a \\<Rightarrow> ('s, 'e + 'b) nondet_monad) \\<Rightarrow> ('s, 'e + 'b) nondet_monad\"\n  (infixl \">>=E\" 60) where\n  \"f >>=E g \\<equiv> f >>= lift g\"", "property": "Exception Handling in Bind: The bind operation in the exception monad, denoted as `>>=E`, behaves like a standard bind but skips the execution of the right-hand side if the left-hand side produces an exception. This ensures that exceptions are properly propagated and handled within the monadic computation.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  The definition of @{term bind} in the exception monad (new\n  name @{text bindE}): the same as normal @{term bind}, but\n  the right-hand side is skipped if the left-hand side\n  produced an exception."}
{"spec": "definition liftE :: \"('s,'a) nondet_monad \\<Rightarrow> ('s, 'e+'a) nondet_monad\" where\n  \"liftE f \\<equiv> f >>= (\\<lambda>r. return (Inr r))\"", "property": "Lifting Nondeterministic Monad: Transforms a nondeterministic monad into an exception monad by wrapping its result in a normal result constructor, ensuring that no exceptions are thrown.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Lifting a normal nondeterministic monad into the\n  exception monad is achieved by always returning its\n  result as normal result and never throwing an exception."}
{"spec": "definition whenE :: \"bool \\<Rightarrow> ('s, 'e + unit) nondet_monad \\<Rightarrow> ('s, 'e + unit) nondet_monad\" where\n  \"whenE P f \\<equiv> if P then f else returnOk ()\"\n\ndefinition unlessE :: \"bool \\<Rightarrow> ('s, 'e + unit) nondet_monad \\<Rightarrow> ('s, 'e + unit) nondet_monad\" where\n  \"unlessE P f \\<equiv> if P then returnOk () else f\"", "property": "Conditional Execution in Nondeterministic Monad:\n- `whenE` executes a given monadic action if a condition is true, otherwise it returns a successful result.\n- `unlessE` executes a given monadic action if a condition is false, otherwise it returns a successful result.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Since the underlying type and @{text return} function changed,\n  we need new definitions for when and unless:"}
{"spec": "definition throw_opt :: \"'e \\<Rightarrow> 'a option \\<Rightarrow> ('s, 'e + 'a) nondet_monad\" where\n  \"throw_opt ex x \\<equiv> case x of None \\<Rightarrow> throwError ex | Some v \\<Rightarrow> returnOk v\"", "property": "Exception Handling with Optional Values: Throws an exception if the input is `None`, otherwise returns the value wrapped in `Some`.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Throwing an exception when the parameter is @{term None}, otherwise\n  returning @{term \"v\"} for @{term \"Some v\"}."}
{"spec": "definition assertE :: \"bool \\<Rightarrow> ('a, 'e + unit) nondet_monad\" where\n  \"assertE P \\<equiv> if P then returnOk () else fail\"", "property": "Assertion with Exceptional Failure: The `assertE` function checks a boolean condition and returns `returnOk ()` if the condition is true, otherwise it fails with an exception.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "\n  Failure in the exception monad is redefined in the same way\n  as @{const whenE} and @{const unlessE}, with @{term returnOk}\n  instead of @{term return}."}
{"spec": "text \\<open>More direct definition of @{const liftE}:\\<close>\nlemma liftE_def2:\n  \"liftE f = (\\<lambda>s. ((\\<lambda>(v,s'). (Inr v, s')) ` fst (f s), snd (f s)))\"\n  by (auto simp: liftE_def return_def split_def bind_def)", "property": "Lift Exception: The `liftE` function transforms a computation that may fail into a computation in the exception monad, wrapping the result in a right constructor and preserving the state.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": ""}
{"spec": "lemma returnOk_bindE[simp]: \"(returnOk x >>=E f) = f x\"\n  unfolding bindE_def returnOk_def\n  by (clarsimp simp: lift_def)\n\nlemma lift_return[simp]:\n  \"lift (return \\<circ> Inr) = return\"\n  by (auto simp: lift_def throwError_def split: sum.splits)", "property": "Left Return Absorption: The `returnOk` function, when bound with another function `f` using the `bindE` operator, is equivalent to simply applying `f` to the value. This property ensures that `returnOk` acts as a left identity for the `bindE` operation, maintaining the integrity and consistency of the monadic computation.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Left @{const returnOk} absorbtion over @{term bindE}:"}
{"spec": "lemma bindE_returnOk[simp]:\n  \"(m >>=E returnOk) = m\"\n  by (simp add: bindE_def returnOk_def)", "property": "Right Absorption Law: The bind operation with the returnOk function on the right side is equivalent to the original monadic value, ensuring that the structure and behavior of the monad are preserved.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Right @{const returnOk} absorbtion over @{term bindE}:"}
{"spec": "lemma bindE_assoc:\n  \"(m >>=E f) >>=E g = m >>=E (\\<lambda>x. f x >>=E g)\"\n  unfolding bindE_def\n  by (fastforce simp: bind_assoc lift_def throwError_def\n                split: sum.splits\n                intro: arg_cong[where f=\"\\<lambda>x. m >>= x\"])", "property": "Associativity of Bind with Exception Handling: The bind operation with exception handling (bindE) is associative, ensuring that the order in which operations are composed does not affect the final result.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Associativity of @{const bindE}:"}
{"spec": "lemma returnOk_liftE:\n  \"returnOk x = liftE (return x)\"\n  by (simp add: liftE_def returnOk_def)", "property": "Nondeterministic State Monad with Failure: The `returnOk` function can be equivalently defined using the `liftE` function, ensuring that both functions behave identically in the context of the monad.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "@{const returnOk} could also be defined via @{const liftE}:"}
{"spec": "lemma throwError_bindE[simp]:\n  \"(throwError E >>=E f) = throwError E\"\n  by (simp add: bindE_def bind_def throwError_def lift_def return_def)", "property": "Exception Propagation: Throwing an exception causes the subsequent execution to be skipped, ensuring that no further operations are performed after an exception is thrown.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Adding Exceptions", "comment": "Execution after throwing an exception is skipped:"}
{"spec": "text \\<open>This section defines traditional Haskell-like do-syntax\n  for the state monad in Isabelle.\\<close>", "property": "Nondeterministic State Monad with Failure: Ensures that the monad operations adhere to the traditional monad laws, providing a consistent and predictable behavior for stateful computations with the possibility of failure.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": ""}
{"spec": "text \\<open>\n  We use @{text K_bind} to syntactically indicate the case where the return argument\n  of the left side of a @{term bind} is ignored\\<close>\ndefinition K_bind :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'a\" where\n  K_bind_def[iff]: \"K_bind \\<equiv> \\<lambda>x y. x\"\n\nnonterminal\n  dobinds and dobind and nobind\n\nsyntax\n  \"_dobind\"    :: \"[pttrn, 'a] => dobind\"             (\"(_ <-/ _)\" 10)\n  \"\"           :: \"dobind => dobinds\"                 (\"_\")\n  \"_nobind\"    :: \"'a => dobind\"                      (\"_\")\n  \"_dobinds\"   :: \"[dobind, dobinds] => dobinds\"      (\"(_);//(_)\")\n\n  \"_do\"        :: \"[dobinds, 'a] => 'a\"               (\"(do ((_);//(_))//od)\" 100)\nsyntax (xsymbols)\n  \"_dobind\"    :: \"[pttrn, 'a] => dobind\"             (\"(_ \\<leftarrow>/ _)\" 10)\n\ntranslations\n  \"_do (_dobinds b bs) e\"  == \"_do b (_do bs e)\"\n  \"_do (_nobind b) e\"      == \"b >>= (CONST K_bind e)\"\n  \"do x <- a; e od\"        == \"a >>= (\\<lambda>x. e)\"", "property": "Nondeterministic State Monad with Failure: Provides syntax for the exception monad, including binding and sequencing operations. The `K_bind` function is used to ignore the return value of the left side of a bind operation, allowing for more flexible and concise do-notation in the monad.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": ""}
{"spec": "lemma \"do x \\<leftarrow> return 1;\n          return (2::nat);\n          return x\n       od =\n       return 1 >>=\n       (\\<lambda>x. return (2::nat) >>=\n            K_bind (return x))\"\n  by (rule refl)\n\nlemma \"do x \\<leftarrow> return 1;\n          return 2;\n          return x\n       od = return 1\"\n  by simp", "property": "Nondeterministic State Monad with Failure: The monad allows for sequencing of operations, where the result of one operation can be used in subsequent operations. The final result is determined by the last return value, and intermediate return values are discarded.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": "Syntax examples:"}
{"spec": "text \\<open>\n  Since the exception monad is a different type, we need to distinguish it in the syntax\n  if we want to avoid ambiguous terms. We use @{text doE}/@{text odE} for this, but can\n  re-use most of the productions from @{text do}/@{text od} above. \\<close>\nsyntax\n  \"_doE\" :: \"[dobinds, 'a] => 'a\"  (\"(doE ((_);//(_))//odE)\" 100)\n\ntranslations\n  \"_doE (_dobinds b bs) e\"  == \"_doE b (_doE bs e)\"\n  \"_doE (_nobind b) e\"      == \"b >>=E (CONST K_bind e)\"\n  \"doE x <- a; e odE\"       == \"a >>=E (\\<lambda>x. e)\"", "property": "Exception Handling in Nondeterministic State Monad: Provides a syntax for handling exceptions within a monadic context, using the @{text doE}/@{text odE} notation to sequence operations and handle failures.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": ""}
{"spec": "lemma \"doE x \\<leftarrow> returnOk 1;\n           returnOk (2::nat);\n           returnOk x\n       odE =\n       returnOk 1 >>=E\n       (\\<lambda>x. returnOk (2::nat) >>=E\n            K_bind (returnOk x))\"\n  by (rule refl)\n\nlemma \"doE x \\<leftarrow> returnOk 1;\n           returnOk 2;\n           returnOk x\n       odE = returnOk 1\"\n  by simp", "property": "Nondeterministic State Monad with Failure: The monad supports sequencing of operations, where the result of one operation can be used in subsequent operations. If an operation fails, the entire sequence fails, and the final result is determined by the last successful operation in the sequence.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Syntax", "comment": "Syntax examples:"}
{"spec": "text \\<open>Lifting a normal function into the monad type:\\<close>\ndefinition liftM :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('s,'a) nondet_monad \\<Rightarrow> ('s, 'b) nondet_monad\" where\n  \"liftM f m \\<equiv> do x \\<leftarrow> m; return (f x) od\"", "property": "Lift Function into Monad: Elevates a pure function into the nondeterministic monad, allowing it to operate on values within the monadic context.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": ""}
{"spec": "definition liftME :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('s,'e+'a) nondet_monad \\<Rightarrow> ('s,'e+'b) nondet_monad\" where\n  \"liftME f m \\<equiv> doE x \\<leftarrow> m; returnOk (f x) odE\"", "property": "Lift Function in Exception Monad: Applies a function to the result of a monadic computation, wrapping the result in an `Ok` value within the exception monad.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "The same for the exception monad:"}
{"spec": "definition maybeM :: \"('a \\<Rightarrow> ('s, unit) nondet_monad) \\<Rightarrow> 'a option \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"maybeM f y \\<equiv> case y of Some x \\<Rightarrow> f x | None \\<Rightarrow> return ()\"", "property": "Conditional Execution: Execute a given function for a provided value if it is present, otherwise do nothing.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "Execute @{term f} for @{term \"Some x\"}, otherwise do nothing."}
{"spec": "definition sequence_x :: \"('s, 'a) nondet_monad list \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"sequence_x xs \\<equiv> foldr (\\<lambda>x y. x >>= (\\<lambda>_. y)) xs (return ())\"", "property": "Sequential Execution of Monads: Execute a list of monadic actions in sequence from left to right, discarding their return values.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "Run a sequence of monads from left to right, ignoring return values."}
{"spec": "definition mapM_x :: \"('a \\<Rightarrow> ('s,'b) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, unit) nondet_monad\" where\n  \"mapM_x f xs \\<equiv> sequence_x (map f xs)\"", "property": "Map Monadic Function Over List: Apply a monadic function to each element of a list from left to right, ignoring the return values.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  Map a monadic function over a list by applying it to each element\n  of the list from left to right, ignoring return values."}
{"spec": "definition zipWithM_x ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> ('s,'c) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> ('s, unit) nondet_monad\"\n  where\n  \"zipWithM_x f xs ys \\<equiv> sequence_x (zipWith f xs ys)\"", "property": "Zip With Monad: Apply a monadic function to pairs of elements from two lists simultaneously, ignoring the return values. This ensures that the function is applied in a left-to-right order, and any side effects are executed, but the results are not collected.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  Map a monadic function with two parameters over two lists,\n  going through both lists simultaneously, left to right, ignoring\n  return values."}
{"spec": "definition sequence :: \"('s, 'a) nondet_monad list \\<Rightarrow> ('s, 'a list) nondet_monad\" where\n  \"sequence xs \\<equiv> let mcons = (\\<lambda>p q. p >>= (\\<lambda>x. q >>= (\\<lambda>y. return (x#y))))\n                 in foldr mcons xs (return [])\"\n\ndefinition mapM :: \"('a \\<Rightarrow> ('s,'b) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, 'b list) nondet_monad\" where\n  \"mapM f xs \\<equiv> sequence (map f xs)\"\n\ndefinition zipWithM ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> ('s,'c) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> 'b list \\<Rightarrow> ('s, 'c list) nondet_monad\"\n  where\n  \"zipWithM f xs ys \\<equiv> sequence (zipWith f xs ys)\"\n\ndefinition foldM ::\n  \"('b \\<Rightarrow> 'a \\<Rightarrow> ('s, 'a) nondet_monad) \\<Rightarrow> 'b list \\<Rightarrow> 'a \\<Rightarrow> ('s, 'a) nondet_monad\"\n  where\n  \"foldM m xs a \\<equiv> foldr (\\<lambda>p q. q >>= m p) xs (return a) \"\n\ndefinition foldME ::\n  \"('b \\<Rightarrow> 'a \\<Rightarrow> ('s,('e + 'b)) nondet_monad) \\<Rightarrow> 'b \\<Rightarrow> 'a list \\<Rightarrow> ('s, ('e + 'b)) nondet_monad\"\n  where\n  \"foldME m a xs \\<equiv> foldr (\\<lambda>p q. q >>=E swp m p) xs (returnOk a)\"", "property": "Monadic Combinators for Nondeterministic Computations: Provide functions to sequence, map, and fold over lists in a nondeterministic monad, allowing for the execution of multiple monadic actions and accumulation of results. These combinators enable the construction of complex monadic operations from simpler ones, supporting both successful and error-handling scenarios.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  The same three functions as above, but returning a list of\n  return values instead of @{text unit}"}
{"spec": "definition sequenceE_x :: \"('s, 'e+'a) nondet_monad list \\<Rightarrow> ('s, 'e+unit) nondet_monad\" where\n  \"sequenceE_x xs \\<equiv> foldr (\\<lambda>x y. doE _ <- x; y odE) xs (returnOk ())\"\n\ndefinition mapME_x :: \"('a \\<Rightarrow> ('s,'e+'b) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s,'e+unit) nondet_monad\" where\n  \"mapME_x f xs \\<equiv> sequenceE_x (map f xs)\"\n\ndefinition sequenceE :: \"('s, 'e+'a) nondet_monad list \\<Rightarrow> ('s, 'e+'a list) nondet_monad\" where\n  \"sequenceE xs \\<equiv> let mcons = (\\<lambda>p q. p >>=E (\\<lambda>x. q >>=E (\\<lambda>y. returnOk (x#y))))\n                   in foldr mcons xs (returnOk [])\"\n\ndefinition mapME ::\n  \"('a \\<Rightarrow> ('s,'e+'b) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s,'e+'b list) nondet_monad\"\n  where\n  \"mapME f xs \\<equiv> sequenceE (map f xs)\"", "property": "Nondeterministic Monad Sequencing: Provides functions to sequence and map monadic operations, handling both unit and list return values. The `sequenceE_x` and `mapME_x` functions execute a list of monadic actions, discarding their results, while `sequenceE` and `mapME` collect the results into a list.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "\n  The sequence and map functions above for the exception monad, with and without\n  lists of return value"}
{"spec": "primrec filterM :: \"('a \\<Rightarrow> ('s, bool) nondet_monad) \\<Rightarrow> 'a list \\<Rightarrow> ('s, 'a list) nondet_monad\" where\n  \"filterM P []       = return []\"\n| \"filterM P (x # xs) = do\n     b  <- P x;\n     ys <- filterM P xs;\n     return (if b then (x # ys) else ys)\n   od\"", "property": "Filtering with Monadic Predicate: Recursively filter a list by applying a monadic predicate to each element, including the element in the result if the predicate returns true, and excluding it otherwise.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "Filtering a list using a monadic function as predicate:"}
{"spec": "lemma state_select_def2:\n  \"state_select r \\<equiv> (do\n    s \\<leftarrow> get;\n    S \\<leftarrow> return {s'. (s, s') \\<in> r};\n    assert (S \\<noteq> {});\n    s' \\<leftarrow> select S;\n    put s'\n  od)\"\n  apply (clarsimp simp add: state_select_def get_def return_def assert_def fail_def select_def\n                            put_def bind_def fun_eq_iff\n                    intro!: eq_reflection)\n  apply fastforce\n  done", "property": "State Selection with Relation: Select a new state based on a given relation, ensuring that the set of possible new states is non-empty before making the selection.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Library of additional Monadic Functions and Combinators", "comment": "An alternative definition of @{term state_select}"}
{"spec": "text \\<open>\n  Turning an exception monad into a normal state monad\n  by catching and handling any potential exceptions:\\<close>\ndefinition catch ::\n  \"('s, 'e + 'a) nondet_monad \\<Rightarrow> ('e \\<Rightarrow> ('s, 'a) nondet_monad) \\<Rightarrow> ('s, 'a) nondet_monad\"\n  (infix \"<catch>\" 10) where\n  \"f <catch> handler \\<equiv>\n     do x \\<leftarrow> f;\n        case x of\n          Inr b \\<Rightarrow> return b\n        | Inl e \\<Rightarrow> handler e\n     od\"", "property": "Exception Handling in Nondeterministic State Monad: Transforms an exception monad into a normal state monad by catching and handling any potential exceptions. If the computation succeeds, it returns the result; if it fails, it invokes a handler to process the exception.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": ""}
{"spec": "definition handleE' ::\n  \"('s, 'e1 + 'a) nondet_monad \\<Rightarrow> ('e1 \\<Rightarrow> ('s, 'e2 + 'a) nondet_monad) \\<Rightarrow> ('s, 'e2 + 'a) nondet_monad\"\n  (infix \"<handle2>\" 10) where\n  \"f <handle2> handler \\<equiv>\n   do\n      v \\<leftarrow> f;\n      case v of\n        Inl e \\<Rightarrow> handler e\n      | Inr v' \\<Rightarrow> return (Inr v')\n   od\"", "property": "Exception Handling in Nondeterministic Monad: Allows for the handling of exceptions within a nondeterministic monad, where the handler can throw a different type of exception than the original. The function continues with the returned value if no exception occurs, or invokes the handler if an exception is caught.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": "\n  Handling exceptions, but staying in the exception monad.\n  The handler may throw a type of exceptions different from\n  the left side."}
{"spec": "definition handleE ::\n  \"('s, 'x + 'a) nondet_monad \\<Rightarrow> ('x \\<Rightarrow> ('s, 'x + 'a) nondet_monad) \\<Rightarrow> ('s, 'x + 'a) nondet_monad\"\n  (infix \"<handle>\" 10) where\n  \"handleE \\<equiv> handleE'\"", "property": "Exception Handling: Allows for the catching and handling of exceptions within a nondeterministic state monad, where the exception handler can potentially throw an exception of the same type as the original.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": "\n  A type restriction of the above that is used more commonly in\n  practice: the exception handle (potentially) throws exception\n  of the same type as the left-hand side."}
{"spec": "definition handle_elseE ::\n  \"('s, 'e + 'a) nondet_monad \\<Rightarrow> ('e \\<Rightarrow> ('s, 'ee + 'b) nondet_monad) \\<Rightarrow>\n   ('a \\<Rightarrow> ('s, 'ee + 'b) nondet_monad) \\<Rightarrow> ('s, 'ee + 'b) nondet_monad\" (\"_ <handle> _ <else> _\" 10)\n  where\n  \"f <handle> handler <else> continue \\<equiv>\n   do v \\<leftarrow> f;\n      case v of Inl e  \\<Rightarrow> handler e\n              | Inr v' \\<Rightarrow> continue v'\n   od\"", "property": "Exception Handling with Continuation: Manages exceptions by applying a handler if an exception is thrown, and a continuation if no exception occurs. This ensures that both error handling and normal flow are appropriately addressed.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": "\n  Handling exceptions, and additionally providing a continuation\n  if the left-hand side throws no exception:"}
{"spec": "text \\<open>\n  Loops are handled using the following inductive predicate;\n  non-termination is represented using the failure flag of the\n  monad.\\<close>\n\ninductive_set whileLoop_results ::\n  \"('r \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> ('r \\<Rightarrow> ('s, 'r) nondet_monad) \\<Rightarrow> ((('r \\<times> 's) option) \\<times> (('r \\<times> 's) option)) set\"\n  for C B where\n    \"\\<lbrakk> \\<not> C r s \\<rbrakk> \\<Longrightarrow> (Some (r, s), Some (r, s)) \\<in> whileLoop_results C B\"\n  | \"\\<lbrakk> C r s; snd (B r s) \\<rbrakk> \\<Longrightarrow> (Some (r, s), None) \\<in> whileLoop_results C B\"\n  | \"\\<lbrakk> C r s; (r', s') \\<in> fst (B r s); (Some (r', s'), z) \\<in> whileLoop_results C B  \\<rbrakk>\n       \\<Longrightarrow> (Some (r, s), z) \\<in> whileLoop_results C B\"\n\ninductive_cases whileLoop_results_cases_valid: \"(Some x, Some y) \\<in> whileLoop_results C B\"\ninductive_cases whileLoop_results_cases_fail: \"(Some x, None) \\<in> whileLoop_results C B\"\ninductive_simps whileLoop_results_simps: \"(Some x, y) \\<in> whileLoop_results C B\"\ninductive_simps whileLoop_results_simps_valid: \"(Some x, Some y) \\<in> whileLoop_results C B\"\ninductive_simps whileLoop_results_simps_start_fail[simp]: \"(None, x) \\<in> whileLoop_results C B\"\n\ninductive whileLoop_terminates ::\n  \"('r \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> ('r \\<Rightarrow> ('s, 'r) nondet_monad) \\<Rightarrow> 'r \\<Rightarrow> 's \\<Rightarrow> bool\"\n  for C B where\n    \"\\<not> C r s \\<Longrightarrow> whileLoop_terminates C B r s\"\n  | \"\\<lbrakk> C r s; \\<forall>(r', s') \\<in> fst (B r s). whileLoop_terminates C B r' s' \\<rbrakk>\n        \\<Longrightarrow> whileLoop_terminates C B r s\"\n\ninductive_cases whileLoop_terminates_cases: \"whileLoop_terminates C B r s\"\ninductive_simps whileLoop_terminates_simps: \"whileLoop_terminates C B r s\"\n\ndefinition whileLoop ::\n  \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> ('b, 'a) nondet_monad) \\<Rightarrow> 'a \\<Rightarrow> ('b, 'a) nondet_monad\"\n  where\n  \"whileLoop C B \\<equiv> \\<lambda>r s.\n     ({(r',s'). (Some (r, s), Some (r', s')) \\<in> whileLoop_results C B},\n      (Some (r, s), None) \\<in> whileLoop_results C B \\<or> \\<not>whileLoop_terminates C B r s)\"\n\nnotation (output)\n  whileLoop  (\"(whileLoop (_)//  (_))\" [1000, 1000] 1000)\n\ndefinition whileLoopE ::\n  \"('r \\<Rightarrow> 's \\<Rightarrow> bool) \\<Rightarrow> ('r \\<Rightarrow> ('s, 'e + 'r) nondet_monad) \\<Rightarrow> 'r \\<Rightarrow> 's \\<Rightarrow> (('e + 'r) \\<times> 's) set \\<times> bool\"\n  where\n  \"whileLoopE C body \\<equiv>\n     \\<lambda>r. whileLoop (\\<lambda>r s. (case r of Inr v \\<Rightarrow> C v s | _ \\<Rightarrow> False)) (lift body) (Inr r)\"\n\nnotation (output)\n  whileLoopE  (\"(whileLoopE (_)//  (_))\" [1000, 1000] 1000)", "property": "Loop Execution with Exception Handling: The while loop executes as long as the condition is true, and it handles non-termination and exceptions using a nondeterministic monad. The loop terminates if the condition is false or if all possible next states lead to termination. If the loop fails to terminate, it returns a failure flag.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Catching and Handling Exceptions", "comment": ""}
{"spec": "definition notM :: \"('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad\" where\n  \"notM m = do c \\<leftarrow> m; return (\\<not> c) od\"\n\ndefinition whileM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad\"\n  where\n  \"whileM C B \\<equiv> do\n    c \\<leftarrow> C;\n    whileLoop (\\<lambda>c s. c) (\\<lambda>_. do B; C od) c;\n    return ()\n  od\"\n\ndefinition ifM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad \\<Rightarrow> ('s, 'a) nondet_monad\"\n  where\n  \"ifM test t f = do\n    c \\<leftarrow> test;\n    if c then t else f\n   od\"\n\ndefinition ifME ::\n  \"('a, 'b + bool) nondet_monad \\<Rightarrow> ('a, 'b + 'c) nondet_monad \\<Rightarrow> ('a, 'b + 'c) nondet_monad\n   \\<Rightarrow> ('a, 'b + 'c) nondet_monad\"\n  where\n  \"ifME test t f = doE\n    c \\<leftarrow> test;\n    if c then t else f\n   odE\"\n\ndefinition whenM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad \\<Rightarrow> ('s, unit) nondet_monad\"\n  where\n  \"whenM t m = ifM t m (return ())\"\n\ndefinition orM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad\"\n  where\n  \"orM a b = ifM a (return True) b\"\n\ndefinition andM ::\n  \"('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad \\<Rightarrow> ('s, bool) nondet_monad\"\n  where\n  \"andM a b = ifM a b (return False)\"\n\nend", "property": "Control Flow with Conditions: Provides combinators for conditional and repetitive execution within a nondeterministic state monad, enabling the evaluation of conditions with side effects and the execution of corresponding actions. These combinators include negation, while loops, if-then-else statements, and logical operations, allowing for flexible and expressive control flow in the presence of nondeterminism.", "title": "./spec/abstract/Nondeterministic State Monad with Failure.thy", "chapter": "Nondeterministic State Monad with Failure", "section": "Combinators that have conditions with side effects", "comment": ""}
